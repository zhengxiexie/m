#ifndef IDL_GENERATED_FILE_MCP_IDL_H_
#define IDL_GENERATED_FILE_MCP_IDL_H_
#include "mcpack_idl.h"
namespace idl {
class sub_class_t;
class class_info_t;
class class_detail_count_t;
class img_info_t;
class attribute_info_t;
class ios_content_info_t;
class game_brief_info_t;
class game_info_t;
class pub_prop_info_t;
class game_info_t_hall;
class online_game_info_t;
class grab_info_t;
class user_grab_number_t;
class mobile_music_info_t;
class pt_game_basic_info_t;
class calender_info_t;
class soft_info_t;
class theme_info_t;
class music_info_t;
class cp_info_t;
class grant_detail_t;
class download_detail_t;
class championship_info_t;
class content_basic_info_t;
class content_detail_t;
class mcp_content_in_param;
class once_consume_goods_t;
class game_news_entire_info_t;
class game_news_info_t;
class netgame_activity_info_t;
class column_info_t;
class game_ext_update_info_t;
class game_update_download_info;
class game_content_download_info_t;
class game_dev_vir_currency_info;
class question_type_name_t;
class user_question_answer_t;
class qp_activity_award_t;
class qp_activity_t;
class qp_activity_person_t;
class person_all_award_info_t;
class person_award_info_t;
class award_info_t;
class mcp_get_test_params;
class mcp_get_test_result_params;
class mcp_get_test_response;
class mcp_get_phone_maker_plat_params;
class mcp_get_phone_maker_plat_result_params;
class mcp_get_phone_maker_plat_response;
class mcp_get_content_list_from_classID_params;
class mcp_get_content_list_from_classID_result_params;
class mcp_get_content_list_from_classID_response;
class mcp_get_content_list_from_typeID_params;
class mcp_get_content_list_from_typeID_result_params;
class mcp_get_content_list_from_typeID_response;
class mcp_get_content_class_params;
class mcp_get_content_class_result_params;
class mcp_get_content_class_response;
class mcp_get_content_class_name_params;
class mcp_get_content_class_name_result_params;
class mcp_get_content_class_name_response;
class mcp_get_content_diy_col_name_params;
class mcp_get_content_diy_col_name_result_params;
class mcp_get_content_diy_col_name_response;
class mcp_get_content_info_params;
class mcp_get_content_info_result_params;
class mcp_get_content_info_response;
class mcp_get_download_info_params;
class mcp_get_download_info_result_params;
class mcp_get_download_info_response;
class mcp_get_content_list_params;
class mcp_get_content_list_result_params;
class mcp_get_content_list_response;
class mcp_get_content_list_from_part_params;
class mcp_get_content_list_from_part_result_params;
class mcp_get_content_list_from_part_response;
class mcp_get_content_count_from_class_params;
class mcp_get_content_count_from_class_result_params;
class mcp_get_content_count_from_class_response;
class mcp_get_phone_info_params;
class mcp_get_phone_info_result_params;
class mcp_get_phone_info_response;
class mcp_get_phone_uaJson_params;
class mcp_get_phone_uaJson_result_params;
class mcp_get_phone_uaJson_response;
class mcp_init_phone_uaJson_map_params;
class mcp_init_phone_uaJson_map_result_params;
class mcp_init_phone_uaJson_map_response;
class mcp_get_phone_type_from_ID_params;
class mcp_get_phone_type_from_ID_result_params;
class mcp_get_phone_type_from_ID_response;
class mcp_get_phone_headword_from_maker_params;
class mcp_get_phone_headword_from_maker_result_params;
class mcp_get_phone_headword_from_maker_response;
class mcp_search_phone_info_params;
class mcp_search_phone_info_result_params;
class mcp_search_phone_info_response;
class mcp_get_carriers_info_from_ip_params;
class mcp_get_carriers_info_from_ip_result_params;
class mcp_get_carriers_info_from_ip_response;
class mcp_get_phone_info_from_maker_plat_params;
class mcp_get_phone_info_from_maker_plat_result_params;
class mcp_get_phone_info_from_maker_plat_response;
class mcp_get_url_info_by_id_params;
class mcp_get_url_info_by_id_result_params;
class mcp_get_url_info_by_id_response;
class mcp_get_url_info_by_class_id_params;
class mcp_get_url_info_by_class_id_result_params;
class mcp_get_url_info_by_class_id_response;
class mcp_get_url_info_by_column_id_params;
class mcp_get_url_info_by_column_id_result_params;
class mcp_get_url_info_by_column_id_response;
class mcp_get_content_list_from_phone_params;
class mcp_get_content_list_from_phone_result_params;
class mcp_get_content_list_from_phone_response;
class mcp_get_content_list_by_rank_params;
class mcp_get_content_list_by_rank_result_params;
class mcp_get_content_list_by_rank_response;
class mcp_get_label_by_content_id_params;
class mcp_get_label_by_content_id_result_params;
class mcp_get_label_by_content_id_response;
class mcp_get_content_list_by_label_params;
class mcp_get_content_list_by_label_result_params;
class mcp_get_content_list_by_label_response;
class mcp_get_topic_info_params;
class mcp_get_topic_info_result_params;
class mcp_get_topic_info_response;
class mcp_get_content_count_by_class_params;
class mcp_get_content_count_by_class_result_params;
class mcp_get_content_count_by_class_response;
class mcp_get_content_img_params;
class mcp_get_content_img_result_params;
class mcp_get_content_img_response;
class mcp_get_label_name_by_id_params;
class mcp_get_label_name_by_id_result_params;
class mcp_get_label_name_by_id_response;
class mcp_get_content_list_by_date_params;
class mcp_get_content_list_by_date_result_params;
class mcp_get_content_list_by_date_response;
class mcp_get_soft_info_by_id_params;
class mcp_get_soft_info_by_id_result_params;
class mcp_get_soft_info_by_id_response;
class mcp_get_android_theme_by_id_params;
class mcp_get_android_theme_by_id_result_params;
class mcp_get_android_theme_by_id_response;
class mcp_get_mcp_stat_params;
class mcp_get_mcp_stat_result_params;
class mcp_get_mcp_stat_response;
class mcp_get_col_list_by_topic_params;
class mcp_get_col_list_by_topic_result_params;
class mcp_get_col_list_by_topic_response;
class mcp_get_soft_list_by_col_id_params;
class mcp_get_soft_list_by_col_id_result_params;
class mcp_get_soft_list_by_col_id_response;
class mcp_get_soft_list_by_class_id_params;
class mcp_get_soft_list_by_class_id_result_params;
class mcp_get_soft_list_by_class_id_response;
class mcp_get_android_theme_by_col_id_params;
class mcp_get_android_theme_by_col_id_result_params;
class mcp_get_android_theme_by_col_id_response;
class mcp_get_android_theme_by_class_id_params;
class mcp_get_android_theme_by_class_id_result_params;
class mcp_get_android_theme_by_class_id_response;
class mcp_get_topic_list_by_type_params;
class mcp_get_topic_list_by_type_result_params;
class mcp_get_topic_list_by_type_response;
class mcp_get_sub_class_by_class_params;
class mcp_get_sub_class_by_class_result_params;
class mcp_get_sub_class_by_class_response;
class mcp_mcp_content_common_init_params;
class mcp_mcp_content_common_init_result_params;
class mcp_mcp_content_common_init_response;
class mcp_get_phone_area_by_phone_num_params;
class mcp_get_phone_area_by_phone_num_result_params;
class mcp_get_phone_area_by_phone_num_response;
class mcp_reload_config_by_id_params;
class mcp_reload_config_by_id_result_params;
class mcp_reload_config_by_id_response;
class mcp_get_ios_content_by_id_params;
class mcp_get_ios_content_by_id_result_params;
class mcp_get_ios_content_by_id_response;
class mcp_get_ios_content_by_class_id_params;
class mcp_get_ios_content_by_class_id_result_params;
class mcp_get_ios_content_by_class_id_response;
class mcp_get_ios_content_by_cp_id_params;
class mcp_get_ios_content_by_cp_id_result_params;
class mcp_get_ios_content_by_cp_id_response;
class mcp_get_ios_content_by_col_id_params;
class mcp_get_ios_content_by_col_id_result_params;
class mcp_get_ios_content_by_col_id_response;
class mcp_get_ios_content_by_rank_params;
class mcp_get_ios_content_by_rank_result_params;
class mcp_get_ios_content_by_rank_response;
class mcp_get_class_list_by_type_id_params;
class mcp_get_class_list_by_type_id_result_params;
class mcp_get_class_list_by_type_id_response;
class mcp_get_ios_probably_like_list_by_id_params;
class mcp_get_ios_probably_like_list_by_id_result_params;
class mcp_get_ios_probably_like_list_by_id_response;
class mcp_get_game_info_list_params;
class mcp_get_game_info_list_result_params;
class mcp_get_game_info_list_response;
class mcp_get_game_info_params;
class mcp_get_game_info_result_params;
class mcp_get_game_info_response;
class mcp_get_game_info_list_by_c_id_params;
class mcp_get_game_info_list_by_c_id_result_params;
class mcp_get_game_info_list_by_c_id_response;
class mcp_get_game_score_by_imei_or_uid_params;
class mcp_get_game_score_by_imei_or_uid_result_params;
class mcp_get_game_score_by_imei_or_uid_response;
class mcp_get_appinfo_by_packagename_params;
class mcp_get_appinfo_by_packagename_result_params;
class mcp_get_appinfo_by_packagename_response;
class mcp_get_score_by_packagename_and_versioncode_params;
class mcp_get_score_by_packagename_and_versioncode_result_params;
class mcp_get_score_by_packagename_and_versioncode_response;
class mcp_get_content_info_by_packagename_and_versioncode_params;
class mcp_get_content_info_by_packagename_and_versioncode_result_params;
class mcp_get_content_info_by_packagename_and_versioncode_response;
class mcp_get_content_info_by_packagename_params;
class mcp_get_content_info_by_packagename_result_params;
class mcp_get_content_info_by_packagename_response;
class mcp_get_online_game_by_id_params;
class mcp_get_online_game_by_id_result_params;
class mcp_get_online_game_by_id_response;
class mcp_get_online_game_by_class_id_params;
class mcp_get_online_game_by_class_id_result_params;
class mcp_get_online_game_by_class_id_response;
class mcp_get_online_game_by_cp_id_params;
class mcp_get_online_game_by_cp_id_result_params;
class mcp_get_online_game_by_cp_id_response;
class mcp_get_online_game_by_col_id_params;
class mcp_get_online_game_by_col_id_result_params;
class mcp_get_online_game_by_col_id_response;
class mcp_get_online_game_by_rank_params;
class mcp_get_online_game_by_rank_result_params;
class mcp_get_online_game_by_rank_response;
class mcp_get_grab_list_by_type_params;
class mcp_get_grab_list_by_type_result_params;
class mcp_get_grab_list_by_type_response;
class mcp_get_grab_info_by_c_id_params;
class mcp_get_grab_info_by_c_id_result_params;
class mcp_get_grab_info_by_c_id_response;
class mcp_get_grab_info_by_id_params;
class mcp_get_grab_info_by_id_result_params;
class mcp_get_grab_info_by_id_response;
class mcp_user_grab_num_params;
class mcp_user_grab_num_result_params;
class mcp_user_grab_num_response;
class mcp_user_grab_num_pre_params;
class mcp_user_grab_num_pre_result_params;
class mcp_user_grab_num_pre_response;
class mcp_set_user_rating_params;
class mcp_set_user_rating_result_params;
class mcp_set_user_rating_response;
class mcp_get_user_rating_params;
class mcp_get_user_rating_result_params;
class mcp_get_user_rating_response;
class mcp_get_calender_list_params;
class mcp_get_calender_list_result_params;
class mcp_get_calender_list_response;
class mcp_get_content_list_by_mixed_topic_id_params;
class mcp_get_content_list_by_mixed_topic_id_result_params;
class mcp_get_content_list_by_mixed_topic_id_response;
class mcp_get_content_list_by_mixed_topic_id1_params;
class mcp_get_content_list_by_mixed_topic_id1_result_params;
class mcp_get_content_list_by_mixed_topic_id1_response;
class mcp_get_user_grab_num_params;
class mcp_get_user_grab_num_result_params;
class mcp_get_user_grab_num_response;
class mcp_set_recently_played_params;
class mcp_set_recently_played_result_params;
class mcp_set_recently_played_response;
class mcp_get_recently_played_by_uid_params;
class mcp_get_recently_played_by_uid_result_params;
class mcp_get_recently_played_by_uid_response;
class mcp_add_game_to_favorite_params;
class mcp_add_game_to_favorite_result_params;
class mcp_add_game_to_favorite_response;
class mcp_get_favoraite_by_uid_params;
class mcp_get_favoraite_by_uid_result_params;
class mcp_get_favoraite_by_uid_response;
class mcp_get_H5_latest_on_shelf_by_date_params;
class mcp_get_H5_latest_on_shelf_by_date_result_params;
class mcp_get_H5_latest_on_shelf_by_date_response;
class mcp_get_H5_latest_on_shelf_by_date_and_type_params;
class mcp_get_H5_latest_on_shelf_by_date_and_type_result_params;
class mcp_get_H5_latest_on_shelf_by_date_and_type_response;
class mcp_get_H5_info_list_by_col_id_params;
class mcp_get_H5_info_list_by_col_id_result_params;
class mcp_get_H5_info_list_by_col_id_response;
class mcp_get_imgurls_and_favorite_by_uid_cid_params;
class mcp_get_imgurls_and_favorite_by_uid_cid_result_params;
class mcp_get_imgurls_and_favorite_by_uid_cid_response;
class mcp_get_random_h5_games_params;
class mcp_get_random_h5_games_result_params;
class mcp_get_random_h5_games_response;
class mcp_get_info_by_col_id_and_type_id_params;
class mcp_get_info_by_col_id_and_type_id_result_params;
class mcp_get_info_by_col_id_and_type_id_response;
class mcp_get_info_by_col_id_params;
class mcp_get_info_by_col_id_result_params;
class mcp_get_info_by_col_id_response;
class mcp_get_soft_by_date_or_star_params;
class mcp_get_soft_by_date_or_star_result_params;
class mcp_get_soft_by_date_or_star_response;
class mcp_get_star_by_cid_and_type_params;
class mcp_get_star_by_cid_and_type_result_params;
class mcp_get_star_by_cid_and_type_response;
class mcp_get_content_list_from_classID_with_weight_params;
class mcp_get_content_list_from_classID_with_weight_result_params;
class mcp_get_content_list_from_classID_with_weight_response;
class mcp_get_content_with_download_info_params;
class mcp_get_content_with_download_info_result_params;
class mcp_get_content_with_download_info_response;
class mcp_get_game_contents_count_params;
class mcp_get_game_contents_count_result_params;
class mcp_get_game_contents_count_response;
class mcp_get_columns_info_params;
class mcp_get_columns_info_result_params;
class mcp_get_columns_info_response;
class mcp_get_once_consume_goods_list_params;
class mcp_get_once_consume_goods_list_result_params;
class mcp_get_once_consume_goods_list_response;
class mcp_get_game_info_list_ext_params;
class mcp_get_game_info_list_ext_result_params;
class mcp_get_game_info_list_ext_response;
class mcp_add_new_download_game_by_uid_params;
class mcp_add_new_download_game_by_uid_result_params;
class mcp_add_new_download_game_by_uid_response;
class mcp_get_download_games_count_by_uid_params;
class mcp_get_download_games_count_by_uid_result_params;
class mcp_get_download_games_count_by_uid_response;
class mcp_is_user_has_relation_with_params;
class mcp_is_user_has_relation_with_result_params;
class mcp_is_user_has_relation_with_response;
class mcp_get_download_games_info_by_uid_params;
class mcp_get_download_games_info_by_uid_result_params;
class mcp_get_download_games_info_by_uid_response;
class mcp_add_new_guide_by_uid_params;
class mcp_add_new_guide_by_uid_result_params;
class mcp_add_new_guide_by_uid_response;
class mcp_remove_guide_by_uid_params;
class mcp_remove_guide_by_uid_result_params;
class mcp_remove_guide_by_uid_response;
class mcp_get_guides_count_by_uid_params;
class mcp_get_guides_count_by_uid_result_params;
class mcp_get_guides_count_by_uid_response;
class mcp_get_guides_info_by_uid_params;
class mcp_get_guides_info_by_uid_result_params;
class mcp_get_guides_info_by_uid_response;
class mcp_add_new_favorite_by_uid_params;
class mcp_add_new_favorite_by_uid_result_params;
class mcp_add_new_favorite_by_uid_response;
class mcp_remove_favorite_by_uid_params;
class mcp_remove_favorite_by_uid_result_params;
class mcp_remove_favorite_by_uid_response;
class mcp_get_favorites_count_by_uid_params;
class mcp_get_favorites_count_by_uid_result_params;
class mcp_get_favorites_count_by_uid_response;
class mcp_get_favorites_info_by_uid_params;
class mcp_get_favorites_info_by_uid_result_params;
class mcp_get_favorites_info_by_uid_response;
class mcp_get_grab_list_params;
class mcp_get_grab_list_result_params;
class mcp_get_grab_list_response;
class mcp_get_user_grab_num_list_params;
class mcp_get_user_grab_num_list_result_params;
class mcp_get_user_grab_num_list_response;
class mcp_get_common_adv_info_params;
class mcp_get_common_adv_info_result_params;
class mcp_get_common_adv_info_response;
class mcp_get_pt_game_basic_list_by_game_id_params;
class mcp_get_pt_game_basic_list_by_game_id_result_params;
class mcp_get_pt_game_basic_list_by_game_id_response;
class mcp_get_pt_game_basic_list_by_app_key_params;
class mcp_get_pt_game_basic_list_by_app_key_result_params;
class mcp_get_pt_game_basic_list_by_app_key_response;
class mcp_get_pt_app_key_by_game_id_params;
class mcp_get_pt_app_key_by_game_id_result_params;
class mcp_get_pt_app_key_by_game_id_response;
class mcp_get_pt_game_id_by_app_key_params;
class mcp_get_pt_game_id_by_app_key_result_params;
class mcp_get_pt_game_id_by_app_key_response;
class mcp_exist_pt_game_by_game_id_params;
class mcp_exist_pt_game_by_game_id_result_params;
class mcp_exist_pt_game_by_game_id_response;
class mcp_is_same_pt_game_params;
class mcp_is_same_pt_game_result_params;
class mcp_is_same_pt_game_response;
class mcp_remove_pt_game_basic_list_by_app_key_params;
class mcp_remove_pt_game_basic_list_by_app_key_result_params;
class mcp_remove_pt_game_basic_list_by_app_key_response;
class mcp_add_new_user_consume_record_params;
class mcp_add_new_user_consume_record_result_params;
class mcp_add_new_user_consume_record_response;
class mcp_get_game_news_info_list_params;
class mcp_get_game_news_info_list_result_params;
class mcp_get_game_news_info_list_response;
class mcp_get_game_news_entire_info_params;
class mcp_get_game_news_entire_info_result_params;
class mcp_get_game_news_entire_info_response;
class mcp_get_netgame_activity_info_params;
class mcp_get_netgame_activity_info_result_params;
class mcp_get_netgame_activity_info_response;
class mcp_get_game_download_app_info_params;
class mcp_get_game_download_app_info_result_params;
class mcp_get_game_download_app_info_response;
class mcp_get_game_dbapp_detail_info_params;
class mcp_get_game_dbapp_detail_info_result_params;
class mcp_get_game_dbapp_detail_info_response;
class mcp_get_device_download_games_info_by_udid_params;
class mcp_get_device_download_games_info_by_udid_result_params;
class mcp_get_device_download_games_info_by_udid_response;
class mcp_add_device_download_game_params;
class mcp_add_device_download_game_result_params;
class mcp_add_device_download_game_response;
class mcp_get_game_content_info_list_ext_params;
class mcp_get_game_content_info_list_ext_result_params;
class mcp_get_game_content_info_list_ext_response;
class mcp_get_game_currency_rate_params;
class mcp_get_game_currency_rate_result_params;
class mcp_get_game_currency_rate_response;
class mcp_get_game_download_info_params;
class mcp_get_game_download_info_result_params;
class mcp_get_game_download_info_response;
class mcp_get_game_news_without_pbus_params;
class mcp_get_game_news_without_pbus_result_params;
class mcp_get_game_news_without_pbus_response;
class mcp_get_mobile_music_info_params;
class mcp_get_mobile_music_info_result_params;
class mcp_get_mobile_music_info_response;
class mcp_set_mobile_music_ptag_by_ring_id_params;
class mcp_set_mobile_music_ptag_by_ring_id_result_params;
class mcp_set_mobile_music_ptag_by_ring_id_response;
class mcp_get_mobile_music_ring_id_by_ptag_params;
class mcp_get_mobile_music_ring_id_by_ptag_result_params;
class mcp_get_mobile_music_ring_id_by_ptag_response;
class mcp_get_championship_info_params;
class mcp_get_championship_info_result_params;
class mcp_get_championship_info_response;
class mcp_user_add_coins_params;
class mcp_user_add_coins_result_params;
class mcp_user_add_coins_response;
class mcp_get_game_news_params;
class mcp_get_game_news_result_params;
class mcp_get_game_news_response;
class mcp_get_ip_province_params;
class mcp_get_ip_province_result_params;
class mcp_get_ip_province_response;
class mcp_get_question_type_name_params;
class mcp_get_question_type_name_result_params;
class mcp_get_question_type_name_response;
class mcp_submit_question_params;
class mcp_submit_question_result_params;
class mcp_submit_question_response;
class mcp_get_user_question_params;
class mcp_get_user_question_result_params;
class mcp_get_user_question_response;
class mcp_get_qp_activity_params;
class mcp_get_qp_activity_result_params;
class mcp_get_qp_activity_response;
class mcp_get_qp_activity_person_params;
class mcp_get_qp_activity_person_result_params;
class mcp_get_qp_activity_person_response;
class mcp_get_person_award_list_params;
class mcp_get_person_award_list_result_params;
class mcp_get_person_award_list_response;
class mcp_get_person_all_awards_params;
class mcp_get_person_all_awards_result_params;
class mcp_get_person_all_awards_response;
class mcp_get_person_award_params;
class mcp_get_person_award_result_params;
class mcp_get_person_award_response;
class mcp_get_award_list_params;
class mcp_get_award_list_result_params;
class mcp_get_award_list_response;
class mcp_grab_award_params;
class mcp_grab_award_result_params;
class mcp_grab_award_response;
class Notify_addSystemNotify_params;
class Notify_addSystemNotify_result_params;
class Notify_addSystemNotify_response;
class GameHallPoint_addGameHallScore_params;
class GameHallPoint_addGameHallScore_result_params;
class GameHallPoint_addGameHallScore_response;
class sub_class_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static sub_class_t* create(bsl::mempool* pool);
static void destroy(sub_class_t* v);
explicit sub_class_t(bsl::mempool* pool);
sub_class_t(const sub_class_t& v);
~sub_class_t();
sub_class_t& operator=(const sub_class_t& v);
void clear();
void check() const;
void detach();
sub_class_t& assign(const sub_class_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline sub_class_t& set_id(const char* s,ssize_t size=-1);
inline sub_class_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline sub_class_t& set_name(const char* s,ssize_t size=-1);
inline sub_class_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string icon;
inline bool has_icon() const;
inline const char* icon(unsigned int* size=0) const;
inline sub_class_t& set_icon(const char* s,ssize_t size=-1);
inline sub_class_t& set_ptr_icon(const char* s,ssize_t size=-1);
inline void clear_icon();
// @@string content_list=array(0,0);
inline bool has_content_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& content_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_content_list();
inline void clear_content_list();
// deprecated.use 'mutable_content_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_content_list();
// deprecated.use 'content_list().size()' instead.
inline size_t content_list_size() const;
inline const char* content_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline sub_class_t& set_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline sub_class_t& set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_name;
 ::idl::string _m_icon;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_content_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class sub_class_t
class class_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static class_info_t* create(bsl::mempool* pool);
static void destroy(class_info_t* v);
explicit class_info_t(bsl::mempool* pool);
class_info_t(const class_info_t& v);
~class_info_t();
class_info_t& operator=(const class_info_t& v);
void clear();
void check() const;
void detach();
class_info_t& assign(const class_info_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline class_info_t& set_id(const char* s,ssize_t size=-1);
inline class_info_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline class_info_t& set_name(const char* s,ssize_t size=-1);
inline class_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_name;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class class_info_t
class class_detail_count_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static class_detail_count_t* create(bsl::mempool* pool);
static void destroy(class_detail_count_t* v);
explicit class_detail_count_t(bsl::mempool* pool);
class_detail_count_t(const class_detail_count_t& v);
~class_detail_count_t();
class_detail_count_t& operator=(const class_detail_count_t& v);
void clear();
void check() const;
void detach();
class_detail_count_t& assign(const class_detail_count_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline class_detail_count_t& set_id(const char* s,ssize_t size=-1);
inline class_detail_count_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline class_detail_count_t& set_name(const char* s,ssize_t size=-1);
inline class_detail_count_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string icon;
inline bool has_icon() const;
inline const char* icon(unsigned int* size=0) const;
inline class_detail_count_t& set_icon(const char* s,ssize_t size=-1);
inline class_detail_count_t& set_ptr_icon(const char* s,ssize_t size=-1);
inline void clear_icon();
// @@string count;
inline bool has_count() const;
inline const char* count(unsigned int* size=0) const;
inline class_detail_count_t& set_count(const char* s,ssize_t size=-1);
inline class_detail_count_t& set_ptr_count(const char* s,ssize_t size=-1);
inline void clear_count();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_name;
 ::idl::string _m_icon;
 ::idl::string _m_count;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class class_detail_count_t
class img_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static img_info_t* create(bsl::mempool* pool);
static void destroy(img_info_t* v);
explicit img_info_t(bsl::mempool* pool);
img_info_t(const img_info_t& v);
~img_info_t();
img_info_t& operator=(const img_info_t& v);
void clear();
void check() const;
void detach();
img_info_t& assign(const img_info_t& v);
// @@string type;
inline bool has_type() const;
inline const char* type(unsigned int* size=0) const;
inline img_info_t& set_type(const char* s,ssize_t size=-1);
inline img_info_t& set_ptr_type(const char* s,ssize_t size=-1);
inline void clear_type();
// @@string url;
inline bool has_url() const;
inline const char* url(unsigned int* size=0) const;
inline img_info_t& set_url(const char* s,ssize_t size=-1);
inline img_info_t& set_ptr_url(const char* s,ssize_t size=-1);
inline void clear_url();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_type;
 ::idl::string _m_url;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class img_info_t
class attribute_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static attribute_info_t* create(bsl::mempool* pool);
static void destroy(attribute_info_t* v);
explicit attribute_info_t(bsl::mempool* pool);
attribute_info_t(const attribute_info_t& v);
~attribute_info_t();
attribute_info_t& operator=(const attribute_info_t& v);
void clear();
void check() const;
void detach();
attribute_info_t& assign(const attribute_info_t& v);
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline attribute_info_t& set_name(const char* s,ssize_t size=-1);
inline attribute_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string content;
inline bool has_content() const;
inline const char* content(unsigned int* size=0) const;
inline attribute_info_t& set_content(const char* s,ssize_t size=-1);
inline attribute_info_t& set_ptr_content(const char* s,ssize_t size=-1);
inline void clear_content();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_name;
 ::idl::string _m_content;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class attribute_info_t
class ios_content_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static ios_content_info_t* create(bsl::mempool* pool);
static void destroy(ios_content_info_t* v);
explicit ios_content_info_t(bsl::mempool* pool);
ios_content_info_t(const ios_content_info_t& v);
~ios_content_info_t();
ios_content_info_t& operator=(const ios_content_info_t& v);
void clear();
void check() const;
void detach();
ios_content_info_t& assign(const ios_content_info_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline ios_content_info_t& set_id(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline ios_content_info_t& set_name(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string icon;
inline bool has_icon() const;
inline const char* icon(unsigned int* size=0) const;
inline ios_content_info_t& set_icon(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_icon(const char* s,ssize_t size=-1);
inline void clear_icon();
// @@string type;
inline bool has_type() const;
inline const char* type(unsigned int* size=0) const;
inline ios_content_info_t& set_type(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_type(const char* s,ssize_t size=-1);
inline void clear_type();
// @@string itunes_id;
inline bool has_itunes_id() const;
inline const char* itunes_id(unsigned int* size=0) const;
inline ios_content_info_t& set_itunes_id(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_itunes_id(const char* s,ssize_t size=-1);
inline void clear_itunes_id();
// @@string info;
inline bool has_info() const;
inline const char* info(unsigned int* size=0) const;
inline ios_content_info_t& set_info(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_info(const char* s,ssize_t size=-1);
inline void clear_info();
// @@string version;
inline bool has_version() const;
inline const char* version(unsigned int* size=0) const;
inline ios_content_info_t& set_version(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_version(const char* s,ssize_t size=-1);
inline void clear_version();
// @@string cp_id;
inline bool has_cp_id() const;
inline const char* cp_id(unsigned int* size=0) const;
inline ios_content_info_t& set_cp_id(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_cp_id(const char* s,ssize_t size=-1);
inline void clear_cp_id();
// @@string cp_name;
inline bool has_cp_name() const;
inline const char* cp_name(unsigned int* size=0) const;
inline ios_content_info_t& set_cp_name(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_cp_name(const char* s,ssize_t size=-1);
inline void clear_cp_name();
// @@string star;
inline bool has_star() const;
inline const char* star(unsigned int* size=0) const;
inline ios_content_info_t& set_star(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_star(const char* s,ssize_t size=-1);
inline void clear_star();
// @@string gdate;
inline bool has_gdate() const;
inline const char* gdate(unsigned int* size=0) const;
inline ios_content_info_t& set_gdate(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_gdate(const char* s,ssize_t size=-1);
inline void clear_gdate();
// @@string mdate;
inline bool has_mdate() const;
inline const char* mdate(unsigned int* size=0) const;
inline ios_content_info_t& set_mdate(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_mdate(const char* s,ssize_t size=-1);
inline void clear_mdate();
// @@string adapt;
inline bool has_adapt() const;
inline const char* adapt(unsigned int* size=0) const;
inline ios_content_info_t& set_adapt(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_adapt(const char* s,ssize_t size=-1);
inline void clear_adapt();
// @@string url;
inline bool has_url() const;
inline const char* url(unsigned int* size=0) const;
inline ios_content_info_t& set_url(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_url(const char* s,ssize_t size=-1);
inline void clear_url();
// @@string jump_url;
inline bool has_jump_url() const;
inline const char* jump_url(unsigned int* size=0) const;
inline ios_content_info_t& set_jump_url(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_jump_url(const char* s,ssize_t size=-1);
inline void clear_jump_url();
// @@string size;
inline bool has_size() const;
inline const char* size(unsigned int* size=0) const;
inline ios_content_info_t& set_size(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_size(const char* s,ssize_t size=-1);
inline void clear_size();
// @@string now_price;
inline bool has_now_price() const;
inline const char* now_price(unsigned int* size=0) const;
inline ios_content_info_t& set_now_price(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_now_price(const char* s,ssize_t size=-1);
inline void clear_now_price();
// @@string original_price;
inline bool has_original_price() const;
inline const char* original_price(unsigned int* size=0) const;
inline ios_content_info_t& set_original_price(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_original_price(const char* s,ssize_t size=-1);
inline void clear_original_price();
// @@string rating;
inline bool has_rating() const;
inline const char* rating(unsigned int* size=0) const;
inline ios_content_info_t& set_rating(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_rating(const char* s,ssize_t size=-1);
inline void clear_rating();
// @@string count;
inline bool has_count() const;
inline const char* count(unsigned int* size=0) const;
inline ios_content_info_t& set_count(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_count(const char* s,ssize_t size=-1);
inline void clear_count();
// @@string crt_rating;
inline bool has_crt_rating() const;
inline const char* crt_rating(unsigned int* size=0) const;
inline ios_content_info_t& set_crt_rating(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_crt_rating(const char* s,ssize_t size=-1);
inline void clear_crt_rating();
// @@string crt_count;
inline bool has_crt_count() const;
inline const char* crt_count(unsigned int* size=0) const;
inline ios_content_info_t& set_crt_count(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_crt_count(const char* s,ssize_t size=-1);
inline void clear_crt_count();
// @@string language;
inline bool has_language() const;
inline const char* language(unsigned int* size=0) const;
inline ios_content_info_t& set_language(const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_language(const char* s,ssize_t size=-1);
inline void clear_language();
// @@string img_list=array(0);
inline bool has_img_list() const;
inline const ::idl::vector< ::idl::string >& img_list() const;
inline ::idl::vector< ::idl::string >* mutable_img_list();
inline void clear_img_list();
// deprecated.use 'mutable_img_list' instead.
inline ::idl::vector< ::idl::string >* m_img_list();
// deprecated.use 'img_list().size()' instead.
inline size_t img_list_size() const;
inline const char* img_list(size_t i0,unsigned int* size=0) const;
inline ios_content_info_t& set_img_list(size_t i0,const char* s,ssize_t size=-1);
inline ios_content_info_t& set_ptr_img_list(size_t i0,const char* s,ssize_t size=-1);
// @@class_info_t class_info=array(0);
inline bool has_class_info() const;
inline const ::idl::vector< ::idl::class_info_t >& class_info() const;
inline ::idl::vector< ::idl::class_info_t >* mutable_class_info();
inline void clear_class_info();
// deprecated.use 'mutable_class_info' instead.
inline ::idl::vector< ::idl::class_info_t >* m_class_info();
// deprecated.use 'class_info().size()' instead.
inline size_t class_info_size() const;
inline const ::idl::class_info_t& class_info(size_t i0) const;
inline ::idl::class_info_t* mutable_class_info(size_t i0);
// deprecated.use 'mutable_class_info' instead.
inline ::idl::class_info_t* m_class_info(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_name;
 ::idl::string _m_icon;
 ::idl::string _m_type;
 ::idl::string _m_itunes_id;
 ::idl::string _m_info;
 ::idl::string _m_version;
 ::idl::string _m_cp_id;
 ::idl::string _m_cp_name;
 ::idl::string _m_star;
 ::idl::string _m_gdate;
 ::idl::string _m_mdate;
 ::idl::string _m_adapt;
 ::idl::string _m_url;
 ::idl::string _m_jump_url;
 ::idl::string _m_size;
 ::idl::string _m_now_price;
 ::idl::string _m_original_price;
 ::idl::string _m_rating;
 ::idl::string _m_count;
 ::idl::string _m_crt_rating;
 ::idl::string _m_crt_count;
 ::idl::string _m_language;
 ::idl::vector< ::idl::string > _m_img_list;
 ::idl::vector< ::idl::class_info_t > _m_class_info;
mutable ::idl::Unknown _unknown;
char _flag[4];
}; // class ios_content_info_t
class game_brief_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static game_brief_info_t* create(bsl::mempool* pool);
static void destroy(game_brief_info_t* v);
explicit game_brief_info_t(bsl::mempool* pool);
game_brief_info_t(const game_brief_info_t& v);
~game_brief_info_t();
game_brief_info_t& operator=(const game_brief_info_t& v);
void clear();
void check() const;
void detach();
game_brief_info_t& assign(const game_brief_info_t& v);
// @@string info_type;
inline bool has_info_type() const;
inline const char* info_type(unsigned int* size=0) const;
inline game_brief_info_t& set_info_type(const char* s,ssize_t size=-1);
inline game_brief_info_t& set_ptr_info_type(const char* s,ssize_t size=-1);
inline void clear_info_type();
// @@string info_id;
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline game_brief_info_t& set_info_id(const char* s,ssize_t size=-1);
inline game_brief_info_t& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@string info_title;
inline bool has_info_title() const;
inline const char* info_title(unsigned int* size=0) const;
inline game_brief_info_t& set_info_title(const char* s,ssize_t size=-1);
inline game_brief_info_t& set_ptr_info_title(const char* s,ssize_t size=-1);
inline void clear_info_title();
// @@string info_datetime;
inline bool has_info_datetime() const;
inline const char* info_datetime(unsigned int* size=0) const;
inline game_brief_info_t& set_info_datetime(const char* s,ssize_t size=-1);
inline game_brief_info_t& set_ptr_info_datetime(const char* s,ssize_t size=-1);
inline void clear_info_datetime();
// @@string type_name;
inline bool has_type_name() const;
inline const char* type_name(unsigned int* size=0) const;
inline game_brief_info_t& set_type_name(const char* s,ssize_t size=-1);
inline game_brief_info_t& set_ptr_type_name(const char* s,ssize_t size=-1);
inline void clear_type_name();
// @@string game_type;
inline bool has_game_type() const;
inline const char* game_type(unsigned int* size=0) const;
inline game_brief_info_t& set_game_type(const char* s,ssize_t size=-1);
inline game_brief_info_t& set_ptr_game_type(const char* s,ssize_t size=-1);
inline void clear_game_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_info_type;
 ::idl::string _m_info_id;
 ::idl::string _m_info_title;
 ::idl::string _m_info_datetime;
 ::idl::string _m_type_name;
 ::idl::string _m_game_type;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class game_brief_info_t
class game_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static game_info_t* create(bsl::mempool* pool);
static void destroy(game_info_t* v);
explicit game_info_t(bsl::mempool* pool);
game_info_t(const game_info_t& v);
~game_info_t();
game_info_t& operator=(const game_info_t& v);
void clear();
void check() const;
void detach();
game_info_t& assign(const game_info_t& v);
// @@string info_type;
inline bool has_info_type() const;
inline const char* info_type(unsigned int* size=0) const;
inline game_info_t& set_info_type(const char* s,ssize_t size=-1);
inline game_info_t& set_ptr_info_type(const char* s,ssize_t size=-1);
inline void clear_info_type();
// @@string info_id;
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline game_info_t& set_info_id(const char* s,ssize_t size=-1);
inline game_info_t& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@string c_id;
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline game_info_t& set_c_id(const char* s,ssize_t size=-1);
inline game_info_t& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string info_title;
inline bool has_info_title() const;
inline const char* info_title(unsigned int* size=0) const;
inline game_info_t& set_info_title(const char* s,ssize_t size=-1);
inline game_info_t& set_ptr_info_title(const char* s,ssize_t size=-1);
inline void clear_info_title();
// @@string info_content;
inline bool has_info_content() const;
inline const char* info_content(unsigned int* size=0) const;
inline game_info_t& set_info_content(const char* s,ssize_t size=-1);
inline game_info_t& set_ptr_info_content(const char* s,ssize_t size=-1);
inline void clear_info_content();
// @@string info_date;
inline bool has_info_date() const;
inline const char* info_date(unsigned int* size=0) const;
inline game_info_t& set_info_date(const char* s,ssize_t size=-1);
inline game_info_t& set_ptr_info_date(const char* s,ssize_t size=-1);
inline void clear_info_date();
// @@string type_name;
inline bool has_type_name() const;
inline const char* type_name(unsigned int* size=0) const;
inline game_info_t& set_type_name(const char* s,ssize_t size=-1);
inline game_info_t& set_ptr_type_name(const char* s,ssize_t size=-1);
inline void clear_type_name();
// @@string game_type;
inline bool has_game_type() const;
inline const char* game_type(unsigned int* size=0) const;
inline game_info_t& set_game_type(const char* s,ssize_t size=-1);
inline game_info_t& set_ptr_game_type(const char* s,ssize_t size=-1);
inline void clear_game_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_info_type;
 ::idl::string _m_info_id;
 ::idl::string _m_c_id;
 ::idl::string _m_info_title;
 ::idl::string _m_info_content;
 ::idl::string _m_info_date;
 ::idl::string _m_type_name;
 ::idl::string _m_game_type;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class game_info_t
class pub_prop_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static pub_prop_info_t* create(bsl::mempool* pool);
static void destroy(pub_prop_info_t* v);
explicit pub_prop_info_t(bsl::mempool* pool);
pub_prop_info_t(const pub_prop_info_t& v);
~pub_prop_info_t();
pub_prop_info_t& operator=(const pub_prop_info_t& v);
void clear();
void check() const;
void detach();
pub_prop_info_t& assign(const pub_prop_info_t& v);
// @@string prop_url;
inline bool has_prop_url() const;
inline const char* prop_url(unsigned int* size=0) const;
inline pub_prop_info_t& set_prop_url(const char* s,ssize_t size=-1);
inline pub_prop_info_t& set_ptr_prop_url(const char* s,ssize_t size=-1);
inline void clear_prop_url();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline pub_prop_info_t& set_name(const char* s,ssize_t size=-1);
inline pub_prop_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string color;
inline bool has_color() const;
inline const char* color(unsigned int* size=0) const;
inline pub_prop_info_t& set_color(const char* s,ssize_t size=-1);
inline pub_prop_info_t& set_ptr_color(const char* s,ssize_t size=-1);
inline void clear_color();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_prop_url;
 ::idl::string _m_name;
 ::idl::string _m_color;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class pub_prop_info_t
class game_info_t_hall : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static game_info_t_hall* create(bsl::mempool* pool);
static void destroy(game_info_t_hall* v);
explicit game_info_t_hall(bsl::mempool* pool);
game_info_t_hall(const game_info_t_hall& v);
~game_info_t_hall();
game_info_t_hall& operator=(const game_info_t_hall& v);
void clear();
void check() const;
void detach();
game_info_t_hall& assign(const game_info_t_hall& v);
// @@string info_type;
inline bool has_info_type() const;
inline const char* info_type(unsigned int* size=0) const;
inline game_info_t_hall& set_info_type(const char* s,ssize_t size=-1);
inline game_info_t_hall& set_ptr_info_type(const char* s,ssize_t size=-1);
inline void clear_info_type();
// @@string info_id;
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline game_info_t_hall& set_info_id(const char* s,ssize_t size=-1);
inline game_info_t_hall& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@string c_id;
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline game_info_t_hall& set_c_id(const char* s,ssize_t size=-1);
inline game_info_t_hall& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string info_title;
inline bool has_info_title() const;
inline const char* info_title(unsigned int* size=0) const;
inline game_info_t_hall& set_info_title(const char* s,ssize_t size=-1);
inline game_info_t_hall& set_ptr_info_title(const char* s,ssize_t size=-1);
inline void clear_info_title();
// @@string info_content;
inline bool has_info_content() const;
inline const char* info_content(unsigned int* size=0) const;
inline game_info_t_hall& set_info_content(const char* s,ssize_t size=-1);
inline game_info_t_hall& set_ptr_info_content(const char* s,ssize_t size=-1);
inline void clear_info_content();
// @@string info_date;
inline bool has_info_date() const;
inline const char* info_date(unsigned int* size=0) const;
inline game_info_t_hall& set_info_date(const char* s,ssize_t size=-1);
inline game_info_t_hall& set_ptr_info_date(const char* s,ssize_t size=-1);
inline void clear_info_date();
// @@string type_name;
inline bool has_type_name() const;
inline const char* type_name(unsigned int* size=0) const;
inline game_info_t_hall& set_type_name(const char* s,ssize_t size=-1);
inline game_info_t_hall& set_ptr_type_name(const char* s,ssize_t size=-1);
inline void clear_type_name();
// @@string game_type;
inline bool has_game_type() const;
inline const char* game_type(unsigned int* size=0) const;
inline game_info_t_hall& set_game_type(const char* s,ssize_t size=-1);
inline game_info_t_hall& set_ptr_game_type(const char* s,ssize_t size=-1);
inline void clear_game_type();
// @@string news_source;
inline bool has_news_source() const;
inline const char* news_source(unsigned int* size=0) const;
inline game_info_t_hall& set_news_source(const char* s,ssize_t size=-1);
inline game_info_t_hall& set_ptr_news_source(const char* s,ssize_t size=-1);
inline void clear_news_source();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_info_type;
 ::idl::string _m_info_id;
 ::idl::string _m_c_id;
 ::idl::string _m_info_title;
 ::idl::string _m_info_content;
 ::idl::string _m_info_date;
 ::idl::string _m_type_name;
 ::idl::string _m_game_type;
 ::idl::string _m_news_source;
mutable ::idl::Unknown _unknown;
char _flag[2];
}; // class game_info_t_hall
class online_game_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static online_game_info_t* create(bsl::mempool* pool);
static void destroy(online_game_info_t* v);
explicit online_game_info_t(bsl::mempool* pool);
online_game_info_t(const online_game_info_t& v);
~online_game_info_t();
online_game_info_t& operator=(const online_game_info_t& v);
void clear();
void check() const;
void detach();
online_game_info_t& assign(const online_game_info_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline online_game_info_t& set_id(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline online_game_info_t& set_name(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string icon;
inline bool has_icon() const;
inline const char* icon(unsigned int* size=0) const;
inline online_game_info_t& set_icon(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_icon(const char* s,ssize_t size=-1);
inline void clear_icon();
// @@string thumb;
inline bool has_thumb() const;
inline const char* thumb(unsigned int* size=0) const;
inline online_game_info_t& set_thumb(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_thumb(const char* s,ssize_t size=-1);
inline void clear_thumb();
// @@string type;
inline bool has_type() const;
inline const char* type(unsigned int* size=0) const;
inline online_game_info_t& set_type(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_type(const char* s,ssize_t size=-1);
inline void clear_type();
// @@string info;
inline bool has_info() const;
inline const char* info(unsigned int* size=0) const;
inline online_game_info_t& set_info(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_info(const char* s,ssize_t size=-1);
inline void clear_info();
// @@string version;
inline bool has_version() const;
inline const char* version(unsigned int* size=0) const;
inline online_game_info_t& set_version(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_version(const char* s,ssize_t size=-1);
inline void clear_version();
// @@string system_req;
inline bool has_system_req() const;
inline const char* system_req(unsigned int* size=0) const;
inline online_game_info_t& set_system_req(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_system_req(const char* s,ssize_t size=-1);
inline void clear_system_req();
// @@string cp_id;
inline bool has_cp_id() const;
inline const char* cp_id(unsigned int* size=0) const;
inline online_game_info_t& set_cp_id(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_cp_id(const char* s,ssize_t size=-1);
inline void clear_cp_id();
// @@string cp_name;
inline bool has_cp_name() const;
inline const char* cp_name(unsigned int* size=0) const;
inline online_game_info_t& set_cp_name(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_cp_name(const char* s,ssize_t size=-1);
inline void clear_cp_name();
// @@string star;
inline bool has_star() const;
inline const char* star(unsigned int* size=0) const;
inline online_game_info_t& set_star(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_star(const char* s,ssize_t size=-1);
inline void clear_star();
// @@string popularity;
inline bool has_popularity() const;
inline const char* popularity(unsigned int* size=0) const;
inline online_game_info_t& set_popularity(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_popularity(const char* s,ssize_t size=-1);
inline void clear_popularity();
// @@string language;
inline bool has_language() const;
inline const char* language(unsigned int* size=0) const;
inline online_game_info_t& set_language(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_language(const char* s,ssize_t size=-1);
inline void clear_language();
// @@string gdate;
inline bool has_gdate() const;
inline const char* gdate(unsigned int* size=0) const;
inline online_game_info_t& set_gdate(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_gdate(const char* s,ssize_t size=-1);
inline void clear_gdate();
// @@string mdate;
inline bool has_mdate() const;
inline const char* mdate(unsigned int* size=0) const;
inline online_game_info_t& set_mdate(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_mdate(const char* s,ssize_t size=-1);
inline void clear_mdate();
// @@string ldate;
inline bool has_ldate() const;
inline const char* ldate(unsigned int* size=0) const;
inline online_game_info_t& set_ldate(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_ldate(const char* s,ssize_t size=-1);
inline void clear_ldate();
// @@string url;
inline bool has_url() const;
inline const char* url(unsigned int* size=0) const;
inline online_game_info_t& set_url(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_url(const char* s,ssize_t size=-1);
inline void clear_url();
// @@string size;
inline bool has_size() const;
inline const char* size(unsigned int* size=0) const;
inline online_game_info_t& set_size(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_size(const char* s,ssize_t size=-1);
inline void clear_size();
// @@string label_list=array(0);
inline bool has_label_list() const;
inline const ::idl::vector< ::idl::string >& label_list() const;
inline ::idl::vector< ::idl::string >* mutable_label_list();
inline void clear_label_list();
// deprecated.use 'mutable_label_list' instead.
inline ::idl::vector< ::idl::string >* m_label_list();
// deprecated.use 'label_list().size()' instead.
inline size_t label_list_size() const;
inline const char* label_list(size_t i0,unsigned int* size=0) const;
inline online_game_info_t& set_label_list(size_t i0,const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_label_list(size_t i0,const char* s,ssize_t size=-1);
// @@string img_list=array(0);
inline bool has_img_list() const;
inline const ::idl::vector< ::idl::string >& img_list() const;
inline ::idl::vector< ::idl::string >* mutable_img_list();
inline void clear_img_list();
// deprecated.use 'mutable_img_list' instead.
inline ::idl::vector< ::idl::string >* m_img_list();
// deprecated.use 'img_list().size()' instead.
inline size_t img_list_size() const;
inline const char* img_list(size_t i0,unsigned int* size=0) const;
inline online_game_info_t& set_img_list(size_t i0,const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_img_list(size_t i0,const char* s,ssize_t size=-1);
// @@string apk_flag;
inline bool has_apk_flag() const;
inline const char* apk_flag(unsigned int* size=0) const;
inline online_game_info_t& set_apk_flag(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_apk_flag(const char* s,ssize_t size=-1);
inline void clear_apk_flag();
// @@string editor_recom;
inline bool has_editor_recom() const;
inline const char* editor_recom(unsigned int* size=0) const;
inline online_game_info_t& set_editor_recom(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_editor_recom(const char* s,ssize_t size=-1);
inline void clear_editor_recom();
// @@class_info_t class_info=array(0);
inline bool has_class_info() const;
inline const ::idl::vector< ::idl::class_info_t >& class_info() const;
inline ::idl::vector< ::idl::class_info_t >* mutable_class_info();
inline void clear_class_info();
// deprecated.use 'mutable_class_info' instead.
inline ::idl::vector< ::idl::class_info_t >* m_class_info();
// deprecated.use 'class_info().size()' instead.
inline size_t class_info_size() const;
inline const ::idl::class_info_t& class_info(size_t i0) const;
inline ::idl::class_info_t* mutable_class_info(size_t i0);
// deprecated.use 'mutable_class_info' instead.
inline ::idl::class_info_t* m_class_info(size_t i0);
// @@attribute_info_t attribute_list=array(0);
inline bool has_attribute_list() const;
inline const ::idl::vector< ::idl::attribute_info_t >& attribute_list() const;
inline ::idl::vector< ::idl::attribute_info_t >* mutable_attribute_list();
inline void clear_attribute_list();
// deprecated.use 'mutable_attribute_list' instead.
inline ::idl::vector< ::idl::attribute_info_t >* m_attribute_list();
// deprecated.use 'attribute_list().size()' instead.
inline size_t attribute_list_size() const;
inline const ::idl::attribute_info_t& attribute_list(size_t i0) const;
inline ::idl::attribute_info_t* mutable_attribute_list(size_t i0);
// deprecated.use 'mutable_attribute_list' instead.
inline ::idl::attribute_info_t* m_attribute_list(size_t i0);
// @@string pub_prop_ids;
inline bool has_pub_prop_ids() const;
inline const char* pub_prop_ids(unsigned int* size=0) const;
inline online_game_info_t& set_pub_prop_ids(const char* s,ssize_t size=-1);
inline online_game_info_t& set_ptr_pub_prop_ids(const char* s,ssize_t size=-1);
inline void clear_pub_prop_ids();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_name;
 ::idl::string _m_icon;
 ::idl::string _m_thumb;
 ::idl::string _m_type;
 ::idl::string _m_info;
 ::idl::string _m_version;
 ::idl::string _m_system_req;
 ::idl::string _m_cp_id;
 ::idl::string _m_cp_name;
 ::idl::string _m_star;
 ::idl::string _m_popularity;
 ::idl::string _m_language;
 ::idl::string _m_gdate;
 ::idl::string _m_mdate;
 ::idl::string _m_ldate;
 ::idl::string _m_url;
 ::idl::string _m_size;
 ::idl::vector< ::idl::string > _m_label_list;
 ::idl::vector< ::idl::string > _m_img_list;
 ::idl::string _m_apk_flag;
 ::idl::string _m_editor_recom;
 ::idl::vector< ::idl::class_info_t > _m_class_info;
 ::idl::vector< ::idl::attribute_info_t > _m_attribute_list;
 ::idl::string _m_pub_prop_ids;
mutable ::idl::Unknown _unknown;
char _flag[4];
}; // class online_game_info_t
class grab_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static grab_info_t* create(bsl::mempool* pool);
static void destroy(grab_info_t* v);
explicit grab_info_t(bsl::mempool* pool);
grab_info_t(const grab_info_t& v);
~grab_info_t();
grab_info_t& operator=(const grab_info_t& v);
void clear();
void check() const;
void detach();
grab_info_t& assign(const grab_info_t& v);
// @@uint32_t id;
inline bool has_id() const;
inline uint32_t id() const;
inline grab_info_t& set_id(uint32_t v);
inline void clear_id();
// @@string c_id;
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline grab_info_t& set_c_id(const char* s,ssize_t size=-1);
inline grab_info_t& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline grab_info_t& set_name(const char* s,ssize_t size=-1);
inline grab_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@uint32_t amount;
inline bool has_amount() const;
inline uint32_t amount() const;
inline grab_info_t& set_amount(uint32_t v);
inline void clear_amount();
// @@uint32_t send_amount;
inline bool has_send_amount() const;
inline uint32_t send_amount() const;
inline grab_info_t& set_send_amount(uint32_t v);
inline void clear_send_amount();
// @@string create_time;
inline bool has_create_time() const;
inline const char* create_time(unsigned int* size=0) const;
inline grab_info_t& set_create_time(const char* s,ssize_t size=-1);
inline grab_info_t& set_ptr_create_time(const char* s,ssize_t size=-1);
inline void clear_create_time();
// @@string start_time;
inline bool has_start_time() const;
inline const char* start_time(unsigned int* size=0) const;
inline grab_info_t& set_start_time(const char* s,ssize_t size=-1);
inline grab_info_t& set_ptr_start_time(const char* s,ssize_t size=-1);
inline void clear_start_time();
// @@string end_time;
inline bool has_end_time() const;
inline const char* end_time(unsigned int* size=0) const;
inline grab_info_t& set_end_time(const char* s,ssize_t size=-1);
inline grab_info_t& set_ptr_end_time(const char* s,ssize_t size=-1);
inline void clear_end_time();
// @@string info;
inline bool has_info() const;
inline const char* info(unsigned int* size=0) const;
inline grab_info_t& set_info(const char* s,ssize_t size=-1);
inline grab_info_t& set_ptr_info(const char* s,ssize_t size=-1);
inline void clear_info();
// @@string num;
inline bool has_num() const;
inline const char* num(unsigned int* size=0) const;
inline grab_info_t& set_num(const char* s,ssize_t size=-1);
inline grab_info_t& set_ptr_num(const char* s,ssize_t size=-1);
inline void clear_num();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_id;
 ::idl::string _m_c_id;
 ::idl::string _m_name;
 uint32_t _m_amount;
 uint32_t _m_send_amount;
 ::idl::string _m_create_time;
 ::idl::string _m_start_time;
 ::idl::string _m_end_time;
 ::idl::string _m_info;
 ::idl::string _m_num;
mutable ::idl::Unknown _unknown;
char _flag[2];
}; // class grab_info_t
class user_grab_number_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static user_grab_number_t* create(bsl::mempool* pool);
static void destroy(user_grab_number_t* v);
explicit user_grab_number_t(bsl::mempool* pool);
user_grab_number_t(const user_grab_number_t& v);
~user_grab_number_t();
user_grab_number_t& operator=(const user_grab_number_t& v);
void clear();
void check() const;
void detach();
user_grab_number_t& assign(const user_grab_number_t& v);
// @@uint32_t grab_id;
inline bool has_grab_id() const;
inline uint32_t grab_id() const;
inline user_grab_number_t& set_grab_id(uint32_t v);
inline void clear_grab_id();
// @@string num;
inline bool has_num() const;
inline const char* num(unsigned int* size=0) const;
inline user_grab_number_t& set_num(const char* s,ssize_t size=-1);
inline user_grab_number_t& set_ptr_num(const char* s,ssize_t size=-1);
inline void clear_num();
// @@string c_id;
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline user_grab_number_t& set_c_id(const char* s,ssize_t size=-1);
inline user_grab_number_t& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline user_grab_number_t& set_name(const char* s,ssize_t size=-1);
inline user_grab_number_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string create_time;
inline bool has_create_time() const;
inline const char* create_time(unsigned int* size=0) const;
inline user_grab_number_t& set_create_time(const char* s,ssize_t size=-1);
inline user_grab_number_t& set_ptr_create_time(const char* s,ssize_t size=-1);
inline void clear_create_time();
// @@string start_time;
inline bool has_start_time() const;
inline const char* start_time(unsigned int* size=0) const;
inline user_grab_number_t& set_start_time(const char* s,ssize_t size=-1);
inline user_grab_number_t& set_ptr_start_time(const char* s,ssize_t size=-1);
inline void clear_start_time();
// @@string end_time;
inline bool has_end_time() const;
inline const char* end_time(unsigned int* size=0) const;
inline user_grab_number_t& set_end_time(const char* s,ssize_t size=-1);
inline user_grab_number_t& set_ptr_end_time(const char* s,ssize_t size=-1);
inline void clear_end_time();
// @@string info;
inline bool has_info() const;
inline const char* info(unsigned int* size=0) const;
inline user_grab_number_t& set_info(const char* s,ssize_t size=-1);
inline user_grab_number_t& set_ptr_info(const char* s,ssize_t size=-1);
inline void clear_info();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_grab_id;
 ::idl::string _m_num;
 ::idl::string _m_c_id;
 ::idl::string _m_name;
 ::idl::string _m_create_time;
 ::idl::string _m_start_time;
 ::idl::string _m_end_time;
 ::idl::string _m_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class user_grab_number_t
class mobile_music_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mobile_music_info_t* create(bsl::mempool* pool);
static void destroy(mobile_music_info_t* v);
explicit mobile_music_info_t(bsl::mempool* pool);
mobile_music_info_t(const mobile_music_info_t& v);
~mobile_music_info_t();
mobile_music_info_t& operator=(const mobile_music_info_t& v);
void clear();
void check() const;
void detach();
mobile_music_info_t& assign(const mobile_music_info_t& v);
// @@string ring_id;
inline bool has_ring_id() const;
inline const char* ring_id(unsigned int* size=0) const;
inline mobile_music_info_t& set_ring_id(const char* s,ssize_t size=-1);
inline mobile_music_info_t& set_ptr_ring_id(const char* s,ssize_t size=-1);
inline void clear_ring_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline mobile_music_info_t& set_name(const char* s,ssize_t size=-1);
inline mobile_music_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string singer;
inline bool has_singer() const;
inline const char* singer(unsigned int* size=0) const;
inline mobile_music_info_t& set_singer(const char* s,ssize_t size=-1);
inline mobile_music_info_t& set_ptr_singer(const char* s,ssize_t size=-1);
inline void clear_singer();
// @@string bell_id;
inline bool has_bell_id() const;
inline const char* bell_id(unsigned int* size=0) const;
inline mobile_music_info_t& set_bell_id(const char* s,ssize_t size=-1);
inline mobile_music_info_t& set_ptr_bell_id(const char* s,ssize_t size=-1);
inline void clear_bell_id();
// @@string song_id;
inline bool has_song_id() const;
inline const char* song_id(unsigned int* size=0) const;
inline mobile_music_info_t& set_song_id(const char* s,ssize_t size=-1);
inline mobile_music_info_t& set_ptr_song_id(const char* s,ssize_t size=-1);
inline void clear_song_id();
// @@string cp_id;
inline bool has_cp_id() const;
inline const char* cp_id(unsigned int* size=0) const;
inline mobile_music_info_t& set_cp_id(const char* s,ssize_t size=-1);
inline mobile_music_info_t& set_ptr_cp_id(const char* s,ssize_t size=-1);
inline void clear_cp_id();
// @@string date;
inline bool has_date() const;
inline const char* date(unsigned int* size=0) const;
inline mobile_music_info_t& set_date(const char* s,ssize_t size=-1);
inline mobile_music_info_t& set_ptr_date(const char* s,ssize_t size=-1);
inline void clear_date();
// @@string dolby_flag;
inline bool has_dolby_flag() const;
inline const char* dolby_flag(unsigned int* size=0) const;
inline mobile_music_info_t& set_dolby_flag(const char* s,ssize_t size=-1);
inline mobile_music_info_t& set_ptr_dolby_flag(const char* s,ssize_t size=-1);
inline void clear_dolby_flag();
// @@string status;
inline bool has_status() const;
inline const char* status(unsigned int* size=0) const;
inline mobile_music_info_t& set_status(const char* s,ssize_t size=-1);
inline mobile_music_info_t& set_ptr_status(const char* s,ssize_t size=-1);
inline void clear_status();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_ring_id;
 ::idl::string _m_name;
 ::idl::string _m_singer;
 ::idl::string _m_bell_id;
 ::idl::string _m_song_id;
 ::idl::string _m_cp_id;
 ::idl::string _m_date;
 ::idl::string _m_dolby_flag;
 ::idl::string _m_status;
mutable ::idl::Unknown _unknown;
char _flag[2];
}; // class mobile_music_info_t
class pt_game_basic_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static pt_game_basic_info_t* create(bsl::mempool* pool);
static void destroy(pt_game_basic_info_t* v);
explicit pt_game_basic_info_t(bsl::mempool* pool);
pt_game_basic_info_t(const pt_game_basic_info_t& v);
~pt_game_basic_info_t();
pt_game_basic_info_t& operator=(const pt_game_basic_info_t& v);
void clear();
void check() const;
void detach();
pt_game_basic_info_t& assign(const pt_game_basic_info_t& v);
// @@string game_id;
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline pt_game_basic_info_t& set_game_id(const char* s,ssize_t size=-1);
inline pt_game_basic_info_t& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline pt_game_basic_info_t& set_name(const char* s,ssize_t size=-1);
inline pt_game_basic_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string app_key;
inline bool has_app_key() const;
inline const char* app_key(unsigned int* size=0) const;
inline pt_game_basic_info_t& set_app_key(const char* s,ssize_t size=-1);
inline pt_game_basic_info_t& set_ptr_app_key(const char* s,ssize_t size=-1);
inline void clear_app_key();
// @@string app_secret;
inline bool has_app_secret() const;
inline const char* app_secret(unsigned int* size=0) const;
inline pt_game_basic_info_t& set_app_secret(const char* s,ssize_t size=-1);
inline pt_game_basic_info_t& set_ptr_app_secret(const char* s,ssize_t size=-1);
inline void clear_app_secret();
// @@string notify_url;
inline bool has_notify_url() const;
inline const char* notify_url(unsigned int* size=0) const;
inline pt_game_basic_info_t& set_notify_url(const char* s,ssize_t size=-1);
inline pt_game_basic_info_t& set_ptr_notify_url(const char* s,ssize_t size=-1);
inline void clear_notify_url();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_game_id;
 ::idl::string _m_name;
 ::idl::string _m_app_key;
 ::idl::string _m_app_secret;
 ::idl::string _m_notify_url;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class pt_game_basic_info_t
class calender_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static calender_info_t* create(bsl::mempool* pool);
static void destroy(calender_info_t* v);
explicit calender_info_t(bsl::mempool* pool);
calender_info_t(const calender_info_t& v);
~calender_info_t();
calender_info_t& operator=(const calender_info_t& v);
void clear();
void check() const;
void detach();
calender_info_t& assign(const calender_info_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline calender_info_t& set_id(const char* s,ssize_t size=-1);
inline calender_info_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string title;
inline bool has_title() const;
inline const char* title(unsigned int* size=0) const;
inline calender_info_t& set_title(const char* s,ssize_t size=-1);
inline calender_info_t& set_ptr_title(const char* s,ssize_t size=-1);
inline void clear_title();
// @@uint32_t type;
inline bool has_type() const;
inline uint32_t type() const;
inline calender_info_t& set_type(uint32_t v);
inline void clear_type();
// @@string c_id;
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline calender_info_t& set_c_id(const char* s,ssize_t size=-1);
inline calender_info_t& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string date;
inline bool has_date() const;
inline const char* date(unsigned int* size=0) const;
inline calender_info_t& set_date(const char* s,ssize_t size=-1);
inline calender_info_t& set_ptr_date(const char* s,ssize_t size=-1);
inline void clear_date();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_title;
 uint32_t _m_type;
 ::idl::string _m_c_id;
 ::idl::string _m_date;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class calender_info_t
class soft_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static soft_info_t* create(bsl::mempool* pool);
static void destroy(soft_info_t* v);
explicit soft_info_t(bsl::mempool* pool);
soft_info_t(const soft_info_t& v);
~soft_info_t();
soft_info_t& operator=(const soft_info_t& v);
void clear();
void check() const;
void detach();
soft_info_t& assign(const soft_info_t& v);
// @@string type_id;
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline soft_info_t& set_type_id(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline soft_info_t& set_id(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline soft_info_t& set_name(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string icon;
inline bool has_icon() const;
inline const char* icon(unsigned int* size=0) const;
inline soft_info_t& set_icon(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_icon(const char* s,ssize_t size=-1);
inline void clear_icon();
// @@string preview;
inline bool has_preview() const;
inline const char* preview(unsigned int* size=0) const;
inline soft_info_t& set_preview(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_preview(const char* s,ssize_t size=-1);
inline void clear_preview();
// @@string version;
inline bool has_version() const;
inline const char* version(unsigned int* size=0) const;
inline soft_info_t& set_version(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_version(const char* s,ssize_t size=-1);
inline void clear_version();
// @@string size;
inline bool has_size() const;
inline const char* size(unsigned int* size=0) const;
inline soft_info_t& set_size(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_size(const char* s,ssize_t size=-1);
inline void clear_size();
// @@string pop;
inline bool has_pop() const;
inline const char* pop(unsigned int* size=0) const;
inline soft_info_t& set_pop(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_pop(const char* s,ssize_t size=-1);
inline void clear_pop();
// @@string adapt;
inline bool has_adapt() const;
inline const char* adapt(unsigned int* size=0) const;
inline soft_info_t& set_adapt(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_adapt(const char* s,ssize_t size=-1);
inline void clear_adapt();
// @@string date;
inline bool has_date() const;
inline const char* date(unsigned int* size=0) const;
inline soft_info_t& set_date(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_date(const char* s,ssize_t size=-1);
inline void clear_date();
// @@string froms;
inline bool has_froms() const;
inline const char* froms(unsigned int* size=0) const;
inline soft_info_t& set_froms(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_froms(const char* s,ssize_t size=-1);
inline void clear_froms();
// @@string info;
inline bool has_info() const;
inline const char* info(unsigned int* size=0) const;
inline soft_info_t& set_info(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_info(const char* s,ssize_t size=-1);
inline void clear_info();
// @@string down_url;
inline bool has_down_url() const;
inline const char* down_url(unsigned int* size=0) const;
inline soft_info_t& set_down_url(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_down_url(const char* s,ssize_t size=-1);
inline void clear_down_url();
// @@string star;
inline bool has_star() const;
inline const char* star(unsigned int* size=0) const;
inline soft_info_t& set_star(const char* s,ssize_t size=-1);
inline soft_info_t& set_ptr_star(const char* s,ssize_t size=-1);
inline void clear_star();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_type_id;
 ::idl::string _m_id;
 ::idl::string _m_name;
 ::idl::string _m_icon;
 ::idl::string _m_preview;
 ::idl::string _m_version;
 ::idl::string _m_size;
 ::idl::string _m_pop;
 ::idl::string _m_adapt;
 ::idl::string _m_date;
 ::idl::string _m_froms;
 ::idl::string _m_info;
 ::idl::string _m_down_url;
 ::idl::string _m_star;
mutable ::idl::Unknown _unknown;
char _flag[2];
}; // class soft_info_t
class theme_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static theme_info_t* create(bsl::mempool* pool);
static void destroy(theme_info_t* v);
explicit theme_info_t(bsl::mempool* pool);
theme_info_t(const theme_info_t& v);
~theme_info_t();
theme_info_t& operator=(const theme_info_t& v);
void clear();
void check() const;
void detach();
theme_info_t& assign(const theme_info_t& v);
// @@string type_id;
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline theme_info_t& set_type_id(const char* s,ssize_t size=-1);
inline theme_info_t& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline theme_info_t& set_id(const char* s,ssize_t size=-1);
inline theme_info_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline theme_info_t& set_name(const char* s,ssize_t size=-1);
inline theme_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string icon;
inline bool has_icon() const;
inline const char* icon(unsigned int* size=0) const;
inline theme_info_t& set_icon(const char* s,ssize_t size=-1);
inline theme_info_t& set_ptr_icon(const char* s,ssize_t size=-1);
inline void clear_icon();
// @@string preview;
inline bool has_preview() const;
inline const char* preview(unsigned int* size=0) const;
inline theme_info_t& set_preview(const char* s,ssize_t size=-1);
inline theme_info_t& set_ptr_preview(const char* s,ssize_t size=-1);
inline void clear_preview();
// @@string size;
inline bool has_size() const;
inline const char* size(unsigned int* size=0) const;
inline theme_info_t& set_size(const char* s,ssize_t size=-1);
inline theme_info_t& set_ptr_size(const char* s,ssize_t size=-1);
inline void clear_size();
// @@string pop;
inline bool has_pop() const;
inline const char* pop(unsigned int* size=0) const;
inline theme_info_t& set_pop(const char* s,ssize_t size=-1);
inline theme_info_t& set_ptr_pop(const char* s,ssize_t size=-1);
inline void clear_pop();
// @@string adapt;
inline bool has_adapt() const;
inline const char* adapt(unsigned int* size=0) const;
inline theme_info_t& set_adapt(const char* s,ssize_t size=-1);
inline theme_info_t& set_ptr_adapt(const char* s,ssize_t size=-1);
inline void clear_adapt();
// @@string date;
inline bool has_date() const;
inline const char* date(unsigned int* size=0) const;
inline theme_info_t& set_date(const char* s,ssize_t size=-1);
inline theme_info_t& set_ptr_date(const char* s,ssize_t size=-1);
inline void clear_date();
// @@string froms;
inline bool has_froms() const;
inline const char* froms(unsigned int* size=0) const;
inline theme_info_t& set_froms(const char* s,ssize_t size=-1);
inline theme_info_t& set_ptr_froms(const char* s,ssize_t size=-1);
inline void clear_froms();
// @@string info;
inline bool has_info() const;
inline const char* info(unsigned int* size=0) const;
inline theme_info_t& set_info(const char* s,ssize_t size=-1);
inline theme_info_t& set_ptr_info(const char* s,ssize_t size=-1);
inline void clear_info();
// @@string down_url;
inline bool has_down_url() const;
inline const char* down_url(unsigned int* size=0) const;
inline theme_info_t& set_down_url(const char* s,ssize_t size=-1);
inline theme_info_t& set_ptr_down_url(const char* s,ssize_t size=-1);
inline void clear_down_url();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_type_id;
 ::idl::string _m_id;
 ::idl::string _m_name;
 ::idl::string _m_icon;
 ::idl::string _m_preview;
 ::idl::string _m_size;
 ::idl::string _m_pop;
 ::idl::string _m_adapt;
 ::idl::string _m_date;
 ::idl::string _m_froms;
 ::idl::string _m_info;
 ::idl::string _m_down_url;
mutable ::idl::Unknown _unknown;
char _flag[2];
}; // class theme_info_t
class music_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static music_info_t* create(bsl::mempool* pool);
static void destroy(music_info_t* v);
explicit music_info_t(bsl::mempool* pool);
music_info_t(const music_info_t& v);
~music_info_t();
music_info_t& operator=(const music_info_t& v);
void clear();
void check() const;
void detach();
music_info_t& assign(const music_info_t& v);
// @@string music_id;
inline bool has_music_id() const;
inline const char* music_id(unsigned int* size=0) const;
inline music_info_t& set_music_id(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_music_id(const char* s,ssize_t size=-1);
inline void clear_music_id();
// @@string songname;
inline bool has_songname() const;
inline const char* songname(unsigned int* size=0) const;
inline music_info_t& set_songname(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_songname(const char* s,ssize_t size=-1);
inline void clear_songname();
// @@string area_id;
inline bool has_area_id() const;
inline const char* area_id(unsigned int* size=0) const;
inline music_info_t& set_area_id(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_area_id(const char* s,ssize_t size=-1);
inline void clear_area_id();
// @@string area_name;
inline bool has_area_name() const;
inline const char* area_name(unsigned int* size=0) const;
inline music_info_t& set_area_name(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_area_name(const char* s,ssize_t size=-1);
inline void clear_area_name();
// @@string cp_id;
inline bool has_cp_id() const;
inline const char* cp_id(unsigned int* size=0) const;
inline music_info_t& set_cp_id(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_cp_id(const char* s,ssize_t size=-1);
inline void clear_cp_id();
// @@string cp_name;
inline bool has_cp_name() const;
inline const char* cp_name(unsigned int* size=0) const;
inline music_info_t& set_cp_name(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_cp_name(const char* s,ssize_t size=-1);
inline void clear_cp_name();
// @@string language_id;
inline bool has_language_id() const;
inline const char* language_id(unsigned int* size=0) const;
inline music_info_t& set_language_id(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_language_id(const char* s,ssize_t size=-1);
inline void clear_language_id();
// @@string language;
inline bool has_language() const;
inline const char* language(unsigned int* size=0) const;
inline music_info_t& set_language(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_language(const char* s,ssize_t size=-1);
inline void clear_language();
// @@string publish_date;
inline bool has_publish_date() const;
inline const char* publish_date(unsigned int* size=0) const;
inline music_info_t& set_publish_date(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_publish_date(const char* s,ssize_t size=-1);
inline void clear_publish_date();
// @@string intro;
inline bool has_intro() const;
inline const char* intro(unsigned int* size=0) const;
inline music_info_t& set_intro(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_intro(const char* s,ssize_t size=-1);
inline void clear_intro();
// @@string lyric_writer;
inline bool has_lyric_writer() const;
inline const char* lyric_writer(unsigned int* size=0) const;
inline music_info_t& set_lyric_writer(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_lyric_writer(const char* s,ssize_t size=-1);
inline void clear_lyric_writer();
// @@string composer;
inline bool has_composer() const;
inline const char* composer(unsigned int* size=0) const;
inline music_info_t& set_composer(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_composer(const char* s,ssize_t size=-1);
inline void clear_composer();
// @@string price;
inline bool has_price() const;
inline const char* price(unsigned int* size=0) const;
inline music_info_t& set_price(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_price(const char* s,ssize_t size=-1);
inline void clear_price();
// @@string discount;
inline bool has_discount() const;
inline const char* discount(unsigned int* size=0) const;
inline music_info_t& set_discount(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_discount(const char* s,ssize_t size=-1);
inline void clear_discount();
// @@string download_base;
inline bool has_download_base() const;
inline const char* download_base(unsigned int* size=0) const;
inline music_info_t& set_download_base(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_download_base(const char* s,ssize_t size=-1);
inline void clear_download_base();
// @@string lyric_txt;
inline bool has_lyric_txt() const;
inline const char* lyric_txt(unsigned int* size=0) const;
inline music_info_t& set_lyric_txt(const char* s,ssize_t size=-1);
inline music_info_t& set_ptr_lyric_txt(const char* s,ssize_t size=-1);
inline void clear_lyric_txt();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_music_id;
 ::idl::string _m_songname;
 ::idl::string _m_area_id;
 ::idl::string _m_area_name;
 ::idl::string _m_cp_id;
 ::idl::string _m_cp_name;
 ::idl::string _m_language_id;
 ::idl::string _m_language;
 ::idl::string _m_publish_date;
 ::idl::string _m_intro;
 ::idl::string _m_lyric_writer;
 ::idl::string _m_composer;
 ::idl::string _m_price;
 ::idl::string _m_discount;
 ::idl::string _m_download_base;
 ::idl::string _m_lyric_txt;
mutable ::idl::Unknown _unknown;
char _flag[2];
}; // class music_info_t
class cp_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static cp_info_t* create(bsl::mempool* pool);
static void destroy(cp_info_t* v);
explicit cp_info_t(bsl::mempool* pool);
cp_info_t(const cp_info_t& v);
~cp_info_t();
cp_info_t& operator=(const cp_info_t& v);
void clear();
void check() const;
void detach();
cp_info_t& assign(const cp_info_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline cp_info_t& set_id(const char* s,ssize_t size=-1);
inline cp_info_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline cp_info_t& set_name(const char* s,ssize_t size=-1);
inline cp_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_name;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class cp_info_t
class grant_detail_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static grant_detail_t* create(bsl::mempool* pool);
static void destroy(grant_detail_t* v);
explicit grant_detail_t(bsl::mempool* pool);
grant_detail_t(const grant_detail_t& v);
~grant_detail_t();
grant_detail_t& operator=(const grant_detail_t& v);
void clear();
void check() const;
void detach();
grant_detail_t& assign(const grant_detail_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline grant_detail_t& set_id(const char* s,ssize_t size=-1);
inline grant_detail_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string grant_time;
inline bool has_grant_time() const;
inline const char* grant_time(unsigned int* size=0) const;
inline grant_detail_t& set_grant_time(const char* s,ssize_t size=-1);
inline grant_detail_t& set_ptr_grant_time(const char* s,ssize_t size=-1);
inline void clear_grant_time();
// @@string valid_time;
inline bool has_valid_time() const;
inline const char* valid_time(unsigned int* size=0) const;
inline grant_detail_t& set_valid_time(const char* s,ssize_t size=-1);
inline grant_detail_t& set_ptr_valid_time(const char* s,ssize_t size=-1);
inline void clear_valid_time();
// @@string modify_time;
inline bool has_modify_time() const;
inline const char* modify_time(unsigned int* size=0) const;
inline grant_detail_t& set_modify_time(const char* s,ssize_t size=-1);
inline grant_detail_t& set_ptr_modify_time(const char* s,ssize_t size=-1);
inline void clear_modify_time();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_grant_time;
 ::idl::string _m_valid_time;
 ::idl::string _m_modify_time;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class grant_detail_t
class download_detail_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static download_detail_t* create(bsl::mempool* pool);
static void destroy(download_detail_t* v);
explicit download_detail_t(bsl::mempool* pool);
download_detail_t(const download_detail_t& v);
~download_detail_t();
download_detail_t& operator=(const download_detail_t& v);
void clear();
void check() const;
void detach();
download_detail_t& assign(const download_detail_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline download_detail_t& set_id(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string url;
inline bool has_url() const;
inline const char* url(unsigned int* size=0) const;
inline download_detail_t& set_url(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_url(const char* s,ssize_t size=-1);
inline void clear_url();
// @@string baidu_url;
inline bool has_baidu_url() const;
inline const char* baidu_url(unsigned int* size=0) const;
inline download_detail_t& set_baidu_url(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_baidu_url(const char* s,ssize_t size=-1);
inline void clear_baidu_url();
// @@string url_type;
inline bool has_url_type() const;
inline const char* url_type(unsigned int* size=0) const;
inline download_detail_t& set_url_type(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_url_type(const char* s,ssize_t size=-1);
inline void clear_url_type();
// @@string media_format;
inline bool has_media_format() const;
inline const char* media_format(unsigned int* size=0) const;
inline download_detail_t& set_media_format(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_media_format(const char* s,ssize_t size=-1);
inline void clear_media_format();
// @@string size;
inline bool has_size() const;
inline const char* size(unsigned int* size=0) const;
inline download_detail_t& set_size(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_size(const char* s,ssize_t size=-1);
inline void clear_size();
// @@string mtype;
inline bool has_mtype() const;
inline const char* mtype(unsigned int* size=0) const;
inline download_detail_t& set_mtype(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_mtype(const char* s,ssize_t size=-1);
inline void clear_mtype();
// @@string charge_id;
inline bool has_charge_id() const;
inline const char* charge_id(unsigned int* size=0) const;
inline download_detail_t& set_charge_id(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_charge_id(const char* s,ssize_t size=-1);
inline void clear_charge_id();
// @@string charge_value;
inline bool has_charge_value() const;
inline const char* charge_value(unsigned int* size=0) const;
inline download_detail_t& set_charge_value(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_charge_value(const char* s,ssize_t size=-1);
inline void clear_charge_value();
// @@string apk_flag;
inline bool has_apk_flag() const;
inline const char* apk_flag(unsigned int* size=0) const;
inline download_detail_t& set_apk_flag(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_apk_flag(const char* s,ssize_t size=-1);
inline void clear_apk_flag();
// @@string channel_info;
inline bool has_channel_info() const;
inline const char* channel_info(unsigned int* size=0) const;
inline download_detail_t& set_channel_info(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_channel_info(const char* s,ssize_t size=-1);
inline void clear_channel_info();
// @@string channel_id;
inline bool has_channel_id() const;
inline const char* channel_id(unsigned int* size=0) const;
inline download_detail_t& set_channel_id(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_channel_id(const char* s,ssize_t size=-1);
inline void clear_channel_id();
// @@string package_name;
inline bool has_package_name() const;
inline const char* package_name(unsigned int* size=0) const;
inline download_detail_t& set_package_name(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_package_name(const char* s,ssize_t size=-1);
inline void clear_package_name();
// @@string int_version;
inline bool has_int_version() const;
inline const char* int_version(unsigned int* size=0) const;
inline download_detail_t& set_int_version(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_int_version(const char* s,ssize_t size=-1);
inline void clear_int_version();
// @@string string_version;
inline bool has_string_version() const;
inline const char* string_version(unsigned int* size=0) const;
inline download_detail_t& set_string_version(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_string_version(const char* s,ssize_t size=-1);
inline void clear_string_version();
// @@string sdk_version;
inline bool has_sdk_version() const;
inline const char* sdk_version(unsigned int* size=0) const;
inline download_detail_t& set_sdk_version(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_sdk_version(const char* s,ssize_t size=-1);
inline void clear_sdk_version();
// @@string apk_md5;
inline bool has_apk_md5() const;
inline const char* apk_md5(unsigned int* size=0) const;
inline download_detail_t& set_apk_md5(const char* s,ssize_t size=-1);
inline download_detail_t& set_ptr_apk_md5(const char* s,ssize_t size=-1);
inline void clear_apk_md5();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_url;
 ::idl::string _m_baidu_url;
 ::idl::string _m_url_type;
 ::idl::string _m_media_format;
 ::idl::string _m_size;
 ::idl::string _m_mtype;
 ::idl::string _m_charge_id;
 ::idl::string _m_charge_value;
 ::idl::string _m_apk_flag;
 ::idl::string _m_channel_info;
 ::idl::string _m_channel_id;
 ::idl::string _m_package_name;
 ::idl::string _m_int_version;
 ::idl::string _m_string_version;
 ::idl::string _m_sdk_version;
 ::idl::string _m_apk_md5;
mutable ::idl::Unknown _unknown;
char _flag[3];
}; // class download_detail_t
class championship_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static championship_info_t* create(bsl::mempool* pool);
static void destroy(championship_info_t* v);
explicit championship_info_t(bsl::mempool* pool);
championship_info_t(const championship_info_t& v);
~championship_info_t();
championship_info_t& operator=(const championship_info_t& v);
void clear();
void check() const;
void detach();
championship_info_t& assign(const championship_info_t& v);
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline championship_info_t& set_name(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string game_name;
inline bool has_game_name() const;
inline const char* game_name(unsigned int* size=0) const;
inline championship_info_t& set_game_name(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_game_name(const char* s,ssize_t size=-1);
inline void clear_game_name();
// @@string union_start_action;
inline bool has_union_start_action() const;
inline const char* union_start_action(unsigned int* size=0) const;
inline championship_info_t& set_union_start_action(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_union_start_action(const char* s,ssize_t size=-1);
inline void clear_union_start_action();
// @@string has_account;
inline bool has_has_account() const;
inline const char* has_account(unsigned int* size=0) const;
inline championship_info_t& set_has_account(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_has_account(const char* s,ssize_t size=-1);
inline void clear_has_account();
// @@string c_id;
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline championship_info_t& set_c_id(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string log_date;
inline bool has_log_date() const;
inline const char* log_date(unsigned int* size=0) const;
inline championship_info_t& set_log_date(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_log_date(const char* s,ssize_t size=-1);
inline void clear_log_date();
// @@string channel_info;
inline bool has_channel_info() const;
inline const char* channel_info(unsigned int* size=0) const;
inline championship_info_t& set_channel_info(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_channel_info(const char* s,ssize_t size=-1);
inline void clear_channel_info();
// @@string start_time;
inline bool has_start_time() const;
inline const char* start_time(unsigned int* size=0) const;
inline championship_info_t& set_start_time(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_start_time(const char* s,ssize_t size=-1);
inline void clear_start_time();
// @@string end_time;
inline bool has_end_time() const;
inline const char* end_time(unsigned int* size=0) const;
inline championship_info_t& set_end_time(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_end_time(const char* s,ssize_t size=-1);
inline void clear_end_time();
// @@string join_num;
inline bool has_join_num() const;
inline const char* join_num(unsigned int* size=0) const;
inline championship_info_t& set_join_num(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_join_num(const char* s,ssize_t size=-1);
inline void clear_join_num();
// @@string award;
inline bool has_award() const;
inline const char* award(unsigned int* size=0) const;
inline championship_info_t& set_award(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_award(const char* s,ssize_t size=-1);
inline void clear_award();
// @@string rule;
inline bool has_rule() const;
inline const char* rule(unsigned int* size=0) const;
inline championship_info_t& set_rule(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_rule(const char* s,ssize_t size=-1);
inline void clear_rule();
// @@string total_coins;
inline bool has_total_coins() const;
inline const char* total_coins(unsigned int* size=0) const;
inline championship_info_t& set_total_coins(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_total_coins(const char* s,ssize_t size=-1);
inline void clear_total_coins();
// @@string pic_url;
inline bool has_pic_url() const;
inline const char* pic_url(unsigned int* size=0) const;
inline championship_info_t& set_pic_url(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_pic_url(const char* s,ssize_t size=-1);
inline void clear_pic_url();
// @@string enable;
inline bool has_enable() const;
inline const char* enable(unsigned int* size=0) const;
inline championship_info_t& set_enable(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_enable(const char* s,ssize_t size=-1);
inline void clear_enable();
// @@string top_award;
inline bool has_top_award() const;
inline const char* top_award(unsigned int* size=0) const;
inline championship_info_t& set_top_award(const char* s,ssize_t size=-1);
inline championship_info_t& set_ptr_top_award(const char* s,ssize_t size=-1);
inline void clear_top_award();
// @@download_detail_t championship_download_list=array(0);
inline bool has_championship_download_list() const;
inline const ::idl::vector< ::idl::download_detail_t >& championship_download_list() const;
inline ::idl::vector< ::idl::download_detail_t >* mutable_championship_download_list();
inline void clear_championship_download_list();
// deprecated.use 'mutable_championship_download_list' instead.
inline ::idl::vector< ::idl::download_detail_t >* m_championship_download_list();
// deprecated.use 'championship_download_list().size()' instead.
inline size_t championship_download_list_size() const;
inline const ::idl::download_detail_t& championship_download_list(size_t i0) const;
inline ::idl::download_detail_t* mutable_championship_download_list(size_t i0);
// deprecated.use 'mutable_championship_download_list' instead.
inline ::idl::download_detail_t* m_championship_download_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_name;
 ::idl::string _m_game_name;
 ::idl::string _m_union_start_action;
 ::idl::string _m_has_account;
 ::idl::string _m_c_id;
 ::idl::string _m_log_date;
 ::idl::string _m_channel_info;
 ::idl::string _m_start_time;
 ::idl::string _m_end_time;
 ::idl::string _m_join_num;
 ::idl::string _m_award;
 ::idl::string _m_rule;
 ::idl::string _m_total_coins;
 ::idl::string _m_pic_url;
 ::idl::string _m_enable;
 ::idl::string _m_top_award;
 ::idl::vector< ::idl::download_detail_t > _m_championship_download_list;
mutable ::idl::Unknown _unknown;
char _flag[3];
}; // class championship_info_t
class content_basic_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static content_basic_info_t* create(bsl::mempool* pool);
static void destroy(content_basic_info_t* v);
explicit content_basic_info_t(bsl::mempool* pool);
content_basic_info_t(const content_basic_info_t& v);
~content_basic_info_t();
content_basic_info_t& operator=(const content_basic_info_t& v);
void clear();
void check() const;
void detach();
content_basic_info_t& assign(const content_basic_info_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline content_basic_info_t& set_id(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline content_basic_info_t& set_name(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string type;
inline bool has_type() const;
inline const char* type(unsigned int* size=0) const;
inline content_basic_info_t& set_type(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_type(const char* s,ssize_t size=-1);
inline void clear_type();
// @@string ext_id;
inline bool has_ext_id() const;
inline const char* ext_id(unsigned int* size=0) const;
inline content_basic_info_t& set_ext_id(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_ext_id(const char* s,ssize_t size=-1);
inline void clear_ext_id();
// @@string abstract_;
inline bool has_abstract_() const;
inline const char* abstract_(unsigned int* size=0) const;
inline content_basic_info_t& set_abstract_(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_abstract_(const char* s,ssize_t size=-1);
inline void clear_abstract_();
// @@string version;
inline bool has_version() const;
inline const char* version(unsigned int* size=0) const;
inline content_basic_info_t& set_version(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_version(const char* s,ssize_t size=-1);
inline void clear_version();
// @@string method;
inline bool has_method() const;
inline const char* method(unsigned int* size=0) const;
inline content_basic_info_t& set_method(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_method(const char* s,ssize_t size=-1);
inline void clear_method();
// @@string star;
inline bool has_star() const;
inline const char* star(unsigned int* size=0) const;
inline content_basic_info_t& set_star(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_star(const char* s,ssize_t size=-1);
inline void clear_star();
// @@string network;
inline bool has_network() const;
inline const char* network(unsigned int* size=0) const;
inline content_basic_info_t& set_network(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_network(const char* s,ssize_t size=-1);
inline void clear_network();
// @@string code;
inline bool has_code() const;
inline const char* code(unsigned int* size=0) const;
inline content_basic_info_t& set_code(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_code(const char* s,ssize_t size=-1);
inline void clear_code();
// @@string log_date;
inline bool has_log_date() const;
inline const char* log_date(unsigned int* size=0) const;
inline content_basic_info_t& set_log_date(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_log_date(const char* s,ssize_t size=-1);
inline void clear_log_date();
// @@string mod_date;
inline bool has_mod_date() const;
inline const char* mod_date(unsigned int* size=0) const;
inline content_basic_info_t& set_mod_date(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_mod_date(const char* s,ssize_t size=-1);
inline void clear_mod_date();
// @@string dft_charge_type;
inline bool has_dft_charge_type() const;
inline const char* dft_charge_type(unsigned int* size=0) const;
inline content_basic_info_t& set_dft_charge_type(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_dft_charge_type(const char* s,ssize_t size=-1);
inline void clear_dft_charge_type();
// @@string dft_charge_val;
inline bool has_dft_charge_val() const;
inline const char* dft_charge_val(unsigned int* size=0) const;
inline content_basic_info_t& set_dft_charge_val(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_dft_charge_val(const char* s,ssize_t size=-1);
inline void clear_dft_charge_val();
// @@string enName;
inline bool has_enName() const;
inline const char* enName(unsigned int* size=0) const;
inline content_basic_info_t& set_enName(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_enName(const char* s,ssize_t size=-1);
inline void clear_enName();
// @@string language;
inline bool has_language() const;
inline const char* language(unsigned int* size=0) const;
inline content_basic_info_t& set_language(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_language(const char* s,ssize_t size=-1);
inline void clear_language();
// @@string adapt;
inline bool has_adapt() const;
inline const char* adapt(unsigned int* size=0) const;
inline content_basic_info_t& set_adapt(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_adapt(const char* s,ssize_t size=-1);
inline void clear_adapt();
// @@string package_name;
inline bool has_package_name() const;
inline const char* package_name(unsigned int* size=0) const;
inline content_basic_info_t& set_package_name(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_package_name(const char* s,ssize_t size=-1);
inline void clear_package_name();
// @@string version_appinfo;
inline bool has_version_appinfo() const;
inline const char* version_appinfo(unsigned int* size=0) const;
inline content_basic_info_t& set_version_appinfo(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_version_appinfo(const char* s,ssize_t size=-1);
inline void clear_version_appinfo();
// @@string sdk_version;
inline bool has_sdk_version() const;
inline const char* sdk_version(unsigned int* size=0) const;
inline content_basic_info_t& set_sdk_version(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_sdk_version(const char* s,ssize_t size=-1);
inline void clear_sdk_version();
// @@string version_code;
inline bool has_version_code() const;
inline const char* version_code(unsigned int* size=0) const;
inline content_basic_info_t& set_version_code(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_version_code(const char* s,ssize_t size=-1);
inline void clear_version_code();
// @@string ptype_0;
inline bool has_ptype_0() const;
inline const char* ptype_0(unsigned int* size=0) const;
inline content_basic_info_t& set_ptype_0(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_ptype_0(const char* s,ssize_t size=-1);
inline void clear_ptype_0();
// @@string ptype_1;
inline bool has_ptype_1() const;
inline const char* ptype_1(unsigned int* size=0) const;
inline content_basic_info_t& set_ptype_1(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_ptype_1(const char* s,ssize_t size=-1);
inline void clear_ptype_1();
// @@string ptype_2;
inline bool has_ptype_2() const;
inline const char* ptype_2(unsigned int* size=0) const;
inline content_basic_info_t& set_ptype_2(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_ptype_2(const char* s,ssize_t size=-1);
inline void clear_ptype_2();
// @@string ptype_3;
inline bool has_ptype_3() const;
inline const char* ptype_3(unsigned int* size=0) const;
inline content_basic_info_t& set_ptype_3(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_ptype_3(const char* s,ssize_t size=-1);
inline void clear_ptype_3();
// @@string ptype_4;
inline bool has_ptype_4() const;
inline const char* ptype_4(unsigned int* size=0) const;
inline content_basic_info_t& set_ptype_4(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_ptype_4(const char* s,ssize_t size=-1);
inline void clear_ptype_4();
// @@string pub_props=array(0);
inline bool has_pub_props() const;
inline const ::idl::vector< ::idl::string >& pub_props() const;
inline ::idl::vector< ::idl::string >* mutable_pub_props();
inline void clear_pub_props();
// deprecated.use 'mutable_pub_props' instead.
inline ::idl::vector< ::idl::string >* m_pub_props();
// deprecated.use 'pub_props().size()' instead.
inline size_t pub_props_size() const;
inline const char* pub_props(size_t i0,unsigned int* size=0) const;
inline content_basic_info_t& set_pub_props(size_t i0,const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_pub_props(size_t i0,const char* s,ssize_t size=-1);
// @@pub_prop_info_t pub_prop_info=array(0);
inline bool has_pub_prop_info() const;
inline const ::idl::vector< ::idl::pub_prop_info_t >& pub_prop_info() const;
inline ::idl::vector< ::idl::pub_prop_info_t >* mutable_pub_prop_info();
inline void clear_pub_prop_info();
// deprecated.use 'mutable_pub_prop_info' instead.
inline ::idl::vector< ::idl::pub_prop_info_t >* m_pub_prop_info();
// deprecated.use 'pub_prop_info().size()' instead.
inline size_t pub_prop_info_size() const;
inline const ::idl::pub_prop_info_t& pub_prop_info(size_t i0) const;
inline ::idl::pub_prop_info_t* mutable_pub_prop_info(size_t i0);
// deprecated.use 'mutable_pub_prop_info' instead.
inline ::idl::pub_prop_info_t* m_pub_prop_info(size_t i0);
// @@string union_start_action;
inline bool has_union_start_action() const;
inline const char* union_start_action(unsigned int* size=0) const;
inline content_basic_info_t& set_union_start_action(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_union_start_action(const char* s,ssize_t size=-1);
inline void clear_union_start_action();
// @@string has_account;
inline bool has_has_account() const;
inline const char* has_account(unsigned int* size=0) const;
inline content_basic_info_t& set_has_account(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_has_account(const char* s,ssize_t size=-1);
inline void clear_has_account();
// @@string editor_recom;
inline bool has_editor_recom() const;
inline const char* editor_recom(unsigned int* size=0) const;
inline content_basic_info_t& set_editor_recom(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_editor_recom(const char* s,ssize_t size=-1);
inline void clear_editor_recom();
// @@string show_highspeed;
inline bool has_show_highspeed() const;
inline const char* show_highspeed(unsigned int* size=0) const;
inline content_basic_info_t& set_show_highspeed(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_show_highspeed(const char* s,ssize_t size=-1);
inline void clear_show_highspeed();
// @@string bind_resource_id;
inline bool has_bind_resource_id() const;
inline const char* bind_resource_id(unsigned int* size=0) const;
inline content_basic_info_t& set_bind_resource_id(const char* s,ssize_t size=-1);
inline content_basic_info_t& set_ptr_bind_resource_id(const char* s,ssize_t size=-1);
inline void clear_bind_resource_id();
// @@class_info_t class_info=array(0);
inline bool has_class_info() const;
inline const ::idl::vector< ::idl::class_info_t >& class_info() const;
inline ::idl::vector< ::idl::class_info_t >* mutable_class_info();
inline void clear_class_info();
// deprecated.use 'mutable_class_info' instead.
inline ::idl::vector< ::idl::class_info_t >* m_class_info();
// deprecated.use 'class_info().size()' instead.
inline size_t class_info_size() const;
inline const ::idl::class_info_t& class_info(size_t i0) const;
inline ::idl::class_info_t* mutable_class_info(size_t i0);
// deprecated.use 'mutable_class_info' instead.
inline ::idl::class_info_t* m_class_info(size_t i0);
// @@img_info_t img_info=array(0);
inline bool has_img_info() const;
inline const ::idl::vector< ::idl::img_info_t >& img_info() const;
inline ::idl::vector< ::idl::img_info_t >* mutable_img_info();
inline void clear_img_info();
// deprecated.use 'mutable_img_info' instead.
inline ::idl::vector< ::idl::img_info_t >* m_img_info();
// deprecated.use 'img_info().size()' instead.
inline size_t img_info_size() const;
inline const ::idl::img_info_t& img_info(size_t i0) const;
inline ::idl::img_info_t* mutable_img_info(size_t i0);
// deprecated.use 'mutable_img_info' instead.
inline ::idl::img_info_t* m_img_info(size_t i0);
// @@cp_info_t cp_info;
inline bool has_cp_info() const;
inline const ::idl::cp_info_t& cp_info() const;
inline ::idl::cp_info_t* mutable_cp_info();
// deprecated.use 'mutable_cp_info()' instead.
inline ::idl::cp_info_t* m_cp_info();
inline void clear_cp_info();
// @@grant_detail_t grant_info;
inline bool has_grant_info() const;
inline const ::idl::grant_detail_t& grant_info() const;
inline ::idl::grant_detail_t* mutable_grant_info();
// deprecated.use 'mutable_grant_info()' instead.
inline ::idl::grant_detail_t* m_grant_info();
inline void clear_grant_info();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_name;
 ::idl::string _m_type;
 ::idl::string _m_ext_id;
 ::idl::string _m_abstract_;
 ::idl::string _m_version;
 ::idl::string _m_method;
 ::idl::string _m_star;
 ::idl::string _m_network;
 ::idl::string _m_code;
 ::idl::string _m_log_date;
 ::idl::string _m_mod_date;
 ::idl::string _m_dft_charge_type;
 ::idl::string _m_dft_charge_val;
 ::idl::string _m_enName;
 ::idl::string _m_language;
 ::idl::string _m_adapt;
 ::idl::string _m_package_name;
 ::idl::string _m_version_appinfo;
 ::idl::string _m_sdk_version;
 ::idl::string _m_version_code;
 ::idl::string _m_ptype_0;
 ::idl::string _m_ptype_1;
 ::idl::string _m_ptype_2;
 ::idl::string _m_ptype_3;
 ::idl::string _m_ptype_4;
 ::idl::vector< ::idl::string > _m_pub_props;
 ::idl::vector< ::idl::pub_prop_info_t > _m_pub_prop_info;
 ::idl::string _m_union_start_action;
 ::idl::string _m_has_account;
 ::idl::string _m_editor_recom;
 ::idl::string _m_show_highspeed;
 ::idl::string _m_bind_resource_id;
 ::idl::vector< ::idl::class_info_t > _m_class_info;
 ::idl::vector< ::idl::img_info_t > _m_img_info;
mutable ::idl::cp_info_t* _m_cp_info;
mutable ::idl::grant_detail_t* _m_grant_info;
mutable ::idl::Unknown _unknown;
char _flag[5];
}; // class content_basic_info_t
class content_detail_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static content_detail_t* create(bsl::mempool* pool);
static void destroy(content_detail_t* v);
explicit content_detail_t(bsl::mempool* pool);
content_detail_t(const content_detail_t& v);
~content_detail_t();
content_detail_t& operator=(const content_detail_t& v);
void clear();
void check() const;
void detach();
content_detail_t& assign(const content_detail_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline content_detail_t& set_id(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline content_detail_t& set_name(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string type;
inline bool has_type() const;
inline const char* type(unsigned int* size=0) const;
inline content_detail_t& set_type(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_type(const char* s,ssize_t size=-1);
inline void clear_type();
// @@class_info_t class_info=array(0);
inline bool has_class_info() const;
inline const ::idl::vector< ::idl::class_info_t >& class_info() const;
inline ::idl::vector< ::idl::class_info_t >* mutable_class_info();
inline void clear_class_info();
// deprecated.use 'mutable_class_info' instead.
inline ::idl::vector< ::idl::class_info_t >* m_class_info();
// deprecated.use 'class_info().size()' instead.
inline size_t class_info_size() const;
inline const ::idl::class_info_t& class_info(size_t i0) const;
inline ::idl::class_info_t* mutable_class_info(size_t i0);
// deprecated.use 'mutable_class_info' instead.
inline ::idl::class_info_t* m_class_info(size_t i0);
// @@img_info_t img_info=array(0);
inline bool has_img_info() const;
inline const ::idl::vector< ::idl::img_info_t >& img_info() const;
inline ::idl::vector< ::idl::img_info_t >* mutable_img_info();
inline void clear_img_info();
// deprecated.use 'mutable_img_info' instead.
inline ::idl::vector< ::idl::img_info_t >* m_img_info();
// deprecated.use 'img_info().size()' instead.
inline size_t img_info_size() const;
inline const ::idl::img_info_t& img_info(size_t i0) const;
inline ::idl::img_info_t* mutable_img_info(size_t i0);
// deprecated.use 'mutable_img_info' instead.
inline ::idl::img_info_t* m_img_info(size_t i0);
// @@string ext_id;
inline bool has_ext_id() const;
inline const char* ext_id(unsigned int* size=0) const;
inline content_detail_t& set_ext_id(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_ext_id(const char* s,ssize_t size=-1);
inline void clear_ext_id();
// @@string abstract_;
inline bool has_abstract_() const;
inline const char* abstract_(unsigned int* size=0) const;
inline content_detail_t& set_abstract_(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_abstract_(const char* s,ssize_t size=-1);
inline void clear_abstract_();
// @@string version;
inline bool has_version() const;
inline const char* version(unsigned int* size=0) const;
inline content_detail_t& set_version(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_version(const char* s,ssize_t size=-1);
inline void clear_version();
// @@string method;
inline bool has_method() const;
inline const char* method(unsigned int* size=0) const;
inline content_detail_t& set_method(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_method(const char* s,ssize_t size=-1);
inline void clear_method();
// @@string star;
inline bool has_star() const;
inline const char* star(unsigned int* size=0) const;
inline content_detail_t& set_star(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_star(const char* s,ssize_t size=-1);
inline void clear_star();
// @@string network;
inline bool has_network() const;
inline const char* network(unsigned int* size=0) const;
inline content_detail_t& set_network(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_network(const char* s,ssize_t size=-1);
inline void clear_network();
// @@string code;
inline bool has_code() const;
inline const char* code(unsigned int* size=0) const;
inline content_detail_t& set_code(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_code(const char* s,ssize_t size=-1);
inline void clear_code();
// @@string log_date;
inline bool has_log_date() const;
inline const char* log_date(unsigned int* size=0) const;
inline content_detail_t& set_log_date(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_log_date(const char* s,ssize_t size=-1);
inline void clear_log_date();
// @@string mod_date;
inline bool has_mod_date() const;
inline const char* mod_date(unsigned int* size=0) const;
inline content_detail_t& set_mod_date(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_mod_date(const char* s,ssize_t size=-1);
inline void clear_mod_date();
// @@string dft_charge_type;
inline bool has_dft_charge_type() const;
inline const char* dft_charge_type(unsigned int* size=0) const;
inline content_detail_t& set_dft_charge_type(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_dft_charge_type(const char* s,ssize_t size=-1);
inline void clear_dft_charge_type();
// @@string dft_charge_val;
inline bool has_dft_charge_val() const;
inline const char* dft_charge_val(unsigned int* size=0) const;
inline content_detail_t& set_dft_charge_val(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_dft_charge_val(const char* s,ssize_t size=-1);
inline void clear_dft_charge_val();
// @@string enName;
inline bool has_enName() const;
inline const char* enName(unsigned int* size=0) const;
inline content_detail_t& set_enName(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_enName(const char* s,ssize_t size=-1);
inline void clear_enName();
// @@string language;
inline bool has_language() const;
inline const char* language(unsigned int* size=0) const;
inline content_detail_t& set_language(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_language(const char* s,ssize_t size=-1);
inline void clear_language();
// @@string adapt;
inline bool has_adapt() const;
inline const char* adapt(unsigned int* size=0) const;
inline content_detail_t& set_adapt(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_adapt(const char* s,ssize_t size=-1);
inline void clear_adapt();
// @@string package_name;
inline bool has_package_name() const;
inline const char* package_name(unsigned int* size=0) const;
inline content_detail_t& set_package_name(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_package_name(const char* s,ssize_t size=-1);
inline void clear_package_name();
// @@string version_appinfo;
inline bool has_version_appinfo() const;
inline const char* version_appinfo(unsigned int* size=0) const;
inline content_detail_t& set_version_appinfo(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_version_appinfo(const char* s,ssize_t size=-1);
inline void clear_version_appinfo();
// @@string sdk_version;
inline bool has_sdk_version() const;
inline const char* sdk_version(unsigned int* size=0) const;
inline content_detail_t& set_sdk_version(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_sdk_version(const char* s,ssize_t size=-1);
inline void clear_sdk_version();
// @@string version_code;
inline bool has_version_code() const;
inline const char* version_code(unsigned int* size=0) const;
inline content_detail_t& set_version_code(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_version_code(const char* s,ssize_t size=-1);
inline void clear_version_code();
// @@string ptype_0;
inline bool has_ptype_0() const;
inline const char* ptype_0(unsigned int* size=0) const;
inline content_detail_t& set_ptype_0(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_ptype_0(const char* s,ssize_t size=-1);
inline void clear_ptype_0();
// @@string ptype_1;
inline bool has_ptype_1() const;
inline const char* ptype_1(unsigned int* size=0) const;
inline content_detail_t& set_ptype_1(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_ptype_1(const char* s,ssize_t size=-1);
inline void clear_ptype_1();
// @@string ptype_2;
inline bool has_ptype_2() const;
inline const char* ptype_2(unsigned int* size=0) const;
inline content_detail_t& set_ptype_2(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_ptype_2(const char* s,ssize_t size=-1);
inline void clear_ptype_2();
// @@string ptype_3;
inline bool has_ptype_3() const;
inline const char* ptype_3(unsigned int* size=0) const;
inline content_detail_t& set_ptype_3(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_ptype_3(const char* s,ssize_t size=-1);
inline void clear_ptype_3();
// @@string ptype_4;
inline bool has_ptype_4() const;
inline const char* ptype_4(unsigned int* size=0) const;
inline content_detail_t& set_ptype_4(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_ptype_4(const char* s,ssize_t size=-1);
inline void clear_ptype_4();
// @@string pub_props=array(0);
inline bool has_pub_props() const;
inline const ::idl::vector< ::idl::string >& pub_props() const;
inline ::idl::vector< ::idl::string >* mutable_pub_props();
inline void clear_pub_props();
// deprecated.use 'mutable_pub_props' instead.
inline ::idl::vector< ::idl::string >* m_pub_props();
// deprecated.use 'pub_props().size()' instead.
inline size_t pub_props_size() const;
inline const char* pub_props(size_t i0,unsigned int* size=0) const;
inline content_detail_t& set_pub_props(size_t i0,const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_pub_props(size_t i0,const char* s,ssize_t size=-1);
// @@pub_prop_info_t pub_prop_info=array(0);
inline bool has_pub_prop_info() const;
inline const ::idl::vector< ::idl::pub_prop_info_t >& pub_prop_info() const;
inline ::idl::vector< ::idl::pub_prop_info_t >* mutable_pub_prop_info();
inline void clear_pub_prop_info();
// deprecated.use 'mutable_pub_prop_info' instead.
inline ::idl::vector< ::idl::pub_prop_info_t >* m_pub_prop_info();
// deprecated.use 'pub_prop_info().size()' instead.
inline size_t pub_prop_info_size() const;
inline const ::idl::pub_prop_info_t& pub_prop_info(size_t i0) const;
inline ::idl::pub_prop_info_t* mutable_pub_prop_info(size_t i0);
// deprecated.use 'mutable_pub_prop_info' instead.
inline ::idl::pub_prop_info_t* m_pub_prop_info(size_t i0);
// @@string union_start_action;
inline bool has_union_start_action() const;
inline const char* union_start_action(unsigned int* size=0) const;
inline content_detail_t& set_union_start_action(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_union_start_action(const char* s,ssize_t size=-1);
inline void clear_union_start_action();
// @@string has_account;
inline bool has_has_account() const;
inline const char* has_account(unsigned int* size=0) const;
inline content_detail_t& set_has_account(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_has_account(const char* s,ssize_t size=-1);
inline void clear_has_account();
// @@string editor_recom;
inline bool has_editor_recom() const;
inline const char* editor_recom(unsigned int* size=0) const;
inline content_detail_t& set_editor_recom(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_editor_recom(const char* s,ssize_t size=-1);
inline void clear_editor_recom();
// @@string show_highspeed;
inline bool has_show_highspeed() const;
inline const char* show_highspeed(unsigned int* size=0) const;
inline content_detail_t& set_show_highspeed(const char* s,ssize_t size=-1);
inline content_detail_t& set_ptr_show_highspeed(const char* s,ssize_t size=-1);
inline void clear_show_highspeed();
// @@cp_info_t cp_info;
inline bool has_cp_info() const;
inline const ::idl::cp_info_t& cp_info() const;
inline ::idl::cp_info_t* mutable_cp_info();
// deprecated.use 'mutable_cp_info()' instead.
inline ::idl::cp_info_t* m_cp_info();
inline void clear_cp_info();
// @@grant_detail_t grant_info;
inline bool has_grant_info() const;
inline const ::idl::grant_detail_t& grant_info() const;
inline ::idl::grant_detail_t* mutable_grant_info();
// deprecated.use 'mutable_grant_info()' instead.
inline ::idl::grant_detail_t* m_grant_info();
inline void clear_grant_info();
// @@download_detail_t download_info=array(0);
inline bool has_download_info() const;
inline const ::idl::vector< ::idl::download_detail_t >& download_info() const;
inline ::idl::vector< ::idl::download_detail_t >* mutable_download_info();
inline void clear_download_info();
// deprecated.use 'mutable_download_info' instead.
inline ::idl::vector< ::idl::download_detail_t >* m_download_info();
// deprecated.use 'download_info().size()' instead.
inline size_t download_info_size() const;
inline const ::idl::download_detail_t& download_info(size_t i0) const;
inline ::idl::download_detail_t* mutable_download_info(size_t i0);
// deprecated.use 'mutable_download_info' instead.
inline ::idl::download_detail_t* m_download_info(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_name;
 ::idl::string _m_type;
 ::idl::vector< ::idl::class_info_t > _m_class_info;
 ::idl::vector< ::idl::img_info_t > _m_img_info;
 ::idl::string _m_ext_id;
 ::idl::string _m_abstract_;
 ::idl::string _m_version;
 ::idl::string _m_method;
 ::idl::string _m_star;
 ::idl::string _m_network;
 ::idl::string _m_code;
 ::idl::string _m_log_date;
 ::idl::string _m_mod_date;
 ::idl::string _m_dft_charge_type;
 ::idl::string _m_dft_charge_val;
 ::idl::string _m_enName;
 ::idl::string _m_language;
 ::idl::string _m_adapt;
 ::idl::string _m_package_name;
 ::idl::string _m_version_appinfo;
 ::idl::string _m_sdk_version;
 ::idl::string _m_version_code;
 ::idl::string _m_ptype_0;
 ::idl::string _m_ptype_1;
 ::idl::string _m_ptype_2;
 ::idl::string _m_ptype_3;
 ::idl::string _m_ptype_4;
 ::idl::vector< ::idl::string > _m_pub_props;
 ::idl::vector< ::idl::pub_prop_info_t > _m_pub_prop_info;
 ::idl::string _m_union_start_action;
 ::idl::string _m_has_account;
 ::idl::string _m_editor_recom;
 ::idl::string _m_show_highspeed;
mutable ::idl::cp_info_t* _m_cp_info;
mutable ::idl::grant_detail_t* _m_grant_info;
 ::idl::vector< ::idl::download_detail_t > _m_download_info;
mutable ::idl::Unknown _unknown;
char _flag[5];
}; // class content_detail_t
class mcp_content_in_param : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_content_in_param* create(bsl::mempool* pool);
static void destroy(mcp_content_in_param* v);
explicit mcp_content_in_param(bsl::mempool* pool);
mcp_content_in_param(const mcp_content_in_param& v);
~mcp_content_in_param();
mcp_content_in_param& operator=(const mcp_content_in_param& v);
void clear();
void check() const;
void detach();
mcp_content_in_param& assign(const mcp_content_in_param& v);
// @@string type_id;
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_content_in_param& set_type_id(const char* s,ssize_t size=-1);
inline mcp_content_in_param& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@string class_id;
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_content_in_param& set_class_id(const char* s,ssize_t size=-1);
inline mcp_content_in_param& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
// @@string weight_order;
inline bool has_weight_order() const;
inline const char* weight_order(unsigned int* size=0) const;
inline mcp_content_in_param& set_weight_order(const char* s,ssize_t size=-1);
inline mcp_content_in_param& set_ptr_weight_order(const char* s,ssize_t size=-1);
inline void clear_weight_order();
// @@string label_id;
inline bool has_label_id() const;
inline const char* label_id(unsigned int* size=0) const;
inline mcp_content_in_param& set_label_id(const char* s,ssize_t size=-1);
inline mcp_content_in_param& set_ptr_label_id(const char* s,ssize_t size=-1);
inline void clear_label_id();
// @@string img_type;
inline bool has_img_type() const;
inline const char* img_type(unsigned int* size=0) const;
inline mcp_content_in_param& set_img_type(const char* s,ssize_t size=-1);
inline mcp_content_in_param& set_ptr_img_type(const char* s,ssize_t size=-1);
inline void clear_img_type();
// @@string column_id;
inline bool has_column_id() const;
inline const char* column_id(unsigned int* size=0) const;
inline mcp_content_in_param& set_column_id(const char* s,ssize_t size=-1);
inline mcp_content_in_param& set_ptr_column_id(const char* s,ssize_t size=-1);
inline void clear_column_id();
// @@string content_id;
inline bool has_content_id() const;
inline const char* content_id(unsigned int* size=0) const;
inline mcp_content_in_param& set_content_id(const char* s,ssize_t size=-1);
inline mcp_content_in_param& set_ptr_content_id(const char* s,ssize_t size=-1);
inline void clear_content_id();
// @@string channel_id;
inline bool has_channel_id() const;
inline const char* channel_id(unsigned int* size=0) const;
inline mcp_content_in_param& set_channel_id(const char* s,ssize_t size=-1);
inline mcp_content_in_param& set_ptr_channel_id(const char* s,ssize_t size=-1);
inline void clear_channel_id();
// @@string channel_info;
inline bool has_channel_info() const;
inline const char* channel_info(unsigned int* size=0) const;
inline mcp_content_in_param& set_channel_info(const char* s,ssize_t size=-1);
inline mcp_content_in_param& set_ptr_channel_info(const char* s,ssize_t size=-1);
inline void clear_channel_info();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_type_id;
 ::idl::string _m_class_id;
 ::idl::string _m_weight_order;
 ::idl::string _m_label_id;
 ::idl::string _m_img_type;
 ::idl::string _m_column_id;
 ::idl::string _m_content_id;
 ::idl::string _m_channel_id;
 ::idl::string _m_channel_info;
mutable ::idl::Unknown _unknown;
char _flag[2];
}; // class mcp_content_in_param
class once_consume_goods_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static once_consume_goods_t* create(bsl::mempool* pool);
static void destroy(once_consume_goods_t* v);
explicit once_consume_goods_t(bsl::mempool* pool);
once_consume_goods_t(const once_consume_goods_t& v);
~once_consume_goods_t();
once_consume_goods_t& operator=(const once_consume_goods_t& v);
void clear();
void check() const;
void detach();
once_consume_goods_t& assign(const once_consume_goods_t& v);
// @@string orderid;
inline bool has_orderid() const;
inline const char* orderid(unsigned int* size=0) const;
inline once_consume_goods_t& set_orderid(const char* s,ssize_t size=-1);
inline once_consume_goods_t& set_ptr_orderid(const char* s,ssize_t size=-1);
inline void clear_orderid();
// @@string itemid;
inline bool has_itemid() const;
inline const char* itemid(unsigned int* size=0) const;
inline once_consume_goods_t& set_itemid(const char* s,ssize_t size=-1);
inline once_consume_goods_t& set_ptr_itemid(const char* s,ssize_t size=-1);
inline void clear_itemid();
// @@string ordertime;
inline bool has_ordertime() const;
inline const char* ordertime(unsigned int* size=0) const;
inline once_consume_goods_t& set_ordertime(const char* s,ssize_t size=-1);
inline once_consume_goods_t& set_ptr_ordertime(const char* s,ssize_t size=-1);
inline void clear_ordertime();
// @@string udid;
inline bool has_udid() const;
inline const char* udid(unsigned int* size=0) const;
inline once_consume_goods_t& set_udid(const char* s,ssize_t size=-1);
inline once_consume_goods_t& set_ptr_udid(const char* s,ssize_t size=-1);
inline void clear_udid();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_orderid;
 ::idl::string _m_itemid;
 ::idl::string _m_ordertime;
 ::idl::string _m_udid;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class once_consume_goods_t
class game_news_entire_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static game_news_entire_info_t* create(bsl::mempool* pool);
static void destroy(game_news_entire_info_t* v);
explicit game_news_entire_info_t(bsl::mempool* pool);
game_news_entire_info_t(const game_news_entire_info_t& v);
~game_news_entire_info_t();
game_news_entire_info_t& operator=(const game_news_entire_info_t& v);
void clear();
void check() const;
void detach();
game_news_entire_info_t& assign(const game_news_entire_info_t& v);
// @@game_info_t news_info;
inline bool has_news_info() const;
inline const ::idl::game_info_t& news_info() const;
inline ::idl::game_info_t* mutable_news_info();
// deprecated.use 'mutable_news_info()' instead.
inline ::idl::game_info_t* m_news_info();
inline void clear_news_info();
// @@content_basic_info_t game_basic_info;
inline bool has_game_basic_info() const;
inline const ::idl::content_basic_info_t& game_basic_info() const;
inline ::idl::content_basic_info_t* mutable_game_basic_info();
// deprecated.use 'mutable_game_basic_info()' instead.
inline ::idl::content_basic_info_t* m_game_basic_info();
inline void clear_game_basic_info();
// @@download_detail_t game_download_list=array(0);
inline bool has_game_download_list() const;
inline const ::idl::vector< ::idl::download_detail_t >& game_download_list() const;
inline ::idl::vector< ::idl::download_detail_t >* mutable_game_download_list();
inline void clear_game_download_list();
// deprecated.use 'mutable_game_download_list' instead.
inline ::idl::vector< ::idl::download_detail_t >* m_game_download_list();
// deprecated.use 'game_download_list().size()' instead.
inline size_t game_download_list_size() const;
inline const ::idl::download_detail_t& game_download_list(size_t i0) const;
inline ::idl::download_detail_t* mutable_game_download_list(size_t i0);
// deprecated.use 'mutable_game_download_list' instead.
inline ::idl::download_detail_t* m_game_download_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::game_info_t* _m_news_info;
mutable ::idl::content_basic_info_t* _m_game_basic_info;
 ::idl::vector< ::idl::download_detail_t > _m_game_download_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class game_news_entire_info_t
class game_news_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static game_news_info_t* create(bsl::mempool* pool);
static void destroy(game_news_info_t* v);
explicit game_news_info_t(bsl::mempool* pool);
game_news_info_t(const game_news_info_t& v);
~game_news_info_t();
game_news_info_t& operator=(const game_news_info_t& v);
void clear();
void check() const;
void detach();
game_news_info_t& assign(const game_news_info_t& v);
// @@string news_id;
inline bool has_news_id() const;
inline const char* news_id(unsigned int* size=0) const;
inline game_news_info_t& set_news_id(const char* s,ssize_t size=-1);
inline game_news_info_t& set_ptr_news_id(const char* s,ssize_t size=-1);
inline void clear_news_id();
// @@string news_type;
inline bool has_news_type() const;
inline const char* news_type(unsigned int* size=0) const;
inline game_news_info_t& set_news_type(const char* s,ssize_t size=-1);
inline game_news_info_t& set_ptr_news_type(const char* s,ssize_t size=-1);
inline void clear_news_type();
// @@string news_time;
inline bool has_news_time() const;
inline const char* news_time(unsigned int* size=0) const;
inline game_news_info_t& set_news_time(const char* s,ssize_t size=-1);
inline game_news_info_t& set_ptr_news_time(const char* s,ssize_t size=-1);
inline void clear_news_time();
// @@string news_content;
inline bool has_news_content() const;
inline const char* news_content(unsigned int* size=0) const;
inline game_news_info_t& set_news_content(const char* s,ssize_t size=-1);
inline game_news_info_t& set_ptr_news_content(const char* s,ssize_t size=-1);
inline void clear_news_content();
// @@string news_title;
inline bool has_news_title() const;
inline const char* news_title(unsigned int* size=0) const;
inline game_news_info_t& set_news_title(const char* s,ssize_t size=-1);
inline game_news_info_t& set_ptr_news_title(const char* s,ssize_t size=-1);
inline void clear_news_title();
// @@string news_type_name;
inline bool has_news_type_name() const;
inline const char* news_type_name(unsigned int* size=0) const;
inline game_news_info_t& set_news_type_name(const char* s,ssize_t size=-1);
inline game_news_info_t& set_ptr_news_type_name(const char* s,ssize_t size=-1);
inline void clear_news_type_name();
// @@string game_id;
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline game_news_info_t& set_game_id(const char* s,ssize_t size=-1);
inline game_news_info_t& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
// @@string game_type;
inline bool has_game_type() const;
inline const char* game_type(unsigned int* size=0) const;
inline game_news_info_t& set_game_type(const char* s,ssize_t size=-1);
inline game_news_info_t& set_ptr_game_type(const char* s,ssize_t size=-1);
inline void clear_game_type();
// @@string game_name;
inline bool has_game_name() const;
inline const char* game_name(unsigned int* size=0) const;
inline game_news_info_t& set_game_name(const char* s,ssize_t size=-1);
inline game_news_info_t& set_ptr_game_name(const char* s,ssize_t size=-1);
inline void clear_game_name();
// @@img_info_t game_img_info=array(0);
inline bool has_game_img_info() const;
inline const ::idl::vector< ::idl::img_info_t >& game_img_info() const;
inline ::idl::vector< ::idl::img_info_t >* mutable_game_img_info();
inline void clear_game_img_info();
// deprecated.use 'mutable_game_img_info' instead.
inline ::idl::vector< ::idl::img_info_t >* m_game_img_info();
// deprecated.use 'game_img_info().size()' instead.
inline size_t game_img_info_size() const;
inline const ::idl::img_info_t& game_img_info(size_t i0) const;
inline ::idl::img_info_t* mutable_game_img_info(size_t i0);
// deprecated.use 'mutable_game_img_info' instead.
inline ::idl::img_info_t* m_game_img_info(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_news_id;
 ::idl::string _m_news_type;
 ::idl::string _m_news_time;
 ::idl::string _m_news_content;
 ::idl::string _m_news_title;
 ::idl::string _m_news_type_name;
 ::idl::string _m_game_id;
 ::idl::string _m_game_type;
 ::idl::string _m_game_name;
 ::idl::vector< ::idl::img_info_t > _m_game_img_info;
mutable ::idl::Unknown _unknown;
char _flag[2];
}; // class game_news_info_t
class netgame_activity_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static netgame_activity_info_t* create(bsl::mempool* pool);
static void destroy(netgame_activity_info_t* v);
explicit netgame_activity_info_t(bsl::mempool* pool);
netgame_activity_info_t(const netgame_activity_info_t& v);
~netgame_activity_info_t();
netgame_activity_info_t& operator=(const netgame_activity_info_t& v);
void clear();
void check() const;
void detach();
netgame_activity_info_t& assign(const netgame_activity_info_t& v);
// @@string act_id;
inline bool has_act_id() const;
inline const char* act_id(unsigned int* size=0) const;
inline netgame_activity_info_t& set_act_id(const char* s,ssize_t size=-1);
inline netgame_activity_info_t& set_ptr_act_id(const char* s,ssize_t size=-1);
inline void clear_act_id();
// @@string act_title;
inline bool has_act_title() const;
inline const char* act_title(unsigned int* size=0) const;
inline netgame_activity_info_t& set_act_title(const char* s,ssize_t size=-1);
inline netgame_activity_info_t& set_ptr_act_title(const char* s,ssize_t size=-1);
inline void clear_act_title();
// @@string act_content;
inline bool has_act_content() const;
inline const char* act_content(unsigned int* size=0) const;
inline netgame_activity_info_t& set_act_content(const char* s,ssize_t size=-1);
inline netgame_activity_info_t& set_ptr_act_content(const char* s,ssize_t size=-1);
inline void clear_act_content();
// @@string act_logdate;
inline bool has_act_logdate() const;
inline const char* act_logdate(unsigned int* size=0) const;
inline netgame_activity_info_t& set_act_logdate(const char* s,ssize_t size=-1);
inline netgame_activity_info_t& set_ptr_act_logdate(const char* s,ssize_t size=-1);
inline void clear_act_logdate();
// @@img_info_t act_img_info=array(0);
inline bool has_act_img_info() const;
inline const ::idl::vector< ::idl::img_info_t >& act_img_info() const;
inline ::idl::vector< ::idl::img_info_t >* mutable_act_img_info();
inline void clear_act_img_info();
// deprecated.use 'mutable_act_img_info' instead.
inline ::idl::vector< ::idl::img_info_t >* m_act_img_info();
// deprecated.use 'act_img_info().size()' instead.
inline size_t act_img_info_size() const;
inline const ::idl::img_info_t& act_img_info(size_t i0) const;
inline ::idl::img_info_t* mutable_act_img_info(size_t i0);
// deprecated.use 'mutable_act_img_info' instead.
inline ::idl::img_info_t* m_act_img_info(size_t i0);
// @@game_news_info_t game_news_list=array(0);
inline bool has_game_news_list() const;
inline const ::idl::vector< ::idl::game_news_info_t >& game_news_list() const;
inline ::idl::vector< ::idl::game_news_info_t >* mutable_game_news_list();
inline void clear_game_news_list();
// deprecated.use 'mutable_game_news_list' instead.
inline ::idl::vector< ::idl::game_news_info_t >* m_game_news_list();
// deprecated.use 'game_news_list().size()' instead.
inline size_t game_news_list_size() const;
inline const ::idl::game_news_info_t& game_news_list(size_t i0) const;
inline ::idl::game_news_info_t* mutable_game_news_list(size_t i0);
// deprecated.use 'mutable_game_news_list' instead.
inline ::idl::game_news_info_t* m_game_news_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_act_id;
 ::idl::string _m_act_title;
 ::idl::string _m_act_content;
 ::idl::string _m_act_logdate;
 ::idl::vector< ::idl::img_info_t > _m_act_img_info;
 ::idl::vector< ::idl::game_news_info_t > _m_game_news_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class netgame_activity_info_t
class column_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static column_info_t* create(bsl::mempool* pool);
static void destroy(column_info_t* v);
explicit column_info_t(bsl::mempool* pool);
column_info_t(const column_info_t& v);
~column_info_t();
column_info_t& operator=(const column_info_t& v);
void clear();
void check() const;
void detach();
column_info_t& assign(const column_info_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline column_info_t& set_id(const char* s,ssize_t size=-1);
inline column_info_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline column_info_t& set_name(const char* s,ssize_t size=-1);
inline column_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string type_id;
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline column_info_t& set_type_id(const char* s,ssize_t size=-1);
inline column_info_t& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_name;
 ::idl::string _m_type_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class column_info_t
class game_ext_update_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static game_ext_update_info_t* create(bsl::mempool* pool);
static void destroy(game_ext_update_info_t* v);
explicit game_ext_update_info_t(bsl::mempool* pool);
game_ext_update_info_t(const game_ext_update_info_t& v);
~game_ext_update_info_t();
game_ext_update_info_t& operator=(const game_ext_update_info_t& v);
void clear();
void check() const;
void detach();
game_ext_update_info_t& assign(const game_ext_update_info_t& v);
// @@string c_id;
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline game_ext_update_info_t& set_c_id(const char* s,ssize_t size=-1);
inline game_ext_update_info_t& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string update_url;
inline bool has_update_url() const;
inline const char* update_url(unsigned int* size=0) const;
inline game_ext_update_info_t& set_update_url(const char* s,ssize_t size=-1);
inline game_ext_update_info_t& set_ptr_update_url(const char* s,ssize_t size=-1);
inline void clear_update_url();
// @@string diff_pkg_size;
inline bool has_diff_pkg_size() const;
inline const char* diff_pkg_size(unsigned int* size=0) const;
inline game_ext_update_info_t& set_diff_pkg_size(const char* s,ssize_t size=-1);
inline game_ext_update_info_t& set_ptr_diff_pkg_size(const char* s,ssize_t size=-1);
inline void clear_diff_pkg_size();
// @@string channel_info;
inline bool has_channel_info() const;
inline const char* channel_info(unsigned int* size=0) const;
inline game_ext_update_info_t& set_channel_info(const char* s,ssize_t size=-1);
inline game_ext_update_info_t& set_ptr_channel_info(const char* s,ssize_t size=-1);
inline void clear_channel_info();
// @@string channel_id;
inline bool has_channel_id() const;
inline const char* channel_id(unsigned int* size=0) const;
inline game_ext_update_info_t& set_channel_id(const char* s,ssize_t size=-1);
inline game_ext_update_info_t& set_ptr_channel_id(const char* s,ssize_t size=-1);
inline void clear_channel_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_c_id;
 ::idl::string _m_update_url;
 ::idl::string _m_diff_pkg_size;
 ::idl::string _m_channel_info;
 ::idl::string _m_channel_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class game_ext_update_info_t
class game_update_download_info : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static game_update_download_info* create(bsl::mempool* pool);
static void destroy(game_update_download_info* v);
explicit game_update_download_info(bsl::mempool* pool);
game_update_download_info(const game_update_download_info& v);
~game_update_download_info();
game_update_download_info& operator=(const game_update_download_info& v);
void clear();
void check() const;
void detach();
game_update_download_info& assign(const game_update_download_info& v);
// @@content_basic_info_t basic_info;
inline bool has_basic_info() const;
inline const ::idl::content_basic_info_t& basic_info() const;
inline ::idl::content_basic_info_t* mutable_basic_info();
// deprecated.use 'mutable_basic_info()' instead.
inline ::idl::content_basic_info_t* m_basic_info();
inline void clear_basic_info();
// @@download_detail_t download_info=array(0);
inline bool has_download_info() const;
inline const ::idl::vector< ::idl::download_detail_t >& download_info() const;
inline ::idl::vector< ::idl::download_detail_t >* mutable_download_info();
inline void clear_download_info();
// deprecated.use 'mutable_download_info' instead.
inline ::idl::vector< ::idl::download_detail_t >* m_download_info();
// deprecated.use 'download_info().size()' instead.
inline size_t download_info_size() const;
inline const ::idl::download_detail_t& download_info(size_t i0) const;
inline ::idl::download_detail_t* mutable_download_info(size_t i0);
// deprecated.use 'mutable_download_info' instead.
inline ::idl::download_detail_t* m_download_info(size_t i0);
// @@game_ext_update_info_t update_info=array(0);
inline bool has_update_info() const;
inline const ::idl::vector< ::idl::game_ext_update_info_t >& update_info() const;
inline ::idl::vector< ::idl::game_ext_update_info_t >* mutable_update_info();
inline void clear_update_info();
// deprecated.use 'mutable_update_info' instead.
inline ::idl::vector< ::idl::game_ext_update_info_t >* m_update_info();
// deprecated.use 'update_info().size()' instead.
inline size_t update_info_size() const;
inline const ::idl::game_ext_update_info_t& update_info(size_t i0) const;
inline ::idl::game_ext_update_info_t* mutable_update_info(size_t i0);
// deprecated.use 'mutable_update_info' instead.
inline ::idl::game_ext_update_info_t* m_update_info(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::content_basic_info_t* _m_basic_info;
 ::idl::vector< ::idl::download_detail_t > _m_download_info;
 ::idl::vector< ::idl::game_ext_update_info_t > _m_update_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class game_update_download_info
class game_content_download_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static game_content_download_info_t* create(bsl::mempool* pool);
static void destroy(game_content_download_info_t* v);
explicit game_content_download_info_t(bsl::mempool* pool);
game_content_download_info_t(const game_content_download_info_t& v);
~game_content_download_info_t();
game_content_download_info_t& operator=(const game_content_download_info_t& v);
void clear();
void check() const;
void detach();
game_content_download_info_t& assign(const game_content_download_info_t& v);
// @@content_basic_info_t basic_info;
inline bool has_basic_info() const;
inline const ::idl::content_basic_info_t& basic_info() const;
inline ::idl::content_basic_info_t* mutable_basic_info();
// deprecated.use 'mutable_basic_info()' instead.
inline ::idl::content_basic_info_t* m_basic_info();
inline void clear_basic_info();
// @@download_detail_t download_info=array(0);
inline bool has_download_info() const;
inline const ::idl::vector< ::idl::download_detail_t >& download_info() const;
inline ::idl::vector< ::idl::download_detail_t >* mutable_download_info();
inline void clear_download_info();
// deprecated.use 'mutable_download_info' instead.
inline ::idl::vector< ::idl::download_detail_t >* m_download_info();
// deprecated.use 'download_info().size()' instead.
inline size_t download_info_size() const;
inline const ::idl::download_detail_t& download_info(size_t i0) const;
inline ::idl::download_detail_t* mutable_download_info(size_t i0);
// deprecated.use 'mutable_download_info' instead.
inline ::idl::download_detail_t* m_download_info(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::content_basic_info_t* _m_basic_info;
 ::idl::vector< ::idl::download_detail_t > _m_download_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class game_content_download_info_t
class game_dev_vir_currency_info : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static game_dev_vir_currency_info* create(bsl::mempool* pool);
static void destroy(game_dev_vir_currency_info* v);
explicit game_dev_vir_currency_info(bsl::mempool* pool);
game_dev_vir_currency_info(const game_dev_vir_currency_info& v);
~game_dev_vir_currency_info();
game_dev_vir_currency_info& operator=(const game_dev_vir_currency_info& v);
void clear();
void check() const;
void detach();
game_dev_vir_currency_info& assign(const game_dev_vir_currency_info& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline game_dev_vir_currency_info& set_id(const char* s,ssize_t size=-1);
inline game_dev_vir_currency_info& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline game_dev_vir_currency_info& set_name(const char* s,ssize_t size=-1);
inline game_dev_vir_currency_info& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string game_id;
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline game_dev_vir_currency_info& set_game_id(const char* s,ssize_t size=-1);
inline game_dev_vir_currency_info& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
// @@string exchage_rate;
inline bool has_exchage_rate() const;
inline const char* exchage_rate(unsigned int* size=0) const;
inline game_dev_vir_currency_info& set_exchage_rate(const char* s,ssize_t size=-1);
inline game_dev_vir_currency_info& set_ptr_exchage_rate(const char* s,ssize_t size=-1);
inline void clear_exchage_rate();
// @@string icon;
inline bool has_icon() const;
inline const char* icon(unsigned int* size=0) const;
inline game_dev_vir_currency_info& set_icon(const char* s,ssize_t size=-1);
inline game_dev_vir_currency_info& set_ptr_icon(const char* s,ssize_t size=-1);
inline void clear_icon();
// @@string desc;
inline bool has_desc() const;
inline const char* desc(unsigned int* size=0) const;
inline game_dev_vir_currency_info& set_desc(const char* s,ssize_t size=-1);
inline game_dev_vir_currency_info& set_ptr_desc(const char* s,ssize_t size=-1);
inline void clear_desc();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_name;
 ::idl::string _m_game_id;
 ::idl::string _m_exchage_rate;
 ::idl::string _m_icon;
 ::idl::string _m_desc;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class game_dev_vir_currency_info
class question_type_name_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static question_type_name_t* create(bsl::mempool* pool);
static void destroy(question_type_name_t* v);
explicit question_type_name_t(bsl::mempool* pool);
question_type_name_t(const question_type_name_t& v);
~question_type_name_t();
question_type_name_t& operator=(const question_type_name_t& v);
void clear();
void check() const;
void detach();
question_type_name_t& assign(const question_type_name_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline question_type_name_t& set_id(const char* s,ssize_t size=-1);
inline question_type_name_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline question_type_name_t& set_name(const char* s,ssize_t size=-1);
inline question_type_name_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_name;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class question_type_name_t
class user_question_answer_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static user_question_answer_t* create(bsl::mempool* pool);
static void destroy(user_question_answer_t* v);
explicit user_question_answer_t(bsl::mempool* pool);
user_question_answer_t(const user_question_answer_t& v);
~user_question_answer_t();
user_question_answer_t& operator=(const user_question_answer_t& v);
void clear();
void check() const;
void detach();
user_question_answer_t& assign(const user_question_answer_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline user_question_answer_t& set_id(const char* s,ssize_t size=-1);
inline user_question_answer_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string app_id;
inline bool has_app_id() const;
inline const char* app_id(unsigned int* size=0) const;
inline user_question_answer_t& set_app_id(const char* s,ssize_t size=-1);
inline user_question_answer_t& set_ptr_app_id(const char* s,ssize_t size=-1);
inline void clear_app_id();
// @@string question;
inline bool has_question() const;
inline const char* question(unsigned int* size=0) const;
inline user_question_answer_t& set_question(const char* s,ssize_t size=-1);
inline user_question_answer_t& set_ptr_question(const char* s,ssize_t size=-1);
inline void clear_question();
// @@string answer;
inline bool has_answer() const;
inline const char* answer(unsigned int* size=0) const;
inline user_question_answer_t& set_answer(const char* s,ssize_t size=-1);
inline user_question_answer_t& set_ptr_answer(const char* s,ssize_t size=-1);
inline void clear_answer();
// @@string status;
inline bool has_status() const;
inline const char* status(unsigned int* size=0) const;
inline user_question_answer_t& set_status(const char* s,ssize_t size=-1);
inline user_question_answer_t& set_ptr_status(const char* s,ssize_t size=-1);
inline void clear_status();
// @@string date_q;
inline bool has_date_q() const;
inline const char* date_q(unsigned int* size=0) const;
inline user_question_answer_t& set_date_q(const char* s,ssize_t size=-1);
inline user_question_answer_t& set_ptr_date_q(const char* s,ssize_t size=-1);
inline void clear_date_q();
// @@string date_a;
inline bool has_date_a() const;
inline const char* date_a(unsigned int* size=0) const;
inline user_question_answer_t& set_date_a(const char* s,ssize_t size=-1);
inline user_question_answer_t& set_ptr_date_a(const char* s,ssize_t size=-1);
inline void clear_date_a();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_app_id;
 ::idl::string _m_question;
 ::idl::string _m_answer;
 ::idl::string _m_status;
 ::idl::string _m_date_q;
 ::idl::string _m_date_a;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class user_question_answer_t
class qp_activity_award_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static qp_activity_award_t* create(bsl::mempool* pool);
static void destroy(qp_activity_award_t* v);
explicit qp_activity_award_t(bsl::mempool* pool);
qp_activity_award_t(const qp_activity_award_t& v);
~qp_activity_award_t();
qp_activity_award_t& operator=(const qp_activity_award_t& v);
void clear();
void check() const;
void detach();
qp_activity_award_t& assign(const qp_activity_award_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline qp_activity_award_t& set_id(const char* s,ssize_t size=-1);
inline qp_activity_award_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline qp_activity_award_t& set_name(const char* s,ssize_t size=-1);
inline qp_activity_award_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string pic_url;
inline bool has_pic_url() const;
inline const char* pic_url(unsigned int* size=0) const;
inline qp_activity_award_t& set_pic_url(const char* s,ssize_t size=-1);
inline qp_activity_award_t& set_ptr_pic_url(const char* s,ssize_t size=-1);
inline void clear_pic_url();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_name;
 ::idl::string _m_pic_url;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class qp_activity_award_t
class qp_activity_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static qp_activity_t* create(bsl::mempool* pool);
static void destroy(qp_activity_t* v);
explicit qp_activity_t(bsl::mempool* pool);
qp_activity_t(const qp_activity_t& v);
~qp_activity_t();
qp_activity_t& operator=(const qp_activity_t& v);
void clear();
void check() const;
void detach();
qp_activity_t& assign(const qp_activity_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline qp_activity_t& set_id(const char* s,ssize_t size=-1);
inline qp_activity_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string c_id;
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline qp_activity_t& set_c_id(const char* s,ssize_t size=-1);
inline qp_activity_t& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string title;
inline bool has_title() const;
inline const char* title(unsigned int* size=0) const;
inline qp_activity_t& set_title(const char* s,ssize_t size=-1);
inline qp_activity_t& set_ptr_title(const char* s,ssize_t size=-1);
inline void clear_title();
// @@string info;
inline bool has_info() const;
inline const char* info(unsigned int* size=0) const;
inline qp_activity_t& set_info(const char* s,ssize_t size=-1);
inline qp_activity_t& set_ptr_info(const char* s,ssize_t size=-1);
inline void clear_info();
// @@string rules;
inline bool has_rules() const;
inline const char* rules(unsigned int* size=0) const;
inline qp_activity_t& set_rules(const char* s,ssize_t size=-1);
inline qp_activity_t& set_ptr_rules(const char* s,ssize_t size=-1);
inline void clear_rules();
// @@int64_t start_time;
inline bool has_start_time() const;
inline int64_t start_time() const;
inline qp_activity_t& set_start_time(int64_t v);
inline void clear_start_time();
// @@int64_t end_time;
inline bool has_end_time() const;
inline int64_t end_time() const;
inline qp_activity_t& set_end_time(int64_t v);
inline void clear_end_time();
// @@string icon_url;
inline bool has_icon_url() const;
inline const char* icon_url(unsigned int* size=0) const;
inline qp_activity_t& set_icon_url(const char* s,ssize_t size=-1);
inline qp_activity_t& set_ptr_icon_url(const char* s,ssize_t size=-1);
inline void clear_icon_url();
// @@string status;
inline bool has_status() const;
inline const char* status(unsigned int* size=0) const;
inline qp_activity_t& set_status(const char* s,ssize_t size=-1);
inline qp_activity_t& set_ptr_status(const char* s,ssize_t size=-1);
inline void clear_status();
// @@string act_info;
inline bool has_act_info() const;
inline const char* act_info(unsigned int* size=0) const;
inline qp_activity_t& set_act_info(const char* s,ssize_t size=-1);
inline qp_activity_t& set_ptr_act_info(const char* s,ssize_t size=-1);
inline void clear_act_info();
// @@qp_activity_award_t qp_activity_award_list=array(0);
inline bool has_qp_activity_award_list() const;
inline const ::idl::vector< ::idl::qp_activity_award_t >& qp_activity_award_list() const;
inline ::idl::vector< ::idl::qp_activity_award_t >* mutable_qp_activity_award_list();
inline void clear_qp_activity_award_list();
// deprecated.use 'mutable_qp_activity_award_list' instead.
inline ::idl::vector< ::idl::qp_activity_award_t >* m_qp_activity_award_list();
// deprecated.use 'qp_activity_award_list().size()' instead.
inline size_t qp_activity_award_list_size() const;
inline const ::idl::qp_activity_award_t& qp_activity_award_list(size_t i0) const;
inline ::idl::qp_activity_award_t* mutable_qp_activity_award_list(size_t i0);
// deprecated.use 'mutable_qp_activity_award_list' instead.
inline ::idl::qp_activity_award_t* m_qp_activity_award_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_c_id;
 ::idl::string _m_title;
 ::idl::string _m_info;
 ::idl::string _m_rules;
 int64_t _m_start_time;
 int64_t _m_end_time;
 ::idl::string _m_icon_url;
 ::idl::string _m_status;
 ::idl::string _m_act_info;
 ::idl::vector< ::idl::qp_activity_award_t > _m_qp_activity_award_list;
mutable ::idl::Unknown _unknown;
char _flag[2];
}; // class qp_activity_t
class qp_activity_person_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static qp_activity_person_t* create(bsl::mempool* pool);
static void destroy(qp_activity_person_t* v);
explicit qp_activity_person_t(bsl::mempool* pool);
qp_activity_person_t(const qp_activity_person_t& v);
~qp_activity_person_t();
qp_activity_person_t& operator=(const qp_activity_person_t& v);
void clear();
void check() const;
void detach();
qp_activity_person_t& assign(const qp_activity_person_t& v);
// @@string c_id;
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline qp_activity_person_t& set_c_id(const char* s,ssize_t size=-1);
inline qp_activity_person_t& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string person_num;
inline bool has_person_num() const;
inline const char* person_num(unsigned int* size=0) const;
inline qp_activity_person_t& set_person_num(const char* s,ssize_t size=-1);
inline qp_activity_person_t& set_ptr_person_num(const char* s,ssize_t size=-1);
inline void clear_person_num();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_c_id;
 ::idl::string _m_person_num;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class qp_activity_person_t
class person_all_award_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static person_all_award_info_t* create(bsl::mempool* pool);
static void destroy(person_all_award_info_t* v);
explicit person_all_award_info_t(bsl::mempool* pool);
person_all_award_info_t(const person_all_award_info_t& v);
~person_all_award_info_t();
person_all_award_info_t& operator=(const person_all_award_info_t& v);
void clear();
void check() const;
void detach();
person_all_award_info_t& assign(const person_all_award_info_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline person_all_award_info_t& set_id(const char* s,ssize_t size=-1);
inline person_all_award_info_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string icon;
inline bool has_icon() const;
inline const char* icon(unsigned int* size=0) const;
inline person_all_award_info_t& set_icon(const char* s,ssize_t size=-1);
inline person_all_award_info_t& set_ptr_icon(const char* s,ssize_t size=-1);
inline void clear_icon();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline person_all_award_info_t& set_name(const char* s,ssize_t size=-1);
inline person_all_award_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@int64_t date;
inline bool has_date() const;
inline int64_t date() const;
inline person_all_award_info_t& set_date(int64_t v);
inline void clear_date();
// @@string type;
inline bool has_type() const;
inline const char* type(unsigned int* size=0) const;
inline person_all_award_info_t& set_type(const char* s,ssize_t size=-1);
inline person_all_award_info_t& set_ptr_type(const char* s,ssize_t size=-1);
inline void clear_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_icon;
 ::idl::string _m_name;
 int64_t _m_date;
 ::idl::string _m_type;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class person_all_award_info_t
class person_award_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static person_award_info_t* create(bsl::mempool* pool);
static void destroy(person_award_info_t* v);
explicit person_award_info_t(bsl::mempool* pool);
person_award_info_t(const person_award_info_t& v);
~person_award_info_t();
person_award_info_t& operator=(const person_award_info_t& v);
void clear();
void check() const;
void detach();
person_award_info_t& assign(const person_award_info_t& v);
// @@string id;
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline person_award_info_t& set_id(const char* s,ssize_t size=-1);
inline person_award_info_t& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string user_id;
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline person_award_info_t& set_user_id(const char* s,ssize_t size=-1);
inline person_award_info_t& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
// @@string commodity_id;
inline bool has_commodity_id() const;
inline const char* commodity_id(unsigned int* size=0) const;
inline person_award_info_t& set_commodity_id(const char* s,ssize_t size=-1);
inline person_award_info_t& set_ptr_commodity_id(const char* s,ssize_t size=-1);
inline void clear_commodity_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline person_award_info_t& set_name(const char* s,ssize_t size=-1);
inline person_award_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string kudou;
inline bool has_kudou() const;
inline const char* kudou(unsigned int* size=0) const;
inline person_award_info_t& set_kudou(const char* s,ssize_t size=-1);
inline person_award_info_t& set_ptr_kudou(const char* s,ssize_t size=-1);
inline void clear_kudou();
// @@string priority;
inline bool has_priority() const;
inline const char* priority(unsigned int* size=0) const;
inline person_award_info_t& set_priority(const char* s,ssize_t size=-1);
inline person_award_info_t& set_ptr_priority(const char* s,ssize_t size=-1);
inline void clear_priority();
// @@string icon;
inline bool has_icon() const;
inline const char* icon(unsigned int* size=0) const;
inline person_award_info_t& set_icon(const char* s,ssize_t size=-1);
inline person_award_info_t& set_ptr_icon(const char* s,ssize_t size=-1);
inline void clear_icon();
// @@int32_t rank;
inline bool has_rank() const;
inline int32_t rank() const;
inline person_award_info_t& set_rank(int32_t v);
inline void clear_rank();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_user_id;
 ::idl::string _m_commodity_id;
 ::idl::string _m_name;
 ::idl::string _m_kudou;
 ::idl::string _m_priority;
 ::idl::string _m_icon;
 int32_t _m_rank;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class person_award_info_t
class award_info_t : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static award_info_t* create(bsl::mempool* pool);
static void destroy(award_info_t* v);
explicit award_info_t(bsl::mempool* pool);
award_info_t(const award_info_t& v);
~award_info_t();
award_info_t& operator=(const award_info_t& v);
void clear();
void check() const;
void detach();
award_info_t& assign(const award_info_t& v);
// @@string type;
inline bool has_type() const;
inline const char* type(unsigned int* size=0) const;
inline award_info_t& set_type(const char* s,ssize_t size=-1);
inline award_info_t& set_ptr_type(const char* s,ssize_t size=-1);
inline void clear_type();
// @@string award_id;
inline bool has_award_id() const;
inline const char* award_id(unsigned int* size=0) const;
inline award_info_t& set_award_id(const char* s,ssize_t size=-1);
inline award_info_t& set_ptr_award_id(const char* s,ssize_t size=-1);
inline void clear_award_id();
// @@string name;
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline award_info_t& set_name(const char* s,ssize_t size=-1);
inline award_info_t& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string prize_name;
inline bool has_prize_name() const;
inline const char* prize_name(unsigned int* size=0) const;
inline award_info_t& set_prize_name(const char* s,ssize_t size=-1);
inline award_info_t& set_ptr_prize_name(const char* s,ssize_t size=-1);
inline void clear_prize_name();
// @@string icon;
inline bool has_icon() const;
inline const char* icon(unsigned int* size=0) const;
inline award_info_t& set_icon(const char* s,ssize_t size=-1);
inline award_info_t& set_ptr_icon(const char* s,ssize_t size=-1);
inline void clear_icon();
// @@string prize_url;
inline bool has_prize_url() const;
inline const char* prize_url(unsigned int* size=0) const;
inline award_info_t& set_prize_url(const char* s,ssize_t size=-1);
inline award_info_t& set_ptr_prize_url(const char* s,ssize_t size=-1);
inline void clear_prize_url();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_type;
 ::idl::string _m_award_id;
 ::idl::string _m_name;
 ::idl::string _m_prize_name;
 ::idl::string _m_icon;
 ::idl::string _m_prize_url;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class award_info_t
class mcp_get_test_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_test_params* create(bsl::mempool* pool);
static void destroy(mcp_get_test_params* v);
explicit mcp_get_test_params(bsl::mempool* pool);
mcp_get_test_params(const mcp_get_test_params& v);
~mcp_get_test_params();
mcp_get_test_params& operator=(const mcp_get_test_params& v);
void clear();
void check() const;
void detach();
mcp_get_test_params& assign(const mcp_get_test_params& v);
// @@uint32_t info_type=in();
inline bool has_info_type() const;
inline uint32_t info_type() const;
inline mcp_get_test_params& set_info_type(uint32_t v);
inline void clear_info_type();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_test_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_test_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_info_type;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_test_params
class mcp_get_test_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_test_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_test_result_params* v);
explicit mcp_get_test_result_params(bsl::mempool* pool);
mcp_get_test_result_params(const mcp_get_test_result_params& v);
~mcp_get_test_result_params();
mcp_get_test_result_params& operator=(const mcp_get_test_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_test_result_params& assign(const mcp_get_test_result_params& v);
// @@uint32_t info_count=out();
inline bool has_info_count() const;
inline uint32_t info_count() const;
inline mcp_get_test_result_params& set_info_count(uint32_t v);
inline void clear_info_count();
// @@string info_id=out(),array(0);
inline bool has_info_id() const;
inline const ::idl::vector< ::idl::string >& info_id() const;
inline ::idl::vector< ::idl::string >* mutable_info_id();
inline void clear_info_id();
// deprecated.use 'mutable_info_id' instead.
inline ::idl::vector< ::idl::string >* m_info_id();
// deprecated.use 'info_id().size()' instead.
inline size_t info_id_size() const;
inline const char* info_id(size_t i0,unsigned int* size=0) const;
inline mcp_get_test_result_params& set_info_id(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_test_result_params& set_ptr_info_id(size_t i0,const char* s,ssize_t size=-1);
// @@string info_name=out(),array(0);
inline bool has_info_name() const;
inline const ::idl::vector< ::idl::string >& info_name() const;
inline ::idl::vector< ::idl::string >* mutable_info_name();
inline void clear_info_name();
// deprecated.use 'mutable_info_name' instead.
inline ::idl::vector< ::idl::string >* m_info_name();
// deprecated.use 'info_name().size()' instead.
inline size_t info_name_size() const;
inline const char* info_name(size_t i0,unsigned int* size=0) const;
inline mcp_get_test_result_params& set_info_name(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_test_result_params& set_ptr_info_name(size_t i0,const char* s,ssize_t size=-1);
// @@uint32_t phone_count=out(),array(0);
inline bool has_phone_count() const;
inline const ::idl::vector< uint32_t >& phone_count() const;
inline ::idl::vector< uint32_t >* mutable_phone_count();
inline void clear_phone_count();
// deprecated.use 'mutable_phone_count' instead.
inline ::idl::vector< uint32_t >* m_phone_count();
// deprecated.use 'phone_count().size()' instead.
inline size_t phone_count_size() const;
inline uint32_t phone_count(size_t i0) const;
inline mcp_get_test_result_params& set_phone_count(size_t i0,uint32_t v);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_info_count;
 ::idl::vector< ::idl::string > _m_info_id;
 ::idl::vector< ::idl::string > _m_info_name;
 ::idl::vector< uint32_t > _m_phone_count;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_test_result_params
class mcp_get_test_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_test_response* create(bsl::mempool* pool);
static void destroy(mcp_get_test_response* v);
explicit mcp_get_test_response(bsl::mempool* pool);
mcp_get_test_response(const mcp_get_test_response& v);
~mcp_get_test_response();
mcp_get_test_response& operator=(const mcp_get_test_response& v);
void clear();
void check() const;
void detach();
mcp_get_test_response& assign(const mcp_get_test_response& v);
// @@mcp_get_test_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_test_result_params& result_params() const;
inline ::idl::mcp_get_test_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_test_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_test_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_test_response
class mcp_get_phone_maker_plat_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_maker_plat_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_maker_plat_params* v);
explicit mcp_get_phone_maker_plat_params(bsl::mempool* pool);
mcp_get_phone_maker_plat_params(const mcp_get_phone_maker_plat_params& v);
~mcp_get_phone_maker_plat_params();
mcp_get_phone_maker_plat_params& operator=(const mcp_get_phone_maker_plat_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_maker_plat_params& assign(const mcp_get_phone_maker_plat_params& v);
// @@uint32_t info_type=in();
inline bool has_info_type() const;
inline uint32_t info_type() const;
inline mcp_get_phone_maker_plat_params& set_info_type(uint32_t v);
inline void clear_info_type();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_phone_maker_plat_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_phone_maker_plat_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_info_type;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_maker_plat_params
class mcp_get_phone_maker_plat_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_maker_plat_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_maker_plat_result_params* v);
explicit mcp_get_phone_maker_plat_result_params(bsl::mempool* pool);
mcp_get_phone_maker_plat_result_params(const mcp_get_phone_maker_plat_result_params& v);
~mcp_get_phone_maker_plat_result_params();
mcp_get_phone_maker_plat_result_params& operator=(const mcp_get_phone_maker_plat_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_maker_plat_result_params& assign(const mcp_get_phone_maker_plat_result_params& v);
// @@uint32_t info_count=out();
inline bool has_info_count() const;
inline uint32_t info_count() const;
inline mcp_get_phone_maker_plat_result_params& set_info_count(uint32_t v);
inline void clear_info_count();
// @@string info_id=out(),array(0);
inline bool has_info_id() const;
inline const ::idl::vector< ::idl::string >& info_id() const;
inline ::idl::vector< ::idl::string >* mutable_info_id();
inline void clear_info_id();
// deprecated.use 'mutable_info_id' instead.
inline ::idl::vector< ::idl::string >* m_info_id();
// deprecated.use 'info_id().size()' instead.
inline size_t info_id_size() const;
inline const char* info_id(size_t i0,unsigned int* size=0) const;
inline mcp_get_phone_maker_plat_result_params& set_info_id(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_phone_maker_plat_result_params& set_ptr_info_id(size_t i0,const char* s,ssize_t size=-1);
// @@string info_name=out(),array(0);
inline bool has_info_name() const;
inline const ::idl::vector< ::idl::string >& info_name() const;
inline ::idl::vector< ::idl::string >* mutable_info_name();
inline void clear_info_name();
// deprecated.use 'mutable_info_name' instead.
inline ::idl::vector< ::idl::string >* m_info_name();
// deprecated.use 'info_name().size()' instead.
inline size_t info_name_size() const;
inline const char* info_name(size_t i0,unsigned int* size=0) const;
inline mcp_get_phone_maker_plat_result_params& set_info_name(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_phone_maker_plat_result_params& set_ptr_info_name(size_t i0,const char* s,ssize_t size=-1);
// @@uint32_t phone_count=out(),array(0);
inline bool has_phone_count() const;
inline const ::idl::vector< uint32_t >& phone_count() const;
inline ::idl::vector< uint32_t >* mutable_phone_count();
inline void clear_phone_count();
// deprecated.use 'mutable_phone_count' instead.
inline ::idl::vector< uint32_t >* m_phone_count();
// deprecated.use 'phone_count().size()' instead.
inline size_t phone_count_size() const;
inline uint32_t phone_count(size_t i0) const;
inline mcp_get_phone_maker_plat_result_params& set_phone_count(size_t i0,uint32_t v);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_info_count;
 ::idl::vector< ::idl::string > _m_info_id;
 ::idl::vector< ::idl::string > _m_info_name;
 ::idl::vector< uint32_t > _m_phone_count;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_maker_plat_result_params
class mcp_get_phone_maker_plat_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_maker_plat_response* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_maker_plat_response* v);
explicit mcp_get_phone_maker_plat_response(bsl::mempool* pool);
mcp_get_phone_maker_plat_response(const mcp_get_phone_maker_plat_response& v);
~mcp_get_phone_maker_plat_response();
mcp_get_phone_maker_plat_response& operator=(const mcp_get_phone_maker_plat_response& v);
void clear();
void check() const;
void detach();
mcp_get_phone_maker_plat_response& assign(const mcp_get_phone_maker_plat_response& v);
// @@mcp_get_phone_maker_plat_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_phone_maker_plat_result_params& result_params() const;
inline ::idl::mcp_get_phone_maker_plat_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_phone_maker_plat_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_phone_maker_plat_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_maker_plat_response
class mcp_get_content_list_from_classID_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_classID_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_classID_params* v);
explicit mcp_get_content_list_from_classID_params(bsl::mempool* pool);
mcp_get_content_list_from_classID_params(const mcp_get_content_list_from_classID_params& v);
~mcp_get_content_list_from_classID_params();
mcp_get_content_list_from_classID_params& operator=(const mcp_get_content_list_from_classID_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_classID_params& assign(const mcp_get_content_list_from_classID_params& v);
// @@string class_id=in();
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_get_content_list_from_classID_params& set_class_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_classID_params& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
// @@string content_type_id=in();
inline bool has_content_type_id() const;
inline const char* content_type_id(unsigned int* size=0) const;
inline mcp_get_content_list_from_classID_params& set_content_type_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_classID_params& set_ptr_content_type_id(const char* s,ssize_t size=-1);
inline void clear_content_type_id();
// @@uint32_t priority=in();
inline bool has_priority() const;
inline uint32_t priority() const;
inline mcp_get_content_list_from_classID_params& set_priority(uint32_t v);
inline void clear_priority();
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_content_list_from_classID_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_classID_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@uint32_t info_type=in();
inline bool has_info_type() const;
inline uint32_t info_type() const;
inline mcp_get_content_list_from_classID_params& set_info_type(uint32_t v);
inline void clear_info_type();
// @@string img_size=in();
inline bool has_img_size() const;
inline const char* img_size(unsigned int* size=0) const;
inline mcp_get_content_list_from_classID_params& set_img_size(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_classID_params& set_ptr_img_size(const char* s,ssize_t size=-1);
inline void clear_img_size();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_content_list_from_classID_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_content_list_from_classID_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
// @@uint32_t for_adapt=in();
inline bool has_for_adapt() const;
inline uint32_t for_adapt() const;
inline mcp_get_content_list_from_classID_params& set_for_adapt(uint32_t v);
inline void clear_for_adapt();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_class_id;
 ::idl::string _m_content_type_id;
 uint32_t _m_priority;
 ::idl::string _m_info_id;
 uint32_t _m_info_type;
 ::idl::string _m_img_size;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
 uint32_t _m_for_adapt;
mutable ::idl::Unknown _unknown;
char _flag[2];
}; // class mcp_get_content_list_from_classID_params
class mcp_get_content_list_from_classID_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_classID_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_classID_result_params* v);
explicit mcp_get_content_list_from_classID_result_params(bsl::mempool* pool);
mcp_get_content_list_from_classID_result_params(const mcp_get_content_list_from_classID_result_params& v);
~mcp_get_content_list_from_classID_result_params();
mcp_get_content_list_from_classID_result_params& operator=(const mcp_get_content_list_from_classID_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_classID_result_params& assign(const mcp_get_content_list_from_classID_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_content_list_from_classID_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string content_list=out(),array(0,0);
inline bool has_content_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& content_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_content_list();
inline void clear_content_list();
// deprecated.use 'mutable_content_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_content_list();
// deprecated.use 'content_list().size()' instead.
inline size_t content_list_size() const;
inline const char* content_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_content_list_from_classID_result_params& set_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_classID_result_params& set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_content_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_from_classID_result_params
class mcp_get_content_list_from_classID_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_classID_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_classID_response* v);
explicit mcp_get_content_list_from_classID_response(bsl::mempool* pool);
mcp_get_content_list_from_classID_response(const mcp_get_content_list_from_classID_response& v);
~mcp_get_content_list_from_classID_response();
mcp_get_content_list_from_classID_response& operator=(const mcp_get_content_list_from_classID_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_classID_response& assign(const mcp_get_content_list_from_classID_response& v);
// @@mcp_get_content_list_from_classID_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_list_from_classID_result_params& result_params() const;
inline ::idl::mcp_get_content_list_from_classID_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_list_from_classID_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_list_from_classID_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_from_classID_response
class mcp_get_content_list_from_typeID_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_typeID_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_typeID_params* v);
explicit mcp_get_content_list_from_typeID_params(bsl::mempool* pool);
mcp_get_content_list_from_typeID_params(const mcp_get_content_list_from_typeID_params& v);
~mcp_get_content_list_from_typeID_params();
mcp_get_content_list_from_typeID_params& operator=(const mcp_get_content_list_from_typeID_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_typeID_params& assign(const mcp_get_content_list_from_typeID_params& v);
// @@string content_type_id=in();
inline bool has_content_type_id() const;
inline const char* content_type_id(unsigned int* size=0) const;
inline mcp_get_content_list_from_typeID_params& set_content_type_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_typeID_params& set_ptr_content_type_id(const char* s,ssize_t size=-1);
inline void clear_content_type_id();
// @@uint32_t priority=in();
inline bool has_priority() const;
inline uint32_t priority() const;
inline mcp_get_content_list_from_typeID_params& set_priority(uint32_t v);
inline void clear_priority();
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_content_list_from_typeID_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_typeID_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@uint32_t info_type=in();
inline bool has_info_type() const;
inline uint32_t info_type() const;
inline mcp_get_content_list_from_typeID_params& set_info_type(uint32_t v);
inline void clear_info_type();
// @@string img_size=in();
inline bool has_img_size() const;
inline const char* img_size(unsigned int* size=0) const;
inline mcp_get_content_list_from_typeID_params& set_img_size(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_typeID_params& set_ptr_img_size(const char* s,ssize_t size=-1);
inline void clear_img_size();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_content_list_from_typeID_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_content_list_from_typeID_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_content_type_id;
 uint32_t _m_priority;
 ::idl::string _m_info_id;
 uint32_t _m_info_type;
 ::idl::string _m_img_size;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_from_typeID_params
class mcp_get_content_list_from_typeID_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_typeID_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_typeID_result_params* v);
explicit mcp_get_content_list_from_typeID_result_params(bsl::mempool* pool);
mcp_get_content_list_from_typeID_result_params(const mcp_get_content_list_from_typeID_result_params& v);
~mcp_get_content_list_from_typeID_result_params();
mcp_get_content_list_from_typeID_result_params& operator=(const mcp_get_content_list_from_typeID_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_typeID_result_params& assign(const mcp_get_content_list_from_typeID_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_content_list_from_typeID_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string content_list=out(),array(0,0);
inline bool has_content_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& content_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_content_list();
inline void clear_content_list();
// deprecated.use 'mutable_content_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_content_list();
// deprecated.use 'content_list().size()' instead.
inline size_t content_list_size() const;
inline const char* content_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_content_list_from_typeID_result_params& set_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_typeID_result_params& set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_content_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_from_typeID_result_params
class mcp_get_content_list_from_typeID_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_typeID_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_typeID_response* v);
explicit mcp_get_content_list_from_typeID_response(bsl::mempool* pool);
mcp_get_content_list_from_typeID_response(const mcp_get_content_list_from_typeID_response& v);
~mcp_get_content_list_from_typeID_response();
mcp_get_content_list_from_typeID_response& operator=(const mcp_get_content_list_from_typeID_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_typeID_response& assign(const mcp_get_content_list_from_typeID_response& v);
// @@mcp_get_content_list_from_typeID_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_list_from_typeID_result_params& result_params() const;
inline ::idl::mcp_get_content_list_from_typeID_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_list_from_typeID_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_list_from_typeID_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_from_typeID_response
class mcp_get_content_class_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_class_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_class_params* v);
explicit mcp_get_content_class_params(bsl::mempool* pool);
mcp_get_content_class_params(const mcp_get_content_class_params& v);
~mcp_get_content_class_params();
mcp_get_content_class_params& operator=(const mcp_get_content_class_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_class_params& assign(const mcp_get_content_class_params& v);
// @@string content_type_id=in();
inline bool has_content_type_id() const;
inline const char* content_type_id(unsigned int* size=0) const;
inline mcp_get_content_class_params& set_content_type_id(const char* s,ssize_t size=-1);
inline mcp_get_content_class_params& set_ptr_content_type_id(const char* s,ssize_t size=-1);
inline void clear_content_type_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_content_type_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_class_params
class mcp_get_content_class_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_class_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_class_result_params* v);
explicit mcp_get_content_class_result_params(bsl::mempool* pool);
mcp_get_content_class_result_params(const mcp_get_content_class_result_params& v);
~mcp_get_content_class_result_params();
mcp_get_content_class_result_params& operator=(const mcp_get_content_class_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_class_result_params& assign(const mcp_get_content_class_result_params& v);
// @@string content_class_id=out(),array(0);
inline bool has_content_class_id() const;
inline const ::idl::vector< ::idl::string >& content_class_id() const;
inline ::idl::vector< ::idl::string >* mutable_content_class_id();
inline void clear_content_class_id();
// deprecated.use 'mutable_content_class_id' instead.
inline ::idl::vector< ::idl::string >* m_content_class_id();
// deprecated.use 'content_class_id().size()' instead.
inline size_t content_class_id_size() const;
inline const char* content_class_id(size_t i0,unsigned int* size=0) const;
inline mcp_get_content_class_result_params& set_content_class_id(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_content_class_result_params& set_ptr_content_class_id(size_t i0,const char* s,ssize_t size=-1);
// @@string content_class_name=out(),array(0);
inline bool has_content_class_name() const;
inline const ::idl::vector< ::idl::string >& content_class_name() const;
inline ::idl::vector< ::idl::string >* mutable_content_class_name();
inline void clear_content_class_name();
// deprecated.use 'mutable_content_class_name' instead.
inline ::idl::vector< ::idl::string >* m_content_class_name();
// deprecated.use 'content_class_name().size()' instead.
inline size_t content_class_name_size() const;
inline const char* content_class_name(size_t i0,unsigned int* size=0) const;
inline mcp_get_content_class_result_params& set_content_class_name(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_content_class_result_params& set_ptr_content_class_name(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::vector< ::idl::string > _m_content_class_id;
 ::idl::vector< ::idl::string > _m_content_class_name;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_class_result_params
class mcp_get_content_class_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_class_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_class_response* v);
explicit mcp_get_content_class_response(bsl::mempool* pool);
mcp_get_content_class_response(const mcp_get_content_class_response& v);
~mcp_get_content_class_response();
mcp_get_content_class_response& operator=(const mcp_get_content_class_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_class_response& assign(const mcp_get_content_class_response& v);
// @@mcp_get_content_class_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_class_result_params& result_params() const;
inline ::idl::mcp_get_content_class_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_class_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_class_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_class_response
class mcp_get_content_class_name_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_class_name_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_class_name_params* v);
explicit mcp_get_content_class_name_params(bsl::mempool* pool);
mcp_get_content_class_name_params(const mcp_get_content_class_name_params& v);
~mcp_get_content_class_name_params();
mcp_get_content_class_name_params& operator=(const mcp_get_content_class_name_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_class_name_params& assign(const mcp_get_content_class_name_params& v);
// @@string class_id=in();
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_get_content_class_name_params& set_class_id(const char* s,ssize_t size=-1);
inline mcp_get_content_class_name_params& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_class_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_class_name_params
class mcp_get_content_class_name_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_class_name_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_class_name_result_params* v);
explicit mcp_get_content_class_name_result_params(bsl::mempool* pool);
mcp_get_content_class_name_result_params(const mcp_get_content_class_name_result_params& v);
~mcp_get_content_class_name_result_params();
mcp_get_content_class_name_result_params& operator=(const mcp_get_content_class_name_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_class_name_result_params& assign(const mcp_get_content_class_name_result_params& v);
// @@string class_name=out();
inline bool has_class_name() const;
inline const char* class_name(unsigned int* size=0) const;
inline mcp_get_content_class_name_result_params& set_class_name(const char* s,ssize_t size=-1);
inline mcp_get_content_class_name_result_params& set_ptr_class_name(const char* s,ssize_t size=-1);
inline void clear_class_name();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_class_name;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_class_name_result_params
class mcp_get_content_class_name_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_class_name_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_class_name_response* v);
explicit mcp_get_content_class_name_response(bsl::mempool* pool);
mcp_get_content_class_name_response(const mcp_get_content_class_name_response& v);
~mcp_get_content_class_name_response();
mcp_get_content_class_name_response& operator=(const mcp_get_content_class_name_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_class_name_response& assign(const mcp_get_content_class_name_response& v);
// @@mcp_get_content_class_name_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_class_name_result_params& result_params() const;
inline ::idl::mcp_get_content_class_name_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_class_name_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_class_name_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_class_name_response
class mcp_get_content_diy_col_name_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_diy_col_name_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_diy_col_name_params* v);
explicit mcp_get_content_diy_col_name_params(bsl::mempool* pool);
mcp_get_content_diy_col_name_params(const mcp_get_content_diy_col_name_params& v);
~mcp_get_content_diy_col_name_params();
mcp_get_content_diy_col_name_params& operator=(const mcp_get_content_diy_col_name_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_diy_col_name_params& assign(const mcp_get_content_diy_col_name_params& v);
// @@string diycol_id=in();
inline bool has_diycol_id() const;
inline const char* diycol_id(unsigned int* size=0) const;
inline mcp_get_content_diy_col_name_params& set_diycol_id(const char* s,ssize_t size=-1);
inline mcp_get_content_diy_col_name_params& set_ptr_diycol_id(const char* s,ssize_t size=-1);
inline void clear_diycol_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_diycol_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_diy_col_name_params
class mcp_get_content_diy_col_name_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_diy_col_name_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_diy_col_name_result_params* v);
explicit mcp_get_content_diy_col_name_result_params(bsl::mempool* pool);
mcp_get_content_diy_col_name_result_params(const mcp_get_content_diy_col_name_result_params& v);
~mcp_get_content_diy_col_name_result_params();
mcp_get_content_diy_col_name_result_params& operator=(const mcp_get_content_diy_col_name_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_diy_col_name_result_params& assign(const mcp_get_content_diy_col_name_result_params& v);
// @@string diycol_name=out();
inline bool has_diycol_name() const;
inline const char* diycol_name(unsigned int* size=0) const;
inline mcp_get_content_diy_col_name_result_params& set_diycol_name(const char* s,ssize_t size=-1);
inline mcp_get_content_diy_col_name_result_params& set_ptr_diycol_name(const char* s,ssize_t size=-1);
inline void clear_diycol_name();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_diycol_name;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_diy_col_name_result_params
class mcp_get_content_diy_col_name_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_diy_col_name_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_diy_col_name_response* v);
explicit mcp_get_content_diy_col_name_response(bsl::mempool* pool);
mcp_get_content_diy_col_name_response(const mcp_get_content_diy_col_name_response& v);
~mcp_get_content_diy_col_name_response();
mcp_get_content_diy_col_name_response& operator=(const mcp_get_content_diy_col_name_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_diy_col_name_response& assign(const mcp_get_content_diy_col_name_response& v);
// @@mcp_get_content_diy_col_name_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_diy_col_name_result_params& result_params() const;
inline ::idl::mcp_get_content_diy_col_name_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_diy_col_name_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_diy_col_name_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_diy_col_name_response
class mcp_get_content_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_info_params* v);
explicit mcp_get_content_info_params(bsl::mempool* pool);
mcp_get_content_info_params(const mcp_get_content_info_params& v);
~mcp_get_content_info_params();
mcp_get_content_info_params& operator=(const mcp_get_content_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_info_params& assign(const mcp_get_content_info_params& v);
// @@string content_id=in();
inline bool has_content_id() const;
inline const char* content_id(unsigned int* size=0) const;
inline mcp_get_content_info_params& set_content_id(const char* s,ssize_t size=-1);
inline mcp_get_content_info_params& set_ptr_content_id(const char* s,ssize_t size=-1);
inline void clear_content_id();
// @@uint32_t content_ext=in();
inline bool has_content_ext() const;
inline uint32_t content_ext() const;
inline mcp_get_content_info_params& set_content_ext(uint32_t v);
inline void clear_content_ext();
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_content_info_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_content_info_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@uint32_t info_type=in();
inline bool has_info_type() const;
inline uint32_t info_type() const;
inline mcp_get_content_info_params& set_info_type(uint32_t v);
inline void clear_info_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_content_id;
 uint32_t _m_content_ext;
 ::idl::string _m_info_id;
 uint32_t _m_info_type;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_info_params
class mcp_get_content_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_info_result_params* v);
explicit mcp_get_content_info_result_params(bsl::mempool* pool);
mcp_get_content_info_result_params(const mcp_get_content_info_result_params& v);
~mcp_get_content_info_result_params();
mcp_get_content_info_result_params& operator=(const mcp_get_content_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_info_result_params& assign(const mcp_get_content_info_result_params& v);
// @@string info_list=out(),array(0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::string >& info_list() const;
inline ::idl::vector< ::idl::string >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::string >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const char* info_list(size_t i0,unsigned int* size=0) const;
inline mcp_get_content_info_result_params& set_info_list(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_content_info_result_params& set_ptr_info_list(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::vector< ::idl::string > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_info_result_params
class mcp_get_content_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_info_response* v);
explicit mcp_get_content_info_response(bsl::mempool* pool);
mcp_get_content_info_response(const mcp_get_content_info_response& v);
~mcp_get_content_info_response();
mcp_get_content_info_response& operator=(const mcp_get_content_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_info_response& assign(const mcp_get_content_info_response& v);
// @@mcp_get_content_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_info_result_params& result_params() const;
inline ::idl::mcp_get_content_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_info_response
class mcp_get_download_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_download_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_download_info_params* v);
explicit mcp_get_download_info_params(bsl::mempool* pool);
mcp_get_download_info_params(const mcp_get_download_info_params& v);
~mcp_get_download_info_params();
mcp_get_download_info_params& operator=(const mcp_get_download_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_download_info_params& assign(const mcp_get_download_info_params& v);
// @@string content_id=in();
inline bool has_content_id() const;
inline const char* content_id(unsigned int* size=0) const;
inline mcp_get_download_info_params& set_content_id(const char* s,ssize_t size=-1);
inline mcp_get_download_info_params& set_ptr_content_id(const char* s,ssize_t size=-1);
inline void clear_content_id();
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_download_info_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_download_info_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@uint32_t info_type=in();
inline bool has_info_type() const;
inline uint32_t info_type() const;
inline mcp_get_download_info_params& set_info_type(uint32_t v);
inline void clear_info_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_content_id;
 ::idl::string _m_info_id;
 uint32_t _m_info_type;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_download_info_params
class mcp_get_download_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_download_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_download_info_result_params* v);
explicit mcp_get_download_info_result_params(bsl::mempool* pool);
mcp_get_download_info_result_params(const mcp_get_download_info_result_params& v);
~mcp_get_download_info_result_params();
mcp_get_download_info_result_params& operator=(const mcp_get_download_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_download_info_result_params& assign(const mcp_get_download_info_result_params& v);
// @@string download_info=out(),array(0,0);
inline bool has_download_info() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& download_info() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_download_info();
inline void clear_download_info();
// deprecated.use 'mutable_download_info' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_download_info();
// deprecated.use 'download_info().size()' instead.
inline size_t download_info_size() const;
inline const char* download_info(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_download_info_result_params& set_download_info(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_download_info_result_params& set_ptr_download_info(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_download_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_download_info_result_params
class mcp_get_download_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_download_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_download_info_response* v);
explicit mcp_get_download_info_response(bsl::mempool* pool);
mcp_get_download_info_response(const mcp_get_download_info_response& v);
~mcp_get_download_info_response();
mcp_get_download_info_response& operator=(const mcp_get_download_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_download_info_response& assign(const mcp_get_download_info_response& v);
// @@mcp_get_download_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_download_info_result_params& result_params() const;
inline ::idl::mcp_get_download_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_download_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_download_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_download_info_response
class mcp_get_content_list_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_params* v);
explicit mcp_get_content_list_params(bsl::mempool* pool);
mcp_get_content_list_params(const mcp_get_content_list_params& v);
~mcp_get_content_list_params();
mcp_get_content_list_params& operator=(const mcp_get_content_list_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_params& assign(const mcp_get_content_list_params& v);
// @@uint32_t priority=in();
inline bool has_priority() const;
inline uint32_t priority() const;
inline mcp_get_content_list_params& set_priority(uint32_t v);
inline void clear_priority();
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_content_list_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@uint32_t info_type=in();
inline bool has_info_type() const;
inline uint32_t info_type() const;
inline mcp_get_content_list_params& set_info_type(uint32_t v);
inline void clear_info_type();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_content_list_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_content_list_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_priority;
 ::idl::string _m_info_id;
 uint32_t _m_info_type;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_params
class mcp_get_content_list_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_result_params* v);
explicit mcp_get_content_list_result_params(bsl::mempool* pool);
mcp_get_content_list_result_params(const mcp_get_content_list_result_params& v);
~mcp_get_content_list_result_params();
mcp_get_content_list_result_params& operator=(const mcp_get_content_list_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_result_params& assign(const mcp_get_content_list_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_content_list_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string content_list=out(),array(0,0);
inline bool has_content_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& content_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_content_list();
inline void clear_content_list();
// deprecated.use 'mutable_content_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_content_list();
// deprecated.use 'content_list().size()' instead.
inline size_t content_list_size() const;
inline const char* content_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_content_list_result_params& set_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_content_list_result_params& set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_content_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_result_params
class mcp_get_content_list_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_response* v);
explicit mcp_get_content_list_response(bsl::mempool* pool);
mcp_get_content_list_response(const mcp_get_content_list_response& v);
~mcp_get_content_list_response();
mcp_get_content_list_response& operator=(const mcp_get_content_list_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_response& assign(const mcp_get_content_list_response& v);
// @@mcp_get_content_list_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_list_result_params& result_params() const;
inline ::idl::mcp_get_content_list_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_list_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_list_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_response
class mcp_get_content_list_from_part_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_part_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_part_params* v);
explicit mcp_get_content_list_from_part_params(bsl::mempool* pool);
mcp_get_content_list_from_part_params(const mcp_get_content_list_from_part_params& v);
~mcp_get_content_list_from_part_params();
mcp_get_content_list_from_part_params& operator=(const mcp_get_content_list_from_part_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_part_params& assign(const mcp_get_content_list_from_part_params& v);
// @@string part_id=in();
inline bool has_part_id() const;
inline const char* part_id(unsigned int* size=0) const;
inline mcp_get_content_list_from_part_params& set_part_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_part_params& set_ptr_part_id(const char* s,ssize_t size=-1);
inline void clear_part_id();
// @@string content_type_id=in();
inline bool has_content_type_id() const;
inline const char* content_type_id(unsigned int* size=0) const;
inline mcp_get_content_list_from_part_params& set_content_type_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_part_params& set_ptr_content_type_id(const char* s,ssize_t size=-1);
inline void clear_content_type_id();
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_content_list_from_part_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_part_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@uint32_t info_type=in();
inline bool has_info_type() const;
inline uint32_t info_type() const;
inline mcp_get_content_list_from_part_params& set_info_type(uint32_t v);
inline void clear_info_type();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_content_list_from_part_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_content_list_from_part_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_part_id;
 ::idl::string _m_content_type_id;
 ::idl::string _m_info_id;
 uint32_t _m_info_type;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_from_part_params
class mcp_get_content_list_from_part_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_part_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_part_result_params* v);
explicit mcp_get_content_list_from_part_result_params(bsl::mempool* pool);
mcp_get_content_list_from_part_result_params(const mcp_get_content_list_from_part_result_params& v);
~mcp_get_content_list_from_part_result_params();
mcp_get_content_list_from_part_result_params& operator=(const mcp_get_content_list_from_part_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_part_result_params& assign(const mcp_get_content_list_from_part_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_content_list_from_part_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string content_list=out(),array(0,0);
inline bool has_content_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& content_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_content_list();
inline void clear_content_list();
// deprecated.use 'mutable_content_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_content_list();
// deprecated.use 'content_list().size()' instead.
inline size_t content_list_size() const;
inline const char* content_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_content_list_from_part_result_params& set_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_part_result_params& set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_content_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_from_part_result_params
class mcp_get_content_list_from_part_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_part_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_part_response* v);
explicit mcp_get_content_list_from_part_response(bsl::mempool* pool);
mcp_get_content_list_from_part_response(const mcp_get_content_list_from_part_response& v);
~mcp_get_content_list_from_part_response();
mcp_get_content_list_from_part_response& operator=(const mcp_get_content_list_from_part_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_part_response& assign(const mcp_get_content_list_from_part_response& v);
// @@mcp_get_content_list_from_part_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_list_from_part_result_params& result_params() const;
inline ::idl::mcp_get_content_list_from_part_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_list_from_part_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_list_from_part_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_from_part_response
class mcp_get_content_count_from_class_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_count_from_class_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_count_from_class_params* v);
explicit mcp_get_content_count_from_class_params(bsl::mempool* pool);
mcp_get_content_count_from_class_params(const mcp_get_content_count_from_class_params& v);
~mcp_get_content_count_from_class_params();
mcp_get_content_count_from_class_params& operator=(const mcp_get_content_count_from_class_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_count_from_class_params& assign(const mcp_get_content_count_from_class_params& v);
// @@string class_id=in();
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_get_content_count_from_class_params& set_class_id(const char* s,ssize_t size=-1);
inline mcp_get_content_count_from_class_params& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
// @@uint32_t class_type=in();
inline bool has_class_type() const;
inline uint32_t class_type() const;
inline mcp_get_content_count_from_class_params& set_class_type(uint32_t v);
inline void clear_class_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_class_id;
 uint32_t _m_class_type;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_count_from_class_params
class mcp_get_content_count_from_class_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_count_from_class_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_count_from_class_result_params* v);
explicit mcp_get_content_count_from_class_result_params(bsl::mempool* pool);
mcp_get_content_count_from_class_result_params(const mcp_get_content_count_from_class_result_params& v);
~mcp_get_content_count_from_class_result_params();
mcp_get_content_count_from_class_result_params& operator=(const mcp_get_content_count_from_class_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_count_from_class_result_params& assign(const mcp_get_content_count_from_class_result_params& v);
// @@string class_name=out();
inline bool has_class_name() const;
inline const char* class_name(unsigned int* size=0) const;
inline mcp_get_content_count_from_class_result_params& set_class_name(const char* s,ssize_t size=-1);
inline mcp_get_content_count_from_class_result_params& set_ptr_class_name(const char* s,ssize_t size=-1);
inline void clear_class_name();
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_content_count_from_class_result_params& set_count(uint32_t v);
inline void clear_count();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_class_name;
 uint32_t _m_count;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_count_from_class_result_params
class mcp_get_content_count_from_class_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_count_from_class_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_count_from_class_response* v);
explicit mcp_get_content_count_from_class_response(bsl::mempool* pool);
mcp_get_content_count_from_class_response(const mcp_get_content_count_from_class_response& v);
~mcp_get_content_count_from_class_response();
mcp_get_content_count_from_class_response& operator=(const mcp_get_content_count_from_class_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_count_from_class_response& assign(const mcp_get_content_count_from_class_response& v);
// @@mcp_get_content_count_from_class_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_count_from_class_result_params& result_params() const;
inline ::idl::mcp_get_content_count_from_class_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_count_from_class_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_count_from_class_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_count_from_class_response
class mcp_get_phone_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_info_params* v);
explicit mcp_get_phone_info_params(bsl::mempool* pool);
mcp_get_phone_info_params(const mcp_get_phone_info_params& v);
~mcp_get_phone_info_params();
mcp_get_phone_info_params& operator=(const mcp_get_phone_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_info_params& assign(const mcp_get_phone_info_params& v);
// @@string user_info=in();
inline bool has_user_info() const;
inline const char* user_info(unsigned int* size=0) const;
inline mcp_get_phone_info_params& set_user_info(const char* s,ssize_t size=-1);
inline mcp_get_phone_info_params& set_ptr_user_info(const char* s,ssize_t size=-1);
inline void clear_user_info();
// @@uint32_t user_type=in();
inline bool has_user_type() const;
inline uint32_t user_type() const;
inline mcp_get_phone_info_params& set_user_type(uint32_t v);
inline void clear_user_type();
// @@uint32_t phone_info_type=in();
inline bool has_phone_info_type() const;
inline uint32_t phone_info_type() const;
inline mcp_get_phone_info_params& set_phone_info_type(uint32_t v);
inline void clear_phone_info_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_user_info;
 uint32_t _m_user_type;
 uint32_t _m_phone_info_type;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_info_params
class mcp_get_phone_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_info_result_params* v);
explicit mcp_get_phone_info_result_params(bsl::mempool* pool);
mcp_get_phone_info_result_params(const mcp_get_phone_info_result_params& v);
~mcp_get_phone_info_result_params();
mcp_get_phone_info_result_params& operator=(const mcp_get_phone_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_info_result_params& assign(const mcp_get_phone_info_result_params& v);
// @@string phone_info=out(),array(0,0);
inline bool has_phone_info() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& phone_info() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_phone_info();
inline void clear_phone_info();
// deprecated.use 'mutable_phone_info' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_phone_info();
// deprecated.use 'phone_info().size()' instead.
inline size_t phone_info_size() const;
inline const char* phone_info(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_phone_info_result_params& set_phone_info(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_phone_info_result_params& set_ptr_phone_info(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_phone_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_info_result_params
class mcp_get_phone_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_info_response* v);
explicit mcp_get_phone_info_response(bsl::mempool* pool);
mcp_get_phone_info_response(const mcp_get_phone_info_response& v);
~mcp_get_phone_info_response();
mcp_get_phone_info_response& operator=(const mcp_get_phone_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_phone_info_response& assign(const mcp_get_phone_info_response& v);
// @@mcp_get_phone_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_phone_info_result_params& result_params() const;
inline ::idl::mcp_get_phone_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_phone_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_phone_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_info_response
class mcp_get_phone_uaJson_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_uaJson_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_uaJson_params* v);
explicit mcp_get_phone_uaJson_params(bsl::mempool* pool);
mcp_get_phone_uaJson_params(const mcp_get_phone_uaJson_params& v);
~mcp_get_phone_uaJson_params();
mcp_get_phone_uaJson_params& operator=(const mcp_get_phone_uaJson_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_uaJson_params& assign(const mcp_get_phone_uaJson_params& v);
// @@string ua=in();
inline bool has_ua() const;
inline const char* ua(unsigned int* size=0) const;
inline mcp_get_phone_uaJson_params& set_ua(const char* s,ssize_t size=-1);
inline mcp_get_phone_uaJson_params& set_ptr_ua(const char* s,ssize_t size=-1);
inline void clear_ua();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_ua;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_uaJson_params
class mcp_get_phone_uaJson_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_uaJson_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_uaJson_result_params* v);
explicit mcp_get_phone_uaJson_result_params(bsl::mempool* pool);
mcp_get_phone_uaJson_result_params(const mcp_get_phone_uaJson_result_params& v);
~mcp_get_phone_uaJson_result_params();
mcp_get_phone_uaJson_result_params& operator=(const mcp_get_phone_uaJson_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_uaJson_result_params& assign(const mcp_get_phone_uaJson_result_params& v);
// @@string ua_Json=out(),array(0);
inline bool has_ua_Json() const;
inline const ::idl::vector< ::idl::string >& ua_Json() const;
inline ::idl::vector< ::idl::string >* mutable_ua_Json();
inline void clear_ua_Json();
// deprecated.use 'mutable_ua_Json' instead.
inline ::idl::vector< ::idl::string >* m_ua_Json();
// deprecated.use 'ua_Json().size()' instead.
inline size_t ua_Json_size() const;
inline const char* ua_Json(size_t i0,unsigned int* size=0) const;
inline mcp_get_phone_uaJson_result_params& set_ua_Json(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_phone_uaJson_result_params& set_ptr_ua_Json(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::vector< ::idl::string > _m_ua_Json;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_uaJson_result_params
class mcp_get_phone_uaJson_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_uaJson_response* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_uaJson_response* v);
explicit mcp_get_phone_uaJson_response(bsl::mempool* pool);
mcp_get_phone_uaJson_response(const mcp_get_phone_uaJson_response& v);
~mcp_get_phone_uaJson_response();
mcp_get_phone_uaJson_response& operator=(const mcp_get_phone_uaJson_response& v);
void clear();
void check() const;
void detach();
mcp_get_phone_uaJson_response& assign(const mcp_get_phone_uaJson_response& v);
// @@mcp_get_phone_uaJson_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_phone_uaJson_result_params& result_params() const;
inline ::idl::mcp_get_phone_uaJson_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_phone_uaJson_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_phone_uaJson_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_uaJson_response
class mcp_init_phone_uaJson_map_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_init_phone_uaJson_map_params* create(bsl::mempool* pool);
static void destroy(mcp_init_phone_uaJson_map_params* v);
explicit mcp_init_phone_uaJson_map_params(bsl::mempool* pool);
mcp_init_phone_uaJson_map_params(const mcp_init_phone_uaJson_map_params& v);
~mcp_init_phone_uaJson_map_params();
mcp_init_phone_uaJson_map_params& operator=(const mcp_init_phone_uaJson_map_params& v);
void clear();
void check() const;
void detach();
mcp_init_phone_uaJson_map_params& assign(const mcp_init_phone_uaJson_map_params& v);
// @@string input=in();
inline bool has_input() const;
inline const char* input(unsigned int* size=0) const;
inline mcp_init_phone_uaJson_map_params& set_input(const char* s,ssize_t size=-1);
inline mcp_init_phone_uaJson_map_params& set_ptr_input(const char* s,ssize_t size=-1);
inline void clear_input();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_input;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_init_phone_uaJson_map_params
class mcp_init_phone_uaJson_map_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_init_phone_uaJson_map_result_params* create(bsl::mempool* pool);
static void destroy(mcp_init_phone_uaJson_map_result_params* v);
explicit mcp_init_phone_uaJson_map_result_params(bsl::mempool* pool);
mcp_init_phone_uaJson_map_result_params(const mcp_init_phone_uaJson_map_result_params& v);
~mcp_init_phone_uaJson_map_result_params();
mcp_init_phone_uaJson_map_result_params& operator=(const mcp_init_phone_uaJson_map_result_params& v);
void clear();
void check() const;
void detach();
mcp_init_phone_uaJson_map_result_params& assign(const mcp_init_phone_uaJson_map_result_params& v);
// @@string output=out(),array(0);
inline bool has_output() const;
inline const ::idl::vector< ::idl::string >& output() const;
inline ::idl::vector< ::idl::string >* mutable_output();
inline void clear_output();
// deprecated.use 'mutable_output' instead.
inline ::idl::vector< ::idl::string >* m_output();
// deprecated.use 'output().size()' instead.
inline size_t output_size() const;
inline const char* output(size_t i0,unsigned int* size=0) const;
inline mcp_init_phone_uaJson_map_result_params& set_output(size_t i0,const char* s,ssize_t size=-1);
inline mcp_init_phone_uaJson_map_result_params& set_ptr_output(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::vector< ::idl::string > _m_output;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_init_phone_uaJson_map_result_params
class mcp_init_phone_uaJson_map_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_init_phone_uaJson_map_response* create(bsl::mempool* pool);
static void destroy(mcp_init_phone_uaJson_map_response* v);
explicit mcp_init_phone_uaJson_map_response(bsl::mempool* pool);
mcp_init_phone_uaJson_map_response(const mcp_init_phone_uaJson_map_response& v);
~mcp_init_phone_uaJson_map_response();
mcp_init_phone_uaJson_map_response& operator=(const mcp_init_phone_uaJson_map_response& v);
void clear();
void check() const;
void detach();
mcp_init_phone_uaJson_map_response& assign(const mcp_init_phone_uaJson_map_response& v);
// @@mcp_init_phone_uaJson_map_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_init_phone_uaJson_map_result_params& result_params() const;
inline ::idl::mcp_init_phone_uaJson_map_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_init_phone_uaJson_map_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_init_phone_uaJson_map_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_init_phone_uaJson_map_response
class mcp_get_phone_type_from_ID_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_type_from_ID_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_type_from_ID_params* v);
explicit mcp_get_phone_type_from_ID_params(bsl::mempool* pool);
mcp_get_phone_type_from_ID_params(const mcp_get_phone_type_from_ID_params& v);
~mcp_get_phone_type_from_ID_params();
mcp_get_phone_type_from_ID_params& operator=(const mcp_get_phone_type_from_ID_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_type_from_ID_params& assign(const mcp_get_phone_type_from_ID_params& v);
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_phone_type_from_ID_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_phone_type_from_ID_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@uint32_t id_type=in();
inline bool has_id_type() const;
inline uint32_t id_type() const;
inline mcp_get_phone_type_from_ID_params& set_id_type(uint32_t v);
inline void clear_id_type();
// @@string head_word=in();
inline bool has_head_word() const;
inline const char* head_word(unsigned int* size=0) const;
inline mcp_get_phone_type_from_ID_params& set_head_word(const char* s,ssize_t size=-1);
inline mcp_get_phone_type_from_ID_params& set_ptr_head_word(const char* s,ssize_t size=-1);
inline void clear_head_word();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_phone_type_from_ID_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_phone_type_from_ID_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_info_id;
 uint32_t _m_id_type;
 ::idl::string _m_head_word;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_type_from_ID_params
class mcp_get_phone_type_from_ID_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_type_from_ID_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_type_from_ID_result_params* v);
explicit mcp_get_phone_type_from_ID_result_params(bsl::mempool* pool);
mcp_get_phone_type_from_ID_result_params(const mcp_get_phone_type_from_ID_result_params& v);
~mcp_get_phone_type_from_ID_result_params();
mcp_get_phone_type_from_ID_result_params& operator=(const mcp_get_phone_type_from_ID_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_type_from_ID_result_params& assign(const mcp_get_phone_type_from_ID_result_params& v);
// @@uint32_t phone_count=out();
inline bool has_phone_count() const;
inline uint32_t phone_count() const;
inline mcp_get_phone_type_from_ID_result_params& set_phone_count(uint32_t v);
inline void clear_phone_count();
// @@string phone_id=out(),array(0);
inline bool has_phone_id() const;
inline const ::idl::vector< ::idl::string >& phone_id() const;
inline ::idl::vector< ::idl::string >* mutable_phone_id();
inline void clear_phone_id();
// deprecated.use 'mutable_phone_id' instead.
inline ::idl::vector< ::idl::string >* m_phone_id();
// deprecated.use 'phone_id().size()' instead.
inline size_t phone_id_size() const;
inline const char* phone_id(size_t i0,unsigned int* size=0) const;
inline mcp_get_phone_type_from_ID_result_params& set_phone_id(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_phone_type_from_ID_result_params& set_ptr_phone_id(size_t i0,const char* s,ssize_t size=-1);
// @@string phone_name=out(),array(0);
inline bool has_phone_name() const;
inline const ::idl::vector< ::idl::string >& phone_name() const;
inline ::idl::vector< ::idl::string >* mutable_phone_name();
inline void clear_phone_name();
// deprecated.use 'mutable_phone_name' instead.
inline ::idl::vector< ::idl::string >* m_phone_name();
// deprecated.use 'phone_name().size()' instead.
inline size_t phone_name_size() const;
inline const char* phone_name(size_t i0,unsigned int* size=0) const;
inline mcp_get_phone_type_from_ID_result_params& set_phone_name(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_phone_type_from_ID_result_params& set_ptr_phone_name(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_phone_count;
 ::idl::vector< ::idl::string > _m_phone_id;
 ::idl::vector< ::idl::string > _m_phone_name;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_type_from_ID_result_params
class mcp_get_phone_type_from_ID_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_type_from_ID_response* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_type_from_ID_response* v);
explicit mcp_get_phone_type_from_ID_response(bsl::mempool* pool);
mcp_get_phone_type_from_ID_response(const mcp_get_phone_type_from_ID_response& v);
~mcp_get_phone_type_from_ID_response();
mcp_get_phone_type_from_ID_response& operator=(const mcp_get_phone_type_from_ID_response& v);
void clear();
void check() const;
void detach();
mcp_get_phone_type_from_ID_response& assign(const mcp_get_phone_type_from_ID_response& v);
// @@mcp_get_phone_type_from_ID_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_phone_type_from_ID_result_params& result_params() const;
inline ::idl::mcp_get_phone_type_from_ID_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_phone_type_from_ID_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_phone_type_from_ID_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_type_from_ID_response
class mcp_get_phone_headword_from_maker_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_headword_from_maker_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_headword_from_maker_params* v);
explicit mcp_get_phone_headword_from_maker_params(bsl::mempool* pool);
mcp_get_phone_headword_from_maker_params(const mcp_get_phone_headword_from_maker_params& v);
~mcp_get_phone_headword_from_maker_params();
mcp_get_phone_headword_from_maker_params& operator=(const mcp_get_phone_headword_from_maker_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_headword_from_maker_params& assign(const mcp_get_phone_headword_from_maker_params& v);
// @@string maker_id=in();
inline bool has_maker_id() const;
inline const char* maker_id(unsigned int* size=0) const;
inline mcp_get_phone_headword_from_maker_params& set_maker_id(const char* s,ssize_t size=-1);
inline mcp_get_phone_headword_from_maker_params& set_ptr_maker_id(const char* s,ssize_t size=-1);
inline void clear_maker_id();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_phone_headword_from_maker_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_phone_headword_from_maker_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_maker_id;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_headword_from_maker_params
class mcp_get_phone_headword_from_maker_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_headword_from_maker_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_headword_from_maker_result_params* v);
explicit mcp_get_phone_headword_from_maker_result_params(bsl::mempool* pool);
mcp_get_phone_headword_from_maker_result_params(const mcp_get_phone_headword_from_maker_result_params& v);
~mcp_get_phone_headword_from_maker_result_params();
mcp_get_phone_headword_from_maker_result_params& operator=(const mcp_get_phone_headword_from_maker_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_headword_from_maker_result_params& assign(const mcp_get_phone_headword_from_maker_result_params& v);
// @@uint32_t headword_count=out();
inline bool has_headword_count() const;
inline uint32_t headword_count() const;
inline mcp_get_phone_headword_from_maker_result_params& set_headword_count(uint32_t v);
inline void clear_headword_count();
// @@string head_word=out(),array(0);
inline bool has_head_word() const;
inline const ::idl::vector< ::idl::string >& head_word() const;
inline ::idl::vector< ::idl::string >* mutable_head_word();
inline void clear_head_word();
// deprecated.use 'mutable_head_word' instead.
inline ::idl::vector< ::idl::string >* m_head_word();
// deprecated.use 'head_word().size()' instead.
inline size_t head_word_size() const;
inline const char* head_word(size_t i0,unsigned int* size=0) const;
inline mcp_get_phone_headword_from_maker_result_params& set_head_word(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_phone_headword_from_maker_result_params& set_ptr_head_word(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_headword_count;
 ::idl::vector< ::idl::string > _m_head_word;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_headword_from_maker_result_params
class mcp_get_phone_headword_from_maker_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_headword_from_maker_response* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_headword_from_maker_response* v);
explicit mcp_get_phone_headword_from_maker_response(bsl::mempool* pool);
mcp_get_phone_headword_from_maker_response(const mcp_get_phone_headword_from_maker_response& v);
~mcp_get_phone_headword_from_maker_response();
mcp_get_phone_headword_from_maker_response& operator=(const mcp_get_phone_headword_from_maker_response& v);
void clear();
void check() const;
void detach();
mcp_get_phone_headword_from_maker_response& assign(const mcp_get_phone_headword_from_maker_response& v);
// @@mcp_get_phone_headword_from_maker_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_phone_headword_from_maker_result_params& result_params() const;
inline ::idl::mcp_get_phone_headword_from_maker_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_phone_headword_from_maker_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_phone_headword_from_maker_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_headword_from_maker_response
class mcp_search_phone_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_search_phone_info_params* create(bsl::mempool* pool);
static void destroy(mcp_search_phone_info_params* v);
explicit mcp_search_phone_info_params(bsl::mempool* pool);
mcp_search_phone_info_params(const mcp_search_phone_info_params& v);
~mcp_search_phone_info_params();
mcp_search_phone_info_params& operator=(const mcp_search_phone_info_params& v);
void clear();
void check() const;
void detach();
mcp_search_phone_info_params& assign(const mcp_search_phone_info_params& v);
// @@string key=in();
inline bool has_key() const;
inline const char* key(unsigned int* size=0) const;
inline mcp_search_phone_info_params& set_key(const char* s,ssize_t size=-1);
inline mcp_search_phone_info_params& set_ptr_key(const char* s,ssize_t size=-1);
inline void clear_key();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_search_phone_info_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_search_phone_info_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_key;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_search_phone_info_params
class mcp_search_phone_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_search_phone_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_search_phone_info_result_params* v);
explicit mcp_search_phone_info_result_params(bsl::mempool* pool);
mcp_search_phone_info_result_params(const mcp_search_phone_info_result_params& v);
~mcp_search_phone_info_result_params();
mcp_search_phone_info_result_params& operator=(const mcp_search_phone_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_search_phone_info_result_params& assign(const mcp_search_phone_info_result_params& v);
// @@uint32_t phone_count=out();
inline bool has_phone_count() const;
inline uint32_t phone_count() const;
inline mcp_search_phone_info_result_params& set_phone_count(uint32_t v);
inline void clear_phone_count();
// @@string phone_id=out(),array(0);
inline bool has_phone_id() const;
inline const ::idl::vector< ::idl::string >& phone_id() const;
inline ::idl::vector< ::idl::string >* mutable_phone_id();
inline void clear_phone_id();
// deprecated.use 'mutable_phone_id' instead.
inline ::idl::vector< ::idl::string >* m_phone_id();
// deprecated.use 'phone_id().size()' instead.
inline size_t phone_id_size() const;
inline const char* phone_id(size_t i0,unsigned int* size=0) const;
inline mcp_search_phone_info_result_params& set_phone_id(size_t i0,const char* s,ssize_t size=-1);
inline mcp_search_phone_info_result_params& set_ptr_phone_id(size_t i0,const char* s,ssize_t size=-1);
// @@string phone_name=out(),array(0);
inline bool has_phone_name() const;
inline const ::idl::vector< ::idl::string >& phone_name() const;
inline ::idl::vector< ::idl::string >* mutable_phone_name();
inline void clear_phone_name();
// deprecated.use 'mutable_phone_name' instead.
inline ::idl::vector< ::idl::string >* m_phone_name();
// deprecated.use 'phone_name().size()' instead.
inline size_t phone_name_size() const;
inline const char* phone_name(size_t i0,unsigned int* size=0) const;
inline mcp_search_phone_info_result_params& set_phone_name(size_t i0,const char* s,ssize_t size=-1);
inline mcp_search_phone_info_result_params& set_ptr_phone_name(size_t i0,const char* s,ssize_t size=-1);
// @@string brand_id=out(),array(0);
inline bool has_brand_id() const;
inline const ::idl::vector< ::idl::string >& brand_id() const;
inline ::idl::vector< ::idl::string >* mutable_brand_id();
inline void clear_brand_id();
// deprecated.use 'mutable_brand_id' instead.
inline ::idl::vector< ::idl::string >* m_brand_id();
// deprecated.use 'brand_id().size()' instead.
inline size_t brand_id_size() const;
inline const char* brand_id(size_t i0,unsigned int* size=0) const;
inline mcp_search_phone_info_result_params& set_brand_id(size_t i0,const char* s,ssize_t size=-1);
inline mcp_search_phone_info_result_params& set_ptr_brand_id(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_phone_count;
 ::idl::vector< ::idl::string > _m_phone_id;
 ::idl::vector< ::idl::string > _m_phone_name;
 ::idl::vector< ::idl::string > _m_brand_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_search_phone_info_result_params
class mcp_search_phone_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_search_phone_info_response* create(bsl::mempool* pool);
static void destroy(mcp_search_phone_info_response* v);
explicit mcp_search_phone_info_response(bsl::mempool* pool);
mcp_search_phone_info_response(const mcp_search_phone_info_response& v);
~mcp_search_phone_info_response();
mcp_search_phone_info_response& operator=(const mcp_search_phone_info_response& v);
void clear();
void check() const;
void detach();
mcp_search_phone_info_response& assign(const mcp_search_phone_info_response& v);
// @@mcp_search_phone_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_search_phone_info_result_params& result_params() const;
inline ::idl::mcp_search_phone_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_search_phone_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_search_phone_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_search_phone_info_response
class mcp_get_carriers_info_from_ip_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_carriers_info_from_ip_params* create(bsl::mempool* pool);
static void destroy(mcp_get_carriers_info_from_ip_params* v);
explicit mcp_get_carriers_info_from_ip_params(bsl::mempool* pool);
mcp_get_carriers_info_from_ip_params(const mcp_get_carriers_info_from_ip_params& v);
~mcp_get_carriers_info_from_ip_params();
mcp_get_carriers_info_from_ip_params& operator=(const mcp_get_carriers_info_from_ip_params& v);
void clear();
void check() const;
void detach();
mcp_get_carriers_info_from_ip_params& assign(const mcp_get_carriers_info_from_ip_params& v);
// @@string ip_addres=in();
inline bool has_ip_addres() const;
inline const char* ip_addres(unsigned int* size=0) const;
inline mcp_get_carriers_info_from_ip_params& set_ip_addres(const char* s,ssize_t size=-1);
inline mcp_get_carriers_info_from_ip_params& set_ptr_ip_addres(const char* s,ssize_t size=-1);
inline void clear_ip_addres();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_ip_addres;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_carriers_info_from_ip_params
class mcp_get_carriers_info_from_ip_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_carriers_info_from_ip_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_carriers_info_from_ip_result_params* v);
explicit mcp_get_carriers_info_from_ip_result_params(bsl::mempool* pool);
mcp_get_carriers_info_from_ip_result_params(const mcp_get_carriers_info_from_ip_result_params& v);
~mcp_get_carriers_info_from_ip_result_params();
mcp_get_carriers_info_from_ip_result_params& operator=(const mcp_get_carriers_info_from_ip_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_carriers_info_from_ip_result_params& assign(const mcp_get_carriers_info_from_ip_result_params& v);
// @@uint32_t carriers_name=out();
inline bool has_carriers_name() const;
inline uint32_t carriers_name() const;
inline mcp_get_carriers_info_from_ip_result_params& set_carriers_name(uint32_t v);
inline void clear_carriers_name();
// @@uint32_t owner_place=out();
inline bool has_owner_place() const;
inline uint32_t owner_place() const;
inline mcp_get_carriers_info_from_ip_result_params& set_owner_place(uint32_t v);
inline void clear_owner_place();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_carriers_name;
 uint32_t _m_owner_place;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_carriers_info_from_ip_result_params
class mcp_get_carriers_info_from_ip_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_carriers_info_from_ip_response* create(bsl::mempool* pool);
static void destroy(mcp_get_carriers_info_from_ip_response* v);
explicit mcp_get_carriers_info_from_ip_response(bsl::mempool* pool);
mcp_get_carriers_info_from_ip_response(const mcp_get_carriers_info_from_ip_response& v);
~mcp_get_carriers_info_from_ip_response();
mcp_get_carriers_info_from_ip_response& operator=(const mcp_get_carriers_info_from_ip_response& v);
void clear();
void check() const;
void detach();
mcp_get_carriers_info_from_ip_response& assign(const mcp_get_carriers_info_from_ip_response& v);
// @@mcp_get_carriers_info_from_ip_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_carriers_info_from_ip_result_params& result_params() const;
inline ::idl::mcp_get_carriers_info_from_ip_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_carriers_info_from_ip_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_carriers_info_from_ip_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_carriers_info_from_ip_response
class mcp_get_phone_info_from_maker_plat_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_info_from_maker_plat_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_info_from_maker_plat_params* v);
explicit mcp_get_phone_info_from_maker_plat_params(bsl::mempool* pool);
mcp_get_phone_info_from_maker_plat_params(const mcp_get_phone_info_from_maker_plat_params& v);
~mcp_get_phone_info_from_maker_plat_params();
mcp_get_phone_info_from_maker_plat_params& operator=(const mcp_get_phone_info_from_maker_plat_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_info_from_maker_plat_params& assign(const mcp_get_phone_info_from_maker_plat_params& v);
// @@string maker_id=in();
inline bool has_maker_id() const;
inline const char* maker_id(unsigned int* size=0) const;
inline mcp_get_phone_info_from_maker_plat_params& set_maker_id(const char* s,ssize_t size=-1);
inline mcp_get_phone_info_from_maker_plat_params& set_ptr_maker_id(const char* s,ssize_t size=-1);
inline void clear_maker_id();
// @@string plat_id=in();
inline bool has_plat_id() const;
inline const char* plat_id(unsigned int* size=0) const;
inline mcp_get_phone_info_from_maker_plat_params& set_plat_id(const char* s,ssize_t size=-1);
inline mcp_get_phone_info_from_maker_plat_params& set_ptr_plat_id(const char* s,ssize_t size=-1);
inline void clear_plat_id();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_phone_info_from_maker_plat_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_phone_info_from_maker_plat_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_maker_id;
 ::idl::string _m_plat_id;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_info_from_maker_plat_params
class mcp_get_phone_info_from_maker_plat_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_info_from_maker_plat_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_info_from_maker_plat_result_params* v);
explicit mcp_get_phone_info_from_maker_plat_result_params(bsl::mempool* pool);
mcp_get_phone_info_from_maker_plat_result_params(const mcp_get_phone_info_from_maker_plat_result_params& v);
~mcp_get_phone_info_from_maker_plat_result_params();
mcp_get_phone_info_from_maker_plat_result_params& operator=(const mcp_get_phone_info_from_maker_plat_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_info_from_maker_plat_result_params& assign(const mcp_get_phone_info_from_maker_plat_result_params& v);
// @@uint32_t phone_count=out();
inline bool has_phone_count() const;
inline uint32_t phone_count() const;
inline mcp_get_phone_info_from_maker_plat_result_params& set_phone_count(uint32_t v);
inline void clear_phone_count();
// @@string phone_id=out(),array(0);
inline bool has_phone_id() const;
inline const ::idl::vector< ::idl::string >& phone_id() const;
inline ::idl::vector< ::idl::string >* mutable_phone_id();
inline void clear_phone_id();
// deprecated.use 'mutable_phone_id' instead.
inline ::idl::vector< ::idl::string >* m_phone_id();
// deprecated.use 'phone_id().size()' instead.
inline size_t phone_id_size() const;
inline const char* phone_id(size_t i0,unsigned int* size=0) const;
inline mcp_get_phone_info_from_maker_plat_result_params& set_phone_id(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_phone_info_from_maker_plat_result_params& set_ptr_phone_id(size_t i0,const char* s,ssize_t size=-1);
// @@string phone_name=out(),array(0);
inline bool has_phone_name() const;
inline const ::idl::vector< ::idl::string >& phone_name() const;
inline ::idl::vector< ::idl::string >* mutable_phone_name();
inline void clear_phone_name();
// deprecated.use 'mutable_phone_name' instead.
inline ::idl::vector< ::idl::string >* m_phone_name();
// deprecated.use 'phone_name().size()' instead.
inline size_t phone_name_size() const;
inline const char* phone_name(size_t i0,unsigned int* size=0) const;
inline mcp_get_phone_info_from_maker_plat_result_params& set_phone_name(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_phone_info_from_maker_plat_result_params& set_ptr_phone_name(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_phone_count;
 ::idl::vector< ::idl::string > _m_phone_id;
 ::idl::vector< ::idl::string > _m_phone_name;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_info_from_maker_plat_result_params
class mcp_get_phone_info_from_maker_plat_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_info_from_maker_plat_response* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_info_from_maker_plat_response* v);
explicit mcp_get_phone_info_from_maker_plat_response(bsl::mempool* pool);
mcp_get_phone_info_from_maker_plat_response(const mcp_get_phone_info_from_maker_plat_response& v);
~mcp_get_phone_info_from_maker_plat_response();
mcp_get_phone_info_from_maker_plat_response& operator=(const mcp_get_phone_info_from_maker_plat_response& v);
void clear();
void check() const;
void detach();
mcp_get_phone_info_from_maker_plat_response& assign(const mcp_get_phone_info_from_maker_plat_response& v);
// @@mcp_get_phone_info_from_maker_plat_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_phone_info_from_maker_plat_result_params& result_params() const;
inline ::idl::mcp_get_phone_info_from_maker_plat_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_phone_info_from_maker_plat_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_phone_info_from_maker_plat_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_info_from_maker_plat_response
class mcp_get_url_info_by_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_url_info_by_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_url_info_by_id_params* v);
explicit mcp_get_url_info_by_id_params(bsl::mempool* pool);
mcp_get_url_info_by_id_params(const mcp_get_url_info_by_id_params& v);
~mcp_get_url_info_by_id_params();
mcp_get_url_info_by_id_params& operator=(const mcp_get_url_info_by_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_url_info_by_id_params& assign(const mcp_get_url_info_by_id_params& v);
// @@string id=in();
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline mcp_get_url_info_by_id_params& set_id(const char* s,ssize_t size=-1);
inline mcp_get_url_info_by_id_params& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_url_info_by_id_params
class mcp_get_url_info_by_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_url_info_by_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_url_info_by_id_result_params* v);
explicit mcp_get_url_info_by_id_result_params(bsl::mempool* pool);
mcp_get_url_info_by_id_result_params(const mcp_get_url_info_by_id_result_params& v);
~mcp_get_url_info_by_id_result_params();
mcp_get_url_info_by_id_result_params& operator=(const mcp_get_url_info_by_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_url_info_by_id_result_params& assign(const mcp_get_url_info_by_id_result_params& v);
// @@string url_info=out(),array(0);
inline bool has_url_info() const;
inline const ::idl::vector< ::idl::string >& url_info() const;
inline ::idl::vector< ::idl::string >* mutable_url_info();
inline void clear_url_info();
// deprecated.use 'mutable_url_info' instead.
inline ::idl::vector< ::idl::string >* m_url_info();
// deprecated.use 'url_info().size()' instead.
inline size_t url_info_size() const;
inline const char* url_info(size_t i0,unsigned int* size=0) const;
inline mcp_get_url_info_by_id_result_params& set_url_info(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_url_info_by_id_result_params& set_ptr_url_info(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::vector< ::idl::string > _m_url_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_url_info_by_id_result_params
class mcp_get_url_info_by_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_url_info_by_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_url_info_by_id_response* v);
explicit mcp_get_url_info_by_id_response(bsl::mempool* pool);
mcp_get_url_info_by_id_response(const mcp_get_url_info_by_id_response& v);
~mcp_get_url_info_by_id_response();
mcp_get_url_info_by_id_response& operator=(const mcp_get_url_info_by_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_url_info_by_id_response& assign(const mcp_get_url_info_by_id_response& v);
// @@mcp_get_url_info_by_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_url_info_by_id_result_params& result_params() const;
inline ::idl::mcp_get_url_info_by_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_url_info_by_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_url_info_by_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_url_info_by_id_response
class mcp_get_url_info_by_class_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_url_info_by_class_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_url_info_by_class_id_params* v);
explicit mcp_get_url_info_by_class_id_params(bsl::mempool* pool);
mcp_get_url_info_by_class_id_params(const mcp_get_url_info_by_class_id_params& v);
~mcp_get_url_info_by_class_id_params();
mcp_get_url_info_by_class_id_params& operator=(const mcp_get_url_info_by_class_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_url_info_by_class_id_params& assign(const mcp_get_url_info_by_class_id_params& v);
// @@string class_id=in();
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_get_url_info_by_class_id_params& set_class_id(const char* s,ssize_t size=-1);
inline mcp_get_url_info_by_class_id_params& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_url_info_by_class_id_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_url_info_by_class_id_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_class_id;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_url_info_by_class_id_params
class mcp_get_url_info_by_class_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_url_info_by_class_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_url_info_by_class_id_result_params* v);
explicit mcp_get_url_info_by_class_id_result_params(bsl::mempool* pool);
mcp_get_url_info_by_class_id_result_params(const mcp_get_url_info_by_class_id_result_params& v);
~mcp_get_url_info_by_class_id_result_params();
mcp_get_url_info_by_class_id_result_params& operator=(const mcp_get_url_info_by_class_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_url_info_by_class_id_result_params& assign(const mcp_get_url_info_by_class_id_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_url_info_by_class_id_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string url_info=out(),array(0,0);
inline bool has_url_info() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& url_info() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_url_info();
inline void clear_url_info();
// deprecated.use 'mutable_url_info' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_url_info();
// deprecated.use 'url_info().size()' instead.
inline size_t url_info_size() const;
inline const char* url_info(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_url_info_by_class_id_result_params& set_url_info(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_url_info_by_class_id_result_params& set_ptr_url_info(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_url_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_url_info_by_class_id_result_params
class mcp_get_url_info_by_class_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_url_info_by_class_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_url_info_by_class_id_response* v);
explicit mcp_get_url_info_by_class_id_response(bsl::mempool* pool);
mcp_get_url_info_by_class_id_response(const mcp_get_url_info_by_class_id_response& v);
~mcp_get_url_info_by_class_id_response();
mcp_get_url_info_by_class_id_response& operator=(const mcp_get_url_info_by_class_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_url_info_by_class_id_response& assign(const mcp_get_url_info_by_class_id_response& v);
// @@mcp_get_url_info_by_class_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_url_info_by_class_id_result_params& result_params() const;
inline ::idl::mcp_get_url_info_by_class_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_url_info_by_class_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_url_info_by_class_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_url_info_by_class_id_response
class mcp_get_url_info_by_column_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_url_info_by_column_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_url_info_by_column_id_params* v);
explicit mcp_get_url_info_by_column_id_params(bsl::mempool* pool);
mcp_get_url_info_by_column_id_params(const mcp_get_url_info_by_column_id_params& v);
~mcp_get_url_info_by_column_id_params();
mcp_get_url_info_by_column_id_params& operator=(const mcp_get_url_info_by_column_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_url_info_by_column_id_params& assign(const mcp_get_url_info_by_column_id_params& v);
// @@string column_id=in();
inline bool has_column_id() const;
inline const char* column_id(unsigned int* size=0) const;
inline mcp_get_url_info_by_column_id_params& set_column_id(const char* s,ssize_t size=-1);
inline mcp_get_url_info_by_column_id_params& set_ptr_column_id(const char* s,ssize_t size=-1);
inline void clear_column_id();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_url_info_by_column_id_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_url_info_by_column_id_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_column_id;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_url_info_by_column_id_params
class mcp_get_url_info_by_column_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_url_info_by_column_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_url_info_by_column_id_result_params* v);
explicit mcp_get_url_info_by_column_id_result_params(bsl::mempool* pool);
mcp_get_url_info_by_column_id_result_params(const mcp_get_url_info_by_column_id_result_params& v);
~mcp_get_url_info_by_column_id_result_params();
mcp_get_url_info_by_column_id_result_params& operator=(const mcp_get_url_info_by_column_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_url_info_by_column_id_result_params& assign(const mcp_get_url_info_by_column_id_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_url_info_by_column_id_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string url_info=out(),array(0,0);
inline bool has_url_info() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& url_info() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_url_info();
inline void clear_url_info();
// deprecated.use 'mutable_url_info' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_url_info();
// deprecated.use 'url_info().size()' instead.
inline size_t url_info_size() const;
inline const char* url_info(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_url_info_by_column_id_result_params& set_url_info(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_url_info_by_column_id_result_params& set_ptr_url_info(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_url_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_url_info_by_column_id_result_params
class mcp_get_url_info_by_column_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_url_info_by_column_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_url_info_by_column_id_response* v);
explicit mcp_get_url_info_by_column_id_response(bsl::mempool* pool);
mcp_get_url_info_by_column_id_response(const mcp_get_url_info_by_column_id_response& v);
~mcp_get_url_info_by_column_id_response();
mcp_get_url_info_by_column_id_response& operator=(const mcp_get_url_info_by_column_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_url_info_by_column_id_response& assign(const mcp_get_url_info_by_column_id_response& v);
// @@mcp_get_url_info_by_column_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_url_info_by_column_id_result_params& result_params() const;
inline ::idl::mcp_get_url_info_by_column_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_url_info_by_column_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_url_info_by_column_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_url_info_by_column_id_response
class mcp_get_content_list_from_phone_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_phone_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_phone_params* v);
explicit mcp_get_content_list_from_phone_params(bsl::mempool* pool);
mcp_get_content_list_from_phone_params(const mcp_get_content_list_from_phone_params& v);
~mcp_get_content_list_from_phone_params();
mcp_get_content_list_from_phone_params& operator=(const mcp_get_content_list_from_phone_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_phone_params& assign(const mcp_get_content_list_from_phone_params& v);
// @@string p_id=in();
inline bool has_p_id() const;
inline const char* p_id(unsigned int* size=0) const;
inline mcp_get_content_list_from_phone_params& set_p_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_phone_params& set_ptr_p_id(const char* s,ssize_t size=-1);
inline void clear_p_id();
// @@uint32_t priority=in();
inline bool has_priority() const;
inline uint32_t priority() const;
inline mcp_get_content_list_from_phone_params& set_priority(uint32_t v);
inline void clear_priority();
// @@uint32_t type=in();
inline bool has_type() const;
inline uint32_t type() const;
inline mcp_get_content_list_from_phone_params& set_type(uint32_t v);
inline void clear_type();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_content_list_from_phone_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_content_list_from_phone_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_p_id;
 uint32_t _m_priority;
 uint32_t _m_type;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_from_phone_params
class mcp_get_content_list_from_phone_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_phone_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_phone_result_params* v);
explicit mcp_get_content_list_from_phone_result_params(bsl::mempool* pool);
mcp_get_content_list_from_phone_result_params(const mcp_get_content_list_from_phone_result_params& v);
~mcp_get_content_list_from_phone_result_params();
mcp_get_content_list_from_phone_result_params& operator=(const mcp_get_content_list_from_phone_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_phone_result_params& assign(const mcp_get_content_list_from_phone_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_content_list_from_phone_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string content_list=out(),array(0,0);
inline bool has_content_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& content_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_content_list();
inline void clear_content_list();
// deprecated.use 'mutable_content_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_content_list();
// deprecated.use 'content_list().size()' instead.
inline size_t content_list_size() const;
inline const char* content_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_content_list_from_phone_result_params& set_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_phone_result_params& set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_content_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_from_phone_result_params
class mcp_get_content_list_from_phone_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_phone_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_phone_response* v);
explicit mcp_get_content_list_from_phone_response(bsl::mempool* pool);
mcp_get_content_list_from_phone_response(const mcp_get_content_list_from_phone_response& v);
~mcp_get_content_list_from_phone_response();
mcp_get_content_list_from_phone_response& operator=(const mcp_get_content_list_from_phone_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_phone_response& assign(const mcp_get_content_list_from_phone_response& v);
// @@mcp_get_content_list_from_phone_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_list_from_phone_result_params& result_params() const;
inline ::idl::mcp_get_content_list_from_phone_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_list_from_phone_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_list_from_phone_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_from_phone_response
class mcp_get_content_list_by_rank_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_rank_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_rank_params* v);
explicit mcp_get_content_list_by_rank_params(bsl::mempool* pool);
mcp_get_content_list_by_rank_params(const mcp_get_content_list_by_rank_params& v);
~mcp_get_content_list_by_rank_params();
mcp_get_content_list_by_rank_params& operator=(const mcp_get_content_list_by_rank_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_rank_params& assign(const mcp_get_content_list_by_rank_params& v);
// @@string content_type=in();
inline bool has_content_type() const;
inline const char* content_type(unsigned int* size=0) const;
inline mcp_get_content_list_by_rank_params& set_content_type(const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_rank_params& set_ptr_content_type(const char* s,ssize_t size=-1);
inline void clear_content_type();
// @@string class_id=in();
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_get_content_list_by_rank_params& set_class_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_rank_params& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
// @@uint32_t p_type=in();
inline bool has_p_type() const;
inline uint32_t p_type() const;
inline mcp_get_content_list_by_rank_params& set_p_type(uint32_t v);
inline void clear_p_type();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_content_list_by_rank_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_content_list_by_rank_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_content_list_by_rank_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_rank_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@uint32_t info_type=in();
inline bool has_info_type() const;
inline uint32_t info_type() const;
inline mcp_get_content_list_by_rank_params& set_info_type(uint32_t v);
inline void clear_info_type();
// @@uint32_t for_adapt=in();
inline bool has_for_adapt() const;
inline uint32_t for_adapt() const;
inline mcp_get_content_list_by_rank_params& set_for_adapt(uint32_t v);
inline void clear_for_adapt();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_content_type;
 ::idl::string _m_class_id;
 uint32_t _m_p_type;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
 ::idl::string _m_info_id;
 uint32_t _m_info_type;
 uint32_t _m_for_adapt;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_rank_params
class mcp_get_content_list_by_rank_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_rank_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_rank_result_params* v);
explicit mcp_get_content_list_by_rank_result_params(bsl::mempool* pool);
mcp_get_content_list_by_rank_result_params(const mcp_get_content_list_by_rank_result_params& v);
~mcp_get_content_list_by_rank_result_params();
mcp_get_content_list_by_rank_result_params& operator=(const mcp_get_content_list_by_rank_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_rank_result_params& assign(const mcp_get_content_list_by_rank_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_content_list_by_rank_result_params& set_count(int32_t v);
inline void clear_count();
// @@string content_list=out(),array(0,0);
inline bool has_content_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& content_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_content_list();
inline void clear_content_list();
// deprecated.use 'mutable_content_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_content_list();
// deprecated.use 'content_list().size()' instead.
inline size_t content_list_size() const;
inline const char* content_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_content_list_by_rank_result_params& set_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_rank_result_params& set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_content_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_rank_result_params
class mcp_get_content_list_by_rank_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_rank_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_rank_response* v);
explicit mcp_get_content_list_by_rank_response(bsl::mempool* pool);
mcp_get_content_list_by_rank_response(const mcp_get_content_list_by_rank_response& v);
~mcp_get_content_list_by_rank_response();
mcp_get_content_list_by_rank_response& operator=(const mcp_get_content_list_by_rank_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_rank_response& assign(const mcp_get_content_list_by_rank_response& v);
// @@mcp_get_content_list_by_rank_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_list_by_rank_result_params& result_params() const;
inline ::idl::mcp_get_content_list_by_rank_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_list_by_rank_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_list_by_rank_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_rank_response
class mcp_get_label_by_content_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_label_by_content_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_label_by_content_id_params* v);
explicit mcp_get_label_by_content_id_params(bsl::mempool* pool);
mcp_get_label_by_content_id_params(const mcp_get_label_by_content_id_params& v);
~mcp_get_label_by_content_id_params();
mcp_get_label_by_content_id_params& operator=(const mcp_get_label_by_content_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_label_by_content_id_params& assign(const mcp_get_label_by_content_id_params& v);
// @@string content_id=in();
inline bool has_content_id() const;
inline const char* content_id(unsigned int* size=0) const;
inline mcp_get_label_by_content_id_params& set_content_id(const char* s,ssize_t size=-1);
inline mcp_get_label_by_content_id_params& set_ptr_content_id(const char* s,ssize_t size=-1);
inline void clear_content_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_content_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_label_by_content_id_params
class mcp_get_label_by_content_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_label_by_content_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_label_by_content_id_result_params* v);
explicit mcp_get_label_by_content_id_result_params(bsl::mempool* pool);
mcp_get_label_by_content_id_result_params(const mcp_get_label_by_content_id_result_params& v);
~mcp_get_label_by_content_id_result_params();
mcp_get_label_by_content_id_result_params& operator=(const mcp_get_label_by_content_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_label_by_content_id_result_params& assign(const mcp_get_label_by_content_id_result_params& v);
// @@uint32_t result=out();
inline bool has_result() const;
inline uint32_t result() const;
inline mcp_get_label_by_content_id_result_params& set_result(uint32_t v);
inline void clear_result();
// @@string label_list=out(),array(0,2);
inline bool has_label_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& label_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_label_list();
inline void clear_label_list();
// deprecated.use 'mutable_label_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_label_list();
// deprecated.use 'label_list().size()' instead.
inline size_t label_list_size() const;
inline const char* label_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_label_by_content_id_result_params& set_label_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_label_by_content_id_result_params& set_ptr_label_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_result;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_label_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_label_by_content_id_result_params
class mcp_get_label_by_content_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_label_by_content_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_label_by_content_id_response* v);
explicit mcp_get_label_by_content_id_response(bsl::mempool* pool);
mcp_get_label_by_content_id_response(const mcp_get_label_by_content_id_response& v);
~mcp_get_label_by_content_id_response();
mcp_get_label_by_content_id_response& operator=(const mcp_get_label_by_content_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_label_by_content_id_response& assign(const mcp_get_label_by_content_id_response& v);
// @@mcp_get_label_by_content_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_label_by_content_id_result_params& result_params() const;
inline ::idl::mcp_get_label_by_content_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_label_by_content_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_label_by_content_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_label_by_content_id_response
class mcp_get_content_list_by_label_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_label_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_label_params* v);
explicit mcp_get_content_list_by_label_params(bsl::mempool* pool);
mcp_get_content_list_by_label_params(const mcp_get_content_list_by_label_params& v);
~mcp_get_content_list_by_label_params();
mcp_get_content_list_by_label_params& operator=(const mcp_get_content_list_by_label_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_label_params& assign(const mcp_get_content_list_by_label_params& v);
// @@string label_id=in();
inline bool has_label_id() const;
inline const char* label_id(unsigned int* size=0) const;
inline mcp_get_content_list_by_label_params& set_label_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_label_params& set_ptr_label_id(const char* s,ssize_t size=-1);
inline void clear_label_id();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_content_list_by_label_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_content_list_by_label_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_content_list_by_label_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_label_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@uint32_t info_type=in();
inline bool has_info_type() const;
inline uint32_t info_type() const;
inline mcp_get_content_list_by_label_params& set_info_type(uint32_t v);
inline void clear_info_type();
// @@uint32_t for_adapt=in();
inline bool has_for_adapt() const;
inline uint32_t for_adapt() const;
inline mcp_get_content_list_by_label_params& set_for_adapt(uint32_t v);
inline void clear_for_adapt();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_label_id;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
 ::idl::string _m_info_id;
 uint32_t _m_info_type;
 uint32_t _m_for_adapt;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_label_params
class mcp_get_content_list_by_label_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_label_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_label_result_params* v);
explicit mcp_get_content_list_by_label_result_params(bsl::mempool* pool);
mcp_get_content_list_by_label_result_params(const mcp_get_content_list_by_label_result_params& v);
~mcp_get_content_list_by_label_result_params();
mcp_get_content_list_by_label_result_params& operator=(const mcp_get_content_list_by_label_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_label_result_params& assign(const mcp_get_content_list_by_label_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_content_list_by_label_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string content_list=out(),array(0,0);
inline bool has_content_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& content_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_content_list();
inline void clear_content_list();
// deprecated.use 'mutable_content_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_content_list();
// deprecated.use 'content_list().size()' instead.
inline size_t content_list_size() const;
inline const char* content_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_content_list_by_label_result_params& set_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_label_result_params& set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_content_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_label_result_params
class mcp_get_content_list_by_label_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_label_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_label_response* v);
explicit mcp_get_content_list_by_label_response(bsl::mempool* pool);
mcp_get_content_list_by_label_response(const mcp_get_content_list_by_label_response& v);
~mcp_get_content_list_by_label_response();
mcp_get_content_list_by_label_response& operator=(const mcp_get_content_list_by_label_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_label_response& assign(const mcp_get_content_list_by_label_response& v);
// @@mcp_get_content_list_by_label_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_list_by_label_result_params& result_params() const;
inline ::idl::mcp_get_content_list_by_label_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_list_by_label_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_list_by_label_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_label_response
class mcp_get_topic_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_topic_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_topic_info_params* v);
explicit mcp_get_topic_info_params(bsl::mempool* pool);
mcp_get_topic_info_params(const mcp_get_topic_info_params& v);
~mcp_get_topic_info_params();
mcp_get_topic_info_params& operator=(const mcp_get_topic_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_topic_info_params& assign(const mcp_get_topic_info_params& v);
// @@string content_type=in();
inline bool has_content_type() const;
inline const char* content_type(unsigned int* size=0) const;
inline mcp_get_topic_info_params& set_content_type(const char* s,ssize_t size=-1);
inline mcp_get_topic_info_params& set_ptr_content_type(const char* s,ssize_t size=-1);
inline void clear_content_type();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_topic_info_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_topic_info_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_content_type;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_topic_info_params
class mcp_get_topic_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_topic_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_topic_info_result_params* v);
explicit mcp_get_topic_info_result_params(bsl::mempool* pool);
mcp_get_topic_info_result_params(const mcp_get_topic_info_result_params& v);
~mcp_get_topic_info_result_params();
mcp_get_topic_info_result_params& operator=(const mcp_get_topic_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_topic_info_result_params& assign(const mcp_get_topic_info_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_topic_info_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string topic_list=out(),array(0,2);
inline bool has_topic_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& topic_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_topic_list();
inline void clear_topic_list();
// deprecated.use 'mutable_topic_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_topic_list();
// deprecated.use 'topic_list().size()' instead.
inline size_t topic_list_size() const;
inline const char* topic_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_topic_info_result_params& set_topic_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_topic_info_result_params& set_ptr_topic_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_topic_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_topic_info_result_params
class mcp_get_topic_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_topic_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_topic_info_response* v);
explicit mcp_get_topic_info_response(bsl::mempool* pool);
mcp_get_topic_info_response(const mcp_get_topic_info_response& v);
~mcp_get_topic_info_response();
mcp_get_topic_info_response& operator=(const mcp_get_topic_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_topic_info_response& assign(const mcp_get_topic_info_response& v);
// @@mcp_get_topic_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_topic_info_result_params& result_params() const;
inline ::idl::mcp_get_topic_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_topic_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_topic_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_topic_info_response
class mcp_get_content_count_by_class_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_count_by_class_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_count_by_class_params* v);
explicit mcp_get_content_count_by_class_params(bsl::mempool* pool);
mcp_get_content_count_by_class_params(const mcp_get_content_count_by_class_params& v);
~mcp_get_content_count_by_class_params();
mcp_get_content_count_by_class_params& operator=(const mcp_get_content_count_by_class_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_count_by_class_params& assign(const mcp_get_content_count_by_class_params& v);
// @@string class_id=in();
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_get_content_count_by_class_params& set_class_id(const char* s,ssize_t size=-1);
inline mcp_get_content_count_by_class_params& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_content_count_by_class_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_content_count_by_class_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@uint32_t info_type=in();
inline bool has_info_type() const;
inline uint32_t info_type() const;
inline mcp_get_content_count_by_class_params& set_info_type(uint32_t v);
inline void clear_info_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_class_id;
 ::idl::string _m_info_id;
 uint32_t _m_info_type;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_count_by_class_params
class mcp_get_content_count_by_class_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_count_by_class_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_count_by_class_result_params* v);
explicit mcp_get_content_count_by_class_result_params(bsl::mempool* pool);
mcp_get_content_count_by_class_result_params(const mcp_get_content_count_by_class_result_params& v);
~mcp_get_content_count_by_class_result_params();
mcp_get_content_count_by_class_result_params& operator=(const mcp_get_content_count_by_class_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_count_by_class_result_params& assign(const mcp_get_content_count_by_class_result_params& v);
// @@int32_t count=out(),array(0);
inline bool has_count() const;
inline const ::idl::vector< int32_t >& count() const;
inline ::idl::vector< int32_t >* mutable_count();
inline void clear_count();
// deprecated.use 'mutable_count' instead.
inline ::idl::vector< int32_t >* m_count();
// deprecated.use 'count().size()' instead.
inline size_t count_size() const;
inline int32_t count(size_t i0) const;
inline mcp_get_content_count_by_class_result_params& set_count(size_t i0,int32_t v);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::vector< int32_t > _m_count;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_count_by_class_result_params
class mcp_get_content_count_by_class_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_count_by_class_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_count_by_class_response* v);
explicit mcp_get_content_count_by_class_response(bsl::mempool* pool);
mcp_get_content_count_by_class_response(const mcp_get_content_count_by_class_response& v);
~mcp_get_content_count_by_class_response();
mcp_get_content_count_by_class_response& operator=(const mcp_get_content_count_by_class_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_count_by_class_response& assign(const mcp_get_content_count_by_class_response& v);
// @@mcp_get_content_count_by_class_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_count_by_class_result_params& result_params() const;
inline ::idl::mcp_get_content_count_by_class_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_count_by_class_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_count_by_class_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_count_by_class_response
class mcp_get_content_img_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_img_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_img_params* v);
explicit mcp_get_content_img_params(bsl::mempool* pool);
mcp_get_content_img_params(const mcp_get_content_img_params& v);
~mcp_get_content_img_params();
mcp_get_content_img_params& operator=(const mcp_get_content_img_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_img_params& assign(const mcp_get_content_img_params& v);
// @@string content_id=in();
inline bool has_content_id() const;
inline const char* content_id(unsigned int* size=0) const;
inline mcp_get_content_img_params& set_content_id(const char* s,ssize_t size=-1);
inline mcp_get_content_img_params& set_ptr_content_id(const char* s,ssize_t size=-1);
inline void clear_content_id();
// @@uint32_t img_type=in();
inline bool has_img_type() const;
inline uint32_t img_type() const;
inline mcp_get_content_img_params& set_img_type(uint32_t v);
inline void clear_img_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_content_id;
 uint32_t _m_img_type;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_img_params
class mcp_get_content_img_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_img_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_img_result_params* v);
explicit mcp_get_content_img_result_params(bsl::mempool* pool);
mcp_get_content_img_result_params(const mcp_get_content_img_result_params& v);
~mcp_get_content_img_result_params();
mcp_get_content_img_result_params& operator=(const mcp_get_content_img_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_img_result_params& assign(const mcp_get_content_img_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_content_img_result_params& set_count(int32_t v);
inline void clear_count();
// @@string img_url=out(),array(0);
inline bool has_img_url() const;
inline const ::idl::vector< ::idl::string >& img_url() const;
inline ::idl::vector< ::idl::string >* mutable_img_url();
inline void clear_img_url();
// deprecated.use 'mutable_img_url' instead.
inline ::idl::vector< ::idl::string >* m_img_url();
// deprecated.use 'img_url().size()' instead.
inline size_t img_url_size() const;
inline const char* img_url(size_t i0,unsigned int* size=0) const;
inline mcp_get_content_img_result_params& set_img_url(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_content_img_result_params& set_ptr_img_url(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::string > _m_img_url;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_img_result_params
class mcp_get_content_img_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_img_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_img_response* v);
explicit mcp_get_content_img_response(bsl::mempool* pool);
mcp_get_content_img_response(const mcp_get_content_img_response& v);
~mcp_get_content_img_response();
mcp_get_content_img_response& operator=(const mcp_get_content_img_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_img_response& assign(const mcp_get_content_img_response& v);
// @@mcp_get_content_img_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_img_result_params& result_params() const;
inline ::idl::mcp_get_content_img_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_img_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_img_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_img_response
class mcp_get_label_name_by_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_label_name_by_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_label_name_by_id_params* v);
explicit mcp_get_label_name_by_id_params(bsl::mempool* pool);
mcp_get_label_name_by_id_params(const mcp_get_label_name_by_id_params& v);
~mcp_get_label_name_by_id_params();
mcp_get_label_name_by_id_params& operator=(const mcp_get_label_name_by_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_label_name_by_id_params& assign(const mcp_get_label_name_by_id_params& v);
// @@string label_id=in();
inline bool has_label_id() const;
inline const char* label_id(unsigned int* size=0) const;
inline mcp_get_label_name_by_id_params& set_label_id(const char* s,ssize_t size=-1);
inline mcp_get_label_name_by_id_params& set_ptr_label_id(const char* s,ssize_t size=-1);
inline void clear_label_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_label_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_label_name_by_id_params
class mcp_get_label_name_by_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_label_name_by_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_label_name_by_id_result_params* v);
explicit mcp_get_label_name_by_id_result_params(bsl::mempool* pool);
mcp_get_label_name_by_id_result_params(const mcp_get_label_name_by_id_result_params& v);
~mcp_get_label_name_by_id_result_params();
mcp_get_label_name_by_id_result_params& operator=(const mcp_get_label_name_by_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_label_name_by_id_result_params& assign(const mcp_get_label_name_by_id_result_params& v);
// @@string label_name=out();
inline bool has_label_name() const;
inline const char* label_name(unsigned int* size=0) const;
inline mcp_get_label_name_by_id_result_params& set_label_name(const char* s,ssize_t size=-1);
inline mcp_get_label_name_by_id_result_params& set_ptr_label_name(const char* s,ssize_t size=-1);
inline void clear_label_name();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_label_name;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_label_name_by_id_result_params
class mcp_get_label_name_by_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_label_name_by_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_label_name_by_id_response* v);
explicit mcp_get_label_name_by_id_response(bsl::mempool* pool);
mcp_get_label_name_by_id_response(const mcp_get_label_name_by_id_response& v);
~mcp_get_label_name_by_id_response();
mcp_get_label_name_by_id_response& operator=(const mcp_get_label_name_by_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_label_name_by_id_response& assign(const mcp_get_label_name_by_id_response& v);
// @@mcp_get_label_name_by_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_label_name_by_id_result_params& result_params() const;
inline ::idl::mcp_get_label_name_by_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_label_name_by_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_label_name_by_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_label_name_by_id_response
class mcp_get_content_list_by_date_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_date_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_date_params* v);
explicit mcp_get_content_list_by_date_params(bsl::mempool* pool);
mcp_get_content_list_by_date_params(const mcp_get_content_list_by_date_params& v);
~mcp_get_content_list_by_date_params();
mcp_get_content_list_by_date_params& operator=(const mcp_get_content_list_by_date_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_date_params& assign(const mcp_get_content_list_by_date_params& v);
// @@string content_type=in();
inline bool has_content_type() const;
inline const char* content_type(unsigned int* size=0) const;
inline mcp_get_content_list_by_date_params& set_content_type(const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_date_params& set_ptr_content_type(const char* s,ssize_t size=-1);
inline void clear_content_type();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_content_list_by_date_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_content_list_by_date_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_content_list_by_date_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_date_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@uint32_t info_type=in();
inline bool has_info_type() const;
inline uint32_t info_type() const;
inline mcp_get_content_list_by_date_params& set_info_type(uint32_t v);
inline void clear_info_type();
// @@uint32_t for_adapt=in();
inline bool has_for_adapt() const;
inline uint32_t for_adapt() const;
inline mcp_get_content_list_by_date_params& set_for_adapt(uint32_t v);
inline void clear_for_adapt();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_content_type;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
 ::idl::string _m_info_id;
 uint32_t _m_info_type;
 uint32_t _m_for_adapt;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_date_params
class mcp_get_content_list_by_date_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_date_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_date_result_params* v);
explicit mcp_get_content_list_by_date_result_params(bsl::mempool* pool);
mcp_get_content_list_by_date_result_params(const mcp_get_content_list_by_date_result_params& v);
~mcp_get_content_list_by_date_result_params();
mcp_get_content_list_by_date_result_params& operator=(const mcp_get_content_list_by_date_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_date_result_params& assign(const mcp_get_content_list_by_date_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_get_content_list_by_date_result_params& set_result(int32_t v);
inline void clear_result();
// @@string content_list=out(),array(0,0);
inline bool has_content_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& content_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_content_list();
inline void clear_content_list();
// deprecated.use 'mutable_content_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_content_list();
// deprecated.use 'content_list().size()' instead.
inline size_t content_list_size() const;
inline const char* content_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_content_list_by_date_result_params& set_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_date_result_params& set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_content_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_date_result_params
class mcp_get_content_list_by_date_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_date_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_date_response* v);
explicit mcp_get_content_list_by_date_response(bsl::mempool* pool);
mcp_get_content_list_by_date_response(const mcp_get_content_list_by_date_response& v);
~mcp_get_content_list_by_date_response();
mcp_get_content_list_by_date_response& operator=(const mcp_get_content_list_by_date_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_date_response& assign(const mcp_get_content_list_by_date_response& v);
// @@mcp_get_content_list_by_date_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_list_by_date_result_params& result_params() const;
inline ::idl::mcp_get_content_list_by_date_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_list_by_date_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_list_by_date_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_date_response
class mcp_get_soft_info_by_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_soft_info_by_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_soft_info_by_id_params* v);
explicit mcp_get_soft_info_by_id_params(bsl::mempool* pool);
mcp_get_soft_info_by_id_params(const mcp_get_soft_info_by_id_params& v);
~mcp_get_soft_info_by_id_params();
mcp_get_soft_info_by_id_params& operator=(const mcp_get_soft_info_by_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_soft_info_by_id_params& assign(const mcp_get_soft_info_by_id_params& v);
// @@string soft_id=in();
inline bool has_soft_id() const;
inline const char* soft_id(unsigned int* size=0) const;
inline mcp_get_soft_info_by_id_params& set_soft_id(const char* s,ssize_t size=-1);
inline mcp_get_soft_info_by_id_params& set_ptr_soft_id(const char* s,ssize_t size=-1);
inline void clear_soft_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_soft_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_soft_info_by_id_params
class mcp_get_soft_info_by_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_soft_info_by_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_soft_info_by_id_result_params* v);
explicit mcp_get_soft_info_by_id_result_params(bsl::mempool* pool);
mcp_get_soft_info_by_id_result_params(const mcp_get_soft_info_by_id_result_params& v);
~mcp_get_soft_info_by_id_result_params();
mcp_get_soft_info_by_id_result_params& operator=(const mcp_get_soft_info_by_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_soft_info_by_id_result_params& assign(const mcp_get_soft_info_by_id_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_get_soft_info_by_id_result_params& set_result(int32_t v);
inline void clear_result();
// @@string soft_info=out(),array(0);
inline bool has_soft_info() const;
inline const ::idl::vector< ::idl::string >& soft_info() const;
inline ::idl::vector< ::idl::string >* mutable_soft_info();
inline void clear_soft_info();
// deprecated.use 'mutable_soft_info' instead.
inline ::idl::vector< ::idl::string >* m_soft_info();
// deprecated.use 'soft_info().size()' instead.
inline size_t soft_info_size() const;
inline const char* soft_info(size_t i0,unsigned int* size=0) const;
inline mcp_get_soft_info_by_id_result_params& set_soft_info(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_soft_info_by_id_result_params& set_ptr_soft_info(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
 ::idl::vector< ::idl::string > _m_soft_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_soft_info_by_id_result_params
class mcp_get_soft_info_by_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_soft_info_by_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_soft_info_by_id_response* v);
explicit mcp_get_soft_info_by_id_response(bsl::mempool* pool);
mcp_get_soft_info_by_id_response(const mcp_get_soft_info_by_id_response& v);
~mcp_get_soft_info_by_id_response();
mcp_get_soft_info_by_id_response& operator=(const mcp_get_soft_info_by_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_soft_info_by_id_response& assign(const mcp_get_soft_info_by_id_response& v);
// @@mcp_get_soft_info_by_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_soft_info_by_id_result_params& result_params() const;
inline ::idl::mcp_get_soft_info_by_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_soft_info_by_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_soft_info_by_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_soft_info_by_id_response
class mcp_get_android_theme_by_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_android_theme_by_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_android_theme_by_id_params* v);
explicit mcp_get_android_theme_by_id_params(bsl::mempool* pool);
mcp_get_android_theme_by_id_params(const mcp_get_android_theme_by_id_params& v);
~mcp_get_android_theme_by_id_params();
mcp_get_android_theme_by_id_params& operator=(const mcp_get_android_theme_by_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_android_theme_by_id_params& assign(const mcp_get_android_theme_by_id_params& v);
// @@string id=in();
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline mcp_get_android_theme_by_id_params& set_id(const char* s,ssize_t size=-1);
inline mcp_get_android_theme_by_id_params& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_android_theme_by_id_params
class mcp_get_android_theme_by_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_android_theme_by_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_android_theme_by_id_result_params* v);
explicit mcp_get_android_theme_by_id_result_params(bsl::mempool* pool);
mcp_get_android_theme_by_id_result_params(const mcp_get_android_theme_by_id_result_params& v);
~mcp_get_android_theme_by_id_result_params();
mcp_get_android_theme_by_id_result_params& operator=(const mcp_get_android_theme_by_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_android_theme_by_id_result_params& assign(const mcp_get_android_theme_by_id_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_get_android_theme_by_id_result_params& set_result(int32_t v);
inline void clear_result();
// @@string info=out(),array(0);
inline bool has_info() const;
inline const ::idl::vector< ::idl::string >& info() const;
inline ::idl::vector< ::idl::string >* mutable_info();
inline void clear_info();
// deprecated.use 'mutable_info' instead.
inline ::idl::vector< ::idl::string >* m_info();
// deprecated.use 'info().size()' instead.
inline size_t info_size() const;
inline const char* info(size_t i0,unsigned int* size=0) const;
inline mcp_get_android_theme_by_id_result_params& set_info(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_android_theme_by_id_result_params& set_ptr_info(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
 ::idl::vector< ::idl::string > _m_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_android_theme_by_id_result_params
class mcp_get_android_theme_by_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_android_theme_by_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_android_theme_by_id_response* v);
explicit mcp_get_android_theme_by_id_response(bsl::mempool* pool);
mcp_get_android_theme_by_id_response(const mcp_get_android_theme_by_id_response& v);
~mcp_get_android_theme_by_id_response();
mcp_get_android_theme_by_id_response& operator=(const mcp_get_android_theme_by_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_android_theme_by_id_response& assign(const mcp_get_android_theme_by_id_response& v);
// @@mcp_get_android_theme_by_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_android_theme_by_id_result_params& result_params() const;
inline ::idl::mcp_get_android_theme_by_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_android_theme_by_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_android_theme_by_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_android_theme_by_id_response
class mcp_get_mcp_stat_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_mcp_stat_params* create(bsl::mempool* pool);
static void destroy(mcp_get_mcp_stat_params* v);
explicit mcp_get_mcp_stat_params(bsl::mempool* pool);
mcp_get_mcp_stat_params(const mcp_get_mcp_stat_params& v);
~mcp_get_mcp_stat_params();
mcp_get_mcp_stat_params& operator=(const mcp_get_mcp_stat_params& v);
void clear();
void check() const;
void detach();
mcp_get_mcp_stat_params& assign(const mcp_get_mcp_stat_params& v);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::Unknown _unknown;
char _flag[0];
}; // class mcp_get_mcp_stat_params
class mcp_get_mcp_stat_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_mcp_stat_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_mcp_stat_result_params* v);
explicit mcp_get_mcp_stat_result_params(bsl::mempool* pool);
mcp_get_mcp_stat_result_params(const mcp_get_mcp_stat_result_params& v);
~mcp_get_mcp_stat_result_params();
mcp_get_mcp_stat_result_params& operator=(const mcp_get_mcp_stat_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_mcp_stat_result_params& assign(const mcp_get_mcp_stat_result_params& v);
// @@int32_t stat=out(),array(0);
inline bool has_stat() const;
inline const ::idl::vector< int32_t >& stat() const;
inline ::idl::vector< int32_t >* mutable_stat();
inline void clear_stat();
// deprecated.use 'mutable_stat' instead.
inline ::idl::vector< int32_t >* m_stat();
// deprecated.use 'stat().size()' instead.
inline size_t stat_size() const;
inline int32_t stat(size_t i0) const;
inline mcp_get_mcp_stat_result_params& set_stat(size_t i0,int32_t v);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::vector< int32_t > _m_stat;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_mcp_stat_result_params
class mcp_get_mcp_stat_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_mcp_stat_response* create(bsl::mempool* pool);
static void destroy(mcp_get_mcp_stat_response* v);
explicit mcp_get_mcp_stat_response(bsl::mempool* pool);
mcp_get_mcp_stat_response(const mcp_get_mcp_stat_response& v);
~mcp_get_mcp_stat_response();
mcp_get_mcp_stat_response& operator=(const mcp_get_mcp_stat_response& v);
void clear();
void check() const;
void detach();
mcp_get_mcp_stat_response& assign(const mcp_get_mcp_stat_response& v);
// @@mcp_get_mcp_stat_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_mcp_stat_result_params& result_params() const;
inline ::idl::mcp_get_mcp_stat_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_mcp_stat_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_mcp_stat_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_mcp_stat_response
class mcp_get_col_list_by_topic_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_col_list_by_topic_params* create(bsl::mempool* pool);
static void destroy(mcp_get_col_list_by_topic_params* v);
explicit mcp_get_col_list_by_topic_params(bsl::mempool* pool);
mcp_get_col_list_by_topic_params(const mcp_get_col_list_by_topic_params& v);
~mcp_get_col_list_by_topic_params();
mcp_get_col_list_by_topic_params& operator=(const mcp_get_col_list_by_topic_params& v);
void clear();
void check() const;
void detach();
mcp_get_col_list_by_topic_params& assign(const mcp_get_col_list_by_topic_params& v);
// @@string topic_id=in();
inline bool has_topic_id() const;
inline const char* topic_id(unsigned int* size=0) const;
inline mcp_get_col_list_by_topic_params& set_topic_id(const char* s,ssize_t size=-1);
inline mcp_get_col_list_by_topic_params& set_ptr_topic_id(const char* s,ssize_t size=-1);
inline void clear_topic_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_col_list_by_topic_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_col_list_by_topic_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_topic_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_col_list_by_topic_params
class mcp_get_col_list_by_topic_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_col_list_by_topic_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_col_list_by_topic_result_params* v);
explicit mcp_get_col_list_by_topic_result_params(bsl::mempool* pool);
mcp_get_col_list_by_topic_result_params(const mcp_get_col_list_by_topic_result_params& v);
~mcp_get_col_list_by_topic_result_params();
mcp_get_col_list_by_topic_result_params& operator=(const mcp_get_col_list_by_topic_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_col_list_by_topic_result_params& assign(const mcp_get_col_list_by_topic_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_col_list_by_topic_result_params& set_count(int32_t v);
inline void clear_count();
// @@string topic_name=out();
inline bool has_topic_name() const;
inline const char* topic_name(unsigned int* size=0) const;
inline mcp_get_col_list_by_topic_result_params& set_topic_name(const char* s,ssize_t size=-1);
inline mcp_get_col_list_by_topic_result_params& set_ptr_topic_name(const char* s,ssize_t size=-1);
inline void clear_topic_name();
// @@string topic_img=out();
inline bool has_topic_img() const;
inline const char* topic_img(unsigned int* size=0) const;
inline mcp_get_col_list_by_topic_result_params& set_topic_img(const char* s,ssize_t size=-1);
inline mcp_get_col_list_by_topic_result_params& set_ptr_topic_img(const char* s,ssize_t size=-1);
inline void clear_topic_img();
// @@string topic_intro=out();
inline bool has_topic_intro() const;
inline const char* topic_intro(unsigned int* size=0) const;
inline mcp_get_col_list_by_topic_result_params& set_topic_intro(const char* s,ssize_t size=-1);
inline mcp_get_col_list_by_topic_result_params& set_ptr_topic_intro(const char* s,ssize_t size=-1);
inline void clear_topic_intro();
// @@string log_date=out();
inline bool has_log_date() const;
inline const char* log_date(unsigned int* size=0) const;
inline mcp_get_col_list_by_topic_result_params& set_log_date(const char* s,ssize_t size=-1);
inline mcp_get_col_list_by_topic_result_params& set_ptr_log_date(const char* s,ssize_t size=-1);
inline void clear_log_date();
// @@string before_topic=out();
inline bool has_before_topic() const;
inline const char* before_topic(unsigned int* size=0) const;
inline mcp_get_col_list_by_topic_result_params& set_before_topic(const char* s,ssize_t size=-1);
inline mcp_get_col_list_by_topic_result_params& set_ptr_before_topic(const char* s,ssize_t size=-1);
inline void clear_before_topic();
// @@string before_name=out();
inline bool has_before_name() const;
inline const char* before_name(unsigned int* size=0) const;
inline mcp_get_col_list_by_topic_result_params& set_before_name(const char* s,ssize_t size=-1);
inline mcp_get_col_list_by_topic_result_params& set_ptr_before_name(const char* s,ssize_t size=-1);
inline void clear_before_name();
// @@string next_topic=out();
inline bool has_next_topic() const;
inline const char* next_topic(unsigned int* size=0) const;
inline mcp_get_col_list_by_topic_result_params& set_next_topic(const char* s,ssize_t size=-1);
inline mcp_get_col_list_by_topic_result_params& set_ptr_next_topic(const char* s,ssize_t size=-1);
inline void clear_next_topic();
// @@string next_name=out();
inline bool has_next_name() const;
inline const char* next_name(unsigned int* size=0) const;
inline mcp_get_col_list_by_topic_result_params& set_next_name(const char* s,ssize_t size=-1);
inline mcp_get_col_list_by_topic_result_params& set_ptr_next_name(const char* s,ssize_t size=-1);
inline void clear_next_name();
// @@string col_id_list=out(),array(0);
inline bool has_col_id_list() const;
inline const ::idl::vector< ::idl::string >& col_id_list() const;
inline ::idl::vector< ::idl::string >* mutable_col_id_list();
inline void clear_col_id_list();
// deprecated.use 'mutable_col_id_list' instead.
inline ::idl::vector< ::idl::string >* m_col_id_list();
// deprecated.use 'col_id_list().size()' instead.
inline size_t col_id_list_size() const;
inline const char* col_id_list(size_t i0,unsigned int* size=0) const;
inline mcp_get_col_list_by_topic_result_params& set_col_id_list(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_col_list_by_topic_result_params& set_ptr_col_id_list(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::string _m_topic_name;
 ::idl::string _m_topic_img;
 ::idl::string _m_topic_intro;
 ::idl::string _m_log_date;
 ::idl::string _m_before_topic;
 ::idl::string _m_before_name;
 ::idl::string _m_next_topic;
 ::idl::string _m_next_name;
 ::idl::vector< ::idl::string > _m_col_id_list;
mutable ::idl::Unknown _unknown;
char _flag[2];
}; // class mcp_get_col_list_by_topic_result_params
class mcp_get_col_list_by_topic_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_col_list_by_topic_response* create(bsl::mempool* pool);
static void destroy(mcp_get_col_list_by_topic_response* v);
explicit mcp_get_col_list_by_topic_response(bsl::mempool* pool);
mcp_get_col_list_by_topic_response(const mcp_get_col_list_by_topic_response& v);
~mcp_get_col_list_by_topic_response();
mcp_get_col_list_by_topic_response& operator=(const mcp_get_col_list_by_topic_response& v);
void clear();
void check() const;
void detach();
mcp_get_col_list_by_topic_response& assign(const mcp_get_col_list_by_topic_response& v);
// @@mcp_get_col_list_by_topic_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_col_list_by_topic_result_params& result_params() const;
inline ::idl::mcp_get_col_list_by_topic_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_col_list_by_topic_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_col_list_by_topic_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_col_list_by_topic_response
class mcp_get_soft_list_by_col_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_soft_list_by_col_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_soft_list_by_col_id_params* v);
explicit mcp_get_soft_list_by_col_id_params(bsl::mempool* pool);
mcp_get_soft_list_by_col_id_params(const mcp_get_soft_list_by_col_id_params& v);
~mcp_get_soft_list_by_col_id_params();
mcp_get_soft_list_by_col_id_params& operator=(const mcp_get_soft_list_by_col_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_soft_list_by_col_id_params& assign(const mcp_get_soft_list_by_col_id_params& v);
// @@string col_id=in();
inline bool has_col_id() const;
inline const char* col_id(unsigned int* size=0) const;
inline mcp_get_soft_list_by_col_id_params& set_col_id(const char* s,ssize_t size=-1);
inline mcp_get_soft_list_by_col_id_params& set_ptr_col_id(const char* s,ssize_t size=-1);
inline void clear_col_id();
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_soft_list_by_col_id_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_soft_list_by_col_id_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_soft_list_by_col_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_soft_list_by_col_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_col_id;
 ::idl::string _m_type_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_soft_list_by_col_id_params
class mcp_get_soft_list_by_col_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_soft_list_by_col_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_soft_list_by_col_id_result_params* v);
explicit mcp_get_soft_list_by_col_id_result_params(bsl::mempool* pool);
mcp_get_soft_list_by_col_id_result_params(const mcp_get_soft_list_by_col_id_result_params& v);
~mcp_get_soft_list_by_col_id_result_params();
mcp_get_soft_list_by_col_id_result_params& operator=(const mcp_get_soft_list_by_col_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_soft_list_by_col_id_result_params& assign(const mcp_get_soft_list_by_col_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_soft_list_by_col_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@string col_name=out();
inline bool has_col_name() const;
inline const char* col_name(unsigned int* size=0) const;
inline mcp_get_soft_list_by_col_id_result_params& set_col_name(const char* s,ssize_t size=-1);
inline mcp_get_soft_list_by_col_id_result_params& set_ptr_col_name(const char* s,ssize_t size=-1);
inline void clear_col_name();
// @@string soft_list=out(),array(0,0);
inline bool has_soft_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& soft_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_soft_list();
inline void clear_soft_list();
// deprecated.use 'mutable_soft_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_soft_list();
// deprecated.use 'soft_list().size()' instead.
inline size_t soft_list_size() const;
inline const char* soft_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_soft_list_by_col_id_result_params& set_soft_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_soft_list_by_col_id_result_params& set_ptr_soft_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::string _m_col_name;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_soft_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_soft_list_by_col_id_result_params
class mcp_get_soft_list_by_col_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_soft_list_by_col_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_soft_list_by_col_id_response* v);
explicit mcp_get_soft_list_by_col_id_response(bsl::mempool* pool);
mcp_get_soft_list_by_col_id_response(const mcp_get_soft_list_by_col_id_response& v);
~mcp_get_soft_list_by_col_id_response();
mcp_get_soft_list_by_col_id_response& operator=(const mcp_get_soft_list_by_col_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_soft_list_by_col_id_response& assign(const mcp_get_soft_list_by_col_id_response& v);
// @@mcp_get_soft_list_by_col_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_soft_list_by_col_id_result_params& result_params() const;
inline ::idl::mcp_get_soft_list_by_col_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_soft_list_by_col_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_soft_list_by_col_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_soft_list_by_col_id_response
class mcp_get_soft_list_by_class_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_soft_list_by_class_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_soft_list_by_class_id_params* v);
explicit mcp_get_soft_list_by_class_id_params(bsl::mempool* pool);
mcp_get_soft_list_by_class_id_params(const mcp_get_soft_list_by_class_id_params& v);
~mcp_get_soft_list_by_class_id_params();
mcp_get_soft_list_by_class_id_params& operator=(const mcp_get_soft_list_by_class_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_soft_list_by_class_id_params& assign(const mcp_get_soft_list_by_class_id_params& v);
// @@string class_id=in();
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_get_soft_list_by_class_id_params& set_class_id(const char* s,ssize_t size=-1);
inline mcp_get_soft_list_by_class_id_params& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_soft_list_by_class_id_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_soft_list_by_class_id_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t orderby=in();
inline bool has_orderby() const;
inline uint32_t orderby() const;
inline mcp_get_soft_list_by_class_id_params& set_orderby(uint32_t v);
inline void clear_orderby();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_soft_list_by_class_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_soft_list_by_class_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_class_id;
 ::idl::string _m_type_id;
 uint32_t _m_orderby;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_soft_list_by_class_id_params
class mcp_get_soft_list_by_class_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_soft_list_by_class_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_soft_list_by_class_id_result_params* v);
explicit mcp_get_soft_list_by_class_id_result_params(bsl::mempool* pool);
mcp_get_soft_list_by_class_id_result_params(const mcp_get_soft_list_by_class_id_result_params& v);
~mcp_get_soft_list_by_class_id_result_params();
mcp_get_soft_list_by_class_id_result_params& operator=(const mcp_get_soft_list_by_class_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_soft_list_by_class_id_result_params& assign(const mcp_get_soft_list_by_class_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_soft_list_by_class_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@string class_name=out();
inline bool has_class_name() const;
inline const char* class_name(unsigned int* size=0) const;
inline mcp_get_soft_list_by_class_id_result_params& set_class_name(const char* s,ssize_t size=-1);
inline mcp_get_soft_list_by_class_id_result_params& set_ptr_class_name(const char* s,ssize_t size=-1);
inline void clear_class_name();
// @@string class_icon=out();
inline bool has_class_icon() const;
inline const char* class_icon(unsigned int* size=0) const;
inline mcp_get_soft_list_by_class_id_result_params& set_class_icon(const char* s,ssize_t size=-1);
inline mcp_get_soft_list_by_class_id_result_params& set_ptr_class_icon(const char* s,ssize_t size=-1);
inline void clear_class_icon();
// @@string soft_list=out(),array(0,0);
inline bool has_soft_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& soft_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_soft_list();
inline void clear_soft_list();
// deprecated.use 'mutable_soft_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_soft_list();
// deprecated.use 'soft_list().size()' instead.
inline size_t soft_list_size() const;
inline const char* soft_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_soft_list_by_class_id_result_params& set_soft_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_soft_list_by_class_id_result_params& set_ptr_soft_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::string _m_class_name;
 ::idl::string _m_class_icon;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_soft_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_soft_list_by_class_id_result_params
class mcp_get_soft_list_by_class_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_soft_list_by_class_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_soft_list_by_class_id_response* v);
explicit mcp_get_soft_list_by_class_id_response(bsl::mempool* pool);
mcp_get_soft_list_by_class_id_response(const mcp_get_soft_list_by_class_id_response& v);
~mcp_get_soft_list_by_class_id_response();
mcp_get_soft_list_by_class_id_response& operator=(const mcp_get_soft_list_by_class_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_soft_list_by_class_id_response& assign(const mcp_get_soft_list_by_class_id_response& v);
// @@mcp_get_soft_list_by_class_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_soft_list_by_class_id_result_params& result_params() const;
inline ::idl::mcp_get_soft_list_by_class_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_soft_list_by_class_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_soft_list_by_class_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_soft_list_by_class_id_response
class mcp_get_android_theme_by_col_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_android_theme_by_col_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_android_theme_by_col_id_params* v);
explicit mcp_get_android_theme_by_col_id_params(bsl::mempool* pool);
mcp_get_android_theme_by_col_id_params(const mcp_get_android_theme_by_col_id_params& v);
~mcp_get_android_theme_by_col_id_params();
mcp_get_android_theme_by_col_id_params& operator=(const mcp_get_android_theme_by_col_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_android_theme_by_col_id_params& assign(const mcp_get_android_theme_by_col_id_params& v);
// @@string col_id=in();
inline bool has_col_id() const;
inline const char* col_id(unsigned int* size=0) const;
inline mcp_get_android_theme_by_col_id_params& set_col_id(const char* s,ssize_t size=-1);
inline mcp_get_android_theme_by_col_id_params& set_ptr_col_id(const char* s,ssize_t size=-1);
inline void clear_col_id();
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_android_theme_by_col_id_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_android_theme_by_col_id_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_android_theme_by_col_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_android_theme_by_col_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_col_id;
 ::idl::string _m_type_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_android_theme_by_col_id_params
class mcp_get_android_theme_by_col_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_android_theme_by_col_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_android_theme_by_col_id_result_params* v);
explicit mcp_get_android_theme_by_col_id_result_params(bsl::mempool* pool);
mcp_get_android_theme_by_col_id_result_params(const mcp_get_android_theme_by_col_id_result_params& v);
~mcp_get_android_theme_by_col_id_result_params();
mcp_get_android_theme_by_col_id_result_params& operator=(const mcp_get_android_theme_by_col_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_android_theme_by_col_id_result_params& assign(const mcp_get_android_theme_by_col_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_android_theme_by_col_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@string col_name=out();
inline bool has_col_name() const;
inline const char* col_name(unsigned int* size=0) const;
inline mcp_get_android_theme_by_col_id_result_params& set_col_name(const char* s,ssize_t size=-1);
inline mcp_get_android_theme_by_col_id_result_params& set_ptr_col_name(const char* s,ssize_t size=-1);
inline void clear_col_name();
// @@string theme_list=out(),array(0,0);
inline bool has_theme_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& theme_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_theme_list();
inline void clear_theme_list();
// deprecated.use 'mutable_theme_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_theme_list();
// deprecated.use 'theme_list().size()' instead.
inline size_t theme_list_size() const;
inline const char* theme_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_android_theme_by_col_id_result_params& set_theme_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_android_theme_by_col_id_result_params& set_ptr_theme_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::string _m_col_name;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_theme_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_android_theme_by_col_id_result_params
class mcp_get_android_theme_by_col_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_android_theme_by_col_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_android_theme_by_col_id_response* v);
explicit mcp_get_android_theme_by_col_id_response(bsl::mempool* pool);
mcp_get_android_theme_by_col_id_response(const mcp_get_android_theme_by_col_id_response& v);
~mcp_get_android_theme_by_col_id_response();
mcp_get_android_theme_by_col_id_response& operator=(const mcp_get_android_theme_by_col_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_android_theme_by_col_id_response& assign(const mcp_get_android_theme_by_col_id_response& v);
// @@mcp_get_android_theme_by_col_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_android_theme_by_col_id_result_params& result_params() const;
inline ::idl::mcp_get_android_theme_by_col_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_android_theme_by_col_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_android_theme_by_col_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_android_theme_by_col_id_response
class mcp_get_android_theme_by_class_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_android_theme_by_class_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_android_theme_by_class_id_params* v);
explicit mcp_get_android_theme_by_class_id_params(bsl::mempool* pool);
mcp_get_android_theme_by_class_id_params(const mcp_get_android_theme_by_class_id_params& v);
~mcp_get_android_theme_by_class_id_params();
mcp_get_android_theme_by_class_id_params& operator=(const mcp_get_android_theme_by_class_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_android_theme_by_class_id_params& assign(const mcp_get_android_theme_by_class_id_params& v);
// @@string class_id=in();
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_get_android_theme_by_class_id_params& set_class_id(const char* s,ssize_t size=-1);
inline mcp_get_android_theme_by_class_id_params& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_android_theme_by_class_id_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_android_theme_by_class_id_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t orderby=in();
inline bool has_orderby() const;
inline uint32_t orderby() const;
inline mcp_get_android_theme_by_class_id_params& set_orderby(uint32_t v);
inline void clear_orderby();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_android_theme_by_class_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_android_theme_by_class_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_class_id;
 ::idl::string _m_type_id;
 uint32_t _m_orderby;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_android_theme_by_class_id_params
class mcp_get_android_theme_by_class_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_android_theme_by_class_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_android_theme_by_class_id_result_params* v);
explicit mcp_get_android_theme_by_class_id_result_params(bsl::mempool* pool);
mcp_get_android_theme_by_class_id_result_params(const mcp_get_android_theme_by_class_id_result_params& v);
~mcp_get_android_theme_by_class_id_result_params();
mcp_get_android_theme_by_class_id_result_params& operator=(const mcp_get_android_theme_by_class_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_android_theme_by_class_id_result_params& assign(const mcp_get_android_theme_by_class_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_android_theme_by_class_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@string class_name=out();
inline bool has_class_name() const;
inline const char* class_name(unsigned int* size=0) const;
inline mcp_get_android_theme_by_class_id_result_params& set_class_name(const char* s,ssize_t size=-1);
inline mcp_get_android_theme_by_class_id_result_params& set_ptr_class_name(const char* s,ssize_t size=-1);
inline void clear_class_name();
// @@string class_icon=out();
inline bool has_class_icon() const;
inline const char* class_icon(unsigned int* size=0) const;
inline mcp_get_android_theme_by_class_id_result_params& set_class_icon(const char* s,ssize_t size=-1);
inline mcp_get_android_theme_by_class_id_result_params& set_ptr_class_icon(const char* s,ssize_t size=-1);
inline void clear_class_icon();
// @@string theme_list=out(),array(0,0);
inline bool has_theme_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& theme_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_theme_list();
inline void clear_theme_list();
// deprecated.use 'mutable_theme_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_theme_list();
// deprecated.use 'theme_list().size()' instead.
inline size_t theme_list_size() const;
inline const char* theme_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_android_theme_by_class_id_result_params& set_theme_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_android_theme_by_class_id_result_params& set_ptr_theme_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::string _m_class_name;
 ::idl::string _m_class_icon;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_theme_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_android_theme_by_class_id_result_params
class mcp_get_android_theme_by_class_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_android_theme_by_class_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_android_theme_by_class_id_response* v);
explicit mcp_get_android_theme_by_class_id_response(bsl::mempool* pool);
mcp_get_android_theme_by_class_id_response(const mcp_get_android_theme_by_class_id_response& v);
~mcp_get_android_theme_by_class_id_response();
mcp_get_android_theme_by_class_id_response& operator=(const mcp_get_android_theme_by_class_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_android_theme_by_class_id_response& assign(const mcp_get_android_theme_by_class_id_response& v);
// @@mcp_get_android_theme_by_class_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_android_theme_by_class_id_result_params& result_params() const;
inline ::idl::mcp_get_android_theme_by_class_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_android_theme_by_class_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_android_theme_by_class_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_android_theme_by_class_id_response
class mcp_get_topic_list_by_type_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_topic_list_by_type_params* create(bsl::mempool* pool);
static void destroy(mcp_get_topic_list_by_type_params* v);
explicit mcp_get_topic_list_by_type_params(bsl::mempool* pool);
mcp_get_topic_list_by_type_params(const mcp_get_topic_list_by_type_params& v);
~mcp_get_topic_list_by_type_params();
mcp_get_topic_list_by_type_params& operator=(const mcp_get_topic_list_by_type_params& v);
void clear();
void check() const;
void detach();
mcp_get_topic_list_by_type_params& assign(const mcp_get_topic_list_by_type_params& v);
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_topic_list_by_type_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_topic_list_by_type_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_topic_list_by_type_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_topic_list_by_type_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_type_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_topic_list_by_type_params
class mcp_get_topic_list_by_type_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_topic_list_by_type_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_topic_list_by_type_result_params* v);
explicit mcp_get_topic_list_by_type_result_params(bsl::mempool* pool);
mcp_get_topic_list_by_type_result_params(const mcp_get_topic_list_by_type_result_params& v);
~mcp_get_topic_list_by_type_result_params();
mcp_get_topic_list_by_type_result_params& operator=(const mcp_get_topic_list_by_type_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_topic_list_by_type_result_params& assign(const mcp_get_topic_list_by_type_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_topic_list_by_type_result_params& set_count(int32_t v);
inline void clear_count();
// @@string topic_list=out(),array(0,0);
inline bool has_topic_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& topic_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_topic_list();
inline void clear_topic_list();
// deprecated.use 'mutable_topic_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_topic_list();
// deprecated.use 'topic_list().size()' instead.
inline size_t topic_list_size() const;
inline const char* topic_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_topic_list_by_type_result_params& set_topic_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_topic_list_by_type_result_params& set_ptr_topic_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_topic_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_topic_list_by_type_result_params
class mcp_get_topic_list_by_type_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_topic_list_by_type_response* create(bsl::mempool* pool);
static void destroy(mcp_get_topic_list_by_type_response* v);
explicit mcp_get_topic_list_by_type_response(bsl::mempool* pool);
mcp_get_topic_list_by_type_response(const mcp_get_topic_list_by_type_response& v);
~mcp_get_topic_list_by_type_response();
mcp_get_topic_list_by_type_response& operator=(const mcp_get_topic_list_by_type_response& v);
void clear();
void check() const;
void detach();
mcp_get_topic_list_by_type_response& assign(const mcp_get_topic_list_by_type_response& v);
// @@mcp_get_topic_list_by_type_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_topic_list_by_type_result_params& result_params() const;
inline ::idl::mcp_get_topic_list_by_type_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_topic_list_by_type_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_topic_list_by_type_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_topic_list_by_type_response
class mcp_get_sub_class_by_class_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_sub_class_by_class_params* create(bsl::mempool* pool);
static void destroy(mcp_get_sub_class_by_class_params* v);
explicit mcp_get_sub_class_by_class_params(bsl::mempool* pool);
mcp_get_sub_class_by_class_params(const mcp_get_sub_class_by_class_params& v);
~mcp_get_sub_class_by_class_params();
mcp_get_sub_class_by_class_params& operator=(const mcp_get_sub_class_by_class_params& v);
void clear();
void check() const;
void detach();
mcp_get_sub_class_by_class_params& assign(const mcp_get_sub_class_by_class_params& v);
// @@string class_id=in();
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_get_sub_class_by_class_params& set_class_id(const char* s,ssize_t size=-1);
inline mcp_get_sub_class_by_class_params& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_sub_class_by_class_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_sub_class_by_class_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_class_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_sub_class_by_class_params
class mcp_get_sub_class_by_class_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_sub_class_by_class_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_sub_class_by_class_result_params* v);
explicit mcp_get_sub_class_by_class_result_params(bsl::mempool* pool);
mcp_get_sub_class_by_class_result_params(const mcp_get_sub_class_by_class_result_params& v);
~mcp_get_sub_class_by_class_result_params();
mcp_get_sub_class_by_class_result_params& operator=(const mcp_get_sub_class_by_class_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_sub_class_by_class_result_params& assign(const mcp_get_sub_class_by_class_result_params& v);
// @@int32_t cooooooount=out();
inline bool has_cooooooount() const;
inline int32_t cooooooount() const;
inline mcp_get_sub_class_by_class_result_params& set_cooooooount(int32_t v);
inline void clear_cooooooount();
// @@sub_class_t sub_list=out(),array(0);
inline bool has_sub_list() const;
inline const ::idl::vector< ::idl::sub_class_t >& sub_list() const;
inline ::idl::vector< ::idl::sub_class_t >* mutable_sub_list();
inline void clear_sub_list();
// deprecated.use 'mutable_sub_list' instead.
inline ::idl::vector< ::idl::sub_class_t >* m_sub_list();
// deprecated.use 'sub_list().size()' instead.
inline size_t sub_list_size() const;
inline const ::idl::sub_class_t& sub_list(size_t i0) const;
inline ::idl::sub_class_t* mutable_sub_list(size_t i0);
// deprecated.use 'mutable_sub_list' instead.
inline ::idl::sub_class_t* m_sub_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_cooooooount;
 ::idl::vector< ::idl::sub_class_t > _m_sub_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_sub_class_by_class_result_params
class mcp_get_sub_class_by_class_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_sub_class_by_class_response* create(bsl::mempool* pool);
static void destroy(mcp_get_sub_class_by_class_response* v);
explicit mcp_get_sub_class_by_class_response(bsl::mempool* pool);
mcp_get_sub_class_by_class_response(const mcp_get_sub_class_by_class_response& v);
~mcp_get_sub_class_by_class_response();
mcp_get_sub_class_by_class_response& operator=(const mcp_get_sub_class_by_class_response& v);
void clear();
void check() const;
void detach();
mcp_get_sub_class_by_class_response& assign(const mcp_get_sub_class_by_class_response& v);
// @@mcp_get_sub_class_by_class_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_sub_class_by_class_result_params& result_params() const;
inline ::idl::mcp_get_sub_class_by_class_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_sub_class_by_class_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_sub_class_by_class_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_sub_class_by_class_response
class mcp_mcp_content_common_init_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_mcp_content_common_init_params* create(bsl::mempool* pool);
static void destroy(mcp_mcp_content_common_init_params* v);
explicit mcp_mcp_content_common_init_params(bsl::mempool* pool);
mcp_mcp_content_common_init_params(const mcp_mcp_content_common_init_params& v);
~mcp_mcp_content_common_init_params();
mcp_mcp_content_common_init_params& operator=(const mcp_mcp_content_common_init_params& v);
void clear();
void check() const;
void detach();
mcp_mcp_content_common_init_params& assign(const mcp_mcp_content_common_init_params& v);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::Unknown _unknown;
char _flag[0];
}; // class mcp_mcp_content_common_init_params
class mcp_mcp_content_common_init_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_mcp_content_common_init_result_params* create(bsl::mempool* pool);
static void destroy(mcp_mcp_content_common_init_result_params* v);
explicit mcp_mcp_content_common_init_result_params(bsl::mempool* pool);
mcp_mcp_content_common_init_result_params(const mcp_mcp_content_common_init_result_params& v);
~mcp_mcp_content_common_init_result_params();
mcp_mcp_content_common_init_result_params& operator=(const mcp_mcp_content_common_init_result_params& v);
void clear();
void check() const;
void detach();
mcp_mcp_content_common_init_result_params& assign(const mcp_mcp_content_common_init_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_mcp_content_common_init_result_params& set_result(int32_t v);
inline void clear_result();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_mcp_content_common_init_result_params
class mcp_mcp_content_common_init_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_mcp_content_common_init_response* create(bsl::mempool* pool);
static void destroy(mcp_mcp_content_common_init_response* v);
explicit mcp_mcp_content_common_init_response(bsl::mempool* pool);
mcp_mcp_content_common_init_response(const mcp_mcp_content_common_init_response& v);
~mcp_mcp_content_common_init_response();
mcp_mcp_content_common_init_response& operator=(const mcp_mcp_content_common_init_response& v);
void clear();
void check() const;
void detach();
mcp_mcp_content_common_init_response& assign(const mcp_mcp_content_common_init_response& v);
// @@mcp_mcp_content_common_init_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_mcp_content_common_init_result_params& result_params() const;
inline ::idl::mcp_mcp_content_common_init_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_mcp_content_common_init_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_mcp_content_common_init_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_mcp_content_common_init_response
class mcp_get_phone_area_by_phone_num_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_area_by_phone_num_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_area_by_phone_num_params* v);
explicit mcp_get_phone_area_by_phone_num_params(bsl::mempool* pool);
mcp_get_phone_area_by_phone_num_params(const mcp_get_phone_area_by_phone_num_params& v);
~mcp_get_phone_area_by_phone_num_params();
mcp_get_phone_area_by_phone_num_params& operator=(const mcp_get_phone_area_by_phone_num_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_area_by_phone_num_params& assign(const mcp_get_phone_area_by_phone_num_params& v);
// @@string phone_num=in();
inline bool has_phone_num() const;
inline const char* phone_num(unsigned int* size=0) const;
inline mcp_get_phone_area_by_phone_num_params& set_phone_num(const char* s,ssize_t size=-1);
inline mcp_get_phone_area_by_phone_num_params& set_ptr_phone_num(const char* s,ssize_t size=-1);
inline void clear_phone_num();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_phone_num;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_area_by_phone_num_params
class mcp_get_phone_area_by_phone_num_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_area_by_phone_num_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_area_by_phone_num_result_params* v);
explicit mcp_get_phone_area_by_phone_num_result_params(bsl::mempool* pool);
mcp_get_phone_area_by_phone_num_result_params(const mcp_get_phone_area_by_phone_num_result_params& v);
~mcp_get_phone_area_by_phone_num_result_params();
mcp_get_phone_area_by_phone_num_result_params& operator=(const mcp_get_phone_area_by_phone_num_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_phone_area_by_phone_num_result_params& assign(const mcp_get_phone_area_by_phone_num_result_params& v);
// @@string numseg=out();
inline bool has_numseg() const;
inline const char* numseg(unsigned int* size=0) const;
inline mcp_get_phone_area_by_phone_num_result_params& set_numseg(const char* s,ssize_t size=-1);
inline mcp_get_phone_area_by_phone_num_result_params& set_ptr_numseg(const char* s,ssize_t size=-1);
inline void clear_numseg();
// @@string result=out();
inline bool has_result() const;
inline const char* result(unsigned int* size=0) const;
inline mcp_get_phone_area_by_phone_num_result_params& set_result(const char* s,ssize_t size=-1);
inline mcp_get_phone_area_by_phone_num_result_params& set_ptr_result(const char* s,ssize_t size=-1);
inline void clear_result();
// @@string type=out();
inline bool has_type() const;
inline const char* type(unsigned int* size=0) const;
inline mcp_get_phone_area_by_phone_num_result_params& set_type(const char* s,ssize_t size=-1);
inline mcp_get_phone_area_by_phone_num_result_params& set_ptr_type(const char* s,ssize_t size=-1);
inline void clear_type();
// @@string oid=out();
inline bool has_oid() const;
inline const char* oid(unsigned int* size=0) const;
inline mcp_get_phone_area_by_phone_num_result_params& set_oid(const char* s,ssize_t size=-1);
inline mcp_get_phone_area_by_phone_num_result_params& set_ptr_oid(const char* s,ssize_t size=-1);
inline void clear_oid();
// @@string provice=out();
inline bool has_provice() const;
inline const char* provice(unsigned int* size=0) const;
inline mcp_get_phone_area_by_phone_num_result_params& set_provice(const char* s,ssize_t size=-1);
inline mcp_get_phone_area_by_phone_num_result_params& set_ptr_provice(const char* s,ssize_t size=-1);
inline void clear_provice();
// @@string city=out();
inline bool has_city() const;
inline const char* city(unsigned int* size=0) const;
inline mcp_get_phone_area_by_phone_num_result_params& set_city(const char* s,ssize_t size=-1);
inline mcp_get_phone_area_by_phone_num_result_params& set_ptr_city(const char* s,ssize_t size=-1);
inline void clear_city();
// @@string code=out();
inline bool has_code() const;
inline const char* code(unsigned int* size=0) const;
inline mcp_get_phone_area_by_phone_num_result_params& set_code(const char* s,ssize_t size=-1);
inline mcp_get_phone_area_by_phone_num_result_params& set_ptr_code(const char* s,ssize_t size=-1);
inline void clear_code();
// @@string enabled=out();
inline bool has_enabled() const;
inline const char* enabled(unsigned int* size=0) const;
inline mcp_get_phone_area_by_phone_num_result_params& set_enabled(const char* s,ssize_t size=-1);
inline mcp_get_phone_area_by_phone_num_result_params& set_ptr_enabled(const char* s,ssize_t size=-1);
inline void clear_enabled();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_numseg;
 ::idl::string _m_result;
 ::idl::string _m_type;
 ::idl::string _m_oid;
 ::idl::string _m_provice;
 ::idl::string _m_city;
 ::idl::string _m_code;
 ::idl::string _m_enabled;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_area_by_phone_num_result_params
class mcp_get_phone_area_by_phone_num_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_phone_area_by_phone_num_response* create(bsl::mempool* pool);
static void destroy(mcp_get_phone_area_by_phone_num_response* v);
explicit mcp_get_phone_area_by_phone_num_response(bsl::mempool* pool);
mcp_get_phone_area_by_phone_num_response(const mcp_get_phone_area_by_phone_num_response& v);
~mcp_get_phone_area_by_phone_num_response();
mcp_get_phone_area_by_phone_num_response& operator=(const mcp_get_phone_area_by_phone_num_response& v);
void clear();
void check() const;
void detach();
mcp_get_phone_area_by_phone_num_response& assign(const mcp_get_phone_area_by_phone_num_response& v);
// @@mcp_get_phone_area_by_phone_num_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_phone_area_by_phone_num_result_params& result_params() const;
inline ::idl::mcp_get_phone_area_by_phone_num_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_phone_area_by_phone_num_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_phone_area_by_phone_num_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_phone_area_by_phone_num_response
class mcp_reload_config_by_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_reload_config_by_id_params* create(bsl::mempool* pool);
static void destroy(mcp_reload_config_by_id_params* v);
explicit mcp_reload_config_by_id_params(bsl::mempool* pool);
mcp_reload_config_by_id_params(const mcp_reload_config_by_id_params& v);
~mcp_reload_config_by_id_params();
mcp_reload_config_by_id_params& operator=(const mcp_reload_config_by_id_params& v);
void clear();
void check() const;
void detach();
mcp_reload_config_by_id_params& assign(const mcp_reload_config_by_id_params& v);
// @@uint32_t reload_id=in();
inline bool has_reload_id() const;
inline uint32_t reload_id() const;
inline mcp_reload_config_by_id_params& set_reload_id(uint32_t v);
inline void clear_reload_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_reload_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_reload_config_by_id_params
class mcp_reload_config_by_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_reload_config_by_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_reload_config_by_id_result_params* v);
explicit mcp_reload_config_by_id_result_params(bsl::mempool* pool);
mcp_reload_config_by_id_result_params(const mcp_reload_config_by_id_result_params& v);
~mcp_reload_config_by_id_result_params();
mcp_reload_config_by_id_result_params& operator=(const mcp_reload_config_by_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_reload_config_by_id_result_params& assign(const mcp_reload_config_by_id_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_reload_config_by_id_result_params& set_result(int32_t v);
inline void clear_result();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_reload_config_by_id_result_params
class mcp_reload_config_by_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_reload_config_by_id_response* create(bsl::mempool* pool);
static void destroy(mcp_reload_config_by_id_response* v);
explicit mcp_reload_config_by_id_response(bsl::mempool* pool);
mcp_reload_config_by_id_response(const mcp_reload_config_by_id_response& v);
~mcp_reload_config_by_id_response();
mcp_reload_config_by_id_response& operator=(const mcp_reload_config_by_id_response& v);
void clear();
void check() const;
void detach();
mcp_reload_config_by_id_response& assign(const mcp_reload_config_by_id_response& v);
// @@mcp_reload_config_by_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_reload_config_by_id_result_params& result_params() const;
inline ::idl::mcp_reload_config_by_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_reload_config_by_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_reload_config_by_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_reload_config_by_id_response
class mcp_get_ios_content_by_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_id_params* v);
explicit mcp_get_ios_content_by_id_params(bsl::mempool* pool);
mcp_get_ios_content_by_id_params(const mcp_get_ios_content_by_id_params& v);
~mcp_get_ios_content_by_id_params();
mcp_get_ios_content_by_id_params& operator=(const mcp_get_ios_content_by_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_id_params& assign(const mcp_get_ios_content_by_id_params& v);
// @@string id=in();
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline mcp_get_ios_content_by_id_params& set_id(const char* s,ssize_t size=-1);
inline mcp_get_ios_content_by_id_params& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_id_params
class mcp_get_ios_content_by_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_id_result_params* v);
explicit mcp_get_ios_content_by_id_result_params(bsl::mempool* pool);
mcp_get_ios_content_by_id_result_params(const mcp_get_ios_content_by_id_result_params& v);
~mcp_get_ios_content_by_id_result_params();
mcp_get_ios_content_by_id_result_params& operator=(const mcp_get_ios_content_by_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_id_result_params& assign(const mcp_get_ios_content_by_id_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_get_ios_content_by_id_result_params& set_result(int32_t v);
inline void clear_result();
// @@ios_content_info_t info=out();
inline bool has_info() const;
inline const ::idl::ios_content_info_t& info() const;
inline ::idl::ios_content_info_t* mutable_info();
// deprecated.use 'mutable_info()' instead.
inline ::idl::ios_content_info_t* m_info();
inline void clear_info();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
mutable ::idl::ios_content_info_t* _m_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_id_result_params
class mcp_get_ios_content_by_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_id_response* v);
explicit mcp_get_ios_content_by_id_response(bsl::mempool* pool);
mcp_get_ios_content_by_id_response(const mcp_get_ios_content_by_id_response& v);
~mcp_get_ios_content_by_id_response();
mcp_get_ios_content_by_id_response& operator=(const mcp_get_ios_content_by_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_id_response& assign(const mcp_get_ios_content_by_id_response& v);
// @@mcp_get_ios_content_by_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_ios_content_by_id_result_params& result_params() const;
inline ::idl::mcp_get_ios_content_by_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_ios_content_by_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_ios_content_by_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_id_response
class mcp_get_ios_content_by_class_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_class_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_class_id_params* v);
explicit mcp_get_ios_content_by_class_id_params(bsl::mempool* pool);
mcp_get_ios_content_by_class_id_params(const mcp_get_ios_content_by_class_id_params& v);
~mcp_get_ios_content_by_class_id_params();
mcp_get_ios_content_by_class_id_params& operator=(const mcp_get_ios_content_by_class_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_class_id_params& assign(const mcp_get_ios_content_by_class_id_params& v);
// @@string class_id=in();
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_get_ios_content_by_class_id_params& set_class_id(const char* s,ssize_t size=-1);
inline mcp_get_ios_content_by_class_id_params& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_ios_content_by_class_id_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_ios_content_by_class_id_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t orderby=in();
inline bool has_orderby() const;
inline uint32_t orderby() const;
inline mcp_get_ios_content_by_class_id_params& set_orderby(uint32_t v);
inline void clear_orderby();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_ios_content_by_class_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_ios_content_by_class_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
// @@uint32_t for_free=in(),default(0);
static const uint32_t k_for_free;
inline bool has_for_free() const;
inline uint32_t for_free() const;
inline mcp_get_ios_content_by_class_id_params& set_for_free(uint32_t v);
inline void clear_for_free();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_class_id;
 ::idl::string _m_type_id;
 uint32_t _m_orderby;
 uint32_t _m_page;
 uint32_t _m_page_size;
 uint32_t _m_for_free;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_class_id_params
class mcp_get_ios_content_by_class_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_class_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_class_id_result_params* v);
explicit mcp_get_ios_content_by_class_id_result_params(bsl::mempool* pool);
mcp_get_ios_content_by_class_id_result_params(const mcp_get_ios_content_by_class_id_result_params& v);
~mcp_get_ios_content_by_class_id_result_params();
mcp_get_ios_content_by_class_id_result_params& operator=(const mcp_get_ios_content_by_class_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_class_id_result_params& assign(const mcp_get_ios_content_by_class_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_ios_content_by_class_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@ios_content_info_t info_list=out(),array(0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::ios_content_info_t >& info_list() const;
inline ::idl::vector< ::idl::ios_content_info_t >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::ios_content_info_t >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const ::idl::ios_content_info_t& info_list(size_t i0) const;
inline ::idl::ios_content_info_t* mutable_info_list(size_t i0);
// deprecated.use 'mutable_info_list' instead.
inline ::idl::ios_content_info_t* m_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::ios_content_info_t > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_class_id_result_params
class mcp_get_ios_content_by_class_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_class_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_class_id_response* v);
explicit mcp_get_ios_content_by_class_id_response(bsl::mempool* pool);
mcp_get_ios_content_by_class_id_response(const mcp_get_ios_content_by_class_id_response& v);
~mcp_get_ios_content_by_class_id_response();
mcp_get_ios_content_by_class_id_response& operator=(const mcp_get_ios_content_by_class_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_class_id_response& assign(const mcp_get_ios_content_by_class_id_response& v);
// @@mcp_get_ios_content_by_class_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_ios_content_by_class_id_result_params& result_params() const;
inline ::idl::mcp_get_ios_content_by_class_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_ios_content_by_class_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_ios_content_by_class_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_class_id_response
class mcp_get_ios_content_by_cp_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_cp_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_cp_id_params* v);
explicit mcp_get_ios_content_by_cp_id_params(bsl::mempool* pool);
mcp_get_ios_content_by_cp_id_params(const mcp_get_ios_content_by_cp_id_params& v);
~mcp_get_ios_content_by_cp_id_params();
mcp_get_ios_content_by_cp_id_params& operator=(const mcp_get_ios_content_by_cp_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_cp_id_params& assign(const mcp_get_ios_content_by_cp_id_params& v);
// @@string cp_id=in();
inline bool has_cp_id() const;
inline const char* cp_id(unsigned int* size=0) const;
inline mcp_get_ios_content_by_cp_id_params& set_cp_id(const char* s,ssize_t size=-1);
inline mcp_get_ios_content_by_cp_id_params& set_ptr_cp_id(const char* s,ssize_t size=-1);
inline void clear_cp_id();
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_ios_content_by_cp_id_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_ios_content_by_cp_id_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t orderby=in();
inline bool has_orderby() const;
inline uint32_t orderby() const;
inline mcp_get_ios_content_by_cp_id_params& set_orderby(uint32_t v);
inline void clear_orderby();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_ios_content_by_cp_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_ios_content_by_cp_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_cp_id;
 ::idl::string _m_type_id;
 uint32_t _m_orderby;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_cp_id_params
class mcp_get_ios_content_by_cp_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_cp_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_cp_id_result_params* v);
explicit mcp_get_ios_content_by_cp_id_result_params(bsl::mempool* pool);
mcp_get_ios_content_by_cp_id_result_params(const mcp_get_ios_content_by_cp_id_result_params& v);
~mcp_get_ios_content_by_cp_id_result_params();
mcp_get_ios_content_by_cp_id_result_params& operator=(const mcp_get_ios_content_by_cp_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_cp_id_result_params& assign(const mcp_get_ios_content_by_cp_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_ios_content_by_cp_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@string cp_name=out();
inline bool has_cp_name() const;
inline const char* cp_name(unsigned int* size=0) const;
inline mcp_get_ios_content_by_cp_id_result_params& set_cp_name(const char* s,ssize_t size=-1);
inline mcp_get_ios_content_by_cp_id_result_params& set_ptr_cp_name(const char* s,ssize_t size=-1);
inline void clear_cp_name();
// @@ios_content_info_t info_list=out(),array(0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::ios_content_info_t >& info_list() const;
inline ::idl::vector< ::idl::ios_content_info_t >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::ios_content_info_t >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const ::idl::ios_content_info_t& info_list(size_t i0) const;
inline ::idl::ios_content_info_t* mutable_info_list(size_t i0);
// deprecated.use 'mutable_info_list' instead.
inline ::idl::ios_content_info_t* m_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::string _m_cp_name;
 ::idl::vector< ::idl::ios_content_info_t > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_cp_id_result_params
class mcp_get_ios_content_by_cp_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_cp_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_cp_id_response* v);
explicit mcp_get_ios_content_by_cp_id_response(bsl::mempool* pool);
mcp_get_ios_content_by_cp_id_response(const mcp_get_ios_content_by_cp_id_response& v);
~mcp_get_ios_content_by_cp_id_response();
mcp_get_ios_content_by_cp_id_response& operator=(const mcp_get_ios_content_by_cp_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_cp_id_response& assign(const mcp_get_ios_content_by_cp_id_response& v);
// @@mcp_get_ios_content_by_cp_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_ios_content_by_cp_id_result_params& result_params() const;
inline ::idl::mcp_get_ios_content_by_cp_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_ios_content_by_cp_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_ios_content_by_cp_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_cp_id_response
class mcp_get_ios_content_by_col_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_col_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_col_id_params* v);
explicit mcp_get_ios_content_by_col_id_params(bsl::mempool* pool);
mcp_get_ios_content_by_col_id_params(const mcp_get_ios_content_by_col_id_params& v);
~mcp_get_ios_content_by_col_id_params();
mcp_get_ios_content_by_col_id_params& operator=(const mcp_get_ios_content_by_col_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_col_id_params& assign(const mcp_get_ios_content_by_col_id_params& v);
// @@string column_id=in();
inline bool has_column_id() const;
inline const char* column_id(unsigned int* size=0) const;
inline mcp_get_ios_content_by_col_id_params& set_column_id(const char* s,ssize_t size=-1);
inline mcp_get_ios_content_by_col_id_params& set_ptr_column_id(const char* s,ssize_t size=-1);
inline void clear_column_id();
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_ios_content_by_col_id_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_ios_content_by_col_id_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t orderby=in();
inline bool has_orderby() const;
inline uint32_t orderby() const;
inline mcp_get_ios_content_by_col_id_params& set_orderby(uint32_t v);
inline void clear_orderby();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_ios_content_by_col_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_ios_content_by_col_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_column_id;
 ::idl::string _m_type_id;
 uint32_t _m_orderby;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_col_id_params
class mcp_get_ios_content_by_col_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_col_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_col_id_result_params* v);
explicit mcp_get_ios_content_by_col_id_result_params(bsl::mempool* pool);
mcp_get_ios_content_by_col_id_result_params(const mcp_get_ios_content_by_col_id_result_params& v);
~mcp_get_ios_content_by_col_id_result_params();
mcp_get_ios_content_by_col_id_result_params& operator=(const mcp_get_ios_content_by_col_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_col_id_result_params& assign(const mcp_get_ios_content_by_col_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_ios_content_by_col_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@string name=out();
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline mcp_get_ios_content_by_col_id_result_params& set_name(const char* s,ssize_t size=-1);
inline mcp_get_ios_content_by_col_id_result_params& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@ios_content_info_t info_list=out(),array(0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::ios_content_info_t >& info_list() const;
inline ::idl::vector< ::idl::ios_content_info_t >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::ios_content_info_t >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const ::idl::ios_content_info_t& info_list(size_t i0) const;
inline ::idl::ios_content_info_t* mutable_info_list(size_t i0);
// deprecated.use 'mutable_info_list' instead.
inline ::idl::ios_content_info_t* m_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::string _m_name;
 ::idl::vector< ::idl::ios_content_info_t > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_col_id_result_params
class mcp_get_ios_content_by_col_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_col_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_col_id_response* v);
explicit mcp_get_ios_content_by_col_id_response(bsl::mempool* pool);
mcp_get_ios_content_by_col_id_response(const mcp_get_ios_content_by_col_id_response& v);
~mcp_get_ios_content_by_col_id_response();
mcp_get_ios_content_by_col_id_response& operator=(const mcp_get_ios_content_by_col_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_col_id_response& assign(const mcp_get_ios_content_by_col_id_response& v);
// @@mcp_get_ios_content_by_col_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_ios_content_by_col_id_result_params& result_params() const;
inline ::idl::mcp_get_ios_content_by_col_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_ios_content_by_col_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_ios_content_by_col_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_col_id_response
class mcp_get_ios_content_by_rank_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_rank_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_rank_params* v);
explicit mcp_get_ios_content_by_rank_params(bsl::mempool* pool);
mcp_get_ios_content_by_rank_params(const mcp_get_ios_content_by_rank_params& v);
~mcp_get_ios_content_by_rank_params();
mcp_get_ios_content_by_rank_params& operator=(const mcp_get_ios_content_by_rank_params& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_rank_params& assign(const mcp_get_ios_content_by_rank_params& v);
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_ios_content_by_rank_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_ios_content_by_rank_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t p_type=in();
inline bool has_p_type() const;
inline uint32_t p_type() const;
inline mcp_get_ios_content_by_rank_params& set_p_type(uint32_t v);
inline void clear_p_type();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_ios_content_by_rank_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_ios_content_by_rank_params& set_page_size(uint32_t v);
inline void clear_page_size();
// @@uint32_t for_free=in(),default(0);
static const uint32_t k_for_free;
inline bool has_for_free() const;
inline uint32_t for_free() const;
inline mcp_get_ios_content_by_rank_params& set_for_free(uint32_t v);
inline void clear_for_free();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_type_id;
 uint32_t _m_p_type;
 uint32_t _m_page;
 uint32_t _m_page_size;
 uint32_t _m_for_free;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_rank_params
class mcp_get_ios_content_by_rank_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_rank_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_rank_result_params* v);
explicit mcp_get_ios_content_by_rank_result_params(bsl::mempool* pool);
mcp_get_ios_content_by_rank_result_params(const mcp_get_ios_content_by_rank_result_params& v);
~mcp_get_ios_content_by_rank_result_params();
mcp_get_ios_content_by_rank_result_params& operator=(const mcp_get_ios_content_by_rank_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_rank_result_params& assign(const mcp_get_ios_content_by_rank_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_ios_content_by_rank_result_params& set_count(int32_t v);
inline void clear_count();
// @@ios_content_info_t info_list=out(),array(0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::ios_content_info_t >& info_list() const;
inline ::idl::vector< ::idl::ios_content_info_t >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::ios_content_info_t >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const ::idl::ios_content_info_t& info_list(size_t i0) const;
inline ::idl::ios_content_info_t* mutable_info_list(size_t i0);
// deprecated.use 'mutable_info_list' instead.
inline ::idl::ios_content_info_t* m_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::ios_content_info_t > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_rank_result_params
class mcp_get_ios_content_by_rank_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_content_by_rank_response* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_content_by_rank_response* v);
explicit mcp_get_ios_content_by_rank_response(bsl::mempool* pool);
mcp_get_ios_content_by_rank_response(const mcp_get_ios_content_by_rank_response& v);
~mcp_get_ios_content_by_rank_response();
mcp_get_ios_content_by_rank_response& operator=(const mcp_get_ios_content_by_rank_response& v);
void clear();
void check() const;
void detach();
mcp_get_ios_content_by_rank_response& assign(const mcp_get_ios_content_by_rank_response& v);
// @@mcp_get_ios_content_by_rank_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_ios_content_by_rank_result_params& result_params() const;
inline ::idl::mcp_get_ios_content_by_rank_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_ios_content_by_rank_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_ios_content_by_rank_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_content_by_rank_response
class mcp_get_class_list_by_type_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_class_list_by_type_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_class_list_by_type_id_params* v);
explicit mcp_get_class_list_by_type_id_params(bsl::mempool* pool);
mcp_get_class_list_by_type_id_params(const mcp_get_class_list_by_type_id_params& v);
~mcp_get_class_list_by_type_id_params();
mcp_get_class_list_by_type_id_params& operator=(const mcp_get_class_list_by_type_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_class_list_by_type_id_params& assign(const mcp_get_class_list_by_type_id_params& v);
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_class_list_by_type_id_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_class_list_by_type_id_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_type_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_class_list_by_type_id_params
class mcp_get_class_list_by_type_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_class_list_by_type_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_class_list_by_type_id_result_params* v);
explicit mcp_get_class_list_by_type_id_result_params(bsl::mempool* pool);
mcp_get_class_list_by_type_id_result_params(const mcp_get_class_list_by_type_id_result_params& v);
~mcp_get_class_list_by_type_id_result_params();
mcp_get_class_list_by_type_id_result_params& operator=(const mcp_get_class_list_by_type_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_class_list_by_type_id_result_params& assign(const mcp_get_class_list_by_type_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_class_list_by_type_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@class_detail_count_t class_list=out(),array(0);
inline bool has_class_list() const;
inline const ::idl::vector< ::idl::class_detail_count_t >& class_list() const;
inline ::idl::vector< ::idl::class_detail_count_t >* mutable_class_list();
inline void clear_class_list();
// deprecated.use 'mutable_class_list' instead.
inline ::idl::vector< ::idl::class_detail_count_t >* m_class_list();
// deprecated.use 'class_list().size()' instead.
inline size_t class_list_size() const;
inline const ::idl::class_detail_count_t& class_list(size_t i0) const;
inline ::idl::class_detail_count_t* mutable_class_list(size_t i0);
// deprecated.use 'mutable_class_list' instead.
inline ::idl::class_detail_count_t* m_class_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::class_detail_count_t > _m_class_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_class_list_by_type_id_result_params
class mcp_get_class_list_by_type_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_class_list_by_type_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_class_list_by_type_id_response* v);
explicit mcp_get_class_list_by_type_id_response(bsl::mempool* pool);
mcp_get_class_list_by_type_id_response(const mcp_get_class_list_by_type_id_response& v);
~mcp_get_class_list_by_type_id_response();
mcp_get_class_list_by_type_id_response& operator=(const mcp_get_class_list_by_type_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_class_list_by_type_id_response& assign(const mcp_get_class_list_by_type_id_response& v);
// @@mcp_get_class_list_by_type_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_class_list_by_type_id_result_params& result_params() const;
inline ::idl::mcp_get_class_list_by_type_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_class_list_by_type_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_class_list_by_type_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_class_list_by_type_id_response
class mcp_get_ios_probably_like_list_by_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_probably_like_list_by_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_probably_like_list_by_id_params* v);
explicit mcp_get_ios_probably_like_list_by_id_params(bsl::mempool* pool);
mcp_get_ios_probably_like_list_by_id_params(const mcp_get_ios_probably_like_list_by_id_params& v);
~mcp_get_ios_probably_like_list_by_id_params();
mcp_get_ios_probably_like_list_by_id_params& operator=(const mcp_get_ios_probably_like_list_by_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_ios_probably_like_list_by_id_params& assign(const mcp_get_ios_probably_like_list_by_id_params& v);
// @@string id=in();
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline mcp_get_ios_probably_like_list_by_id_params& set_id(const char* s,ssize_t size=-1);
inline mcp_get_ios_probably_like_list_by_id_params& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@uint32_t list_cnt=in();
inline bool has_list_cnt() const;
inline uint32_t list_cnt() const;
inline mcp_get_ios_probably_like_list_by_id_params& set_list_cnt(uint32_t v);
inline void clear_list_cnt();
// @@uint32_t type=in();
inline bool has_type() const;
inline uint32_t type() const;
inline mcp_get_ios_probably_like_list_by_id_params& set_type(uint32_t v);
inline void clear_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 uint32_t _m_list_cnt;
 uint32_t _m_type;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_probably_like_list_by_id_params
class mcp_get_ios_probably_like_list_by_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_probably_like_list_by_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_probably_like_list_by_id_result_params* v);
explicit mcp_get_ios_probably_like_list_by_id_result_params(bsl::mempool* pool);
mcp_get_ios_probably_like_list_by_id_result_params(const mcp_get_ios_probably_like_list_by_id_result_params& v);
~mcp_get_ios_probably_like_list_by_id_result_params();
mcp_get_ios_probably_like_list_by_id_result_params& operator=(const mcp_get_ios_probably_like_list_by_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_ios_probably_like_list_by_id_result_params& assign(const mcp_get_ios_probably_like_list_by_id_result_params& v);
// @@ios_content_info_t info_list=out(),array(0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::ios_content_info_t >& info_list() const;
inline ::idl::vector< ::idl::ios_content_info_t >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::ios_content_info_t >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const ::idl::ios_content_info_t& info_list(size_t i0) const;
inline ::idl::ios_content_info_t* mutable_info_list(size_t i0);
// deprecated.use 'mutable_info_list' instead.
inline ::idl::ios_content_info_t* m_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::vector< ::idl::ios_content_info_t > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_probably_like_list_by_id_result_params
class mcp_get_ios_probably_like_list_by_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ios_probably_like_list_by_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_ios_probably_like_list_by_id_response* v);
explicit mcp_get_ios_probably_like_list_by_id_response(bsl::mempool* pool);
mcp_get_ios_probably_like_list_by_id_response(const mcp_get_ios_probably_like_list_by_id_response& v);
~mcp_get_ios_probably_like_list_by_id_response();
mcp_get_ios_probably_like_list_by_id_response& operator=(const mcp_get_ios_probably_like_list_by_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_ios_probably_like_list_by_id_response& assign(const mcp_get_ios_probably_like_list_by_id_response& v);
// @@mcp_get_ios_probably_like_list_by_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_ios_probably_like_list_by_id_result_params& result_params() const;
inline ::idl::mcp_get_ios_probably_like_list_by_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_ios_probably_like_list_by_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_ios_probably_like_list_by_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ios_probably_like_list_by_id_response
class mcp_get_game_info_list_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_info_list_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_info_list_params* v);
explicit mcp_get_game_info_list_params(bsl::mempool* pool);
mcp_get_game_info_list_params(const mcp_get_game_info_list_params& v);
~mcp_get_game_info_list_params();
mcp_get_game_info_list_params& operator=(const mcp_get_game_info_list_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_info_list_params& assign(const mcp_get_game_info_list_params& v);
// @@string info_type=in();
inline bool has_info_type() const;
inline const char* info_type(unsigned int* size=0) const;
inline mcp_get_game_info_list_params& set_info_type(const char* s,ssize_t size=-1);
inline mcp_get_game_info_list_params& set_ptr_info_type(const char* s,ssize_t size=-1);
inline void clear_info_type();
// @@string game_type=in();
inline bool has_game_type() const;
inline const char* game_type(unsigned int* size=0) const;
inline mcp_get_game_info_list_params& set_game_type(const char* s,ssize_t size=-1);
inline mcp_get_game_info_list_params& set_ptr_game_type(const char* s,ssize_t size=-1);
inline void clear_game_type();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_game_info_list_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_game_info_list_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_info_type;
 ::idl::string _m_game_type;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_info_list_params
class mcp_get_game_info_list_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_info_list_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_info_list_result_params* v);
explicit mcp_get_game_info_list_result_params(bsl::mempool* pool);
mcp_get_game_info_list_result_params(const mcp_get_game_info_list_result_params& v);
~mcp_get_game_info_list_result_params();
mcp_get_game_info_list_result_params& operator=(const mcp_get_game_info_list_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_info_list_result_params& assign(const mcp_get_game_info_list_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_game_info_list_result_params& set_count(int32_t v);
inline void clear_count();
// @@game_brief_info_t game_info_list=out(),array(0);
inline bool has_game_info_list() const;
inline const ::idl::vector< ::idl::game_brief_info_t >& game_info_list() const;
inline ::idl::vector< ::idl::game_brief_info_t >* mutable_game_info_list();
inline void clear_game_info_list();
// deprecated.use 'mutable_game_info_list' instead.
inline ::idl::vector< ::idl::game_brief_info_t >* m_game_info_list();
// deprecated.use 'game_info_list().size()' instead.
inline size_t game_info_list_size() const;
inline const ::idl::game_brief_info_t& game_info_list(size_t i0) const;
inline ::idl::game_brief_info_t* mutable_game_info_list(size_t i0);
// deprecated.use 'mutable_game_info_list' instead.
inline ::idl::game_brief_info_t* m_game_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::game_brief_info_t > _m_game_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_info_list_result_params
class mcp_get_game_info_list_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_info_list_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_info_list_response* v);
explicit mcp_get_game_info_list_response(bsl::mempool* pool);
mcp_get_game_info_list_response(const mcp_get_game_info_list_response& v);
~mcp_get_game_info_list_response();
mcp_get_game_info_list_response& operator=(const mcp_get_game_info_list_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_info_list_response& assign(const mcp_get_game_info_list_response& v);
// @@mcp_get_game_info_list_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_info_list_result_params& result_params() const;
inline ::idl::mcp_get_game_info_list_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_info_list_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_info_list_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_info_list_response
class mcp_get_game_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_info_params* v);
explicit mcp_get_game_info_params(bsl::mempool* pool);
mcp_get_game_info_params(const mcp_get_game_info_params& v);
~mcp_get_game_info_params();
mcp_get_game_info_params& operator=(const mcp_get_game_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_info_params& assign(const mcp_get_game_info_params& v);
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_game_info_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_game_info_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_info_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_info_params
class mcp_get_game_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_info_result_params* v);
explicit mcp_get_game_info_result_params(bsl::mempool* pool);
mcp_get_game_info_result_params(const mcp_get_game_info_result_params& v);
~mcp_get_game_info_result_params();
mcp_get_game_info_result_params& operator=(const mcp_get_game_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_info_result_params& assign(const mcp_get_game_info_result_params& v);
// @@game_info_t game_info=out();
inline bool has_game_info() const;
inline const ::idl::game_info_t& game_info() const;
inline ::idl::game_info_t* mutable_game_info();
// deprecated.use 'mutable_game_info()' instead.
inline ::idl::game_info_t* m_game_info();
inline void clear_game_info();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::game_info_t* _m_game_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_info_result_params
class mcp_get_game_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_info_response* v);
explicit mcp_get_game_info_response(bsl::mempool* pool);
mcp_get_game_info_response(const mcp_get_game_info_response& v);
~mcp_get_game_info_response();
mcp_get_game_info_response& operator=(const mcp_get_game_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_info_response& assign(const mcp_get_game_info_response& v);
// @@mcp_get_game_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_info_result_params& result_params() const;
inline ::idl::mcp_get_game_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_info_response
class mcp_get_game_info_list_by_c_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_info_list_by_c_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_info_list_by_c_id_params* v);
explicit mcp_get_game_info_list_by_c_id_params(bsl::mempool* pool);
mcp_get_game_info_list_by_c_id_params(const mcp_get_game_info_list_by_c_id_params& v);
~mcp_get_game_info_list_by_c_id_params();
mcp_get_game_info_list_by_c_id_params& operator=(const mcp_get_game_info_list_by_c_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_info_list_by_c_id_params& assign(const mcp_get_game_info_list_by_c_id_params& v);
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_get_game_info_list_by_c_id_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_get_game_info_list_by_c_id_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string info_type=in();
inline bool has_info_type() const;
inline const char* info_type(unsigned int* size=0) const;
inline mcp_get_game_info_list_by_c_id_params& set_info_type(const char* s,ssize_t size=-1);
inline mcp_get_game_info_list_by_c_id_params& set_ptr_info_type(const char* s,ssize_t size=-1);
inline void clear_info_type();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_game_info_list_by_c_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_game_info_list_by_c_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_c_id;
 ::idl::string _m_info_type;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_info_list_by_c_id_params
class mcp_get_game_info_list_by_c_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_info_list_by_c_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_info_list_by_c_id_result_params* v);
explicit mcp_get_game_info_list_by_c_id_result_params(bsl::mempool* pool);
mcp_get_game_info_list_by_c_id_result_params(const mcp_get_game_info_list_by_c_id_result_params& v);
~mcp_get_game_info_list_by_c_id_result_params();
mcp_get_game_info_list_by_c_id_result_params& operator=(const mcp_get_game_info_list_by_c_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_info_list_by_c_id_result_params& assign(const mcp_get_game_info_list_by_c_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_game_info_list_by_c_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@game_brief_info_t game_info_list=out(),array(0);
inline bool has_game_info_list() const;
inline const ::idl::vector< ::idl::game_brief_info_t >& game_info_list() const;
inline ::idl::vector< ::idl::game_brief_info_t >* mutable_game_info_list();
inline void clear_game_info_list();
// deprecated.use 'mutable_game_info_list' instead.
inline ::idl::vector< ::idl::game_brief_info_t >* m_game_info_list();
// deprecated.use 'game_info_list().size()' instead.
inline size_t game_info_list_size() const;
inline const ::idl::game_brief_info_t& game_info_list(size_t i0) const;
inline ::idl::game_brief_info_t* mutable_game_info_list(size_t i0);
// deprecated.use 'mutable_game_info_list' instead.
inline ::idl::game_brief_info_t* m_game_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::game_brief_info_t > _m_game_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_info_list_by_c_id_result_params
class mcp_get_game_info_list_by_c_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_info_list_by_c_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_info_list_by_c_id_response* v);
explicit mcp_get_game_info_list_by_c_id_response(bsl::mempool* pool);
mcp_get_game_info_list_by_c_id_response(const mcp_get_game_info_list_by_c_id_response& v);
~mcp_get_game_info_list_by_c_id_response();
mcp_get_game_info_list_by_c_id_response& operator=(const mcp_get_game_info_list_by_c_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_info_list_by_c_id_response& assign(const mcp_get_game_info_list_by_c_id_response& v);
// @@mcp_get_game_info_list_by_c_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_info_list_by_c_id_result_params& result_params() const;
inline ::idl::mcp_get_game_info_list_by_c_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_info_list_by_c_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_info_list_by_c_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_info_list_by_c_id_response
class mcp_get_game_score_by_imei_or_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_score_by_imei_or_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_score_by_imei_or_uid_params* v);
explicit mcp_get_game_score_by_imei_or_uid_params(bsl::mempool* pool);
mcp_get_game_score_by_imei_or_uid_params(const mcp_get_game_score_by_imei_or_uid_params& v);
~mcp_get_game_score_by_imei_or_uid_params();
mcp_get_game_score_by_imei_or_uid_params& operator=(const mcp_get_game_score_by_imei_or_uid_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_score_by_imei_or_uid_params& assign(const mcp_get_game_score_by_imei_or_uid_params& v);
// @@string id=in();
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline mcp_get_game_score_by_imei_or_uid_params& set_id(const char* s,ssize_t size=-1);
inline mcp_get_game_score_by_imei_or_uid_params& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_get_game_score_by_imei_or_uid_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_get_game_score_by_imei_or_uid_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string type=in();
inline bool has_type() const;
inline const char* type(unsigned int* size=0) const;
inline mcp_get_game_score_by_imei_or_uid_params& set_type(const char* s,ssize_t size=-1);
inline mcp_get_game_score_by_imei_or_uid_params& set_ptr_type(const char* s,ssize_t size=-1);
inline void clear_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 ::idl::string _m_c_id;
 ::idl::string _m_type;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_score_by_imei_or_uid_params
class mcp_get_game_score_by_imei_or_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_score_by_imei_or_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_score_by_imei_or_uid_result_params* v);
explicit mcp_get_game_score_by_imei_or_uid_result_params(bsl::mempool* pool);
mcp_get_game_score_by_imei_or_uid_result_params(const mcp_get_game_score_by_imei_or_uid_result_params& v);
~mcp_get_game_score_by_imei_or_uid_result_params();
mcp_get_game_score_by_imei_or_uid_result_params& operator=(const mcp_get_game_score_by_imei_or_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_score_by_imei_or_uid_result_params& assign(const mcp_get_game_score_by_imei_or_uid_result_params& v);
// @@string score=out();
inline bool has_score() const;
inline const char* score(unsigned int* size=0) const;
inline mcp_get_game_score_by_imei_or_uid_result_params& set_score(const char* s,ssize_t size=-1);
inline mcp_get_game_score_by_imei_or_uid_result_params& set_ptr_score(const char* s,ssize_t size=-1);
inline void clear_score();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_score;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_score_by_imei_or_uid_result_params
class mcp_get_game_score_by_imei_or_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_score_by_imei_or_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_score_by_imei_or_uid_response* v);
explicit mcp_get_game_score_by_imei_or_uid_response(bsl::mempool* pool);
mcp_get_game_score_by_imei_or_uid_response(const mcp_get_game_score_by_imei_or_uid_response& v);
~mcp_get_game_score_by_imei_or_uid_response();
mcp_get_game_score_by_imei_or_uid_response& operator=(const mcp_get_game_score_by_imei_or_uid_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_score_by_imei_or_uid_response& assign(const mcp_get_game_score_by_imei_or_uid_response& v);
// @@mcp_get_game_score_by_imei_or_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_score_by_imei_or_uid_result_params& result_params() const;
inline ::idl::mcp_get_game_score_by_imei_or_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_score_by_imei_or_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_score_by_imei_or_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_score_by_imei_or_uid_response
class mcp_get_appinfo_by_packagename_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_appinfo_by_packagename_params* create(bsl::mempool* pool);
static void destroy(mcp_get_appinfo_by_packagename_params* v);
explicit mcp_get_appinfo_by_packagename_params(bsl::mempool* pool);
mcp_get_appinfo_by_packagename_params(const mcp_get_appinfo_by_packagename_params& v);
~mcp_get_appinfo_by_packagename_params();
mcp_get_appinfo_by_packagename_params& operator=(const mcp_get_appinfo_by_packagename_params& v);
void clear();
void check() const;
void detach();
mcp_get_appinfo_by_packagename_params& assign(const mcp_get_appinfo_by_packagename_params& v);
// @@string packagename=in();
inline bool has_packagename() const;
inline const char* packagename(unsigned int* size=0) const;
inline mcp_get_appinfo_by_packagename_params& set_packagename(const char* s,ssize_t size=-1);
inline mcp_get_appinfo_by_packagename_params& set_ptr_packagename(const char* s,ssize_t size=-1);
inline void clear_packagename();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_packagename;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_appinfo_by_packagename_params
class mcp_get_appinfo_by_packagename_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_appinfo_by_packagename_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_appinfo_by_packagename_result_params* v);
explicit mcp_get_appinfo_by_packagename_result_params(bsl::mempool* pool);
mcp_get_appinfo_by_packagename_result_params(const mcp_get_appinfo_by_packagename_result_params& v);
~mcp_get_appinfo_by_packagename_result_params();
mcp_get_appinfo_by_packagename_result_params& operator=(const mcp_get_appinfo_by_packagename_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_appinfo_by_packagename_result_params& assign(const mcp_get_appinfo_by_packagename_result_params& v);
// @@string package_info=out(),array(0);
inline bool has_package_info() const;
inline const ::idl::vector< ::idl::string >& package_info() const;
inline ::idl::vector< ::idl::string >* mutable_package_info();
inline void clear_package_info();
// deprecated.use 'mutable_package_info' instead.
inline ::idl::vector< ::idl::string >* m_package_info();
// deprecated.use 'package_info().size()' instead.
inline size_t package_info_size() const;
inline const char* package_info(size_t i0,unsigned int* size=0) const;
inline mcp_get_appinfo_by_packagename_result_params& set_package_info(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_appinfo_by_packagename_result_params& set_ptr_package_info(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::vector< ::idl::string > _m_package_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_appinfo_by_packagename_result_params
class mcp_get_appinfo_by_packagename_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_appinfo_by_packagename_response* create(bsl::mempool* pool);
static void destroy(mcp_get_appinfo_by_packagename_response* v);
explicit mcp_get_appinfo_by_packagename_response(bsl::mempool* pool);
mcp_get_appinfo_by_packagename_response(const mcp_get_appinfo_by_packagename_response& v);
~mcp_get_appinfo_by_packagename_response();
mcp_get_appinfo_by_packagename_response& operator=(const mcp_get_appinfo_by_packagename_response& v);
void clear();
void check() const;
void detach();
mcp_get_appinfo_by_packagename_response& assign(const mcp_get_appinfo_by_packagename_response& v);
// @@mcp_get_appinfo_by_packagename_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_appinfo_by_packagename_result_params& result_params() const;
inline ::idl::mcp_get_appinfo_by_packagename_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_appinfo_by_packagename_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_appinfo_by_packagename_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_appinfo_by_packagename_response
class mcp_get_score_by_packagename_and_versioncode_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_score_by_packagename_and_versioncode_params* create(bsl::mempool* pool);
static void destroy(mcp_get_score_by_packagename_and_versioncode_params* v);
explicit mcp_get_score_by_packagename_and_versioncode_params(bsl::mempool* pool);
mcp_get_score_by_packagename_and_versioncode_params(const mcp_get_score_by_packagename_and_versioncode_params& v);
~mcp_get_score_by_packagename_and_versioncode_params();
mcp_get_score_by_packagename_and_versioncode_params& operator=(const mcp_get_score_by_packagename_and_versioncode_params& v);
void clear();
void check() const;
void detach();
mcp_get_score_by_packagename_and_versioncode_params& assign(const mcp_get_score_by_packagename_and_versioncode_params& v);
// @@string packagename_versioncode_json=in();
inline bool has_packagename_versioncode_json() const;
inline const char* packagename_versioncode_json(unsigned int* size=0) const;
inline mcp_get_score_by_packagename_and_versioncode_params& set_packagename_versioncode_json(const char* s,ssize_t size=-1);
inline mcp_get_score_by_packagename_and_versioncode_params& set_ptr_packagename_versioncode_json(const char* s,ssize_t size=-1);
inline void clear_packagename_versioncode_json();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_packagename_versioncode_json;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_score_by_packagename_and_versioncode_params
class mcp_get_score_by_packagename_and_versioncode_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_score_by_packagename_and_versioncode_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_score_by_packagename_and_versioncode_result_params* v);
explicit mcp_get_score_by_packagename_and_versioncode_result_params(bsl::mempool* pool);
mcp_get_score_by_packagename_and_versioncode_result_params(const mcp_get_score_by_packagename_and_versioncode_result_params& v);
~mcp_get_score_by_packagename_and_versioncode_result_params();
mcp_get_score_by_packagename_and_versioncode_result_params& operator=(const mcp_get_score_by_packagename_and_versioncode_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_score_by_packagename_and_versioncode_result_params& assign(const mcp_get_score_by_packagename_and_versioncode_result_params& v);
// @@string scores_json=out();
inline bool has_scores_json() const;
inline const char* scores_json(unsigned int* size=0) const;
inline mcp_get_score_by_packagename_and_versioncode_result_params& set_scores_json(const char* s,ssize_t size=-1);
inline mcp_get_score_by_packagename_and_versioncode_result_params& set_ptr_scores_json(const char* s,ssize_t size=-1);
inline void clear_scores_json();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_scores_json;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_score_by_packagename_and_versioncode_result_params
class mcp_get_score_by_packagename_and_versioncode_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_score_by_packagename_and_versioncode_response* create(bsl::mempool* pool);
static void destroy(mcp_get_score_by_packagename_and_versioncode_response* v);
explicit mcp_get_score_by_packagename_and_versioncode_response(bsl::mempool* pool);
mcp_get_score_by_packagename_and_versioncode_response(const mcp_get_score_by_packagename_and_versioncode_response& v);
~mcp_get_score_by_packagename_and_versioncode_response();
mcp_get_score_by_packagename_and_versioncode_response& operator=(const mcp_get_score_by_packagename_and_versioncode_response& v);
void clear();
void check() const;
void detach();
mcp_get_score_by_packagename_and_versioncode_response& assign(const mcp_get_score_by_packagename_and_versioncode_response& v);
// @@mcp_get_score_by_packagename_and_versioncode_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_score_by_packagename_and_versioncode_result_params& result_params() const;
inline ::idl::mcp_get_score_by_packagename_and_versioncode_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_score_by_packagename_and_versioncode_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_score_by_packagename_and_versioncode_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_score_by_packagename_and_versioncode_response
class mcp_get_content_info_by_packagename_and_versioncode_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_info_by_packagename_and_versioncode_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_info_by_packagename_and_versioncode_params* v);
explicit mcp_get_content_info_by_packagename_and_versioncode_params(bsl::mempool* pool);
mcp_get_content_info_by_packagename_and_versioncode_params(const mcp_get_content_info_by_packagename_and_versioncode_params& v);
~mcp_get_content_info_by_packagename_and_versioncode_params();
mcp_get_content_info_by_packagename_and_versioncode_params& operator=(const mcp_get_content_info_by_packagename_and_versioncode_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_info_by_packagename_and_versioncode_params& assign(const mcp_get_content_info_by_packagename_and_versioncode_params& v);
// @@string packagename=in();
inline bool has_packagename() const;
inline const char* packagename(unsigned int* size=0) const;
inline mcp_get_content_info_by_packagename_and_versioncode_params& set_packagename(const char* s,ssize_t size=-1);
inline mcp_get_content_info_by_packagename_and_versioncode_params& set_ptr_packagename(const char* s,ssize_t size=-1);
inline void clear_packagename();
// @@string versioncode=in();
inline bool has_versioncode() const;
inline const char* versioncode(unsigned int* size=0) const;
inline mcp_get_content_info_by_packagename_and_versioncode_params& set_versioncode(const char* s,ssize_t size=-1);
inline mcp_get_content_info_by_packagename_and_versioncode_params& set_ptr_versioncode(const char* s,ssize_t size=-1);
inline void clear_versioncode();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_packagename;
 ::idl::string _m_versioncode;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_info_by_packagename_and_versioncode_params
class mcp_get_content_info_by_packagename_and_versioncode_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_info_by_packagename_and_versioncode_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_info_by_packagename_and_versioncode_result_params* v);
explicit mcp_get_content_info_by_packagename_and_versioncode_result_params(bsl::mempool* pool);
mcp_get_content_info_by_packagename_and_versioncode_result_params(const mcp_get_content_info_by_packagename_and_versioncode_result_params& v);
~mcp_get_content_info_by_packagename_and_versioncode_result_params();
mcp_get_content_info_by_packagename_and_versioncode_result_params& operator=(const mcp_get_content_info_by_packagename_and_versioncode_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_info_by_packagename_and_versioncode_result_params& assign(const mcp_get_content_info_by_packagename_and_versioncode_result_params& v);
// @@string info_list=out(),array(0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::string >& info_list() const;
inline ::idl::vector< ::idl::string >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::string >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const char* info_list(size_t i0,unsigned int* size=0) const;
inline mcp_get_content_info_by_packagename_and_versioncode_result_params& set_info_list(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_content_info_by_packagename_and_versioncode_result_params& set_ptr_info_list(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::vector< ::idl::string > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_info_by_packagename_and_versioncode_result_params
class mcp_get_content_info_by_packagename_and_versioncode_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_info_by_packagename_and_versioncode_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_info_by_packagename_and_versioncode_response* v);
explicit mcp_get_content_info_by_packagename_and_versioncode_response(bsl::mempool* pool);
mcp_get_content_info_by_packagename_and_versioncode_response(const mcp_get_content_info_by_packagename_and_versioncode_response& v);
~mcp_get_content_info_by_packagename_and_versioncode_response();
mcp_get_content_info_by_packagename_and_versioncode_response& operator=(const mcp_get_content_info_by_packagename_and_versioncode_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_info_by_packagename_and_versioncode_response& assign(const mcp_get_content_info_by_packagename_and_versioncode_response& v);
// @@mcp_get_content_info_by_packagename_and_versioncode_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params& result_params() const;
inline ::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_info_by_packagename_and_versioncode_response
class mcp_get_content_info_by_packagename_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_info_by_packagename_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_info_by_packagename_params* v);
explicit mcp_get_content_info_by_packagename_params(bsl::mempool* pool);
mcp_get_content_info_by_packagename_params(const mcp_get_content_info_by_packagename_params& v);
~mcp_get_content_info_by_packagename_params();
mcp_get_content_info_by_packagename_params& operator=(const mcp_get_content_info_by_packagename_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_info_by_packagename_params& assign(const mcp_get_content_info_by_packagename_params& v);
// @@string packagename=in();
inline bool has_packagename() const;
inline const char* packagename(unsigned int* size=0) const;
inline mcp_get_content_info_by_packagename_params& set_packagename(const char* s,ssize_t size=-1);
inline mcp_get_content_info_by_packagename_params& set_ptr_packagename(const char* s,ssize_t size=-1);
inline void clear_packagename();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_packagename;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_info_by_packagename_params
class mcp_get_content_info_by_packagename_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_info_by_packagename_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_info_by_packagename_result_params* v);
explicit mcp_get_content_info_by_packagename_result_params(bsl::mempool* pool);
mcp_get_content_info_by_packagename_result_params(const mcp_get_content_info_by_packagename_result_params& v);
~mcp_get_content_info_by_packagename_result_params();
mcp_get_content_info_by_packagename_result_params& operator=(const mcp_get_content_info_by_packagename_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_info_by_packagename_result_params& assign(const mcp_get_content_info_by_packagename_result_params& v);
// @@string info_list=out(),array(0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::string >& info_list() const;
inline ::idl::vector< ::idl::string >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::string >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const char* info_list(size_t i0,unsigned int* size=0) const;
inline mcp_get_content_info_by_packagename_result_params& set_info_list(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_content_info_by_packagename_result_params& set_ptr_info_list(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::vector< ::idl::string > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_info_by_packagename_result_params
class mcp_get_content_info_by_packagename_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_info_by_packagename_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_info_by_packagename_response* v);
explicit mcp_get_content_info_by_packagename_response(bsl::mempool* pool);
mcp_get_content_info_by_packagename_response(const mcp_get_content_info_by_packagename_response& v);
~mcp_get_content_info_by_packagename_response();
mcp_get_content_info_by_packagename_response& operator=(const mcp_get_content_info_by_packagename_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_info_by_packagename_response& assign(const mcp_get_content_info_by_packagename_response& v);
// @@mcp_get_content_info_by_packagename_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_info_by_packagename_result_params& result_params() const;
inline ::idl::mcp_get_content_info_by_packagename_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_info_by_packagename_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_info_by_packagename_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_info_by_packagename_response
class mcp_get_online_game_by_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_id_params* v);
explicit mcp_get_online_game_by_id_params(bsl::mempool* pool);
mcp_get_online_game_by_id_params(const mcp_get_online_game_by_id_params& v);
~mcp_get_online_game_by_id_params();
mcp_get_online_game_by_id_params& operator=(const mcp_get_online_game_by_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_id_params& assign(const mcp_get_online_game_by_id_params& v);
// @@string id=in();
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline mcp_get_online_game_by_id_params& set_id(const char* s,ssize_t size=-1);
inline mcp_get_online_game_by_id_params& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_id_params
class mcp_get_online_game_by_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_id_result_params* v);
explicit mcp_get_online_game_by_id_result_params(bsl::mempool* pool);
mcp_get_online_game_by_id_result_params(const mcp_get_online_game_by_id_result_params& v);
~mcp_get_online_game_by_id_result_params();
mcp_get_online_game_by_id_result_params& operator=(const mcp_get_online_game_by_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_id_result_params& assign(const mcp_get_online_game_by_id_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_get_online_game_by_id_result_params& set_result(int32_t v);
inline void clear_result();
// @@online_game_info_t info=out();
inline bool has_info() const;
inline const ::idl::online_game_info_t& info() const;
inline ::idl::online_game_info_t* mutable_info();
// deprecated.use 'mutable_info()' instead.
inline ::idl::online_game_info_t* m_info();
inline void clear_info();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
mutable ::idl::online_game_info_t* _m_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_id_result_params
class mcp_get_online_game_by_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_id_response* v);
explicit mcp_get_online_game_by_id_response(bsl::mempool* pool);
mcp_get_online_game_by_id_response(const mcp_get_online_game_by_id_response& v);
~mcp_get_online_game_by_id_response();
mcp_get_online_game_by_id_response& operator=(const mcp_get_online_game_by_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_id_response& assign(const mcp_get_online_game_by_id_response& v);
// @@mcp_get_online_game_by_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_online_game_by_id_result_params& result_params() const;
inline ::idl::mcp_get_online_game_by_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_online_game_by_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_online_game_by_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_id_response
class mcp_get_online_game_by_class_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_class_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_class_id_params* v);
explicit mcp_get_online_game_by_class_id_params(bsl::mempool* pool);
mcp_get_online_game_by_class_id_params(const mcp_get_online_game_by_class_id_params& v);
~mcp_get_online_game_by_class_id_params();
mcp_get_online_game_by_class_id_params& operator=(const mcp_get_online_game_by_class_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_class_id_params& assign(const mcp_get_online_game_by_class_id_params& v);
// @@string class_id=in();
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_get_online_game_by_class_id_params& set_class_id(const char* s,ssize_t size=-1);
inline mcp_get_online_game_by_class_id_params& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_online_game_by_class_id_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_online_game_by_class_id_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t orderby=in();
inline bool has_orderby() const;
inline uint32_t orderby() const;
inline mcp_get_online_game_by_class_id_params& set_orderby(uint32_t v);
inline void clear_orderby();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_online_game_by_class_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_online_game_by_class_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_class_id;
 ::idl::string _m_type_id;
 uint32_t _m_orderby;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_class_id_params
class mcp_get_online_game_by_class_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_class_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_class_id_result_params* v);
explicit mcp_get_online_game_by_class_id_result_params(bsl::mempool* pool);
mcp_get_online_game_by_class_id_result_params(const mcp_get_online_game_by_class_id_result_params& v);
~mcp_get_online_game_by_class_id_result_params();
mcp_get_online_game_by_class_id_result_params& operator=(const mcp_get_online_game_by_class_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_class_id_result_params& assign(const mcp_get_online_game_by_class_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_online_game_by_class_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@string class_name=out();
inline bool has_class_name() const;
inline const char* class_name(unsigned int* size=0) const;
inline mcp_get_online_game_by_class_id_result_params& set_class_name(const char* s,ssize_t size=-1);
inline mcp_get_online_game_by_class_id_result_params& set_ptr_class_name(const char* s,ssize_t size=-1);
inline void clear_class_name();
// @@string class_icon=out();
inline bool has_class_icon() const;
inline const char* class_icon(unsigned int* size=0) const;
inline mcp_get_online_game_by_class_id_result_params& set_class_icon(const char* s,ssize_t size=-1);
inline mcp_get_online_game_by_class_id_result_params& set_ptr_class_icon(const char* s,ssize_t size=-1);
inline void clear_class_icon();
// @@online_game_info_t info_list=out(),array(0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::online_game_info_t >& info_list() const;
inline ::idl::vector< ::idl::online_game_info_t >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::online_game_info_t >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const ::idl::online_game_info_t& info_list(size_t i0) const;
inline ::idl::online_game_info_t* mutable_info_list(size_t i0);
// deprecated.use 'mutable_info_list' instead.
inline ::idl::online_game_info_t* m_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::string _m_class_name;
 ::idl::string _m_class_icon;
 ::idl::vector< ::idl::online_game_info_t > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_class_id_result_params
class mcp_get_online_game_by_class_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_class_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_class_id_response* v);
explicit mcp_get_online_game_by_class_id_response(bsl::mempool* pool);
mcp_get_online_game_by_class_id_response(const mcp_get_online_game_by_class_id_response& v);
~mcp_get_online_game_by_class_id_response();
mcp_get_online_game_by_class_id_response& operator=(const mcp_get_online_game_by_class_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_class_id_response& assign(const mcp_get_online_game_by_class_id_response& v);
// @@mcp_get_online_game_by_class_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_online_game_by_class_id_result_params& result_params() const;
inline ::idl::mcp_get_online_game_by_class_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_online_game_by_class_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_online_game_by_class_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_class_id_response
class mcp_get_online_game_by_cp_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_cp_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_cp_id_params* v);
explicit mcp_get_online_game_by_cp_id_params(bsl::mempool* pool);
mcp_get_online_game_by_cp_id_params(const mcp_get_online_game_by_cp_id_params& v);
~mcp_get_online_game_by_cp_id_params();
mcp_get_online_game_by_cp_id_params& operator=(const mcp_get_online_game_by_cp_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_cp_id_params& assign(const mcp_get_online_game_by_cp_id_params& v);
// @@string cp_id=in();
inline bool has_cp_id() const;
inline const char* cp_id(unsigned int* size=0) const;
inline mcp_get_online_game_by_cp_id_params& set_cp_id(const char* s,ssize_t size=-1);
inline mcp_get_online_game_by_cp_id_params& set_ptr_cp_id(const char* s,ssize_t size=-1);
inline void clear_cp_id();
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_online_game_by_cp_id_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_online_game_by_cp_id_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t orderby=in();
inline bool has_orderby() const;
inline uint32_t orderby() const;
inline mcp_get_online_game_by_cp_id_params& set_orderby(uint32_t v);
inline void clear_orderby();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_online_game_by_cp_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_online_game_by_cp_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_cp_id;
 ::idl::string _m_type_id;
 uint32_t _m_orderby;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_cp_id_params
class mcp_get_online_game_by_cp_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_cp_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_cp_id_result_params* v);
explicit mcp_get_online_game_by_cp_id_result_params(bsl::mempool* pool);
mcp_get_online_game_by_cp_id_result_params(const mcp_get_online_game_by_cp_id_result_params& v);
~mcp_get_online_game_by_cp_id_result_params();
mcp_get_online_game_by_cp_id_result_params& operator=(const mcp_get_online_game_by_cp_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_cp_id_result_params& assign(const mcp_get_online_game_by_cp_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_online_game_by_cp_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@string cp_name=out();
inline bool has_cp_name() const;
inline const char* cp_name(unsigned int* size=0) const;
inline mcp_get_online_game_by_cp_id_result_params& set_cp_name(const char* s,ssize_t size=-1);
inline mcp_get_online_game_by_cp_id_result_params& set_ptr_cp_name(const char* s,ssize_t size=-1);
inline void clear_cp_name();
// @@online_game_info_t info_list=out(),array(0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::online_game_info_t >& info_list() const;
inline ::idl::vector< ::idl::online_game_info_t >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::online_game_info_t >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const ::idl::online_game_info_t& info_list(size_t i0) const;
inline ::idl::online_game_info_t* mutable_info_list(size_t i0);
// deprecated.use 'mutable_info_list' instead.
inline ::idl::online_game_info_t* m_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::string _m_cp_name;
 ::idl::vector< ::idl::online_game_info_t > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_cp_id_result_params
class mcp_get_online_game_by_cp_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_cp_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_cp_id_response* v);
explicit mcp_get_online_game_by_cp_id_response(bsl::mempool* pool);
mcp_get_online_game_by_cp_id_response(const mcp_get_online_game_by_cp_id_response& v);
~mcp_get_online_game_by_cp_id_response();
mcp_get_online_game_by_cp_id_response& operator=(const mcp_get_online_game_by_cp_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_cp_id_response& assign(const mcp_get_online_game_by_cp_id_response& v);
// @@mcp_get_online_game_by_cp_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_online_game_by_cp_id_result_params& result_params() const;
inline ::idl::mcp_get_online_game_by_cp_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_online_game_by_cp_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_online_game_by_cp_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_cp_id_response
class mcp_get_online_game_by_col_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_col_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_col_id_params* v);
explicit mcp_get_online_game_by_col_id_params(bsl::mempool* pool);
mcp_get_online_game_by_col_id_params(const mcp_get_online_game_by_col_id_params& v);
~mcp_get_online_game_by_col_id_params();
mcp_get_online_game_by_col_id_params& operator=(const mcp_get_online_game_by_col_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_col_id_params& assign(const mcp_get_online_game_by_col_id_params& v);
// @@string column_id=in();
inline bool has_column_id() const;
inline const char* column_id(unsigned int* size=0) const;
inline mcp_get_online_game_by_col_id_params& set_column_id(const char* s,ssize_t size=-1);
inline mcp_get_online_game_by_col_id_params& set_ptr_column_id(const char* s,ssize_t size=-1);
inline void clear_column_id();
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_online_game_by_col_id_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_online_game_by_col_id_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t orderby=in();
inline bool has_orderby() const;
inline uint32_t orderby() const;
inline mcp_get_online_game_by_col_id_params& set_orderby(uint32_t v);
inline void clear_orderby();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_online_game_by_col_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_online_game_by_col_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_column_id;
 ::idl::string _m_type_id;
 uint32_t _m_orderby;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_col_id_params
class mcp_get_online_game_by_col_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_col_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_col_id_result_params* v);
explicit mcp_get_online_game_by_col_id_result_params(bsl::mempool* pool);
mcp_get_online_game_by_col_id_result_params(const mcp_get_online_game_by_col_id_result_params& v);
~mcp_get_online_game_by_col_id_result_params();
mcp_get_online_game_by_col_id_result_params& operator=(const mcp_get_online_game_by_col_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_col_id_result_params& assign(const mcp_get_online_game_by_col_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_online_game_by_col_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@string name=out();
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline mcp_get_online_game_by_col_id_result_params& set_name(const char* s,ssize_t size=-1);
inline mcp_get_online_game_by_col_id_result_params& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@online_game_info_t info_list=out(),array(0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::online_game_info_t >& info_list() const;
inline ::idl::vector< ::idl::online_game_info_t >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::online_game_info_t >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const ::idl::online_game_info_t& info_list(size_t i0) const;
inline ::idl::online_game_info_t* mutable_info_list(size_t i0);
// deprecated.use 'mutable_info_list' instead.
inline ::idl::online_game_info_t* m_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::string _m_name;
 ::idl::vector< ::idl::online_game_info_t > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_col_id_result_params
class mcp_get_online_game_by_col_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_col_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_col_id_response* v);
explicit mcp_get_online_game_by_col_id_response(bsl::mempool* pool);
mcp_get_online_game_by_col_id_response(const mcp_get_online_game_by_col_id_response& v);
~mcp_get_online_game_by_col_id_response();
mcp_get_online_game_by_col_id_response& operator=(const mcp_get_online_game_by_col_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_col_id_response& assign(const mcp_get_online_game_by_col_id_response& v);
// @@mcp_get_online_game_by_col_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_online_game_by_col_id_result_params& result_params() const;
inline ::idl::mcp_get_online_game_by_col_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_online_game_by_col_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_online_game_by_col_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_col_id_response
class mcp_get_online_game_by_rank_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_rank_params* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_rank_params* v);
explicit mcp_get_online_game_by_rank_params(bsl::mempool* pool);
mcp_get_online_game_by_rank_params(const mcp_get_online_game_by_rank_params& v);
~mcp_get_online_game_by_rank_params();
mcp_get_online_game_by_rank_params& operator=(const mcp_get_online_game_by_rank_params& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_rank_params& assign(const mcp_get_online_game_by_rank_params& v);
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_online_game_by_rank_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_online_game_by_rank_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t p_type=in();
inline bool has_p_type() const;
inline uint32_t p_type() const;
inline mcp_get_online_game_by_rank_params& set_p_type(uint32_t v);
inline void clear_p_type();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_online_game_by_rank_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_online_game_by_rank_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_type_id;
 uint32_t _m_p_type;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_rank_params
class mcp_get_online_game_by_rank_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_rank_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_rank_result_params* v);
explicit mcp_get_online_game_by_rank_result_params(bsl::mempool* pool);
mcp_get_online_game_by_rank_result_params(const mcp_get_online_game_by_rank_result_params& v);
~mcp_get_online_game_by_rank_result_params();
mcp_get_online_game_by_rank_result_params& operator=(const mcp_get_online_game_by_rank_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_rank_result_params& assign(const mcp_get_online_game_by_rank_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_online_game_by_rank_result_params& set_count(int32_t v);
inline void clear_count();
// @@online_game_info_t info_list=out(),array(0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::online_game_info_t >& info_list() const;
inline ::idl::vector< ::idl::online_game_info_t >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::online_game_info_t >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const ::idl::online_game_info_t& info_list(size_t i0) const;
inline ::idl::online_game_info_t* mutable_info_list(size_t i0);
// deprecated.use 'mutable_info_list' instead.
inline ::idl::online_game_info_t* m_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::online_game_info_t > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_rank_result_params
class mcp_get_online_game_by_rank_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_online_game_by_rank_response* create(bsl::mempool* pool);
static void destroy(mcp_get_online_game_by_rank_response* v);
explicit mcp_get_online_game_by_rank_response(bsl::mempool* pool);
mcp_get_online_game_by_rank_response(const mcp_get_online_game_by_rank_response& v);
~mcp_get_online_game_by_rank_response();
mcp_get_online_game_by_rank_response& operator=(const mcp_get_online_game_by_rank_response& v);
void clear();
void check() const;
void detach();
mcp_get_online_game_by_rank_response& assign(const mcp_get_online_game_by_rank_response& v);
// @@mcp_get_online_game_by_rank_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_online_game_by_rank_result_params& result_params() const;
inline ::idl::mcp_get_online_game_by_rank_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_online_game_by_rank_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_online_game_by_rank_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_online_game_by_rank_response
class mcp_get_grab_list_by_type_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_grab_list_by_type_params* create(bsl::mempool* pool);
static void destroy(mcp_get_grab_list_by_type_params* v);
explicit mcp_get_grab_list_by_type_params(bsl::mempool* pool);
mcp_get_grab_list_by_type_params(const mcp_get_grab_list_by_type_params& v);
~mcp_get_grab_list_by_type_params();
mcp_get_grab_list_by_type_params& operator=(const mcp_get_grab_list_by_type_params& v);
void clear();
void check() const;
void detach();
mcp_get_grab_list_by_type_params& assign(const mcp_get_grab_list_by_type_params& v);
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_grab_list_by_type_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_grab_list_by_type_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_grab_list_by_type_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_grab_list_by_type_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_type_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_grab_list_by_type_params
class mcp_get_grab_list_by_type_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_grab_list_by_type_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_grab_list_by_type_result_params* v);
explicit mcp_get_grab_list_by_type_result_params(bsl::mempool* pool);
mcp_get_grab_list_by_type_result_params(const mcp_get_grab_list_by_type_result_params& v);
~mcp_get_grab_list_by_type_result_params();
mcp_get_grab_list_by_type_result_params& operator=(const mcp_get_grab_list_by_type_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_grab_list_by_type_result_params& assign(const mcp_get_grab_list_by_type_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_get_grab_list_by_type_result_params& set_result(int32_t v);
inline void clear_result();
// @@grab_info_t grab_list=out(),array(0);
inline bool has_grab_list() const;
inline const ::idl::vector< ::idl::grab_info_t >& grab_list() const;
inline ::idl::vector< ::idl::grab_info_t >* mutable_grab_list();
inline void clear_grab_list();
// deprecated.use 'mutable_grab_list' instead.
inline ::idl::vector< ::idl::grab_info_t >* m_grab_list();
// deprecated.use 'grab_list().size()' instead.
inline size_t grab_list_size() const;
inline const ::idl::grab_info_t& grab_list(size_t i0) const;
inline ::idl::grab_info_t* mutable_grab_list(size_t i0);
// deprecated.use 'mutable_grab_list' instead.
inline ::idl::grab_info_t* m_grab_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
 ::idl::vector< ::idl::grab_info_t > _m_grab_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_grab_list_by_type_result_params
class mcp_get_grab_list_by_type_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_grab_list_by_type_response* create(bsl::mempool* pool);
static void destroy(mcp_get_grab_list_by_type_response* v);
explicit mcp_get_grab_list_by_type_response(bsl::mempool* pool);
mcp_get_grab_list_by_type_response(const mcp_get_grab_list_by_type_response& v);
~mcp_get_grab_list_by_type_response();
mcp_get_grab_list_by_type_response& operator=(const mcp_get_grab_list_by_type_response& v);
void clear();
void check() const;
void detach();
mcp_get_grab_list_by_type_response& assign(const mcp_get_grab_list_by_type_response& v);
// @@mcp_get_grab_list_by_type_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_grab_list_by_type_result_params& result_params() const;
inline ::idl::mcp_get_grab_list_by_type_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_grab_list_by_type_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_grab_list_by_type_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_grab_list_by_type_response
class mcp_get_grab_info_by_c_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_grab_info_by_c_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_grab_info_by_c_id_params* v);
explicit mcp_get_grab_info_by_c_id_params(bsl::mempool* pool);
mcp_get_grab_info_by_c_id_params(const mcp_get_grab_info_by_c_id_params& v);
~mcp_get_grab_info_by_c_id_params();
mcp_get_grab_info_by_c_id_params& operator=(const mcp_get_grab_info_by_c_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_grab_info_by_c_id_params& assign(const mcp_get_grab_info_by_c_id_params& v);
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_get_grab_info_by_c_id_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_get_grab_info_by_c_id_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_c_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_grab_info_by_c_id_params
class mcp_get_grab_info_by_c_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_grab_info_by_c_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_grab_info_by_c_id_result_params* v);
explicit mcp_get_grab_info_by_c_id_result_params(bsl::mempool* pool);
mcp_get_grab_info_by_c_id_result_params(const mcp_get_grab_info_by_c_id_result_params& v);
~mcp_get_grab_info_by_c_id_result_params();
mcp_get_grab_info_by_c_id_result_params& operator=(const mcp_get_grab_info_by_c_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_grab_info_by_c_id_result_params& assign(const mcp_get_grab_info_by_c_id_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_get_grab_info_by_c_id_result_params& set_result(int32_t v);
inline void clear_result();
// @@grab_info_t grab_list=out(),array(0);
inline bool has_grab_list() const;
inline const ::idl::vector< ::idl::grab_info_t >& grab_list() const;
inline ::idl::vector< ::idl::grab_info_t >* mutable_grab_list();
inline void clear_grab_list();
// deprecated.use 'mutable_grab_list' instead.
inline ::idl::vector< ::idl::grab_info_t >* m_grab_list();
// deprecated.use 'grab_list().size()' instead.
inline size_t grab_list_size() const;
inline const ::idl::grab_info_t& grab_list(size_t i0) const;
inline ::idl::grab_info_t* mutable_grab_list(size_t i0);
// deprecated.use 'mutable_grab_list' instead.
inline ::idl::grab_info_t* m_grab_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
 ::idl::vector< ::idl::grab_info_t > _m_grab_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_grab_info_by_c_id_result_params
class mcp_get_grab_info_by_c_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_grab_info_by_c_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_grab_info_by_c_id_response* v);
explicit mcp_get_grab_info_by_c_id_response(bsl::mempool* pool);
mcp_get_grab_info_by_c_id_response(const mcp_get_grab_info_by_c_id_response& v);
~mcp_get_grab_info_by_c_id_response();
mcp_get_grab_info_by_c_id_response& operator=(const mcp_get_grab_info_by_c_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_grab_info_by_c_id_response& assign(const mcp_get_grab_info_by_c_id_response& v);
// @@mcp_get_grab_info_by_c_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_grab_info_by_c_id_result_params& result_params() const;
inline ::idl::mcp_get_grab_info_by_c_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_grab_info_by_c_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_grab_info_by_c_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_grab_info_by_c_id_response
class mcp_get_grab_info_by_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_grab_info_by_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_grab_info_by_id_params* v);
explicit mcp_get_grab_info_by_id_params(bsl::mempool* pool);
mcp_get_grab_info_by_id_params(const mcp_get_grab_info_by_id_params& v);
~mcp_get_grab_info_by_id_params();
mcp_get_grab_info_by_id_params& operator=(const mcp_get_grab_info_by_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_grab_info_by_id_params& assign(const mcp_get_grab_info_by_id_params& v);
// @@uint32_t id=in();
inline bool has_id() const;
inline uint32_t id() const;
inline mcp_get_grab_info_by_id_params& set_id(uint32_t v);
inline void clear_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_grab_info_by_id_params
class mcp_get_grab_info_by_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_grab_info_by_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_grab_info_by_id_result_params* v);
explicit mcp_get_grab_info_by_id_result_params(bsl::mempool* pool);
mcp_get_grab_info_by_id_result_params(const mcp_get_grab_info_by_id_result_params& v);
~mcp_get_grab_info_by_id_result_params();
mcp_get_grab_info_by_id_result_params& operator=(const mcp_get_grab_info_by_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_grab_info_by_id_result_params& assign(const mcp_get_grab_info_by_id_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_get_grab_info_by_id_result_params& set_result(int32_t v);
inline void clear_result();
// @@grab_info_t info=out();
inline bool has_info() const;
inline const ::idl::grab_info_t& info() const;
inline ::idl::grab_info_t* mutable_info();
// deprecated.use 'mutable_info()' instead.
inline ::idl::grab_info_t* m_info();
inline void clear_info();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
mutable ::idl::grab_info_t* _m_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_grab_info_by_id_result_params
class mcp_get_grab_info_by_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_grab_info_by_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_grab_info_by_id_response* v);
explicit mcp_get_grab_info_by_id_response(bsl::mempool* pool);
mcp_get_grab_info_by_id_response(const mcp_get_grab_info_by_id_response& v);
~mcp_get_grab_info_by_id_response();
mcp_get_grab_info_by_id_response& operator=(const mcp_get_grab_info_by_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_grab_info_by_id_response& assign(const mcp_get_grab_info_by_id_response& v);
// @@mcp_get_grab_info_by_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_grab_info_by_id_result_params& result_params() const;
inline ::idl::mcp_get_grab_info_by_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_grab_info_by_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_grab_info_by_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_grab_info_by_id_response
class mcp_user_grab_num_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_user_grab_num_params* create(bsl::mempool* pool);
static void destroy(mcp_user_grab_num_params* v);
explicit mcp_user_grab_num_params(bsl::mempool* pool);
mcp_user_grab_num_params(const mcp_user_grab_num_params& v);
~mcp_user_grab_num_params();
mcp_user_grab_num_params& operator=(const mcp_user_grab_num_params& v);
void clear();
void check() const;
void detach();
mcp_user_grab_num_params& assign(const mcp_user_grab_num_params& v);
// @@string user_id=in();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_user_grab_num_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_user_grab_num_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
// @@uint32_t grab_id=in();
inline bool has_grab_id() const;
inline uint32_t grab_id() const;
inline mcp_user_grab_num_params& set_grab_id(uint32_t v);
inline void clear_grab_id();
// @@string push_channelid=in();
inline bool has_push_channelid() const;
inline const char* push_channelid(unsigned int* size=0) const;
inline mcp_user_grab_num_params& set_push_channelid(const char* s,ssize_t size=-1);
inline mcp_user_grab_num_params& set_ptr_push_channelid(const char* s,ssize_t size=-1);
inline void clear_push_channelid();
// @@string push_userid=in();
inline bool has_push_userid() const;
inline const char* push_userid(unsigned int* size=0) const;
inline mcp_user_grab_num_params& set_push_userid(const char* s,ssize_t size=-1);
inline mcp_user_grab_num_params& set_ptr_push_userid(const char* s,ssize_t size=-1);
inline void clear_push_userid();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_user_id;
 uint32_t _m_grab_id;
 ::idl::string _m_push_channelid;
 ::idl::string _m_push_userid;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_user_grab_num_params
class mcp_user_grab_num_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_user_grab_num_result_params* create(bsl::mempool* pool);
static void destroy(mcp_user_grab_num_result_params* v);
explicit mcp_user_grab_num_result_params(bsl::mempool* pool);
mcp_user_grab_num_result_params(const mcp_user_grab_num_result_params& v);
~mcp_user_grab_num_result_params();
mcp_user_grab_num_result_params& operator=(const mcp_user_grab_num_result_params& v);
void clear();
void check() const;
void detach();
mcp_user_grab_num_result_params& assign(const mcp_user_grab_num_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_user_grab_num_result_params& set_result(int32_t v);
inline void clear_result();
// @@string num=out();
inline bool has_num() const;
inline const char* num(unsigned int* size=0) const;
inline mcp_user_grab_num_result_params& set_num(const char* s,ssize_t size=-1);
inline mcp_user_grab_num_result_params& set_ptr_num(const char* s,ssize_t size=-1);
inline void clear_num();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
 ::idl::string _m_num;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_user_grab_num_result_params
class mcp_user_grab_num_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_user_grab_num_response* create(bsl::mempool* pool);
static void destroy(mcp_user_grab_num_response* v);
explicit mcp_user_grab_num_response(bsl::mempool* pool);
mcp_user_grab_num_response(const mcp_user_grab_num_response& v);
~mcp_user_grab_num_response();
mcp_user_grab_num_response& operator=(const mcp_user_grab_num_response& v);
void clear();
void check() const;
void detach();
mcp_user_grab_num_response& assign(const mcp_user_grab_num_response& v);
// @@mcp_user_grab_num_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_user_grab_num_result_params& result_params() const;
inline ::idl::mcp_user_grab_num_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_user_grab_num_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_user_grab_num_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_user_grab_num_response
class mcp_user_grab_num_pre_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_user_grab_num_pre_params* create(bsl::mempool* pool);
static void destroy(mcp_user_grab_num_pre_params* v);
explicit mcp_user_grab_num_pre_params(bsl::mempool* pool);
mcp_user_grab_num_pre_params(const mcp_user_grab_num_pre_params& v);
~mcp_user_grab_num_pre_params();
mcp_user_grab_num_pre_params& operator=(const mcp_user_grab_num_pre_params& v);
void clear();
void check() const;
void detach();
mcp_user_grab_num_pre_params& assign(const mcp_user_grab_num_pre_params& v);
// @@string user_id=in();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_user_grab_num_pre_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_user_grab_num_pre_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
// @@uint32_t grab_id=in();
inline bool has_grab_id() const;
inline uint32_t grab_id() const;
inline mcp_user_grab_num_pre_params& set_grab_id(uint32_t v);
inline void clear_grab_id();
// @@string push_channelid=in();
inline bool has_push_channelid() const;
inline const char* push_channelid(unsigned int* size=0) const;
inline mcp_user_grab_num_pre_params& set_push_channelid(const char* s,ssize_t size=-1);
inline mcp_user_grab_num_pre_params& set_ptr_push_channelid(const char* s,ssize_t size=-1);
inline void clear_push_channelid();
// @@string push_userid=in();
inline bool has_push_userid() const;
inline const char* push_userid(unsigned int* size=0) const;
inline mcp_user_grab_num_pre_params& set_push_userid(const char* s,ssize_t size=-1);
inline mcp_user_grab_num_pre_params& set_ptr_push_userid(const char* s,ssize_t size=-1);
inline void clear_push_userid();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_user_id;
 uint32_t _m_grab_id;
 ::idl::string _m_push_channelid;
 ::idl::string _m_push_userid;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_user_grab_num_pre_params
class mcp_user_grab_num_pre_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_user_grab_num_pre_result_params* create(bsl::mempool* pool);
static void destroy(mcp_user_grab_num_pre_result_params* v);
explicit mcp_user_grab_num_pre_result_params(bsl::mempool* pool);
mcp_user_grab_num_pre_result_params(const mcp_user_grab_num_pre_result_params& v);
~mcp_user_grab_num_pre_result_params();
mcp_user_grab_num_pre_result_params& operator=(const mcp_user_grab_num_pre_result_params& v);
void clear();
void check() const;
void detach();
mcp_user_grab_num_pre_result_params& assign(const mcp_user_grab_num_pre_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_user_grab_num_pre_result_params& set_result(int32_t v);
inline void clear_result();
// @@string num=out();
inline bool has_num() const;
inline const char* num(unsigned int* size=0) const;
inline mcp_user_grab_num_pre_result_params& set_num(const char* s,ssize_t size=-1);
inline mcp_user_grab_num_pre_result_params& set_ptr_num(const char* s,ssize_t size=-1);
inline void clear_num();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
 ::idl::string _m_num;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_user_grab_num_pre_result_params
class mcp_user_grab_num_pre_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_user_grab_num_pre_response* create(bsl::mempool* pool);
static void destroy(mcp_user_grab_num_pre_response* v);
explicit mcp_user_grab_num_pre_response(bsl::mempool* pool);
mcp_user_grab_num_pre_response(const mcp_user_grab_num_pre_response& v);
~mcp_user_grab_num_pre_response();
mcp_user_grab_num_pre_response& operator=(const mcp_user_grab_num_pre_response& v);
void clear();
void check() const;
void detach();
mcp_user_grab_num_pre_response& assign(const mcp_user_grab_num_pre_response& v);
// @@mcp_user_grab_num_pre_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_user_grab_num_pre_result_params& result_params() const;
inline ::idl::mcp_user_grab_num_pre_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_user_grab_num_pre_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_user_grab_num_pre_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_user_grab_num_pre_response
class mcp_set_user_rating_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_set_user_rating_params* create(bsl::mempool* pool);
static void destroy(mcp_set_user_rating_params* v);
explicit mcp_set_user_rating_params(bsl::mempool* pool);
mcp_set_user_rating_params(const mcp_set_user_rating_params& v);
~mcp_set_user_rating_params();
mcp_set_user_rating_params& operator=(const mcp_set_user_rating_params& v);
void clear();
void check() const;
void detach();
mcp_set_user_rating_params& assign(const mcp_set_user_rating_params& v);
// @@string user_id=in();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_set_user_rating_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_set_user_rating_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_set_user_rating_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_set_user_rating_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@uint32_t rating=in();
inline bool has_rating() const;
inline uint32_t rating() const;
inline mcp_set_user_rating_params& set_rating(uint32_t v);
inline void clear_rating();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_user_id;
 ::idl::string _m_c_id;
 uint32_t _m_rating;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_set_user_rating_params
class mcp_set_user_rating_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_set_user_rating_result_params* create(bsl::mempool* pool);
static void destroy(mcp_set_user_rating_result_params* v);
explicit mcp_set_user_rating_result_params(bsl::mempool* pool);
mcp_set_user_rating_result_params(const mcp_set_user_rating_result_params& v);
~mcp_set_user_rating_result_params();
mcp_set_user_rating_result_params& operator=(const mcp_set_user_rating_result_params& v);
void clear();
void check() const;
void detach();
mcp_set_user_rating_result_params& assign(const mcp_set_user_rating_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_set_user_rating_result_params& set_result(int32_t v);
inline void clear_result();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_set_user_rating_result_params
class mcp_set_user_rating_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_set_user_rating_response* create(bsl::mempool* pool);
static void destroy(mcp_set_user_rating_response* v);
explicit mcp_set_user_rating_response(bsl::mempool* pool);
mcp_set_user_rating_response(const mcp_set_user_rating_response& v);
~mcp_set_user_rating_response();
mcp_set_user_rating_response& operator=(const mcp_set_user_rating_response& v);
void clear();
void check() const;
void detach();
mcp_set_user_rating_response& assign(const mcp_set_user_rating_response& v);
// @@mcp_set_user_rating_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_set_user_rating_result_params& result_params() const;
inline ::idl::mcp_set_user_rating_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_set_user_rating_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_set_user_rating_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_set_user_rating_response
class mcp_get_user_rating_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_user_rating_params* create(bsl::mempool* pool);
static void destroy(mcp_get_user_rating_params* v);
explicit mcp_get_user_rating_params(bsl::mempool* pool);
mcp_get_user_rating_params(const mcp_get_user_rating_params& v);
~mcp_get_user_rating_params();
mcp_get_user_rating_params& operator=(const mcp_get_user_rating_params& v);
void clear();
void check() const;
void detach();
mcp_get_user_rating_params& assign(const mcp_get_user_rating_params& v);
// @@string user_id=in();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_get_user_rating_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_get_user_rating_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_get_user_rating_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_get_user_rating_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_user_id;
 ::idl::string _m_c_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_user_rating_params
class mcp_get_user_rating_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_user_rating_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_user_rating_result_params* v);
explicit mcp_get_user_rating_result_params(bsl::mempool* pool);
mcp_get_user_rating_result_params(const mcp_get_user_rating_result_params& v);
~mcp_get_user_rating_result_params();
mcp_get_user_rating_result_params& operator=(const mcp_get_user_rating_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_user_rating_result_params& assign(const mcp_get_user_rating_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_get_user_rating_result_params& set_result(int32_t v);
inline void clear_result();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_user_rating_result_params
class mcp_get_user_rating_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_user_rating_response* create(bsl::mempool* pool);
static void destroy(mcp_get_user_rating_response* v);
explicit mcp_get_user_rating_response(bsl::mempool* pool);
mcp_get_user_rating_response(const mcp_get_user_rating_response& v);
~mcp_get_user_rating_response();
mcp_get_user_rating_response& operator=(const mcp_get_user_rating_response& v);
void clear();
void check() const;
void detach();
mcp_get_user_rating_response& assign(const mcp_get_user_rating_response& v);
// @@mcp_get_user_rating_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_user_rating_result_params& result_params() const;
inline ::idl::mcp_get_user_rating_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_user_rating_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_user_rating_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_user_rating_response
class mcp_get_calender_list_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_calender_list_params* create(bsl::mempool* pool);
static void destroy(mcp_get_calender_list_params* v);
explicit mcp_get_calender_list_params(bsl::mempool* pool);
mcp_get_calender_list_params(const mcp_get_calender_list_params& v);
~mcp_get_calender_list_params();
mcp_get_calender_list_params& operator=(const mcp_get_calender_list_params& v);
void clear();
void check() const;
void detach();
mcp_get_calender_list_params& assign(const mcp_get_calender_list_params& v);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::Unknown _unknown;
char _flag[0];
}; // class mcp_get_calender_list_params
class mcp_get_calender_list_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_calender_list_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_calender_list_result_params* v);
explicit mcp_get_calender_list_result_params(bsl::mempool* pool);
mcp_get_calender_list_result_params(const mcp_get_calender_list_result_params& v);
~mcp_get_calender_list_result_params();
mcp_get_calender_list_result_params& operator=(const mcp_get_calender_list_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_calender_list_result_params& assign(const mcp_get_calender_list_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_get_calender_list_result_params& set_result(int32_t v);
inline void clear_result();
// @@calender_info_t calender_list=out(),array(0);
inline bool has_calender_list() const;
inline const ::idl::vector< ::idl::calender_info_t >& calender_list() const;
inline ::idl::vector< ::idl::calender_info_t >* mutable_calender_list();
inline void clear_calender_list();
// deprecated.use 'mutable_calender_list' instead.
inline ::idl::vector< ::idl::calender_info_t >* m_calender_list();
// deprecated.use 'calender_list().size()' instead.
inline size_t calender_list_size() const;
inline const ::idl::calender_info_t& calender_list(size_t i0) const;
inline ::idl::calender_info_t* mutable_calender_list(size_t i0);
// deprecated.use 'mutable_calender_list' instead.
inline ::idl::calender_info_t* m_calender_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
 ::idl::vector< ::idl::calender_info_t > _m_calender_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_calender_list_result_params
class mcp_get_calender_list_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_calender_list_response* create(bsl::mempool* pool);
static void destroy(mcp_get_calender_list_response* v);
explicit mcp_get_calender_list_response(bsl::mempool* pool);
mcp_get_calender_list_response(const mcp_get_calender_list_response& v);
~mcp_get_calender_list_response();
mcp_get_calender_list_response& operator=(const mcp_get_calender_list_response& v);
void clear();
void check() const;
void detach();
mcp_get_calender_list_response& assign(const mcp_get_calender_list_response& v);
// @@mcp_get_calender_list_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_calender_list_result_params& result_params() const;
inline ::idl::mcp_get_calender_list_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_calender_list_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_calender_list_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_calender_list_response
class mcp_get_content_list_by_mixed_topic_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_mixed_topic_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_mixed_topic_id_params* v);
explicit mcp_get_content_list_by_mixed_topic_id_params(bsl::mempool* pool);
mcp_get_content_list_by_mixed_topic_id_params(const mcp_get_content_list_by_mixed_topic_id_params& v);
~mcp_get_content_list_by_mixed_topic_id_params();
mcp_get_content_list_by_mixed_topic_id_params& operator=(const mcp_get_content_list_by_mixed_topic_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_mixed_topic_id_params& assign(const mcp_get_content_list_by_mixed_topic_id_params& v);
// @@string topic_id=in();
inline bool has_topic_id() const;
inline const char* topic_id(unsigned int* size=0) const;
inline mcp_get_content_list_by_mixed_topic_id_params& set_topic_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_mixed_topic_id_params& set_ptr_topic_id(const char* s,ssize_t size=-1);
inline void clear_topic_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_content_list_by_mixed_topic_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_content_list_by_mixed_topic_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_topic_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_mixed_topic_id_params
class mcp_get_content_list_by_mixed_topic_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_mixed_topic_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_mixed_topic_id_result_params* v);
explicit mcp_get_content_list_by_mixed_topic_id_result_params(bsl::mempool* pool);
mcp_get_content_list_by_mixed_topic_id_result_params(const mcp_get_content_list_by_mixed_topic_id_result_params& v);
~mcp_get_content_list_by_mixed_topic_id_result_params();
mcp_get_content_list_by_mixed_topic_id_result_params& operator=(const mcp_get_content_list_by_mixed_topic_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_mixed_topic_id_result_params& assign(const mcp_get_content_list_by_mixed_topic_id_result_params& v);
// @@uint32_t count_soft=out();
inline bool has_count_soft() const;
inline uint32_t count_soft() const;
inline mcp_get_content_list_by_mixed_topic_id_result_params& set_count_soft(uint32_t v);
inline void clear_count_soft();
// @@uint32_t count_theme=out();
inline bool has_count_theme() const;
inline uint32_t count_theme() const;
inline mcp_get_content_list_by_mixed_topic_id_result_params& set_count_theme(uint32_t v);
inline void clear_count_theme();
// @@uint32_t count_song=out();
inline bool has_count_song() const;
inline uint32_t count_song() const;
inline mcp_get_content_list_by_mixed_topic_id_result_params& set_count_song(uint32_t v);
inline void clear_count_song();
// @@soft_info_t soft_info_list=out(),array(0);
inline bool has_soft_info_list() const;
inline const ::idl::vector< ::idl::soft_info_t >& soft_info_list() const;
inline ::idl::vector< ::idl::soft_info_t >* mutable_soft_info_list();
inline void clear_soft_info_list();
// deprecated.use 'mutable_soft_info_list' instead.
inline ::idl::vector< ::idl::soft_info_t >* m_soft_info_list();
// deprecated.use 'soft_info_list().size()' instead.
inline size_t soft_info_list_size() const;
inline const ::idl::soft_info_t& soft_info_list(size_t i0) const;
inline ::idl::soft_info_t* mutable_soft_info_list(size_t i0);
// deprecated.use 'mutable_soft_info_list' instead.
inline ::idl::soft_info_t* m_soft_info_list(size_t i0);
// @@theme_info_t theme_info_list=out(),array(0);
inline bool has_theme_info_list() const;
inline const ::idl::vector< ::idl::theme_info_t >& theme_info_list() const;
inline ::idl::vector< ::idl::theme_info_t >* mutable_theme_info_list();
inline void clear_theme_info_list();
// deprecated.use 'mutable_theme_info_list' instead.
inline ::idl::vector< ::idl::theme_info_t >* m_theme_info_list();
// deprecated.use 'theme_info_list().size()' instead.
inline size_t theme_info_list_size() const;
inline const ::idl::theme_info_t& theme_info_list(size_t i0) const;
inline ::idl::theme_info_t* mutable_theme_info_list(size_t i0);
// deprecated.use 'mutable_theme_info_list' instead.
inline ::idl::theme_info_t* m_theme_info_list(size_t i0);
// @@music_info_t music_info_list=out(),array(0);
inline bool has_music_info_list() const;
inline const ::idl::vector< ::idl::music_info_t >& music_info_list() const;
inline ::idl::vector< ::idl::music_info_t >* mutable_music_info_list();
inline void clear_music_info_list();
// deprecated.use 'mutable_music_info_list' instead.
inline ::idl::vector< ::idl::music_info_t >* m_music_info_list();
// deprecated.use 'music_info_list().size()' instead.
inline size_t music_info_list_size() const;
inline const ::idl::music_info_t& music_info_list(size_t i0) const;
inline ::idl::music_info_t* mutable_music_info_list(size_t i0);
// deprecated.use 'mutable_music_info_list' instead.
inline ::idl::music_info_t* m_music_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count_soft;
 uint32_t _m_count_theme;
 uint32_t _m_count_song;
 ::idl::vector< ::idl::soft_info_t > _m_soft_info_list;
 ::idl::vector< ::idl::theme_info_t > _m_theme_info_list;
 ::idl::vector< ::idl::music_info_t > _m_music_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_mixed_topic_id_result_params
class mcp_get_content_list_by_mixed_topic_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_mixed_topic_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_mixed_topic_id_response* v);
explicit mcp_get_content_list_by_mixed_topic_id_response(bsl::mempool* pool);
mcp_get_content_list_by_mixed_topic_id_response(const mcp_get_content_list_by_mixed_topic_id_response& v);
~mcp_get_content_list_by_mixed_topic_id_response();
mcp_get_content_list_by_mixed_topic_id_response& operator=(const mcp_get_content_list_by_mixed_topic_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_mixed_topic_id_response& assign(const mcp_get_content_list_by_mixed_topic_id_response& v);
// @@mcp_get_content_list_by_mixed_topic_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_list_by_mixed_topic_id_result_params& result_params() const;
inline ::idl::mcp_get_content_list_by_mixed_topic_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_list_by_mixed_topic_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_list_by_mixed_topic_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_mixed_topic_id_response
class mcp_get_content_list_by_mixed_topic_id1_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_mixed_topic_id1_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_mixed_topic_id1_params* v);
explicit mcp_get_content_list_by_mixed_topic_id1_params(bsl::mempool* pool);
mcp_get_content_list_by_mixed_topic_id1_params(const mcp_get_content_list_by_mixed_topic_id1_params& v);
~mcp_get_content_list_by_mixed_topic_id1_params();
mcp_get_content_list_by_mixed_topic_id1_params& operator=(const mcp_get_content_list_by_mixed_topic_id1_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_mixed_topic_id1_params& assign(const mcp_get_content_list_by_mixed_topic_id1_params& v);
// @@string topic_id=in();
inline bool has_topic_id() const;
inline const char* topic_id(unsigned int* size=0) const;
inline mcp_get_content_list_by_mixed_topic_id1_params& set_topic_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_mixed_topic_id1_params& set_ptr_topic_id(const char* s,ssize_t size=-1);
inline void clear_topic_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_content_list_by_mixed_topic_id1_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_content_list_by_mixed_topic_id1_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_topic_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_mixed_topic_id1_params
class mcp_get_content_list_by_mixed_topic_id1_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_mixed_topic_id1_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_mixed_topic_id1_result_params* v);
explicit mcp_get_content_list_by_mixed_topic_id1_result_params(bsl::mempool* pool);
mcp_get_content_list_by_mixed_topic_id1_result_params(const mcp_get_content_list_by_mixed_topic_id1_result_params& v);
~mcp_get_content_list_by_mixed_topic_id1_result_params();
mcp_get_content_list_by_mixed_topic_id1_result_params& operator=(const mcp_get_content_list_by_mixed_topic_id1_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_mixed_topic_id1_result_params& assign(const mcp_get_content_list_by_mixed_topic_id1_result_params& v);
// @@uint32_t col_num1=out();
inline bool has_col_num1() const;
inline uint32_t col_num1() const;
inline mcp_get_content_list_by_mixed_topic_id1_result_params& set_col_num1(uint32_t v);
inline void clear_col_num1();
// @@uint32_t col_num2=out();
inline bool has_col_num2() const;
inline uint32_t col_num2() const;
inline mcp_get_content_list_by_mixed_topic_id1_result_params& set_col_num2(uint32_t v);
inline void clear_col_num2();
// @@uint32_t col_num3=out();
inline bool has_col_num3() const;
inline uint32_t col_num3() const;
inline mcp_get_content_list_by_mixed_topic_id1_result_params& set_col_num3(uint32_t v);
inline void clear_col_num3();
// @@string col_id=out(),array(0);
inline bool has_col_id() const;
inline const ::idl::vector< ::idl::string >& col_id() const;
inline ::idl::vector< ::idl::string >* mutable_col_id();
inline void clear_col_id();
// deprecated.use 'mutable_col_id' instead.
inline ::idl::vector< ::idl::string >* m_col_id();
// deprecated.use 'col_id().size()' instead.
inline size_t col_id_size() const;
inline const char* col_id(size_t i0,unsigned int* size=0) const;
inline mcp_get_content_list_by_mixed_topic_id1_result_params& set_col_id(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_mixed_topic_id1_result_params& set_ptr_col_id(size_t i0,const char* s,ssize_t size=-1);
// @@string col_name=out(),array(0);
inline bool has_col_name() const;
inline const ::idl::vector< ::idl::string >& col_name() const;
inline ::idl::vector< ::idl::string >* mutable_col_name();
inline void clear_col_name();
// deprecated.use 'mutable_col_name' instead.
inline ::idl::vector< ::idl::string >* m_col_name();
// deprecated.use 'col_name().size()' instead.
inline size_t col_name_size() const;
inline const char* col_name(size_t i0,unsigned int* size=0) const;
inline mcp_get_content_list_by_mixed_topic_id1_result_params& set_col_name(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_mixed_topic_id1_result_params& set_ptr_col_name(size_t i0,const char* s,ssize_t size=-1);
// @@soft_info_t soft_info_list=out(),array(0);
inline bool has_soft_info_list() const;
inline const ::idl::vector< ::idl::soft_info_t >& soft_info_list() const;
inline ::idl::vector< ::idl::soft_info_t >* mutable_soft_info_list();
inline void clear_soft_info_list();
// deprecated.use 'mutable_soft_info_list' instead.
inline ::idl::vector< ::idl::soft_info_t >* m_soft_info_list();
// deprecated.use 'soft_info_list().size()' instead.
inline size_t soft_info_list_size() const;
inline const ::idl::soft_info_t& soft_info_list(size_t i0) const;
inline ::idl::soft_info_t* mutable_soft_info_list(size_t i0);
// deprecated.use 'mutable_soft_info_list' instead.
inline ::idl::soft_info_t* m_soft_info_list(size_t i0);
// @@theme_info_t theme_info_list=out(),array(0);
inline bool has_theme_info_list() const;
inline const ::idl::vector< ::idl::theme_info_t >& theme_info_list() const;
inline ::idl::vector< ::idl::theme_info_t >* mutable_theme_info_list();
inline void clear_theme_info_list();
// deprecated.use 'mutable_theme_info_list' instead.
inline ::idl::vector< ::idl::theme_info_t >* m_theme_info_list();
// deprecated.use 'theme_info_list().size()' instead.
inline size_t theme_info_list_size() const;
inline const ::idl::theme_info_t& theme_info_list(size_t i0) const;
inline ::idl::theme_info_t* mutable_theme_info_list(size_t i0);
// deprecated.use 'mutable_theme_info_list' instead.
inline ::idl::theme_info_t* m_theme_info_list(size_t i0);
// @@string music_id=out(),array(0);
inline bool has_music_id() const;
inline const ::idl::vector< ::idl::string >& music_id() const;
inline ::idl::vector< ::idl::string >* mutable_music_id();
inline void clear_music_id();
// deprecated.use 'mutable_music_id' instead.
inline ::idl::vector< ::idl::string >* m_music_id();
// deprecated.use 'music_id().size()' instead.
inline size_t music_id_size() const;
inline const char* music_id(size_t i0,unsigned int* size=0) const;
inline mcp_get_content_list_by_mixed_topic_id1_result_params& set_music_id(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_content_list_by_mixed_topic_id1_result_params& set_ptr_music_id(size_t i0,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_col_num1;
 uint32_t _m_col_num2;
 uint32_t _m_col_num3;
 ::idl::vector< ::idl::string > _m_col_id;
 ::idl::vector< ::idl::string > _m_col_name;
 ::idl::vector< ::idl::soft_info_t > _m_soft_info_list;
 ::idl::vector< ::idl::theme_info_t > _m_theme_info_list;
 ::idl::vector< ::idl::string > _m_music_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_mixed_topic_id1_result_params
class mcp_get_content_list_by_mixed_topic_id1_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_by_mixed_topic_id1_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_by_mixed_topic_id1_response* v);
explicit mcp_get_content_list_by_mixed_topic_id1_response(bsl::mempool* pool);
mcp_get_content_list_by_mixed_topic_id1_response(const mcp_get_content_list_by_mixed_topic_id1_response& v);
~mcp_get_content_list_by_mixed_topic_id1_response();
mcp_get_content_list_by_mixed_topic_id1_response& operator=(const mcp_get_content_list_by_mixed_topic_id1_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_by_mixed_topic_id1_response& assign(const mcp_get_content_list_by_mixed_topic_id1_response& v);
// @@mcp_get_content_list_by_mixed_topic_id1_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_list_by_mixed_topic_id1_result_params& result_params() const;
inline ::idl::mcp_get_content_list_by_mixed_topic_id1_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_list_by_mixed_topic_id1_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_list_by_mixed_topic_id1_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_by_mixed_topic_id1_response
class mcp_get_user_grab_num_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_user_grab_num_params* create(bsl::mempool* pool);
static void destroy(mcp_get_user_grab_num_params* v);
explicit mcp_get_user_grab_num_params(bsl::mempool* pool);
mcp_get_user_grab_num_params(const mcp_get_user_grab_num_params& v);
~mcp_get_user_grab_num_params();
mcp_get_user_grab_num_params& operator=(const mcp_get_user_grab_num_params& v);
void clear();
void check() const;
void detach();
mcp_get_user_grab_num_params& assign(const mcp_get_user_grab_num_params& v);
// @@string user_id=in();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_get_user_grab_num_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_get_user_grab_num_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
// @@uint32_t grab_id=in();
inline bool has_grab_id() const;
inline uint32_t grab_id() const;
inline mcp_get_user_grab_num_params& set_grab_id(uint32_t v);
inline void clear_grab_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_user_id;
 uint32_t _m_grab_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_user_grab_num_params
class mcp_get_user_grab_num_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_user_grab_num_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_user_grab_num_result_params* v);
explicit mcp_get_user_grab_num_result_params(bsl::mempool* pool);
mcp_get_user_grab_num_result_params(const mcp_get_user_grab_num_result_params& v);
~mcp_get_user_grab_num_result_params();
mcp_get_user_grab_num_result_params& operator=(const mcp_get_user_grab_num_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_user_grab_num_result_params& assign(const mcp_get_user_grab_num_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_get_user_grab_num_result_params& set_result(int32_t v);
inline void clear_result();
// @@string num=out();
inline bool has_num() const;
inline const char* num(unsigned int* size=0) const;
inline mcp_get_user_grab_num_result_params& set_num(const char* s,ssize_t size=-1);
inline mcp_get_user_grab_num_result_params& set_ptr_num(const char* s,ssize_t size=-1);
inline void clear_num();
// @@int32_t occupy=out();
inline bool has_occupy() const;
inline int32_t occupy() const;
inline mcp_get_user_grab_num_result_params& set_occupy(int32_t v);
inline void clear_occupy();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
 ::idl::string _m_num;
 int32_t _m_occupy;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_user_grab_num_result_params
class mcp_get_user_grab_num_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_user_grab_num_response* create(bsl::mempool* pool);
static void destroy(mcp_get_user_grab_num_response* v);
explicit mcp_get_user_grab_num_response(bsl::mempool* pool);
mcp_get_user_grab_num_response(const mcp_get_user_grab_num_response& v);
~mcp_get_user_grab_num_response();
mcp_get_user_grab_num_response& operator=(const mcp_get_user_grab_num_response& v);
void clear();
void check() const;
void detach();
mcp_get_user_grab_num_response& assign(const mcp_get_user_grab_num_response& v);
// @@mcp_get_user_grab_num_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_user_grab_num_result_params& result_params() const;
inline ::idl::mcp_get_user_grab_num_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_user_grab_num_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_user_grab_num_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_user_grab_num_response
class mcp_set_recently_played_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_set_recently_played_params* create(bsl::mempool* pool);
static void destroy(mcp_set_recently_played_params* v);
explicit mcp_set_recently_played_params(bsl::mempool* pool);
mcp_set_recently_played_params(const mcp_set_recently_played_params& v);
~mcp_set_recently_played_params();
mcp_set_recently_played_params& operator=(const mcp_set_recently_played_params& v);
void clear();
void check() const;
void detach();
mcp_set_recently_played_params& assign(const mcp_set_recently_played_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_set_recently_played_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_set_recently_played_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_set_recently_played_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_set_recently_played_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
 ::idl::string _m_c_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_set_recently_played_params
class mcp_set_recently_played_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_set_recently_played_result_params* create(bsl::mempool* pool);
static void destroy(mcp_set_recently_played_result_params* v);
explicit mcp_set_recently_played_result_params(bsl::mempool* pool);
mcp_set_recently_played_result_params(const mcp_set_recently_played_result_params& v);
~mcp_set_recently_played_result_params();
mcp_set_recently_played_result_params& operator=(const mcp_set_recently_played_result_params& v);
void clear();
void check() const;
void detach();
mcp_set_recently_played_result_params& assign(const mcp_set_recently_played_result_params& v);
// @@int32_t result=out();
inline bool has_result() const;
inline int32_t result() const;
inline mcp_set_recently_played_result_params& set_result(int32_t v);
inline void clear_result();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_result;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_set_recently_played_result_params
class mcp_set_recently_played_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_set_recently_played_response* create(bsl::mempool* pool);
static void destroy(mcp_set_recently_played_response* v);
explicit mcp_set_recently_played_response(bsl::mempool* pool);
mcp_set_recently_played_response(const mcp_set_recently_played_response& v);
~mcp_set_recently_played_response();
mcp_set_recently_played_response& operator=(const mcp_set_recently_played_response& v);
void clear();
void check() const;
void detach();
mcp_set_recently_played_response& assign(const mcp_set_recently_played_response& v);
// @@mcp_set_recently_played_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_set_recently_played_result_params& result_params() const;
inline ::idl::mcp_set_recently_played_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_set_recently_played_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_set_recently_played_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_set_recently_played_response
class mcp_get_recently_played_by_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_recently_played_by_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_get_recently_played_by_uid_params* v);
explicit mcp_get_recently_played_by_uid_params(bsl::mempool* pool);
mcp_get_recently_played_by_uid_params(const mcp_get_recently_played_by_uid_params& v);
~mcp_get_recently_played_by_uid_params();
mcp_get_recently_played_by_uid_params& operator=(const mcp_get_recently_played_by_uid_params& v);
void clear();
void check() const;
void detach();
mcp_get_recently_played_by_uid_params& assign(const mcp_get_recently_played_by_uid_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_get_recently_played_by_uid_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_get_recently_played_by_uid_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_recently_played_by_uid_params
class mcp_get_recently_played_by_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_recently_played_by_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_recently_played_by_uid_result_params* v);
explicit mcp_get_recently_played_by_uid_result_params(bsl::mempool* pool);
mcp_get_recently_played_by_uid_result_params(const mcp_get_recently_played_by_uid_result_params& v);
~mcp_get_recently_played_by_uid_result_params();
mcp_get_recently_played_by_uid_result_params& operator=(const mcp_get_recently_played_by_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_recently_played_by_uid_result_params& assign(const mcp_get_recently_played_by_uid_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_recently_played_by_uid_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string info_list=out(),array(0,0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& info_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const char* info_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_recently_played_by_uid_result_params& set_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_recently_played_by_uid_result_params& set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_recently_played_by_uid_result_params
class mcp_get_recently_played_by_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_recently_played_by_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_get_recently_played_by_uid_response* v);
explicit mcp_get_recently_played_by_uid_response(bsl::mempool* pool);
mcp_get_recently_played_by_uid_response(const mcp_get_recently_played_by_uid_response& v);
~mcp_get_recently_played_by_uid_response();
mcp_get_recently_played_by_uid_response& operator=(const mcp_get_recently_played_by_uid_response& v);
void clear();
void check() const;
void detach();
mcp_get_recently_played_by_uid_response& assign(const mcp_get_recently_played_by_uid_response& v);
// @@mcp_get_recently_played_by_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_recently_played_by_uid_result_params& result_params() const;
inline ::idl::mcp_get_recently_played_by_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_recently_played_by_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_recently_played_by_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_recently_played_by_uid_response
class mcp_add_game_to_favorite_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_game_to_favorite_params* create(bsl::mempool* pool);
static void destroy(mcp_add_game_to_favorite_params* v);
explicit mcp_add_game_to_favorite_params(bsl::mempool* pool);
mcp_add_game_to_favorite_params(const mcp_add_game_to_favorite_params& v);
~mcp_add_game_to_favorite_params();
mcp_add_game_to_favorite_params& operator=(const mcp_add_game_to_favorite_params& v);
void clear();
void check() const;
void detach();
mcp_add_game_to_favorite_params& assign(const mcp_add_game_to_favorite_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_add_game_to_favorite_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_add_game_to_favorite_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_add_game_to_favorite_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_add_game_to_favorite_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
 ::idl::string _m_c_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_game_to_favorite_params
class mcp_add_game_to_favorite_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_game_to_favorite_result_params* create(bsl::mempool* pool);
static void destroy(mcp_add_game_to_favorite_result_params* v);
explicit mcp_add_game_to_favorite_result_params(bsl::mempool* pool);
mcp_add_game_to_favorite_result_params(const mcp_add_game_to_favorite_result_params& v);
~mcp_add_game_to_favorite_result_params();
mcp_add_game_to_favorite_result_params& operator=(const mcp_add_game_to_favorite_result_params& v);
void clear();
void check() const;
void detach();
mcp_add_game_to_favorite_result_params& assign(const mcp_add_game_to_favorite_result_params& v);
// @@uint32_t result=out();
inline bool has_result() const;
inline uint32_t result() const;
inline mcp_add_game_to_favorite_result_params& set_result(uint32_t v);
inline void clear_result();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_result;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_game_to_favorite_result_params
class mcp_add_game_to_favorite_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_game_to_favorite_response* create(bsl::mempool* pool);
static void destroy(mcp_add_game_to_favorite_response* v);
explicit mcp_add_game_to_favorite_response(bsl::mempool* pool);
mcp_add_game_to_favorite_response(const mcp_add_game_to_favorite_response& v);
~mcp_add_game_to_favorite_response();
mcp_add_game_to_favorite_response& operator=(const mcp_add_game_to_favorite_response& v);
void clear();
void check() const;
void detach();
mcp_add_game_to_favorite_response& assign(const mcp_add_game_to_favorite_response& v);
// @@mcp_add_game_to_favorite_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_add_game_to_favorite_result_params& result_params() const;
inline ::idl::mcp_add_game_to_favorite_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_add_game_to_favorite_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_add_game_to_favorite_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_game_to_favorite_response
class mcp_get_favoraite_by_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_favoraite_by_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_get_favoraite_by_uid_params* v);
explicit mcp_get_favoraite_by_uid_params(bsl::mempool* pool);
mcp_get_favoraite_by_uid_params(const mcp_get_favoraite_by_uid_params& v);
~mcp_get_favoraite_by_uid_params();
mcp_get_favoraite_by_uid_params& operator=(const mcp_get_favoraite_by_uid_params& v);
void clear();
void check() const;
void detach();
mcp_get_favoraite_by_uid_params& assign(const mcp_get_favoraite_by_uid_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_get_favoraite_by_uid_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_get_favoraite_by_uid_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_favoraite_by_uid_params
class mcp_get_favoraite_by_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_favoraite_by_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_favoraite_by_uid_result_params* v);
explicit mcp_get_favoraite_by_uid_result_params(bsl::mempool* pool);
mcp_get_favoraite_by_uid_result_params(const mcp_get_favoraite_by_uid_result_params& v);
~mcp_get_favoraite_by_uid_result_params();
mcp_get_favoraite_by_uid_result_params& operator=(const mcp_get_favoraite_by_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_favoraite_by_uid_result_params& assign(const mcp_get_favoraite_by_uid_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_favoraite_by_uid_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string info_list=out(),array(0,0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& info_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const char* info_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_favoraite_by_uid_result_params& set_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_favoraite_by_uid_result_params& set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_favoraite_by_uid_result_params
class mcp_get_favoraite_by_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_favoraite_by_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_get_favoraite_by_uid_response* v);
explicit mcp_get_favoraite_by_uid_response(bsl::mempool* pool);
mcp_get_favoraite_by_uid_response(const mcp_get_favoraite_by_uid_response& v);
~mcp_get_favoraite_by_uid_response();
mcp_get_favoraite_by_uid_response& operator=(const mcp_get_favoraite_by_uid_response& v);
void clear();
void check() const;
void detach();
mcp_get_favoraite_by_uid_response& assign(const mcp_get_favoraite_by_uid_response& v);
// @@mcp_get_favoraite_by_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_favoraite_by_uid_result_params& result_params() const;
inline ::idl::mcp_get_favoraite_by_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_favoraite_by_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_favoraite_by_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_favoraite_by_uid_response
class mcp_get_H5_latest_on_shelf_by_date_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_H5_latest_on_shelf_by_date_params* create(bsl::mempool* pool);
static void destroy(mcp_get_H5_latest_on_shelf_by_date_params* v);
explicit mcp_get_H5_latest_on_shelf_by_date_params(bsl::mempool* pool);
mcp_get_H5_latest_on_shelf_by_date_params(const mcp_get_H5_latest_on_shelf_by_date_params& v);
~mcp_get_H5_latest_on_shelf_by_date_params();
mcp_get_H5_latest_on_shelf_by_date_params& operator=(const mcp_get_H5_latest_on_shelf_by_date_params& v);
void clear();
void check() const;
void detach();
mcp_get_H5_latest_on_shelf_by_date_params& assign(const mcp_get_H5_latest_on_shelf_by_date_params& v);
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_H5_latest_on_shelf_by_date_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_H5_latest_on_shelf_by_date_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_H5_latest_on_shelf_by_date_params
class mcp_get_H5_latest_on_shelf_by_date_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_H5_latest_on_shelf_by_date_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_H5_latest_on_shelf_by_date_result_params* v);
explicit mcp_get_H5_latest_on_shelf_by_date_result_params(bsl::mempool* pool);
mcp_get_H5_latest_on_shelf_by_date_result_params(const mcp_get_H5_latest_on_shelf_by_date_result_params& v);
~mcp_get_H5_latest_on_shelf_by_date_result_params();
mcp_get_H5_latest_on_shelf_by_date_result_params& operator=(const mcp_get_H5_latest_on_shelf_by_date_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_H5_latest_on_shelf_by_date_result_params& assign(const mcp_get_H5_latest_on_shelf_by_date_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_H5_latest_on_shelf_by_date_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string info_list=out(),array(0,0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& info_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const char* info_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_H5_latest_on_shelf_by_date_result_params& set_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_H5_latest_on_shelf_by_date_result_params& set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_H5_latest_on_shelf_by_date_result_params
class mcp_get_H5_latest_on_shelf_by_date_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_H5_latest_on_shelf_by_date_response* create(bsl::mempool* pool);
static void destroy(mcp_get_H5_latest_on_shelf_by_date_response* v);
explicit mcp_get_H5_latest_on_shelf_by_date_response(bsl::mempool* pool);
mcp_get_H5_latest_on_shelf_by_date_response(const mcp_get_H5_latest_on_shelf_by_date_response& v);
~mcp_get_H5_latest_on_shelf_by_date_response();
mcp_get_H5_latest_on_shelf_by_date_response& operator=(const mcp_get_H5_latest_on_shelf_by_date_response& v);
void clear();
void check() const;
void detach();
mcp_get_H5_latest_on_shelf_by_date_response& assign(const mcp_get_H5_latest_on_shelf_by_date_response& v);
// @@mcp_get_H5_latest_on_shelf_by_date_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_H5_latest_on_shelf_by_date_result_params& result_params() const;
inline ::idl::mcp_get_H5_latest_on_shelf_by_date_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_H5_latest_on_shelf_by_date_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_H5_latest_on_shelf_by_date_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_H5_latest_on_shelf_by_date_response
class mcp_get_H5_latest_on_shelf_by_date_and_type_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_H5_latest_on_shelf_by_date_and_type_params* create(bsl::mempool* pool);
static void destroy(mcp_get_H5_latest_on_shelf_by_date_and_type_params* v);
explicit mcp_get_H5_latest_on_shelf_by_date_and_type_params(bsl::mempool* pool);
mcp_get_H5_latest_on_shelf_by_date_and_type_params(const mcp_get_H5_latest_on_shelf_by_date_and_type_params& v);
~mcp_get_H5_latest_on_shelf_by_date_and_type_params();
mcp_get_H5_latest_on_shelf_by_date_and_type_params& operator=(const mcp_get_H5_latest_on_shelf_by_date_and_type_params& v);
void clear();
void check() const;
void detach();
mcp_get_H5_latest_on_shelf_by_date_and_type_params& assign(const mcp_get_H5_latest_on_shelf_by_date_and_type_params& v);
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
// @@string content_type=in();
inline bool has_content_type() const;
inline const char* content_type(unsigned int* size=0) const;
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params& set_content_type(const char* s,ssize_t size=-1);
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params& set_ptr_content_type(const char* s,ssize_t size=-1);
inline void clear_content_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
 ::idl::string _m_content_type;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_H5_latest_on_shelf_by_date_and_type_params
class mcp_get_H5_latest_on_shelf_by_date_and_type_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_H5_latest_on_shelf_by_date_and_type_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_H5_latest_on_shelf_by_date_and_type_result_params* v);
explicit mcp_get_H5_latest_on_shelf_by_date_and_type_result_params(bsl::mempool* pool);
mcp_get_H5_latest_on_shelf_by_date_and_type_result_params(const mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& v);
~mcp_get_H5_latest_on_shelf_by_date_and_type_result_params();
mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& operator=(const mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& assign(const mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string info_list=out(),array(0,0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& info_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const char* info_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& set_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_H5_latest_on_shelf_by_date_and_type_result_params
class mcp_get_H5_latest_on_shelf_by_date_and_type_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_H5_latest_on_shelf_by_date_and_type_response* create(bsl::mempool* pool);
static void destroy(mcp_get_H5_latest_on_shelf_by_date_and_type_response* v);
explicit mcp_get_H5_latest_on_shelf_by_date_and_type_response(bsl::mempool* pool);
mcp_get_H5_latest_on_shelf_by_date_and_type_response(const mcp_get_H5_latest_on_shelf_by_date_and_type_response& v);
~mcp_get_H5_latest_on_shelf_by_date_and_type_response();
mcp_get_H5_latest_on_shelf_by_date_and_type_response& operator=(const mcp_get_H5_latest_on_shelf_by_date_and_type_response& v);
void clear();
void check() const;
void detach();
mcp_get_H5_latest_on_shelf_by_date_and_type_response& assign(const mcp_get_H5_latest_on_shelf_by_date_and_type_response& v);
// @@mcp_get_H5_latest_on_shelf_by_date_and_type_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& result_params() const;
inline ::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_H5_latest_on_shelf_by_date_and_type_response
class mcp_get_H5_info_list_by_col_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_H5_info_list_by_col_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_H5_info_list_by_col_id_params* v);
explicit mcp_get_H5_info_list_by_col_id_params(bsl::mempool* pool);
mcp_get_H5_info_list_by_col_id_params(const mcp_get_H5_info_list_by_col_id_params& v);
~mcp_get_H5_info_list_by_col_id_params();
mcp_get_H5_info_list_by_col_id_params& operator=(const mcp_get_H5_info_list_by_col_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_H5_info_list_by_col_id_params& assign(const mcp_get_H5_info_list_by_col_id_params& v);
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_H5_info_list_by_col_id_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_H5_info_list_by_col_id_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
// @@string col_id=in();
inline bool has_col_id() const;
inline const char* col_id(unsigned int* size=0) const;
inline mcp_get_H5_info_list_by_col_id_params& set_col_id(const char* s,ssize_t size=-1);
inline mcp_get_H5_info_list_by_col_id_params& set_ptr_col_id(const char* s,ssize_t size=-1);
inline void clear_col_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
 ::idl::string _m_col_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_H5_info_list_by_col_id_params
class mcp_get_H5_info_list_by_col_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_H5_info_list_by_col_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_H5_info_list_by_col_id_result_params* v);
explicit mcp_get_H5_info_list_by_col_id_result_params(bsl::mempool* pool);
mcp_get_H5_info_list_by_col_id_result_params(const mcp_get_H5_info_list_by_col_id_result_params& v);
~mcp_get_H5_info_list_by_col_id_result_params();
mcp_get_H5_info_list_by_col_id_result_params& operator=(const mcp_get_H5_info_list_by_col_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_H5_info_list_by_col_id_result_params& assign(const mcp_get_H5_info_list_by_col_id_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_H5_info_list_by_col_id_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string info_list=out(),array(0,0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& info_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const char* info_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_H5_info_list_by_col_id_result_params& set_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_H5_info_list_by_col_id_result_params& set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_H5_info_list_by_col_id_result_params
class mcp_get_H5_info_list_by_col_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_H5_info_list_by_col_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_H5_info_list_by_col_id_response* v);
explicit mcp_get_H5_info_list_by_col_id_response(bsl::mempool* pool);
mcp_get_H5_info_list_by_col_id_response(const mcp_get_H5_info_list_by_col_id_response& v);
~mcp_get_H5_info_list_by_col_id_response();
mcp_get_H5_info_list_by_col_id_response& operator=(const mcp_get_H5_info_list_by_col_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_H5_info_list_by_col_id_response& assign(const mcp_get_H5_info_list_by_col_id_response& v);
// @@mcp_get_H5_info_list_by_col_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_H5_info_list_by_col_id_result_params& result_params() const;
inline ::idl::mcp_get_H5_info_list_by_col_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_H5_info_list_by_col_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_H5_info_list_by_col_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_H5_info_list_by_col_id_response
class mcp_get_imgurls_and_favorite_by_uid_cid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_imgurls_and_favorite_by_uid_cid_params* create(bsl::mempool* pool);
static void destroy(mcp_get_imgurls_and_favorite_by_uid_cid_params* v);
explicit mcp_get_imgurls_and_favorite_by_uid_cid_params(bsl::mempool* pool);
mcp_get_imgurls_and_favorite_by_uid_cid_params(const mcp_get_imgurls_and_favorite_by_uid_cid_params& v);
~mcp_get_imgurls_and_favorite_by_uid_cid_params();
mcp_get_imgurls_and_favorite_by_uid_cid_params& operator=(const mcp_get_imgurls_and_favorite_by_uid_cid_params& v);
void clear();
void check() const;
void detach();
mcp_get_imgurls_and_favorite_by_uid_cid_params& assign(const mcp_get_imgurls_and_favorite_by_uid_cid_params& v);
// @@string uid=in();
inline bool has_uid() const;
inline const char* uid(unsigned int* size=0) const;
inline mcp_get_imgurls_and_favorite_by_uid_cid_params& set_uid(const char* s,ssize_t size=-1);
inline mcp_get_imgurls_and_favorite_by_uid_cid_params& set_ptr_uid(const char* s,ssize_t size=-1);
inline void clear_uid();
// @@string cid=in();
inline bool has_cid() const;
inline const char* cid(unsigned int* size=0) const;
inline mcp_get_imgurls_and_favorite_by_uid_cid_params& set_cid(const char* s,ssize_t size=-1);
inline mcp_get_imgurls_and_favorite_by_uid_cid_params& set_ptr_cid(const char* s,ssize_t size=-1);
inline void clear_cid();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_uid;
 ::idl::string _m_cid;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_imgurls_and_favorite_by_uid_cid_params
class mcp_get_imgurls_and_favorite_by_uid_cid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_imgurls_and_favorite_by_uid_cid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_imgurls_and_favorite_by_uid_cid_result_params* v);
explicit mcp_get_imgurls_and_favorite_by_uid_cid_result_params(bsl::mempool* pool);
mcp_get_imgurls_and_favorite_by_uid_cid_result_params(const mcp_get_imgurls_and_favorite_by_uid_cid_result_params& v);
~mcp_get_imgurls_and_favorite_by_uid_cid_result_params();
mcp_get_imgurls_and_favorite_by_uid_cid_result_params& operator=(const mcp_get_imgurls_and_favorite_by_uid_cid_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_imgurls_and_favorite_by_uid_cid_result_params& assign(const mcp_get_imgurls_and_favorite_by_uid_cid_result_params& v);
// @@string icon_url=out();
inline bool has_icon_url() const;
inline const char* icon_url(unsigned int* size=0) const;
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& set_icon_url(const char* s,ssize_t size=-1);
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& set_ptr_icon_url(const char* s,ssize_t size=-1);
inline void clear_icon_url();
// @@string xc_url1=out();
inline bool has_xc_url1() const;
inline const char* xc_url1(unsigned int* size=0) const;
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& set_xc_url1(const char* s,ssize_t size=-1);
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& set_ptr_xc_url1(const char* s,ssize_t size=-1);
inline void clear_xc_url1();
// @@string xc_url2=out();
inline bool has_xc_url2() const;
inline const char* xc_url2(unsigned int* size=0) const;
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& set_xc_url2(const char* s,ssize_t size=-1);
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& set_ptr_xc_url2(const char* s,ssize_t size=-1);
inline void clear_xc_url2();
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string xq_url=out(),array(0);
inline bool has_xq_url() const;
inline const ::idl::vector< ::idl::string >& xq_url() const;
inline ::idl::vector< ::idl::string >* mutable_xq_url();
inline void clear_xq_url();
// deprecated.use 'mutable_xq_url' instead.
inline ::idl::vector< ::idl::string >* m_xq_url();
// deprecated.use 'xq_url().size()' instead.
inline size_t xq_url_size() const;
inline const char* xq_url(size_t i0,unsigned int* size=0) const;
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& set_xq_url(size_t i0,const char* s,ssize_t size=-1);
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& set_ptr_xq_url(size_t i0,const char* s,ssize_t size=-1);
// @@uint32_t is_favorite=out();
inline bool has_is_favorite() const;
inline uint32_t is_favorite() const;
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& set_is_favorite(uint32_t v);
inline void clear_is_favorite();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_icon_url;
 ::idl::string _m_xc_url1;
 ::idl::string _m_xc_url2;
 uint32_t _m_count;
 ::idl::vector< ::idl::string > _m_xq_url;
 uint32_t _m_is_favorite;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_imgurls_and_favorite_by_uid_cid_result_params
class mcp_get_imgurls_and_favorite_by_uid_cid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_imgurls_and_favorite_by_uid_cid_response* create(bsl::mempool* pool);
static void destroy(mcp_get_imgurls_and_favorite_by_uid_cid_response* v);
explicit mcp_get_imgurls_and_favorite_by_uid_cid_response(bsl::mempool* pool);
mcp_get_imgurls_and_favorite_by_uid_cid_response(const mcp_get_imgurls_and_favorite_by_uid_cid_response& v);
~mcp_get_imgurls_and_favorite_by_uid_cid_response();
mcp_get_imgurls_and_favorite_by_uid_cid_response& operator=(const mcp_get_imgurls_and_favorite_by_uid_cid_response& v);
void clear();
void check() const;
void detach();
mcp_get_imgurls_and_favorite_by_uid_cid_response& assign(const mcp_get_imgurls_and_favorite_by_uid_cid_response& v);
// @@mcp_get_imgurls_and_favorite_by_uid_cid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params& result_params() const;
inline ::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_imgurls_and_favorite_by_uid_cid_response
class mcp_get_random_h5_games_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_random_h5_games_params* create(bsl::mempool* pool);
static void destroy(mcp_get_random_h5_games_params* v);
explicit mcp_get_random_h5_games_params(bsl::mempool* pool);
mcp_get_random_h5_games_params(const mcp_get_random_h5_games_params& v);
~mcp_get_random_h5_games_params();
mcp_get_random_h5_games_params& operator=(const mcp_get_random_h5_games_params& v);
void clear();
void check() const;
void detach();
mcp_get_random_h5_games_params& assign(const mcp_get_random_h5_games_params& v);
// @@uint32_t count=in();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_random_h5_games_params& set_count(uint32_t v);
inline void clear_count();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_random_h5_games_params
class mcp_get_random_h5_games_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_random_h5_games_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_random_h5_games_result_params* v);
explicit mcp_get_random_h5_games_result_params(bsl::mempool* pool);
mcp_get_random_h5_games_result_params(const mcp_get_random_h5_games_result_params& v);
~mcp_get_random_h5_games_result_params();
mcp_get_random_h5_games_result_params& operator=(const mcp_get_random_h5_games_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_random_h5_games_result_params& assign(const mcp_get_random_h5_games_result_params& v);
// @@uint32_t actual_count=out();
inline bool has_actual_count() const;
inline uint32_t actual_count() const;
inline mcp_get_random_h5_games_result_params& set_actual_count(uint32_t v);
inline void clear_actual_count();
// @@string info_list=out(),array(0,0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& info_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const char* info_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_random_h5_games_result_params& set_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_random_h5_games_result_params& set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_actual_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_random_h5_games_result_params
class mcp_get_random_h5_games_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_random_h5_games_response* create(bsl::mempool* pool);
static void destroy(mcp_get_random_h5_games_response* v);
explicit mcp_get_random_h5_games_response(bsl::mempool* pool);
mcp_get_random_h5_games_response(const mcp_get_random_h5_games_response& v);
~mcp_get_random_h5_games_response();
mcp_get_random_h5_games_response& operator=(const mcp_get_random_h5_games_response& v);
void clear();
void check() const;
void detach();
mcp_get_random_h5_games_response& assign(const mcp_get_random_h5_games_response& v);
// @@mcp_get_random_h5_games_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_random_h5_games_result_params& result_params() const;
inline ::idl::mcp_get_random_h5_games_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_random_h5_games_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_random_h5_games_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_random_h5_games_response
class mcp_get_info_by_col_id_and_type_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_info_by_col_id_and_type_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_info_by_col_id_and_type_id_params* v);
explicit mcp_get_info_by_col_id_and_type_id_params(bsl::mempool* pool);
mcp_get_info_by_col_id_and_type_id_params(const mcp_get_info_by_col_id_and_type_id_params& v);
~mcp_get_info_by_col_id_and_type_id_params();
mcp_get_info_by_col_id_and_type_id_params& operator=(const mcp_get_info_by_col_id_and_type_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_info_by_col_id_and_type_id_params& assign(const mcp_get_info_by_col_id_and_type_id_params& v);
// @@string col_id=in();
inline bool has_col_id() const;
inline const char* col_id(unsigned int* size=0) const;
inline mcp_get_info_by_col_id_and_type_id_params& set_col_id(const char* s,ssize_t size=-1);
inline mcp_get_info_by_col_id_and_type_id_params& set_ptr_col_id(const char* s,ssize_t size=-1);
inline void clear_col_id();
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_info_by_col_id_and_type_id_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_info_by_col_id_and_type_id_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_info_by_col_id_and_type_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_info_by_col_id_and_type_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_col_id;
 ::idl::string _m_type_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_info_by_col_id_and_type_id_params
class mcp_get_info_by_col_id_and_type_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_info_by_col_id_and_type_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_info_by_col_id_and_type_id_result_params* v);
explicit mcp_get_info_by_col_id_and_type_id_result_params(bsl::mempool* pool);
mcp_get_info_by_col_id_and_type_id_result_params(const mcp_get_info_by_col_id_and_type_id_result_params& v);
~mcp_get_info_by_col_id_and_type_id_result_params();
mcp_get_info_by_col_id_and_type_id_result_params& operator=(const mcp_get_info_by_col_id_and_type_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_info_by_col_id_and_type_id_result_params& assign(const mcp_get_info_by_col_id_and_type_id_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_info_by_col_id_and_type_id_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string info_list=out(),array(0,0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& info_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const char* info_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_info_by_col_id_and_type_id_result_params& set_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_info_by_col_id_and_type_id_result_params& set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_info_by_col_id_and_type_id_result_params
class mcp_get_info_by_col_id_and_type_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_info_by_col_id_and_type_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_info_by_col_id_and_type_id_response* v);
explicit mcp_get_info_by_col_id_and_type_id_response(bsl::mempool* pool);
mcp_get_info_by_col_id_and_type_id_response(const mcp_get_info_by_col_id_and_type_id_response& v);
~mcp_get_info_by_col_id_and_type_id_response();
mcp_get_info_by_col_id_and_type_id_response& operator=(const mcp_get_info_by_col_id_and_type_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_info_by_col_id_and_type_id_response& assign(const mcp_get_info_by_col_id_and_type_id_response& v);
// @@mcp_get_info_by_col_id_and_type_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_info_by_col_id_and_type_id_result_params& result_params() const;
inline ::idl::mcp_get_info_by_col_id_and_type_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_info_by_col_id_and_type_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_info_by_col_id_and_type_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_info_by_col_id_and_type_id_response
class mcp_get_info_by_col_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_info_by_col_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_info_by_col_id_params* v);
explicit mcp_get_info_by_col_id_params(bsl::mempool* pool);
mcp_get_info_by_col_id_params(const mcp_get_info_by_col_id_params& v);
~mcp_get_info_by_col_id_params();
mcp_get_info_by_col_id_params& operator=(const mcp_get_info_by_col_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_info_by_col_id_params& assign(const mcp_get_info_by_col_id_params& v);
// @@string col_id=in();
inline bool has_col_id() const;
inline const char* col_id(unsigned int* size=0) const;
inline mcp_get_info_by_col_id_params& set_col_id(const char* s,ssize_t size=-1);
inline mcp_get_info_by_col_id_params& set_ptr_col_id(const char* s,ssize_t size=-1);
inline void clear_col_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_info_by_col_id_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_info_by_col_id_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_col_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_info_by_col_id_params
class mcp_get_info_by_col_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_info_by_col_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_info_by_col_id_result_params* v);
explicit mcp_get_info_by_col_id_result_params(bsl::mempool* pool);
mcp_get_info_by_col_id_result_params(const mcp_get_info_by_col_id_result_params& v);
~mcp_get_info_by_col_id_result_params();
mcp_get_info_by_col_id_result_params& operator=(const mcp_get_info_by_col_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_info_by_col_id_result_params& assign(const mcp_get_info_by_col_id_result_params& v);
// @@string col_name=out();
inline bool has_col_name() const;
inline const char* col_name(unsigned int* size=0) const;
inline mcp_get_info_by_col_id_result_params& set_col_name(const char* s,ssize_t size=-1);
inline mcp_get_info_by_col_id_result_params& set_ptr_col_name(const char* s,ssize_t size=-1);
inline void clear_col_name();
// @@string type_id=out();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_info_by_col_id_result_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_info_by_col_id_result_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_info_by_col_id_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string info_list=out(),array(0,0);
inline bool has_info_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& info_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_info_list();
inline void clear_info_list();
// deprecated.use 'mutable_info_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_info_list();
// deprecated.use 'info_list().size()' instead.
inline size_t info_list_size() const;
inline const char* info_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_info_by_col_id_result_params& set_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_info_by_col_id_result_params& set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_col_name;
 ::idl::string _m_type_id;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_info_by_col_id_result_params
class mcp_get_info_by_col_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_info_by_col_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_info_by_col_id_response* v);
explicit mcp_get_info_by_col_id_response(bsl::mempool* pool);
mcp_get_info_by_col_id_response(const mcp_get_info_by_col_id_response& v);
~mcp_get_info_by_col_id_response();
mcp_get_info_by_col_id_response& operator=(const mcp_get_info_by_col_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_info_by_col_id_response& assign(const mcp_get_info_by_col_id_response& v);
// @@mcp_get_info_by_col_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_info_by_col_id_result_params& result_params() const;
inline ::idl::mcp_get_info_by_col_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_info_by_col_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_info_by_col_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_info_by_col_id_response
class mcp_get_soft_by_date_or_star_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_soft_by_date_or_star_params* create(bsl::mempool* pool);
static void destroy(mcp_get_soft_by_date_or_star_params* v);
explicit mcp_get_soft_by_date_or_star_params(bsl::mempool* pool);
mcp_get_soft_by_date_or_star_params(const mcp_get_soft_by_date_or_star_params& v);
~mcp_get_soft_by_date_or_star_params();
mcp_get_soft_by_date_or_star_params& operator=(const mcp_get_soft_by_date_or_star_params& v);
void clear();
void check() const;
void detach();
mcp_get_soft_by_date_or_star_params& assign(const mcp_get_soft_by_date_or_star_params& v);
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_soft_by_date_or_star_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_soft_by_date_or_star_params& set_page_size(uint32_t v);
inline void clear_page_size();
// @@uint32_t orderby=in();
inline bool has_orderby() const;
inline uint32_t orderby() const;
inline mcp_get_soft_by_date_or_star_params& set_orderby(uint32_t v);
inline void clear_orderby();
// @@uint32_t for_adapt=in();
inline bool has_for_adapt() const;
inline uint32_t for_adapt() const;
inline mcp_get_soft_by_date_or_star_params& set_for_adapt(uint32_t v);
inline void clear_for_adapt();
// @@string except_class_ids=in();
inline bool has_except_class_ids() const;
inline const char* except_class_ids(unsigned int* size=0) const;
inline mcp_get_soft_by_date_or_star_params& set_except_class_ids(const char* s,ssize_t size=-1);
inline mcp_get_soft_by_date_or_star_params& set_ptr_except_class_ids(const char* s,ssize_t size=-1);
inline void clear_except_class_ids();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_page;
 uint32_t _m_page_size;
 uint32_t _m_orderby;
 uint32_t _m_for_adapt;
 ::idl::string _m_except_class_ids;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_soft_by_date_or_star_params
class mcp_get_soft_by_date_or_star_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_soft_by_date_or_star_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_soft_by_date_or_star_result_params* v);
explicit mcp_get_soft_by_date_or_star_result_params(bsl::mempool* pool);
mcp_get_soft_by_date_or_star_result_params(const mcp_get_soft_by_date_or_star_result_params& v);
~mcp_get_soft_by_date_or_star_result_params();
mcp_get_soft_by_date_or_star_result_params& operator=(const mcp_get_soft_by_date_or_star_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_soft_by_date_or_star_result_params& assign(const mcp_get_soft_by_date_or_star_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_soft_by_date_or_star_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string soft_list=out(),array(0,0);
inline bool has_soft_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& soft_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_soft_list();
inline void clear_soft_list();
// deprecated.use 'mutable_soft_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_soft_list();
// deprecated.use 'soft_list().size()' instead.
inline size_t soft_list_size() const;
inline const char* soft_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_soft_by_date_or_star_result_params& set_soft_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_soft_by_date_or_star_result_params& set_ptr_soft_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_soft_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_soft_by_date_or_star_result_params
class mcp_get_soft_by_date_or_star_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_soft_by_date_or_star_response* create(bsl::mempool* pool);
static void destroy(mcp_get_soft_by_date_or_star_response* v);
explicit mcp_get_soft_by_date_or_star_response(bsl::mempool* pool);
mcp_get_soft_by_date_or_star_response(const mcp_get_soft_by_date_or_star_response& v);
~mcp_get_soft_by_date_or_star_response();
mcp_get_soft_by_date_or_star_response& operator=(const mcp_get_soft_by_date_or_star_response& v);
void clear();
void check() const;
void detach();
mcp_get_soft_by_date_or_star_response& assign(const mcp_get_soft_by_date_or_star_response& v);
// @@mcp_get_soft_by_date_or_star_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_soft_by_date_or_star_result_params& result_params() const;
inline ::idl::mcp_get_soft_by_date_or_star_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_soft_by_date_or_star_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_soft_by_date_or_star_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_soft_by_date_or_star_response
class mcp_get_star_by_cid_and_type_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_star_by_cid_and_type_params* create(bsl::mempool* pool);
static void destroy(mcp_get_star_by_cid_and_type_params* v);
explicit mcp_get_star_by_cid_and_type_params(bsl::mempool* pool);
mcp_get_star_by_cid_and_type_params(const mcp_get_star_by_cid_and_type_params& v);
~mcp_get_star_by_cid_and_type_params();
mcp_get_star_by_cid_and_type_params& operator=(const mcp_get_star_by_cid_and_type_params& v);
void clear();
void check() const;
void detach();
mcp_get_star_by_cid_and_type_params& assign(const mcp_get_star_by_cid_and_type_params& v);
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_get_star_by_cid_and_type_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_get_star_by_cid_and_type_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_star_by_cid_and_type_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_star_by_cid_and_type_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_c_id;
 ::idl::string _m_type_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_star_by_cid_and_type_params
class mcp_get_star_by_cid_and_type_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_star_by_cid_and_type_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_star_by_cid_and_type_result_params* v);
explicit mcp_get_star_by_cid_and_type_result_params(bsl::mempool* pool);
mcp_get_star_by_cid_and_type_result_params(const mcp_get_star_by_cid_and_type_result_params& v);
~mcp_get_star_by_cid_and_type_result_params();
mcp_get_star_by_cid_and_type_result_params& operator=(const mcp_get_star_by_cid_and_type_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_star_by_cid_and_type_result_params& assign(const mcp_get_star_by_cid_and_type_result_params& v);
// @@uint32_t star=out();
inline bool has_star() const;
inline uint32_t star() const;
inline mcp_get_star_by_cid_and_type_result_params& set_star(uint32_t v);
inline void clear_star();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_star;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_star_by_cid_and_type_result_params
class mcp_get_star_by_cid_and_type_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_star_by_cid_and_type_response* create(bsl::mempool* pool);
static void destroy(mcp_get_star_by_cid_and_type_response* v);
explicit mcp_get_star_by_cid_and_type_response(bsl::mempool* pool);
mcp_get_star_by_cid_and_type_response(const mcp_get_star_by_cid_and_type_response& v);
~mcp_get_star_by_cid_and_type_response();
mcp_get_star_by_cid_and_type_response& operator=(const mcp_get_star_by_cid_and_type_response& v);
void clear();
void check() const;
void detach();
mcp_get_star_by_cid_and_type_response& assign(const mcp_get_star_by_cid_and_type_response& v);
// @@mcp_get_star_by_cid_and_type_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_star_by_cid_and_type_result_params& result_params() const;
inline ::idl::mcp_get_star_by_cid_and_type_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_star_by_cid_and_type_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_star_by_cid_and_type_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_star_by_cid_and_type_response
class mcp_get_content_list_from_classID_with_weight_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_classID_with_weight_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_classID_with_weight_params* v);
explicit mcp_get_content_list_from_classID_with_weight_params(bsl::mempool* pool);
mcp_get_content_list_from_classID_with_weight_params(const mcp_get_content_list_from_classID_with_weight_params& v);
~mcp_get_content_list_from_classID_with_weight_params();
mcp_get_content_list_from_classID_with_weight_params& operator=(const mcp_get_content_list_from_classID_with_weight_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_classID_with_weight_params& assign(const mcp_get_content_list_from_classID_with_weight_params& v);
// @@string class_id=in();
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_get_content_list_from_classID_with_weight_params& set_class_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_classID_with_weight_params& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
// @@string content_type_id=in();
inline bool has_content_type_id() const;
inline const char* content_type_id(unsigned int* size=0) const;
inline mcp_get_content_list_from_classID_with_weight_params& set_content_type_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_classID_with_weight_params& set_ptr_content_type_id(const char* s,ssize_t size=-1);
inline void clear_content_type_id();
// @@uint32_t priority=in();
inline bool has_priority() const;
inline uint32_t priority() const;
inline mcp_get_content_list_from_classID_with_weight_params& set_priority(uint32_t v);
inline void clear_priority();
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_content_list_from_classID_with_weight_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_classID_with_weight_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@uint32_t info_type=in();
inline bool has_info_type() const;
inline uint32_t info_type() const;
inline mcp_get_content_list_from_classID_with_weight_params& set_info_type(uint32_t v);
inline void clear_info_type();
// @@string img_size=in();
inline bool has_img_size() const;
inline const char* img_size(unsigned int* size=0) const;
inline mcp_get_content_list_from_classID_with_weight_params& set_img_size(const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_classID_with_weight_params& set_ptr_img_size(const char* s,ssize_t size=-1);
inline void clear_img_size();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_content_list_from_classID_with_weight_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_content_list_from_classID_with_weight_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
// @@uint32_t for_adapt=in();
inline bool has_for_adapt() const;
inline uint32_t for_adapt() const;
inline mcp_get_content_list_from_classID_with_weight_params& set_for_adapt(uint32_t v);
inline void clear_for_adapt();
// @@int32_t weight_type=in();
inline bool has_weight_type() const;
inline int32_t weight_type() const;
inline mcp_get_content_list_from_classID_with_weight_params& set_weight_type(int32_t v);
inline void clear_weight_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_class_id;
 ::idl::string _m_content_type_id;
 uint32_t _m_priority;
 ::idl::string _m_info_id;
 uint32_t _m_info_type;
 ::idl::string _m_img_size;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
 uint32_t _m_for_adapt;
 int32_t _m_weight_type;
mutable ::idl::Unknown _unknown;
char _flag[2];
}; // class mcp_get_content_list_from_classID_with_weight_params
class mcp_get_content_list_from_classID_with_weight_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_classID_with_weight_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_classID_with_weight_result_params* v);
explicit mcp_get_content_list_from_classID_with_weight_result_params(bsl::mempool* pool);
mcp_get_content_list_from_classID_with_weight_result_params(const mcp_get_content_list_from_classID_with_weight_result_params& v);
~mcp_get_content_list_from_classID_with_weight_result_params();
mcp_get_content_list_from_classID_with_weight_result_params& operator=(const mcp_get_content_list_from_classID_with_weight_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_classID_with_weight_result_params& assign(const mcp_get_content_list_from_classID_with_weight_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_content_list_from_classID_with_weight_result_params& set_count(uint32_t v);
inline void clear_count();
// @@string content_list=out(),array(0,0);
inline bool has_content_list() const;
inline const ::idl::vector< ::idl::vector< ::idl::string > >& content_list() const;
inline ::idl::vector< ::idl::vector< ::idl::string > >* mutable_content_list();
inline void clear_content_list();
// deprecated.use 'mutable_content_list' instead.
inline ::idl::vector< ::idl::vector< ::idl::string > >* m_content_list();
// deprecated.use 'content_list().size()' instead.
inline size_t content_list_size() const;
inline const char* content_list(size_t i0,size_t i1,unsigned int* size=0) const;
inline mcp_get_content_list_from_classID_with_weight_result_params& set_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline mcp_get_content_list_from_classID_with_weight_result_params& set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size=-1);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::vector< ::idl::string > > _m_content_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_from_classID_with_weight_result_params
class mcp_get_content_list_from_classID_with_weight_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_list_from_classID_with_weight_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_list_from_classID_with_weight_response* v);
explicit mcp_get_content_list_from_classID_with_weight_response(bsl::mempool* pool);
mcp_get_content_list_from_classID_with_weight_response(const mcp_get_content_list_from_classID_with_weight_response& v);
~mcp_get_content_list_from_classID_with_weight_response();
mcp_get_content_list_from_classID_with_weight_response& operator=(const mcp_get_content_list_from_classID_with_weight_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_list_from_classID_with_weight_response& assign(const mcp_get_content_list_from_classID_with_weight_response& v);
// @@mcp_get_content_list_from_classID_with_weight_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_list_from_classID_with_weight_result_params& result_params() const;
inline ::idl::mcp_get_content_list_from_classID_with_weight_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_list_from_classID_with_weight_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_list_from_classID_with_weight_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_list_from_classID_with_weight_response
class mcp_get_content_with_download_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_with_download_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_with_download_info_params* v);
explicit mcp_get_content_with_download_info_params(bsl::mempool* pool);
mcp_get_content_with_download_info_params(const mcp_get_content_with_download_info_params& v);
~mcp_get_content_with_download_info_params();
mcp_get_content_with_download_info_params& operator=(const mcp_get_content_with_download_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_with_download_info_params& assign(const mcp_get_content_with_download_info_params& v);
// @@mcp_content_in_param in_param=in();
inline bool has_in_param() const;
inline const ::idl::mcp_content_in_param& in_param() const;
inline ::idl::mcp_content_in_param* mutable_in_param();
// deprecated.use 'mutable_in_param()' instead.
inline ::idl::mcp_content_in_param* m_in_param();
inline void clear_in_param();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_content_with_download_info_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_content_with_download_info_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_content_in_param* _m_in_param;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_with_download_info_params
class mcp_get_content_with_download_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_with_download_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_content_with_download_info_result_params* v);
explicit mcp_get_content_with_download_info_result_params(bsl::mempool* pool);
mcp_get_content_with_download_info_result_params(const mcp_get_content_with_download_info_result_params& v);
~mcp_get_content_with_download_info_result_params();
mcp_get_content_with_download_info_result_params& operator=(const mcp_get_content_with_download_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_content_with_download_info_result_params& assign(const mcp_get_content_with_download_info_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_content_with_download_info_result_params& set_count(uint32_t v);
inline void clear_count();
// @@content_detail_t result_list=out(),array(0);
inline bool has_result_list() const;
inline const ::idl::vector< ::idl::content_detail_t >& result_list() const;
inline ::idl::vector< ::idl::content_detail_t >* mutable_result_list();
inline void clear_result_list();
// deprecated.use 'mutable_result_list' instead.
inline ::idl::vector< ::idl::content_detail_t >* m_result_list();
// deprecated.use 'result_list().size()' instead.
inline size_t result_list_size() const;
inline const ::idl::content_detail_t& result_list(size_t i0) const;
inline ::idl::content_detail_t* mutable_result_list(size_t i0);
// deprecated.use 'mutable_result_list' instead.
inline ::idl::content_detail_t* m_result_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::content_detail_t > _m_result_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_with_download_info_result_params
class mcp_get_content_with_download_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_content_with_download_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_content_with_download_info_response* v);
explicit mcp_get_content_with_download_info_response(bsl::mempool* pool);
mcp_get_content_with_download_info_response(const mcp_get_content_with_download_info_response& v);
~mcp_get_content_with_download_info_response();
mcp_get_content_with_download_info_response& operator=(const mcp_get_content_with_download_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_content_with_download_info_response& assign(const mcp_get_content_with_download_info_response& v);
// @@mcp_get_content_with_download_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_content_with_download_info_result_params& result_params() const;
inline ::idl::mcp_get_content_with_download_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_content_with_download_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_content_with_download_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_content_with_download_info_response
class mcp_get_game_contents_count_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_contents_count_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_contents_count_params* v);
explicit mcp_get_game_contents_count_params(bsl::mempool* pool);
mcp_get_game_contents_count_params(const mcp_get_game_contents_count_params& v);
~mcp_get_game_contents_count_params();
mcp_get_game_contents_count_params& operator=(const mcp_get_game_contents_count_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_contents_count_params& assign(const mcp_get_game_contents_count_params& v);
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_game_contents_count_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_game_contents_count_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@string class_id=in();
inline bool has_class_id() const;
inline const char* class_id(unsigned int* size=0) const;
inline mcp_get_game_contents_count_params& set_class_id(const char* s,ssize_t size=-1);
inline mcp_get_game_contents_count_params& set_ptr_class_id(const char* s,ssize_t size=-1);
inline void clear_class_id();
// @@string label_id=in();
inline bool has_label_id() const;
inline const char* label_id(unsigned int* size=0) const;
inline mcp_get_game_contents_count_params& set_label_id(const char* s,ssize_t size=-1);
inline mcp_get_game_contents_count_params& set_ptr_label_id(const char* s,ssize_t size=-1);
inline void clear_label_id();
// @@string column_id=in();
inline bool has_column_id() const;
inline const char* column_id(unsigned int* size=0) const;
inline mcp_get_game_contents_count_params& set_column_id(const char* s,ssize_t size=-1);
inline mcp_get_game_contents_count_params& set_ptr_column_id(const char* s,ssize_t size=-1);
inline void clear_column_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_type_id;
 ::idl::string _m_class_id;
 ::idl::string _m_label_id;
 ::idl::string _m_column_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_contents_count_params
class mcp_get_game_contents_count_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_contents_count_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_contents_count_result_params* v);
explicit mcp_get_game_contents_count_result_params(bsl::mempool* pool);
mcp_get_game_contents_count_result_params(const mcp_get_game_contents_count_result_params& v);
~mcp_get_game_contents_count_result_params();
mcp_get_game_contents_count_result_params& operator=(const mcp_get_game_contents_count_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_contents_count_result_params& assign(const mcp_get_game_contents_count_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_game_contents_count_result_params& set_count(uint32_t v);
inline void clear_count();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_contents_count_result_params
class mcp_get_game_contents_count_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_contents_count_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_contents_count_response* v);
explicit mcp_get_game_contents_count_response(bsl::mempool* pool);
mcp_get_game_contents_count_response(const mcp_get_game_contents_count_response& v);
~mcp_get_game_contents_count_response();
mcp_get_game_contents_count_response& operator=(const mcp_get_game_contents_count_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_contents_count_response& assign(const mcp_get_game_contents_count_response& v);
// @@mcp_get_game_contents_count_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_contents_count_result_params& result_params() const;
inline ::idl::mcp_get_game_contents_count_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_contents_count_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_contents_count_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_contents_count_response
class mcp_get_columns_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_columns_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_columns_info_params* v);
explicit mcp_get_columns_info_params(bsl::mempool* pool);
mcp_get_columns_info_params(const mcp_get_columns_info_params& v);
~mcp_get_columns_info_params();
mcp_get_columns_info_params& operator=(const mcp_get_columns_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_columns_info_params& assign(const mcp_get_columns_info_params& v);
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_columns_info_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_columns_info_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@string column_id=in();
inline bool has_column_id() const;
inline const char* column_id(unsigned int* size=0) const;
inline mcp_get_columns_info_params& set_column_id(const char* s,ssize_t size=-1);
inline mcp_get_columns_info_params& set_ptr_column_id(const char* s,ssize_t size=-1);
inline void clear_column_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_type_id;
 ::idl::string _m_column_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_columns_info_params
class mcp_get_columns_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_columns_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_columns_info_result_params* v);
explicit mcp_get_columns_info_result_params(bsl::mempool* pool);
mcp_get_columns_info_result_params(const mcp_get_columns_info_result_params& v);
~mcp_get_columns_info_result_params();
mcp_get_columns_info_result_params& operator=(const mcp_get_columns_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_columns_info_result_params& assign(const mcp_get_columns_info_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_columns_info_result_params& set_count(uint32_t v);
inline void clear_count();
// @@column_info_t result_list=out(),array(0);
inline bool has_result_list() const;
inline const ::idl::vector< ::idl::column_info_t >& result_list() const;
inline ::idl::vector< ::idl::column_info_t >* mutable_result_list();
inline void clear_result_list();
// deprecated.use 'mutable_result_list' instead.
inline ::idl::vector< ::idl::column_info_t >* m_result_list();
// deprecated.use 'result_list().size()' instead.
inline size_t result_list_size() const;
inline const ::idl::column_info_t& result_list(size_t i0) const;
inline ::idl::column_info_t* mutable_result_list(size_t i0);
// deprecated.use 'mutable_result_list' instead.
inline ::idl::column_info_t* m_result_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::column_info_t > _m_result_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_columns_info_result_params
class mcp_get_columns_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_columns_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_columns_info_response* v);
explicit mcp_get_columns_info_response(bsl::mempool* pool);
mcp_get_columns_info_response(const mcp_get_columns_info_response& v);
~mcp_get_columns_info_response();
mcp_get_columns_info_response& operator=(const mcp_get_columns_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_columns_info_response& assign(const mcp_get_columns_info_response& v);
// @@mcp_get_columns_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_columns_info_result_params& result_params() const;
inline ::idl::mcp_get_columns_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_columns_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_columns_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_columns_info_response
class mcp_get_once_consume_goods_list_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_once_consume_goods_list_params* create(bsl::mempool* pool);
static void destroy(mcp_get_once_consume_goods_list_params* v);
explicit mcp_get_once_consume_goods_list_params(bsl::mempool* pool);
mcp_get_once_consume_goods_list_params(const mcp_get_once_consume_goods_list_params& v);
~mcp_get_once_consume_goods_list_params();
mcp_get_once_consume_goods_list_params& operator=(const mcp_get_once_consume_goods_list_params& v);
void clear();
void check() const;
void detach();
mcp_get_once_consume_goods_list_params& assign(const mcp_get_once_consume_goods_list_params& v);
// @@string udid=in();
inline bool has_udid() const;
inline const char* udid(unsigned int* size=0) const;
inline mcp_get_once_consume_goods_list_params& set_udid(const char* s,ssize_t size=-1);
inline mcp_get_once_consume_goods_list_params& set_ptr_udid(const char* s,ssize_t size=-1);
inline void clear_udid();
// @@string app_id=in();
inline bool has_app_id() const;
inline const char* app_id(unsigned int* size=0) const;
inline mcp_get_once_consume_goods_list_params& set_app_id(const char* s,ssize_t size=-1);
inline mcp_get_once_consume_goods_list_params& set_ptr_app_id(const char* s,ssize_t size=-1);
inline void clear_app_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_udid;
 ::idl::string _m_app_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_once_consume_goods_list_params
class mcp_get_once_consume_goods_list_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_once_consume_goods_list_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_once_consume_goods_list_result_params* v);
explicit mcp_get_once_consume_goods_list_result_params(bsl::mempool* pool);
mcp_get_once_consume_goods_list_result_params(const mcp_get_once_consume_goods_list_result_params& v);
~mcp_get_once_consume_goods_list_result_params();
mcp_get_once_consume_goods_list_result_params& operator=(const mcp_get_once_consume_goods_list_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_once_consume_goods_list_result_params& assign(const mcp_get_once_consume_goods_list_result_params& v);
// @@uint32_t itemcount=out();
inline bool has_itemcount() const;
inline uint32_t itemcount() const;
inline mcp_get_once_consume_goods_list_result_params& set_itemcount(uint32_t v);
inline void clear_itemcount();
// @@once_consume_goods_t items=out(),array(0);
inline bool has_items() const;
inline const ::idl::vector< ::idl::once_consume_goods_t >& items() const;
inline ::idl::vector< ::idl::once_consume_goods_t >* mutable_items();
inline void clear_items();
// deprecated.use 'mutable_items' instead.
inline ::idl::vector< ::idl::once_consume_goods_t >* m_items();
// deprecated.use 'items().size()' instead.
inline size_t items_size() const;
inline const ::idl::once_consume_goods_t& items(size_t i0) const;
inline ::idl::once_consume_goods_t* mutable_items(size_t i0);
// deprecated.use 'mutable_items' instead.
inline ::idl::once_consume_goods_t* m_items(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_itemcount;
 ::idl::vector< ::idl::once_consume_goods_t > _m_items;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_once_consume_goods_list_result_params
class mcp_get_once_consume_goods_list_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_once_consume_goods_list_response* create(bsl::mempool* pool);
static void destroy(mcp_get_once_consume_goods_list_response* v);
explicit mcp_get_once_consume_goods_list_response(bsl::mempool* pool);
mcp_get_once_consume_goods_list_response(const mcp_get_once_consume_goods_list_response& v);
~mcp_get_once_consume_goods_list_response();
mcp_get_once_consume_goods_list_response& operator=(const mcp_get_once_consume_goods_list_response& v);
void clear();
void check() const;
void detach();
mcp_get_once_consume_goods_list_response& assign(const mcp_get_once_consume_goods_list_response& v);
// @@mcp_get_once_consume_goods_list_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_once_consume_goods_list_result_params& result_params() const;
inline ::idl::mcp_get_once_consume_goods_list_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_once_consume_goods_list_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_once_consume_goods_list_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_once_consume_goods_list_response
class mcp_get_game_info_list_ext_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_info_list_ext_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_info_list_ext_params* v);
explicit mcp_get_game_info_list_ext_params(bsl::mempool* pool);
mcp_get_game_info_list_ext_params(const mcp_get_game_info_list_ext_params& v);
~mcp_get_game_info_list_ext_params();
mcp_get_game_info_list_ext_params& operator=(const mcp_get_game_info_list_ext_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_info_list_ext_params& assign(const mcp_get_game_info_list_ext_params& v);
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_game_info_list_ext_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_game_info_list_ext_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_get_game_info_list_ext_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_get_game_info_list_ext_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string info_type=in();
inline bool has_info_type() const;
inline const char* info_type(unsigned int* size=0) const;
inline mcp_get_game_info_list_ext_params& set_info_type(const char* s,ssize_t size=-1);
inline mcp_get_game_info_list_ext_params& set_ptr_info_type(const char* s,ssize_t size=-1);
inline void clear_info_type();
// @@string game_type=in();
inline bool has_game_type() const;
inline const char* game_type(unsigned int* size=0) const;
inline mcp_get_game_info_list_ext_params& set_game_type(const char* s,ssize_t size=-1);
inline mcp_get_game_info_list_ext_params& set_ptr_game_type(const char* s,ssize_t size=-1);
inline void clear_game_type();
// @@string date_limit=in();
inline bool has_date_limit() const;
inline const char* date_limit(unsigned int* size=0) const;
inline mcp_get_game_info_list_ext_params& set_date_limit(const char* s,ssize_t size=-1);
inline mcp_get_game_info_list_ext_params& set_ptr_date_limit(const char* s,ssize_t size=-1);
inline void clear_date_limit();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_game_info_list_ext_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_game_info_list_ext_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_info_id;
 ::idl::string _m_c_id;
 ::idl::string _m_info_type;
 ::idl::string _m_game_type;
 ::idl::string _m_date_limit;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_info_list_ext_params
class mcp_get_game_info_list_ext_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_info_list_ext_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_info_list_ext_result_params* v);
explicit mcp_get_game_info_list_ext_result_params(bsl::mempool* pool);
mcp_get_game_info_list_ext_result_params(const mcp_get_game_info_list_ext_result_params& v);
~mcp_get_game_info_list_ext_result_params();
mcp_get_game_info_list_ext_result_params& operator=(const mcp_get_game_info_list_ext_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_info_list_ext_result_params& assign(const mcp_get_game_info_list_ext_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_game_info_list_ext_result_params& set_count(int32_t v);
inline void clear_count();
// @@game_info_t game_info_list=out(),array(0);
inline bool has_game_info_list() const;
inline const ::idl::vector< ::idl::game_info_t >& game_info_list() const;
inline ::idl::vector< ::idl::game_info_t >* mutable_game_info_list();
inline void clear_game_info_list();
// deprecated.use 'mutable_game_info_list' instead.
inline ::idl::vector< ::idl::game_info_t >* m_game_info_list();
// deprecated.use 'game_info_list().size()' instead.
inline size_t game_info_list_size() const;
inline const ::idl::game_info_t& game_info_list(size_t i0) const;
inline ::idl::game_info_t* mutable_game_info_list(size_t i0);
// deprecated.use 'mutable_game_info_list' instead.
inline ::idl::game_info_t* m_game_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::game_info_t > _m_game_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_info_list_ext_result_params
class mcp_get_game_info_list_ext_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_info_list_ext_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_info_list_ext_response* v);
explicit mcp_get_game_info_list_ext_response(bsl::mempool* pool);
mcp_get_game_info_list_ext_response(const mcp_get_game_info_list_ext_response& v);
~mcp_get_game_info_list_ext_response();
mcp_get_game_info_list_ext_response& operator=(const mcp_get_game_info_list_ext_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_info_list_ext_response& assign(const mcp_get_game_info_list_ext_response& v);
// @@mcp_get_game_info_list_ext_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_info_list_ext_result_params& result_params() const;
inline ::idl::mcp_get_game_info_list_ext_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_info_list_ext_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_info_list_ext_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_info_list_ext_response
class mcp_add_new_download_game_by_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_new_download_game_by_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_add_new_download_game_by_uid_params* v);
explicit mcp_add_new_download_game_by_uid_params(bsl::mempool* pool);
mcp_add_new_download_game_by_uid_params(const mcp_add_new_download_game_by_uid_params& v);
~mcp_add_new_download_game_by_uid_params();
mcp_add_new_download_game_by_uid_params& operator=(const mcp_add_new_download_game_by_uid_params& v);
void clear();
void check() const;
void detach();
mcp_add_new_download_game_by_uid_params& assign(const mcp_add_new_download_game_by_uid_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_add_new_download_game_by_uid_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_add_new_download_game_by_uid_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
// @@string game_id=in();
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline mcp_add_new_download_game_by_uid_params& set_game_id(const char* s,ssize_t size=-1);
inline mcp_add_new_download_game_by_uid_params& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
 ::idl::string _m_game_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_new_download_game_by_uid_params
class mcp_add_new_download_game_by_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_new_download_game_by_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_add_new_download_game_by_uid_result_params* v);
explicit mcp_add_new_download_game_by_uid_result_params(bsl::mempool* pool);
mcp_add_new_download_game_by_uid_result_params(const mcp_add_new_download_game_by_uid_result_params& v);
~mcp_add_new_download_game_by_uid_result_params();
mcp_add_new_download_game_by_uid_result_params& operator=(const mcp_add_new_download_game_by_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_add_new_download_game_by_uid_result_params& assign(const mcp_add_new_download_game_by_uid_result_params& v);
// @@int32_t ret_code=out();
inline bool has_ret_code() const;
inline int32_t ret_code() const;
inline mcp_add_new_download_game_by_uid_result_params& set_ret_code(int32_t v);
inline void clear_ret_code();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_ret_code;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_new_download_game_by_uid_result_params
class mcp_add_new_download_game_by_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_new_download_game_by_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_add_new_download_game_by_uid_response* v);
explicit mcp_add_new_download_game_by_uid_response(bsl::mempool* pool);
mcp_add_new_download_game_by_uid_response(const mcp_add_new_download_game_by_uid_response& v);
~mcp_add_new_download_game_by_uid_response();
mcp_add_new_download_game_by_uid_response& operator=(const mcp_add_new_download_game_by_uid_response& v);
void clear();
void check() const;
void detach();
mcp_add_new_download_game_by_uid_response& assign(const mcp_add_new_download_game_by_uid_response& v);
// @@mcp_add_new_download_game_by_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_add_new_download_game_by_uid_result_params& result_params() const;
inline ::idl::mcp_add_new_download_game_by_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_add_new_download_game_by_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_add_new_download_game_by_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_new_download_game_by_uid_response
class mcp_get_download_games_count_by_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_download_games_count_by_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_get_download_games_count_by_uid_params* v);
explicit mcp_get_download_games_count_by_uid_params(bsl::mempool* pool);
mcp_get_download_games_count_by_uid_params(const mcp_get_download_games_count_by_uid_params& v);
~mcp_get_download_games_count_by_uid_params();
mcp_get_download_games_count_by_uid_params& operator=(const mcp_get_download_games_count_by_uid_params& v);
void clear();
void check() const;
void detach();
mcp_get_download_games_count_by_uid_params& assign(const mcp_get_download_games_count_by_uid_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_get_download_games_count_by_uid_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_get_download_games_count_by_uid_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_download_games_count_by_uid_params
class mcp_get_download_games_count_by_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_download_games_count_by_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_download_games_count_by_uid_result_params* v);
explicit mcp_get_download_games_count_by_uid_result_params(bsl::mempool* pool);
mcp_get_download_games_count_by_uid_result_params(const mcp_get_download_games_count_by_uid_result_params& v);
~mcp_get_download_games_count_by_uid_result_params();
mcp_get_download_games_count_by_uid_result_params& operator=(const mcp_get_download_games_count_by_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_download_games_count_by_uid_result_params& assign(const mcp_get_download_games_count_by_uid_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_download_games_count_by_uid_result_params& set_count(uint32_t v);
inline void clear_count();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_download_games_count_by_uid_result_params
class mcp_get_download_games_count_by_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_download_games_count_by_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_get_download_games_count_by_uid_response* v);
explicit mcp_get_download_games_count_by_uid_response(bsl::mempool* pool);
mcp_get_download_games_count_by_uid_response(const mcp_get_download_games_count_by_uid_response& v);
~mcp_get_download_games_count_by_uid_response();
mcp_get_download_games_count_by_uid_response& operator=(const mcp_get_download_games_count_by_uid_response& v);
void clear();
void check() const;
void detach();
mcp_get_download_games_count_by_uid_response& assign(const mcp_get_download_games_count_by_uid_response& v);
// @@mcp_get_download_games_count_by_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_download_games_count_by_uid_result_params& result_params() const;
inline ::idl::mcp_get_download_games_count_by_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_download_games_count_by_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_download_games_count_by_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_download_games_count_by_uid_response
class mcp_is_user_has_relation_with_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_is_user_has_relation_with_params* create(bsl::mempool* pool);
static void destroy(mcp_is_user_has_relation_with_params* v);
explicit mcp_is_user_has_relation_with_params(bsl::mempool* pool);
mcp_is_user_has_relation_with_params(const mcp_is_user_has_relation_with_params& v);
~mcp_is_user_has_relation_with_params();
mcp_is_user_has_relation_with_params& operator=(const mcp_is_user_has_relation_with_params& v);
void clear();
void check() const;
void detach();
mcp_is_user_has_relation_with_params& assign(const mcp_is_user_has_relation_with_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_is_user_has_relation_with_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_is_user_has_relation_with_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_is_user_has_relation_with_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_is_user_has_relation_with_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string c_type=in();
inline bool has_c_type() const;
inline const char* c_type(unsigned int* size=0) const;
inline mcp_is_user_has_relation_with_params& set_c_type(const char* s,ssize_t size=-1);
inline mcp_is_user_has_relation_with_params& set_ptr_c_type(const char* s,ssize_t size=-1);
inline void clear_c_type();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
 ::idl::string _m_c_id;
 ::idl::string _m_c_type;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_is_user_has_relation_with_params
class mcp_is_user_has_relation_with_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_is_user_has_relation_with_result_params* create(bsl::mempool* pool);
static void destroy(mcp_is_user_has_relation_with_result_params* v);
explicit mcp_is_user_has_relation_with_result_params(bsl::mempool* pool);
mcp_is_user_has_relation_with_result_params(const mcp_is_user_has_relation_with_result_params& v);
~mcp_is_user_has_relation_with_result_params();
mcp_is_user_has_relation_with_result_params& operator=(const mcp_is_user_has_relation_with_result_params& v);
void clear();
void check() const;
void detach();
mcp_is_user_has_relation_with_result_params& assign(const mcp_is_user_has_relation_with_result_params& v);
// @@int32_t has_relation=out();
inline bool has_has_relation() const;
inline int32_t has_relation() const;
inline mcp_is_user_has_relation_with_result_params& set_has_relation(int32_t v);
inline void clear_has_relation();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_has_relation;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_is_user_has_relation_with_result_params
class mcp_is_user_has_relation_with_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_is_user_has_relation_with_response* create(bsl::mempool* pool);
static void destroy(mcp_is_user_has_relation_with_response* v);
explicit mcp_is_user_has_relation_with_response(bsl::mempool* pool);
mcp_is_user_has_relation_with_response(const mcp_is_user_has_relation_with_response& v);
~mcp_is_user_has_relation_with_response();
mcp_is_user_has_relation_with_response& operator=(const mcp_is_user_has_relation_with_response& v);
void clear();
void check() const;
void detach();
mcp_is_user_has_relation_with_response& assign(const mcp_is_user_has_relation_with_response& v);
// @@mcp_is_user_has_relation_with_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_is_user_has_relation_with_result_params& result_params() const;
inline ::idl::mcp_is_user_has_relation_with_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_is_user_has_relation_with_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_is_user_has_relation_with_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_is_user_has_relation_with_response
class mcp_get_download_games_info_by_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_download_games_info_by_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_get_download_games_info_by_uid_params* v);
explicit mcp_get_download_games_info_by_uid_params(bsl::mempool* pool);
mcp_get_download_games_info_by_uid_params(const mcp_get_download_games_info_by_uid_params& v);
~mcp_get_download_games_info_by_uid_params();
mcp_get_download_games_info_by_uid_params& operator=(const mcp_get_download_games_info_by_uid_params& v);
void clear();
void check() const;
void detach();
mcp_get_download_games_info_by_uid_params& assign(const mcp_get_download_games_info_by_uid_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_get_download_games_info_by_uid_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_get_download_games_info_by_uid_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
// @@string img_types=in();
inline bool has_img_types() const;
inline const char* img_types(unsigned int* size=0) const;
inline mcp_get_download_games_info_by_uid_params& set_img_types(const char* s,ssize_t size=-1);
inline mcp_get_download_games_info_by_uid_params& set_ptr_img_types(const char* s,ssize_t size=-1);
inline void clear_img_types();
// @@string filter=in();
inline bool has_filter() const;
inline const char* filter(unsigned int* size=0) const;
inline mcp_get_download_games_info_by_uid_params& set_filter(const char* s,ssize_t size=-1);
inline mcp_get_download_games_info_by_uid_params& set_ptr_filter(const char* s,ssize_t size=-1);
inline void clear_filter();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_download_games_info_by_uid_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_download_games_info_by_uid_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
 ::idl::string _m_img_types;
 ::idl::string _m_filter;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_download_games_info_by_uid_params
class mcp_get_download_games_info_by_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_download_games_info_by_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_download_games_info_by_uid_result_params* v);
explicit mcp_get_download_games_info_by_uid_result_params(bsl::mempool* pool);
mcp_get_download_games_info_by_uid_result_params(const mcp_get_download_games_info_by_uid_result_params& v);
~mcp_get_download_games_info_by_uid_result_params();
mcp_get_download_games_info_by_uid_result_params& operator=(const mcp_get_download_games_info_by_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_download_games_info_by_uid_result_params& assign(const mcp_get_download_games_info_by_uid_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_download_games_info_by_uid_result_params& set_count(uint32_t v);
inline void clear_count();
// @@game_content_download_info_t result_list=out(),array(0);
inline bool has_result_list() const;
inline const ::idl::vector< ::idl::game_content_download_info_t >& result_list() const;
inline ::idl::vector< ::idl::game_content_download_info_t >* mutable_result_list();
inline void clear_result_list();
// deprecated.use 'mutable_result_list' instead.
inline ::idl::vector< ::idl::game_content_download_info_t >* m_result_list();
// deprecated.use 'result_list().size()' instead.
inline size_t result_list_size() const;
inline const ::idl::game_content_download_info_t& result_list(size_t i0) const;
inline ::idl::game_content_download_info_t* mutable_result_list(size_t i0);
// deprecated.use 'mutable_result_list' instead.
inline ::idl::game_content_download_info_t* m_result_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::game_content_download_info_t > _m_result_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_download_games_info_by_uid_result_params
class mcp_get_download_games_info_by_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_download_games_info_by_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_get_download_games_info_by_uid_response* v);
explicit mcp_get_download_games_info_by_uid_response(bsl::mempool* pool);
mcp_get_download_games_info_by_uid_response(const mcp_get_download_games_info_by_uid_response& v);
~mcp_get_download_games_info_by_uid_response();
mcp_get_download_games_info_by_uid_response& operator=(const mcp_get_download_games_info_by_uid_response& v);
void clear();
void check() const;
void detach();
mcp_get_download_games_info_by_uid_response& assign(const mcp_get_download_games_info_by_uid_response& v);
// @@mcp_get_download_games_info_by_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_download_games_info_by_uid_result_params& result_params() const;
inline ::idl::mcp_get_download_games_info_by_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_download_games_info_by_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_download_games_info_by_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_download_games_info_by_uid_response
class mcp_add_new_guide_by_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_new_guide_by_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_add_new_guide_by_uid_params* v);
explicit mcp_add_new_guide_by_uid_params(bsl::mempool* pool);
mcp_add_new_guide_by_uid_params(const mcp_add_new_guide_by_uid_params& v);
~mcp_add_new_guide_by_uid_params();
mcp_add_new_guide_by_uid_params& operator=(const mcp_add_new_guide_by_uid_params& v);
void clear();
void check() const;
void detach();
mcp_add_new_guide_by_uid_params& assign(const mcp_add_new_guide_by_uid_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_add_new_guide_by_uid_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_add_new_guide_by_uid_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
// @@string guide_id=in();
inline bool has_guide_id() const;
inline const char* guide_id(unsigned int* size=0) const;
inline mcp_add_new_guide_by_uid_params& set_guide_id(const char* s,ssize_t size=-1);
inline mcp_add_new_guide_by_uid_params& set_ptr_guide_id(const char* s,ssize_t size=-1);
inline void clear_guide_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
 ::idl::string _m_guide_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_new_guide_by_uid_params
class mcp_add_new_guide_by_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_new_guide_by_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_add_new_guide_by_uid_result_params* v);
explicit mcp_add_new_guide_by_uid_result_params(bsl::mempool* pool);
mcp_add_new_guide_by_uid_result_params(const mcp_add_new_guide_by_uid_result_params& v);
~mcp_add_new_guide_by_uid_result_params();
mcp_add_new_guide_by_uid_result_params& operator=(const mcp_add_new_guide_by_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_add_new_guide_by_uid_result_params& assign(const mcp_add_new_guide_by_uid_result_params& v);
// @@int32_t ret_code=out();
inline bool has_ret_code() const;
inline int32_t ret_code() const;
inline mcp_add_new_guide_by_uid_result_params& set_ret_code(int32_t v);
inline void clear_ret_code();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_ret_code;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_new_guide_by_uid_result_params
class mcp_add_new_guide_by_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_new_guide_by_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_add_new_guide_by_uid_response* v);
explicit mcp_add_new_guide_by_uid_response(bsl::mempool* pool);
mcp_add_new_guide_by_uid_response(const mcp_add_new_guide_by_uid_response& v);
~mcp_add_new_guide_by_uid_response();
mcp_add_new_guide_by_uid_response& operator=(const mcp_add_new_guide_by_uid_response& v);
void clear();
void check() const;
void detach();
mcp_add_new_guide_by_uid_response& assign(const mcp_add_new_guide_by_uid_response& v);
// @@mcp_add_new_guide_by_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_add_new_guide_by_uid_result_params& result_params() const;
inline ::idl::mcp_add_new_guide_by_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_add_new_guide_by_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_add_new_guide_by_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_new_guide_by_uid_response
class mcp_remove_guide_by_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_remove_guide_by_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_remove_guide_by_uid_params* v);
explicit mcp_remove_guide_by_uid_params(bsl::mempool* pool);
mcp_remove_guide_by_uid_params(const mcp_remove_guide_by_uid_params& v);
~mcp_remove_guide_by_uid_params();
mcp_remove_guide_by_uid_params& operator=(const mcp_remove_guide_by_uid_params& v);
void clear();
void check() const;
void detach();
mcp_remove_guide_by_uid_params& assign(const mcp_remove_guide_by_uid_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_remove_guide_by_uid_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_remove_guide_by_uid_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
// @@string guide_id=in();
inline bool has_guide_id() const;
inline const char* guide_id(unsigned int* size=0) const;
inline mcp_remove_guide_by_uid_params& set_guide_id(const char* s,ssize_t size=-1);
inline mcp_remove_guide_by_uid_params& set_ptr_guide_id(const char* s,ssize_t size=-1);
inline void clear_guide_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
 ::idl::string _m_guide_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_remove_guide_by_uid_params
class mcp_remove_guide_by_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_remove_guide_by_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_remove_guide_by_uid_result_params* v);
explicit mcp_remove_guide_by_uid_result_params(bsl::mempool* pool);
mcp_remove_guide_by_uid_result_params(const mcp_remove_guide_by_uid_result_params& v);
~mcp_remove_guide_by_uid_result_params();
mcp_remove_guide_by_uid_result_params& operator=(const mcp_remove_guide_by_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_remove_guide_by_uid_result_params& assign(const mcp_remove_guide_by_uid_result_params& v);
// @@int32_t ret_code=out();
inline bool has_ret_code() const;
inline int32_t ret_code() const;
inline mcp_remove_guide_by_uid_result_params& set_ret_code(int32_t v);
inline void clear_ret_code();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_ret_code;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_remove_guide_by_uid_result_params
class mcp_remove_guide_by_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_remove_guide_by_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_remove_guide_by_uid_response* v);
explicit mcp_remove_guide_by_uid_response(bsl::mempool* pool);
mcp_remove_guide_by_uid_response(const mcp_remove_guide_by_uid_response& v);
~mcp_remove_guide_by_uid_response();
mcp_remove_guide_by_uid_response& operator=(const mcp_remove_guide_by_uid_response& v);
void clear();
void check() const;
void detach();
mcp_remove_guide_by_uid_response& assign(const mcp_remove_guide_by_uid_response& v);
// @@mcp_remove_guide_by_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_remove_guide_by_uid_result_params& result_params() const;
inline ::idl::mcp_remove_guide_by_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_remove_guide_by_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_remove_guide_by_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_remove_guide_by_uid_response
class mcp_get_guides_count_by_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_guides_count_by_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_get_guides_count_by_uid_params* v);
explicit mcp_get_guides_count_by_uid_params(bsl::mempool* pool);
mcp_get_guides_count_by_uid_params(const mcp_get_guides_count_by_uid_params& v);
~mcp_get_guides_count_by_uid_params();
mcp_get_guides_count_by_uid_params& operator=(const mcp_get_guides_count_by_uid_params& v);
void clear();
void check() const;
void detach();
mcp_get_guides_count_by_uid_params& assign(const mcp_get_guides_count_by_uid_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_get_guides_count_by_uid_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_get_guides_count_by_uid_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_guides_count_by_uid_params
class mcp_get_guides_count_by_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_guides_count_by_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_guides_count_by_uid_result_params* v);
explicit mcp_get_guides_count_by_uid_result_params(bsl::mempool* pool);
mcp_get_guides_count_by_uid_result_params(const mcp_get_guides_count_by_uid_result_params& v);
~mcp_get_guides_count_by_uid_result_params();
mcp_get_guides_count_by_uid_result_params& operator=(const mcp_get_guides_count_by_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_guides_count_by_uid_result_params& assign(const mcp_get_guides_count_by_uid_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_guides_count_by_uid_result_params& set_count(uint32_t v);
inline void clear_count();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_guides_count_by_uid_result_params
class mcp_get_guides_count_by_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_guides_count_by_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_get_guides_count_by_uid_response* v);
explicit mcp_get_guides_count_by_uid_response(bsl::mempool* pool);
mcp_get_guides_count_by_uid_response(const mcp_get_guides_count_by_uid_response& v);
~mcp_get_guides_count_by_uid_response();
mcp_get_guides_count_by_uid_response& operator=(const mcp_get_guides_count_by_uid_response& v);
void clear();
void check() const;
void detach();
mcp_get_guides_count_by_uid_response& assign(const mcp_get_guides_count_by_uid_response& v);
// @@mcp_get_guides_count_by_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_guides_count_by_uid_result_params& result_params() const;
inline ::idl::mcp_get_guides_count_by_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_guides_count_by_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_guides_count_by_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_guides_count_by_uid_response
class mcp_get_guides_info_by_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_guides_info_by_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_get_guides_info_by_uid_params* v);
explicit mcp_get_guides_info_by_uid_params(bsl::mempool* pool);
mcp_get_guides_info_by_uid_params(const mcp_get_guides_info_by_uid_params& v);
~mcp_get_guides_info_by_uid_params();
mcp_get_guides_info_by_uid_params& operator=(const mcp_get_guides_info_by_uid_params& v);
void clear();
void check() const;
void detach();
mcp_get_guides_info_by_uid_params& assign(const mcp_get_guides_info_by_uid_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_get_guides_info_by_uid_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_get_guides_info_by_uid_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_guides_info_by_uid_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_guides_info_by_uid_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_guides_info_by_uid_params
class mcp_get_guides_info_by_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_guides_info_by_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_guides_info_by_uid_result_params* v);
explicit mcp_get_guides_info_by_uid_result_params(bsl::mempool* pool);
mcp_get_guides_info_by_uid_result_params(const mcp_get_guides_info_by_uid_result_params& v);
~mcp_get_guides_info_by_uid_result_params();
mcp_get_guides_info_by_uid_result_params& operator=(const mcp_get_guides_info_by_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_guides_info_by_uid_result_params& assign(const mcp_get_guides_info_by_uid_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_guides_info_by_uid_result_params& set_count(uint32_t v);
inline void clear_count();
// @@game_info_t result_list=out(),array(0);
inline bool has_result_list() const;
inline const ::idl::vector< ::idl::game_info_t >& result_list() const;
inline ::idl::vector< ::idl::game_info_t >* mutable_result_list();
inline void clear_result_list();
// deprecated.use 'mutable_result_list' instead.
inline ::idl::vector< ::idl::game_info_t >* m_result_list();
// deprecated.use 'result_list().size()' instead.
inline size_t result_list_size() const;
inline const ::idl::game_info_t& result_list(size_t i0) const;
inline ::idl::game_info_t* mutable_result_list(size_t i0);
// deprecated.use 'mutable_result_list' instead.
inline ::idl::game_info_t* m_result_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::game_info_t > _m_result_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_guides_info_by_uid_result_params
class mcp_get_guides_info_by_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_guides_info_by_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_get_guides_info_by_uid_response* v);
explicit mcp_get_guides_info_by_uid_response(bsl::mempool* pool);
mcp_get_guides_info_by_uid_response(const mcp_get_guides_info_by_uid_response& v);
~mcp_get_guides_info_by_uid_response();
mcp_get_guides_info_by_uid_response& operator=(const mcp_get_guides_info_by_uid_response& v);
void clear();
void check() const;
void detach();
mcp_get_guides_info_by_uid_response& assign(const mcp_get_guides_info_by_uid_response& v);
// @@mcp_get_guides_info_by_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_guides_info_by_uid_result_params& result_params() const;
inline ::idl::mcp_get_guides_info_by_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_guides_info_by_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_guides_info_by_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_guides_info_by_uid_response
class mcp_add_new_favorite_by_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_new_favorite_by_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_add_new_favorite_by_uid_params* v);
explicit mcp_add_new_favorite_by_uid_params(bsl::mempool* pool);
mcp_add_new_favorite_by_uid_params(const mcp_add_new_favorite_by_uid_params& v);
~mcp_add_new_favorite_by_uid_params();
mcp_add_new_favorite_by_uid_params& operator=(const mcp_add_new_favorite_by_uid_params& v);
void clear();
void check() const;
void detach();
mcp_add_new_favorite_by_uid_params& assign(const mcp_add_new_favorite_by_uid_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_add_new_favorite_by_uid_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_add_new_favorite_by_uid_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
// @@string favorites_id=in();
inline bool has_favorites_id() const;
inline const char* favorites_id(unsigned int* size=0) const;
inline mcp_add_new_favorite_by_uid_params& set_favorites_id(const char* s,ssize_t size=-1);
inline mcp_add_new_favorite_by_uid_params& set_ptr_favorites_id(const char* s,ssize_t size=-1);
inline void clear_favorites_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
 ::idl::string _m_favorites_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_new_favorite_by_uid_params
class mcp_add_new_favorite_by_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_new_favorite_by_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_add_new_favorite_by_uid_result_params* v);
explicit mcp_add_new_favorite_by_uid_result_params(bsl::mempool* pool);
mcp_add_new_favorite_by_uid_result_params(const mcp_add_new_favorite_by_uid_result_params& v);
~mcp_add_new_favorite_by_uid_result_params();
mcp_add_new_favorite_by_uid_result_params& operator=(const mcp_add_new_favorite_by_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_add_new_favorite_by_uid_result_params& assign(const mcp_add_new_favorite_by_uid_result_params& v);
// @@int32_t ret_code=out();
inline bool has_ret_code() const;
inline int32_t ret_code() const;
inline mcp_add_new_favorite_by_uid_result_params& set_ret_code(int32_t v);
inline void clear_ret_code();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_ret_code;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_new_favorite_by_uid_result_params
class mcp_add_new_favorite_by_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_new_favorite_by_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_add_new_favorite_by_uid_response* v);
explicit mcp_add_new_favorite_by_uid_response(bsl::mempool* pool);
mcp_add_new_favorite_by_uid_response(const mcp_add_new_favorite_by_uid_response& v);
~mcp_add_new_favorite_by_uid_response();
mcp_add_new_favorite_by_uid_response& operator=(const mcp_add_new_favorite_by_uid_response& v);
void clear();
void check() const;
void detach();
mcp_add_new_favorite_by_uid_response& assign(const mcp_add_new_favorite_by_uid_response& v);
// @@mcp_add_new_favorite_by_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_add_new_favorite_by_uid_result_params& result_params() const;
inline ::idl::mcp_add_new_favorite_by_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_add_new_favorite_by_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_add_new_favorite_by_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_new_favorite_by_uid_response
class mcp_remove_favorite_by_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_remove_favorite_by_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_remove_favorite_by_uid_params* v);
explicit mcp_remove_favorite_by_uid_params(bsl::mempool* pool);
mcp_remove_favorite_by_uid_params(const mcp_remove_favorite_by_uid_params& v);
~mcp_remove_favorite_by_uid_params();
mcp_remove_favorite_by_uid_params& operator=(const mcp_remove_favorite_by_uid_params& v);
void clear();
void check() const;
void detach();
mcp_remove_favorite_by_uid_params& assign(const mcp_remove_favorite_by_uid_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_remove_favorite_by_uid_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_remove_favorite_by_uid_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
// @@string favorites_id=in();
inline bool has_favorites_id() const;
inline const char* favorites_id(unsigned int* size=0) const;
inline mcp_remove_favorite_by_uid_params& set_favorites_id(const char* s,ssize_t size=-1);
inline mcp_remove_favorite_by_uid_params& set_ptr_favorites_id(const char* s,ssize_t size=-1);
inline void clear_favorites_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
 ::idl::string _m_favorites_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_remove_favorite_by_uid_params
class mcp_remove_favorite_by_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_remove_favorite_by_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_remove_favorite_by_uid_result_params* v);
explicit mcp_remove_favorite_by_uid_result_params(bsl::mempool* pool);
mcp_remove_favorite_by_uid_result_params(const mcp_remove_favorite_by_uid_result_params& v);
~mcp_remove_favorite_by_uid_result_params();
mcp_remove_favorite_by_uid_result_params& operator=(const mcp_remove_favorite_by_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_remove_favorite_by_uid_result_params& assign(const mcp_remove_favorite_by_uid_result_params& v);
// @@int32_t ret_code=out();
inline bool has_ret_code() const;
inline int32_t ret_code() const;
inline mcp_remove_favorite_by_uid_result_params& set_ret_code(int32_t v);
inline void clear_ret_code();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_ret_code;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_remove_favorite_by_uid_result_params
class mcp_remove_favorite_by_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_remove_favorite_by_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_remove_favorite_by_uid_response* v);
explicit mcp_remove_favorite_by_uid_response(bsl::mempool* pool);
mcp_remove_favorite_by_uid_response(const mcp_remove_favorite_by_uid_response& v);
~mcp_remove_favorite_by_uid_response();
mcp_remove_favorite_by_uid_response& operator=(const mcp_remove_favorite_by_uid_response& v);
void clear();
void check() const;
void detach();
mcp_remove_favorite_by_uid_response& assign(const mcp_remove_favorite_by_uid_response& v);
// @@mcp_remove_favorite_by_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_remove_favorite_by_uid_result_params& result_params() const;
inline ::idl::mcp_remove_favorite_by_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_remove_favorite_by_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_remove_favorite_by_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_remove_favorite_by_uid_response
class mcp_get_favorites_count_by_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_favorites_count_by_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_get_favorites_count_by_uid_params* v);
explicit mcp_get_favorites_count_by_uid_params(bsl::mempool* pool);
mcp_get_favorites_count_by_uid_params(const mcp_get_favorites_count_by_uid_params& v);
~mcp_get_favorites_count_by_uid_params();
mcp_get_favorites_count_by_uid_params& operator=(const mcp_get_favorites_count_by_uid_params& v);
void clear();
void check() const;
void detach();
mcp_get_favorites_count_by_uid_params& assign(const mcp_get_favorites_count_by_uid_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_get_favorites_count_by_uid_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_get_favorites_count_by_uid_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_favorites_count_by_uid_params
class mcp_get_favorites_count_by_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_favorites_count_by_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_favorites_count_by_uid_result_params* v);
explicit mcp_get_favorites_count_by_uid_result_params(bsl::mempool* pool);
mcp_get_favorites_count_by_uid_result_params(const mcp_get_favorites_count_by_uid_result_params& v);
~mcp_get_favorites_count_by_uid_result_params();
mcp_get_favorites_count_by_uid_result_params& operator=(const mcp_get_favorites_count_by_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_favorites_count_by_uid_result_params& assign(const mcp_get_favorites_count_by_uid_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_favorites_count_by_uid_result_params& set_count(uint32_t v);
inline void clear_count();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_favorites_count_by_uid_result_params
class mcp_get_favorites_count_by_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_favorites_count_by_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_get_favorites_count_by_uid_response* v);
explicit mcp_get_favorites_count_by_uid_response(bsl::mempool* pool);
mcp_get_favorites_count_by_uid_response(const mcp_get_favorites_count_by_uid_response& v);
~mcp_get_favorites_count_by_uid_response();
mcp_get_favorites_count_by_uid_response& operator=(const mcp_get_favorites_count_by_uid_response& v);
void clear();
void check() const;
void detach();
mcp_get_favorites_count_by_uid_response& assign(const mcp_get_favorites_count_by_uid_response& v);
// @@mcp_get_favorites_count_by_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_favorites_count_by_uid_result_params& result_params() const;
inline ::idl::mcp_get_favorites_count_by_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_favorites_count_by_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_favorites_count_by_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_favorites_count_by_uid_response
class mcp_get_favorites_info_by_uid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_favorites_info_by_uid_params* create(bsl::mempool* pool);
static void destroy(mcp_get_favorites_info_by_uid_params* v);
explicit mcp_get_favorites_info_by_uid_params(bsl::mempool* pool);
mcp_get_favorites_info_by_uid_params(const mcp_get_favorites_info_by_uid_params& v);
~mcp_get_favorites_info_by_uid_params();
mcp_get_favorites_info_by_uid_params& operator=(const mcp_get_favorites_info_by_uid_params& v);
void clear();
void check() const;
void detach();
mcp_get_favorites_info_by_uid_params& assign(const mcp_get_favorites_info_by_uid_params& v);
// @@string u_id=in();
inline bool has_u_id() const;
inline const char* u_id(unsigned int* size=0) const;
inline mcp_get_favorites_info_by_uid_params& set_u_id(const char* s,ssize_t size=-1);
inline mcp_get_favorites_info_by_uid_params& set_ptr_u_id(const char* s,ssize_t size=-1);
inline void clear_u_id();
// @@string img_types=in();
inline bool has_img_types() const;
inline const char* img_types(unsigned int* size=0) const;
inline mcp_get_favorites_info_by_uid_params& set_img_types(const char* s,ssize_t size=-1);
inline mcp_get_favorites_info_by_uid_params& set_ptr_img_types(const char* s,ssize_t size=-1);
inline void clear_img_types();
// @@string filter=in();
inline bool has_filter() const;
inline const char* filter(unsigned int* size=0) const;
inline mcp_get_favorites_info_by_uid_params& set_filter(const char* s,ssize_t size=-1);
inline mcp_get_favorites_info_by_uid_params& set_ptr_filter(const char* s,ssize_t size=-1);
inline void clear_filter();
// @@uint32_t unit_num=in();
inline bool has_unit_num() const;
inline uint32_t unit_num() const;
inline mcp_get_favorites_info_by_uid_params& set_unit_num(uint32_t v);
inline void clear_unit_num();
// @@uint32_t unit_times=in();
inline bool has_unit_times() const;
inline uint32_t unit_times() const;
inline mcp_get_favorites_info_by_uid_params& set_unit_times(uint32_t v);
inline void clear_unit_times();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_u_id;
 ::idl::string _m_img_types;
 ::idl::string _m_filter;
 uint32_t _m_unit_num;
 uint32_t _m_unit_times;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_favorites_info_by_uid_params
class mcp_get_favorites_info_by_uid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_favorites_info_by_uid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_favorites_info_by_uid_result_params* v);
explicit mcp_get_favorites_info_by_uid_result_params(bsl::mempool* pool);
mcp_get_favorites_info_by_uid_result_params(const mcp_get_favorites_info_by_uid_result_params& v);
~mcp_get_favorites_info_by_uid_result_params();
mcp_get_favorites_info_by_uid_result_params& operator=(const mcp_get_favorites_info_by_uid_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_favorites_info_by_uid_result_params& assign(const mcp_get_favorites_info_by_uid_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_favorites_info_by_uid_result_params& set_count(uint32_t v);
inline void clear_count();
// @@game_content_download_info_t result_list=out(),array(0);
inline bool has_result_list() const;
inline const ::idl::vector< ::idl::game_content_download_info_t >& result_list() const;
inline ::idl::vector< ::idl::game_content_download_info_t >* mutable_result_list();
inline void clear_result_list();
// deprecated.use 'mutable_result_list' instead.
inline ::idl::vector< ::idl::game_content_download_info_t >* m_result_list();
// deprecated.use 'result_list().size()' instead.
inline size_t result_list_size() const;
inline const ::idl::game_content_download_info_t& result_list(size_t i0) const;
inline ::idl::game_content_download_info_t* mutable_result_list(size_t i0);
// deprecated.use 'mutable_result_list' instead.
inline ::idl::game_content_download_info_t* m_result_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::game_content_download_info_t > _m_result_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_favorites_info_by_uid_result_params
class mcp_get_favorites_info_by_uid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_favorites_info_by_uid_response* create(bsl::mempool* pool);
static void destroy(mcp_get_favorites_info_by_uid_response* v);
explicit mcp_get_favorites_info_by_uid_response(bsl::mempool* pool);
mcp_get_favorites_info_by_uid_response(const mcp_get_favorites_info_by_uid_response& v);
~mcp_get_favorites_info_by_uid_response();
mcp_get_favorites_info_by_uid_response& operator=(const mcp_get_favorites_info_by_uid_response& v);
void clear();
void check() const;
void detach();
mcp_get_favorites_info_by_uid_response& assign(const mcp_get_favorites_info_by_uid_response& v);
// @@mcp_get_favorites_info_by_uid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_favorites_info_by_uid_result_params& result_params() const;
inline ::idl::mcp_get_favorites_info_by_uid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_favorites_info_by_uid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_favorites_info_by_uid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_favorites_info_by_uid_response
class mcp_get_grab_list_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_grab_list_params* create(bsl::mempool* pool);
static void destroy(mcp_get_grab_list_params* v);
explicit mcp_get_grab_list_params(bsl::mempool* pool);
mcp_get_grab_list_params(const mcp_get_grab_list_params& v);
~mcp_get_grab_list_params();
mcp_get_grab_list_params& operator=(const mcp_get_grab_list_params& v);
void clear();
void check() const;
void detach();
mcp_get_grab_list_params& assign(const mcp_get_grab_list_params& v);
// @@string type_id=in();
inline bool has_type_id() const;
inline const char* type_id(unsigned int* size=0) const;
inline mcp_get_grab_list_params& set_type_id(const char* s,ssize_t size=-1);
inline mcp_get_grab_list_params& set_ptr_type_id(const char* s,ssize_t size=-1);
inline void clear_type_id();
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_get_grab_list_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_get_grab_list_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@uint32_t id=in();
inline bool has_id() const;
inline uint32_t id() const;
inline mcp_get_grab_list_params& set_id(uint32_t v);
inline void clear_id();
// @@string user_id=in();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_get_grab_list_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_get_grab_list_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_grab_list_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_grab_list_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_type_id;
 ::idl::string _m_c_id;
 uint32_t _m_id;
 ::idl::string _m_user_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_grab_list_params
class mcp_get_grab_list_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_grab_list_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_grab_list_result_params* v);
explicit mcp_get_grab_list_result_params(bsl::mempool* pool);
mcp_get_grab_list_result_params(const mcp_get_grab_list_result_params& v);
~mcp_get_grab_list_result_params();
mcp_get_grab_list_result_params& operator=(const mcp_get_grab_list_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_grab_list_result_params& assign(const mcp_get_grab_list_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_grab_list_result_params& set_count(int32_t v);
inline void clear_count();
// @@grab_info_t grab_list=out(),array(0);
inline bool has_grab_list() const;
inline const ::idl::vector< ::idl::grab_info_t >& grab_list() const;
inline ::idl::vector< ::idl::grab_info_t >* mutable_grab_list();
inline void clear_grab_list();
// deprecated.use 'mutable_grab_list' instead.
inline ::idl::vector< ::idl::grab_info_t >* m_grab_list();
// deprecated.use 'grab_list().size()' instead.
inline size_t grab_list_size() const;
inline const ::idl::grab_info_t& grab_list(size_t i0) const;
inline ::idl::grab_info_t* mutable_grab_list(size_t i0);
// deprecated.use 'mutable_grab_list' instead.
inline ::idl::grab_info_t* m_grab_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::grab_info_t > _m_grab_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_grab_list_result_params
class mcp_get_grab_list_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_grab_list_response* create(bsl::mempool* pool);
static void destroy(mcp_get_grab_list_response* v);
explicit mcp_get_grab_list_response(bsl::mempool* pool);
mcp_get_grab_list_response(const mcp_get_grab_list_response& v);
~mcp_get_grab_list_response();
mcp_get_grab_list_response& operator=(const mcp_get_grab_list_response& v);
void clear();
void check() const;
void detach();
mcp_get_grab_list_response& assign(const mcp_get_grab_list_response& v);
// @@mcp_get_grab_list_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_grab_list_result_params& result_params() const;
inline ::idl::mcp_get_grab_list_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_grab_list_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_grab_list_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_grab_list_response
class mcp_get_user_grab_num_list_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_user_grab_num_list_params* create(bsl::mempool* pool);
static void destroy(mcp_get_user_grab_num_list_params* v);
explicit mcp_get_user_grab_num_list_params(bsl::mempool* pool);
mcp_get_user_grab_num_list_params(const mcp_get_user_grab_num_list_params& v);
~mcp_get_user_grab_num_list_params();
mcp_get_user_grab_num_list_params& operator=(const mcp_get_user_grab_num_list_params& v);
void clear();
void check() const;
void detach();
mcp_get_user_grab_num_list_params& assign(const mcp_get_user_grab_num_list_params& v);
// @@string user_id=in();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_get_user_grab_num_list_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_get_user_grab_num_list_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_user_grab_num_list_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_user_grab_num_list_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_user_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_user_grab_num_list_params
class mcp_get_user_grab_num_list_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_user_grab_num_list_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_user_grab_num_list_result_params* v);
explicit mcp_get_user_grab_num_list_result_params(bsl::mempool* pool);
mcp_get_user_grab_num_list_result_params(const mcp_get_user_grab_num_list_result_params& v);
~mcp_get_user_grab_num_list_result_params();
mcp_get_user_grab_num_list_result_params& operator=(const mcp_get_user_grab_num_list_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_user_grab_num_list_result_params& assign(const mcp_get_user_grab_num_list_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_user_grab_num_list_result_params& set_count(int32_t v);
inline void clear_count();
// @@user_grab_number_t user_grab_num_list=out(),array(0);
inline bool has_user_grab_num_list() const;
inline const ::idl::vector< ::idl::user_grab_number_t >& user_grab_num_list() const;
inline ::idl::vector< ::idl::user_grab_number_t >* mutable_user_grab_num_list();
inline void clear_user_grab_num_list();
// deprecated.use 'mutable_user_grab_num_list' instead.
inline ::idl::vector< ::idl::user_grab_number_t >* m_user_grab_num_list();
// deprecated.use 'user_grab_num_list().size()' instead.
inline size_t user_grab_num_list_size() const;
inline const ::idl::user_grab_number_t& user_grab_num_list(size_t i0) const;
inline ::idl::user_grab_number_t* mutable_user_grab_num_list(size_t i0);
// deprecated.use 'mutable_user_grab_num_list' instead.
inline ::idl::user_grab_number_t* m_user_grab_num_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::user_grab_number_t > _m_user_grab_num_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_user_grab_num_list_result_params
class mcp_get_user_grab_num_list_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_user_grab_num_list_response* create(bsl::mempool* pool);
static void destroy(mcp_get_user_grab_num_list_response* v);
explicit mcp_get_user_grab_num_list_response(bsl::mempool* pool);
mcp_get_user_grab_num_list_response(const mcp_get_user_grab_num_list_response& v);
~mcp_get_user_grab_num_list_response();
mcp_get_user_grab_num_list_response& operator=(const mcp_get_user_grab_num_list_response& v);
void clear();
void check() const;
void detach();
mcp_get_user_grab_num_list_response& assign(const mcp_get_user_grab_num_list_response& v);
// @@mcp_get_user_grab_num_list_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_user_grab_num_list_result_params& result_params() const;
inline ::idl::mcp_get_user_grab_num_list_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_user_grab_num_list_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_user_grab_num_list_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_user_grab_num_list_response
class mcp_get_common_adv_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_common_adv_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_common_adv_info_params* v);
explicit mcp_get_common_adv_info_params(bsl::mempool* pool);
mcp_get_common_adv_info_params(const mcp_get_common_adv_info_params& v);
~mcp_get_common_adv_info_params();
mcp_get_common_adv_info_params& operator=(const mcp_get_common_adv_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_common_adv_info_params& assign(const mcp_get_common_adv_info_params& v);
// @@string id=in();
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline mcp_get_common_adv_info_params& set_id(const char* s,ssize_t size=-1);
inline mcp_get_common_adv_info_params& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_common_adv_info_params
class mcp_get_common_adv_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_common_adv_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_common_adv_info_result_params* v);
explicit mcp_get_common_adv_info_result_params(bsl::mempool* pool);
mcp_get_common_adv_info_result_params(const mcp_get_common_adv_info_result_params& v);
~mcp_get_common_adv_info_result_params();
mcp_get_common_adv_info_result_params& operator=(const mcp_get_common_adv_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_common_adv_info_result_params& assign(const mcp_get_common_adv_info_result_params& v);
// @@string info=out();
inline bool has_info() const;
inline const char* info(unsigned int* size=0) const;
inline mcp_get_common_adv_info_result_params& set_info(const char* s,ssize_t size=-1);
inline mcp_get_common_adv_info_result_params& set_ptr_info(const char* s,ssize_t size=-1);
inline void clear_info();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_common_adv_info_result_params
class mcp_get_common_adv_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_common_adv_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_common_adv_info_response* v);
explicit mcp_get_common_adv_info_response(bsl::mempool* pool);
mcp_get_common_adv_info_response(const mcp_get_common_adv_info_response& v);
~mcp_get_common_adv_info_response();
mcp_get_common_adv_info_response& operator=(const mcp_get_common_adv_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_common_adv_info_response& assign(const mcp_get_common_adv_info_response& v);
// @@mcp_get_common_adv_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_common_adv_info_result_params& result_params() const;
inline ::idl::mcp_get_common_adv_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_common_adv_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_common_adv_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_common_adv_info_response
class mcp_get_pt_game_basic_list_by_game_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_pt_game_basic_list_by_game_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_pt_game_basic_list_by_game_id_params* v);
explicit mcp_get_pt_game_basic_list_by_game_id_params(bsl::mempool* pool);
mcp_get_pt_game_basic_list_by_game_id_params(const mcp_get_pt_game_basic_list_by_game_id_params& v);
~mcp_get_pt_game_basic_list_by_game_id_params();
mcp_get_pt_game_basic_list_by_game_id_params& operator=(const mcp_get_pt_game_basic_list_by_game_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_pt_game_basic_list_by_game_id_params& assign(const mcp_get_pt_game_basic_list_by_game_id_params& v);
// @@string game_id=in();
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline mcp_get_pt_game_basic_list_by_game_id_params& set_game_id(const char* s,ssize_t size=-1);
inline mcp_get_pt_game_basic_list_by_game_id_params& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_game_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_pt_game_basic_list_by_game_id_params
class mcp_get_pt_game_basic_list_by_game_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_pt_game_basic_list_by_game_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_pt_game_basic_list_by_game_id_result_params* v);
explicit mcp_get_pt_game_basic_list_by_game_id_result_params(bsl::mempool* pool);
mcp_get_pt_game_basic_list_by_game_id_result_params(const mcp_get_pt_game_basic_list_by_game_id_result_params& v);
~mcp_get_pt_game_basic_list_by_game_id_result_params();
mcp_get_pt_game_basic_list_by_game_id_result_params& operator=(const mcp_get_pt_game_basic_list_by_game_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_pt_game_basic_list_by_game_id_result_params& assign(const mcp_get_pt_game_basic_list_by_game_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_pt_game_basic_list_by_game_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@pt_game_basic_info_t pt_game_basic_list=out(),array(0);
inline bool has_pt_game_basic_list() const;
inline const ::idl::vector< ::idl::pt_game_basic_info_t >& pt_game_basic_list() const;
inline ::idl::vector< ::idl::pt_game_basic_info_t >* mutable_pt_game_basic_list();
inline void clear_pt_game_basic_list();
// deprecated.use 'mutable_pt_game_basic_list' instead.
inline ::idl::vector< ::idl::pt_game_basic_info_t >* m_pt_game_basic_list();
// deprecated.use 'pt_game_basic_list().size()' instead.
inline size_t pt_game_basic_list_size() const;
inline const ::idl::pt_game_basic_info_t& pt_game_basic_list(size_t i0) const;
inline ::idl::pt_game_basic_info_t* mutable_pt_game_basic_list(size_t i0);
// deprecated.use 'mutable_pt_game_basic_list' instead.
inline ::idl::pt_game_basic_info_t* m_pt_game_basic_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::pt_game_basic_info_t > _m_pt_game_basic_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_pt_game_basic_list_by_game_id_result_params
class mcp_get_pt_game_basic_list_by_game_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_pt_game_basic_list_by_game_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_pt_game_basic_list_by_game_id_response* v);
explicit mcp_get_pt_game_basic_list_by_game_id_response(bsl::mempool* pool);
mcp_get_pt_game_basic_list_by_game_id_response(const mcp_get_pt_game_basic_list_by_game_id_response& v);
~mcp_get_pt_game_basic_list_by_game_id_response();
mcp_get_pt_game_basic_list_by_game_id_response& operator=(const mcp_get_pt_game_basic_list_by_game_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_pt_game_basic_list_by_game_id_response& assign(const mcp_get_pt_game_basic_list_by_game_id_response& v);
// @@mcp_get_pt_game_basic_list_by_game_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_pt_game_basic_list_by_game_id_result_params& result_params() const;
inline ::idl::mcp_get_pt_game_basic_list_by_game_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_pt_game_basic_list_by_game_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_pt_game_basic_list_by_game_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_pt_game_basic_list_by_game_id_response
class mcp_get_pt_game_basic_list_by_app_key_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_pt_game_basic_list_by_app_key_params* create(bsl::mempool* pool);
static void destroy(mcp_get_pt_game_basic_list_by_app_key_params* v);
explicit mcp_get_pt_game_basic_list_by_app_key_params(bsl::mempool* pool);
mcp_get_pt_game_basic_list_by_app_key_params(const mcp_get_pt_game_basic_list_by_app_key_params& v);
~mcp_get_pt_game_basic_list_by_app_key_params();
mcp_get_pt_game_basic_list_by_app_key_params& operator=(const mcp_get_pt_game_basic_list_by_app_key_params& v);
void clear();
void check() const;
void detach();
mcp_get_pt_game_basic_list_by_app_key_params& assign(const mcp_get_pt_game_basic_list_by_app_key_params& v);
// @@string app_key=in();
inline bool has_app_key() const;
inline const char* app_key(unsigned int* size=0) const;
inline mcp_get_pt_game_basic_list_by_app_key_params& set_app_key(const char* s,ssize_t size=-1);
inline mcp_get_pt_game_basic_list_by_app_key_params& set_ptr_app_key(const char* s,ssize_t size=-1);
inline void clear_app_key();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_app_key;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_pt_game_basic_list_by_app_key_params
class mcp_get_pt_game_basic_list_by_app_key_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_pt_game_basic_list_by_app_key_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_pt_game_basic_list_by_app_key_result_params* v);
explicit mcp_get_pt_game_basic_list_by_app_key_result_params(bsl::mempool* pool);
mcp_get_pt_game_basic_list_by_app_key_result_params(const mcp_get_pt_game_basic_list_by_app_key_result_params& v);
~mcp_get_pt_game_basic_list_by_app_key_result_params();
mcp_get_pt_game_basic_list_by_app_key_result_params& operator=(const mcp_get_pt_game_basic_list_by_app_key_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_pt_game_basic_list_by_app_key_result_params& assign(const mcp_get_pt_game_basic_list_by_app_key_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_pt_game_basic_list_by_app_key_result_params& set_count(int32_t v);
inline void clear_count();
// @@pt_game_basic_info_t pt_game_basic_list=out(),array(0);
inline bool has_pt_game_basic_list() const;
inline const ::idl::vector< ::idl::pt_game_basic_info_t >& pt_game_basic_list() const;
inline ::idl::vector< ::idl::pt_game_basic_info_t >* mutable_pt_game_basic_list();
inline void clear_pt_game_basic_list();
// deprecated.use 'mutable_pt_game_basic_list' instead.
inline ::idl::vector< ::idl::pt_game_basic_info_t >* m_pt_game_basic_list();
// deprecated.use 'pt_game_basic_list().size()' instead.
inline size_t pt_game_basic_list_size() const;
inline const ::idl::pt_game_basic_info_t& pt_game_basic_list(size_t i0) const;
inline ::idl::pt_game_basic_info_t* mutable_pt_game_basic_list(size_t i0);
// deprecated.use 'mutable_pt_game_basic_list' instead.
inline ::idl::pt_game_basic_info_t* m_pt_game_basic_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::pt_game_basic_info_t > _m_pt_game_basic_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_pt_game_basic_list_by_app_key_result_params
class mcp_get_pt_game_basic_list_by_app_key_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_pt_game_basic_list_by_app_key_response* create(bsl::mempool* pool);
static void destroy(mcp_get_pt_game_basic_list_by_app_key_response* v);
explicit mcp_get_pt_game_basic_list_by_app_key_response(bsl::mempool* pool);
mcp_get_pt_game_basic_list_by_app_key_response(const mcp_get_pt_game_basic_list_by_app_key_response& v);
~mcp_get_pt_game_basic_list_by_app_key_response();
mcp_get_pt_game_basic_list_by_app_key_response& operator=(const mcp_get_pt_game_basic_list_by_app_key_response& v);
void clear();
void check() const;
void detach();
mcp_get_pt_game_basic_list_by_app_key_response& assign(const mcp_get_pt_game_basic_list_by_app_key_response& v);
// @@mcp_get_pt_game_basic_list_by_app_key_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_pt_game_basic_list_by_app_key_result_params& result_params() const;
inline ::idl::mcp_get_pt_game_basic_list_by_app_key_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_pt_game_basic_list_by_app_key_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_pt_game_basic_list_by_app_key_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_pt_game_basic_list_by_app_key_response
class mcp_get_pt_app_key_by_game_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_pt_app_key_by_game_id_params* create(bsl::mempool* pool);
static void destroy(mcp_get_pt_app_key_by_game_id_params* v);
explicit mcp_get_pt_app_key_by_game_id_params(bsl::mempool* pool);
mcp_get_pt_app_key_by_game_id_params(const mcp_get_pt_app_key_by_game_id_params& v);
~mcp_get_pt_app_key_by_game_id_params();
mcp_get_pt_app_key_by_game_id_params& operator=(const mcp_get_pt_app_key_by_game_id_params& v);
void clear();
void check() const;
void detach();
mcp_get_pt_app_key_by_game_id_params& assign(const mcp_get_pt_app_key_by_game_id_params& v);
// @@string game_id=in();
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline mcp_get_pt_app_key_by_game_id_params& set_game_id(const char* s,ssize_t size=-1);
inline mcp_get_pt_app_key_by_game_id_params& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_game_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_pt_app_key_by_game_id_params
class mcp_get_pt_app_key_by_game_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_pt_app_key_by_game_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_pt_app_key_by_game_id_result_params* v);
explicit mcp_get_pt_app_key_by_game_id_result_params(bsl::mempool* pool);
mcp_get_pt_app_key_by_game_id_result_params(const mcp_get_pt_app_key_by_game_id_result_params& v);
~mcp_get_pt_app_key_by_game_id_result_params();
mcp_get_pt_app_key_by_game_id_result_params& operator=(const mcp_get_pt_app_key_by_game_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_pt_app_key_by_game_id_result_params& assign(const mcp_get_pt_app_key_by_game_id_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_pt_app_key_by_game_id_result_params& set_count(int32_t v);
inline void clear_count();
// @@string app_key=out();
inline bool has_app_key() const;
inline const char* app_key(unsigned int* size=0) const;
inline mcp_get_pt_app_key_by_game_id_result_params& set_app_key(const char* s,ssize_t size=-1);
inline mcp_get_pt_app_key_by_game_id_result_params& set_ptr_app_key(const char* s,ssize_t size=-1);
inline void clear_app_key();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::string _m_app_key;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_pt_app_key_by_game_id_result_params
class mcp_get_pt_app_key_by_game_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_pt_app_key_by_game_id_response* create(bsl::mempool* pool);
static void destroy(mcp_get_pt_app_key_by_game_id_response* v);
explicit mcp_get_pt_app_key_by_game_id_response(bsl::mempool* pool);
mcp_get_pt_app_key_by_game_id_response(const mcp_get_pt_app_key_by_game_id_response& v);
~mcp_get_pt_app_key_by_game_id_response();
mcp_get_pt_app_key_by_game_id_response& operator=(const mcp_get_pt_app_key_by_game_id_response& v);
void clear();
void check() const;
void detach();
mcp_get_pt_app_key_by_game_id_response& assign(const mcp_get_pt_app_key_by_game_id_response& v);
// @@mcp_get_pt_app_key_by_game_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_pt_app_key_by_game_id_result_params& result_params() const;
inline ::idl::mcp_get_pt_app_key_by_game_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_pt_app_key_by_game_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_pt_app_key_by_game_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_pt_app_key_by_game_id_response
class mcp_get_pt_game_id_by_app_key_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_pt_game_id_by_app_key_params* create(bsl::mempool* pool);
static void destroy(mcp_get_pt_game_id_by_app_key_params* v);
explicit mcp_get_pt_game_id_by_app_key_params(bsl::mempool* pool);
mcp_get_pt_game_id_by_app_key_params(const mcp_get_pt_game_id_by_app_key_params& v);
~mcp_get_pt_game_id_by_app_key_params();
mcp_get_pt_game_id_by_app_key_params& operator=(const mcp_get_pt_game_id_by_app_key_params& v);
void clear();
void check() const;
void detach();
mcp_get_pt_game_id_by_app_key_params& assign(const mcp_get_pt_game_id_by_app_key_params& v);
// @@string app_key=in();
inline bool has_app_key() const;
inline const char* app_key(unsigned int* size=0) const;
inline mcp_get_pt_game_id_by_app_key_params& set_app_key(const char* s,ssize_t size=-1);
inline mcp_get_pt_game_id_by_app_key_params& set_ptr_app_key(const char* s,ssize_t size=-1);
inline void clear_app_key();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_app_key;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_pt_game_id_by_app_key_params
class mcp_get_pt_game_id_by_app_key_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_pt_game_id_by_app_key_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_pt_game_id_by_app_key_result_params* v);
explicit mcp_get_pt_game_id_by_app_key_result_params(bsl::mempool* pool);
mcp_get_pt_game_id_by_app_key_result_params(const mcp_get_pt_game_id_by_app_key_result_params& v);
~mcp_get_pt_game_id_by_app_key_result_params();
mcp_get_pt_game_id_by_app_key_result_params& operator=(const mcp_get_pt_game_id_by_app_key_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_pt_game_id_by_app_key_result_params& assign(const mcp_get_pt_game_id_by_app_key_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_pt_game_id_by_app_key_result_params& set_count(int32_t v);
inline void clear_count();
// @@string game_id=out();
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline mcp_get_pt_game_id_by_app_key_result_params& set_game_id(const char* s,ssize_t size=-1);
inline mcp_get_pt_game_id_by_app_key_result_params& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::string _m_game_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_pt_game_id_by_app_key_result_params
class mcp_get_pt_game_id_by_app_key_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_pt_game_id_by_app_key_response* create(bsl::mempool* pool);
static void destroy(mcp_get_pt_game_id_by_app_key_response* v);
explicit mcp_get_pt_game_id_by_app_key_response(bsl::mempool* pool);
mcp_get_pt_game_id_by_app_key_response(const mcp_get_pt_game_id_by_app_key_response& v);
~mcp_get_pt_game_id_by_app_key_response();
mcp_get_pt_game_id_by_app_key_response& operator=(const mcp_get_pt_game_id_by_app_key_response& v);
void clear();
void check() const;
void detach();
mcp_get_pt_game_id_by_app_key_response& assign(const mcp_get_pt_game_id_by_app_key_response& v);
// @@mcp_get_pt_game_id_by_app_key_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_pt_game_id_by_app_key_result_params& result_params() const;
inline ::idl::mcp_get_pt_game_id_by_app_key_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_pt_game_id_by_app_key_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_pt_game_id_by_app_key_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_pt_game_id_by_app_key_response
class mcp_exist_pt_game_by_game_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_exist_pt_game_by_game_id_params* create(bsl::mempool* pool);
static void destroy(mcp_exist_pt_game_by_game_id_params* v);
explicit mcp_exist_pt_game_by_game_id_params(bsl::mempool* pool);
mcp_exist_pt_game_by_game_id_params(const mcp_exist_pt_game_by_game_id_params& v);
~mcp_exist_pt_game_by_game_id_params();
mcp_exist_pt_game_by_game_id_params& operator=(const mcp_exist_pt_game_by_game_id_params& v);
void clear();
void check() const;
void detach();
mcp_exist_pt_game_by_game_id_params& assign(const mcp_exist_pt_game_by_game_id_params& v);
// @@string game_id=in();
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline mcp_exist_pt_game_by_game_id_params& set_game_id(const char* s,ssize_t size=-1);
inline mcp_exist_pt_game_by_game_id_params& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_game_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_exist_pt_game_by_game_id_params
class mcp_exist_pt_game_by_game_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_exist_pt_game_by_game_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_exist_pt_game_by_game_id_result_params* v);
explicit mcp_exist_pt_game_by_game_id_result_params(bsl::mempool* pool);
mcp_exist_pt_game_by_game_id_result_params(const mcp_exist_pt_game_by_game_id_result_params& v);
~mcp_exist_pt_game_by_game_id_result_params();
mcp_exist_pt_game_by_game_id_result_params& operator=(const mcp_exist_pt_game_by_game_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_exist_pt_game_by_game_id_result_params& assign(const mcp_exist_pt_game_by_game_id_result_params& v);
// @@int32_t flag=out();
inline bool has_flag() const;
inline int32_t flag() const;
inline mcp_exist_pt_game_by_game_id_result_params& set_flag(int32_t v);
inline void clear_flag();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_flag;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_exist_pt_game_by_game_id_result_params
class mcp_exist_pt_game_by_game_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_exist_pt_game_by_game_id_response* create(bsl::mempool* pool);
static void destroy(mcp_exist_pt_game_by_game_id_response* v);
explicit mcp_exist_pt_game_by_game_id_response(bsl::mempool* pool);
mcp_exist_pt_game_by_game_id_response(const mcp_exist_pt_game_by_game_id_response& v);
~mcp_exist_pt_game_by_game_id_response();
mcp_exist_pt_game_by_game_id_response& operator=(const mcp_exist_pt_game_by_game_id_response& v);
void clear();
void check() const;
void detach();
mcp_exist_pt_game_by_game_id_response& assign(const mcp_exist_pt_game_by_game_id_response& v);
// @@mcp_exist_pt_game_by_game_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_exist_pt_game_by_game_id_result_params& result_params() const;
inline ::idl::mcp_exist_pt_game_by_game_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_exist_pt_game_by_game_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_exist_pt_game_by_game_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_exist_pt_game_by_game_id_response
class mcp_is_same_pt_game_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_is_same_pt_game_params* create(bsl::mempool* pool);
static void destroy(mcp_is_same_pt_game_params* v);
explicit mcp_is_same_pt_game_params(bsl::mempool* pool);
mcp_is_same_pt_game_params(const mcp_is_same_pt_game_params& v);
~mcp_is_same_pt_game_params();
mcp_is_same_pt_game_params& operator=(const mcp_is_same_pt_game_params& v);
void clear();
void check() const;
void detach();
mcp_is_same_pt_game_params& assign(const mcp_is_same_pt_game_params& v);
// @@string game_id=in();
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline mcp_is_same_pt_game_params& set_game_id(const char* s,ssize_t size=-1);
inline mcp_is_same_pt_game_params& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
// @@string app_key=in();
inline bool has_app_key() const;
inline const char* app_key(unsigned int* size=0) const;
inline mcp_is_same_pt_game_params& set_app_key(const char* s,ssize_t size=-1);
inline mcp_is_same_pt_game_params& set_ptr_app_key(const char* s,ssize_t size=-1);
inline void clear_app_key();
// @@string app_secret=in();
inline bool has_app_secret() const;
inline const char* app_secret(unsigned int* size=0) const;
inline mcp_is_same_pt_game_params& set_app_secret(const char* s,ssize_t size=-1);
inline mcp_is_same_pt_game_params& set_ptr_app_secret(const char* s,ssize_t size=-1);
inline void clear_app_secret();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_game_id;
 ::idl::string _m_app_key;
 ::idl::string _m_app_secret;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_is_same_pt_game_params
class mcp_is_same_pt_game_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_is_same_pt_game_result_params* create(bsl::mempool* pool);
static void destroy(mcp_is_same_pt_game_result_params* v);
explicit mcp_is_same_pt_game_result_params(bsl::mempool* pool);
mcp_is_same_pt_game_result_params(const mcp_is_same_pt_game_result_params& v);
~mcp_is_same_pt_game_result_params();
mcp_is_same_pt_game_result_params& operator=(const mcp_is_same_pt_game_result_params& v);
void clear();
void check() const;
void detach();
mcp_is_same_pt_game_result_params& assign(const mcp_is_same_pt_game_result_params& v);
// @@int32_t flag=out();
inline bool has_flag() const;
inline int32_t flag() const;
inline mcp_is_same_pt_game_result_params& set_flag(int32_t v);
inline void clear_flag();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_flag;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_is_same_pt_game_result_params
class mcp_is_same_pt_game_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_is_same_pt_game_response* create(bsl::mempool* pool);
static void destroy(mcp_is_same_pt_game_response* v);
explicit mcp_is_same_pt_game_response(bsl::mempool* pool);
mcp_is_same_pt_game_response(const mcp_is_same_pt_game_response& v);
~mcp_is_same_pt_game_response();
mcp_is_same_pt_game_response& operator=(const mcp_is_same_pt_game_response& v);
void clear();
void check() const;
void detach();
mcp_is_same_pt_game_response& assign(const mcp_is_same_pt_game_response& v);
// @@mcp_is_same_pt_game_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_is_same_pt_game_result_params& result_params() const;
inline ::idl::mcp_is_same_pt_game_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_is_same_pt_game_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_is_same_pt_game_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_is_same_pt_game_response
class mcp_remove_pt_game_basic_list_by_app_key_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_remove_pt_game_basic_list_by_app_key_params* create(bsl::mempool* pool);
static void destroy(mcp_remove_pt_game_basic_list_by_app_key_params* v);
explicit mcp_remove_pt_game_basic_list_by_app_key_params(bsl::mempool* pool);
mcp_remove_pt_game_basic_list_by_app_key_params(const mcp_remove_pt_game_basic_list_by_app_key_params& v);
~mcp_remove_pt_game_basic_list_by_app_key_params();
mcp_remove_pt_game_basic_list_by_app_key_params& operator=(const mcp_remove_pt_game_basic_list_by_app_key_params& v);
void clear();
void check() const;
void detach();
mcp_remove_pt_game_basic_list_by_app_key_params& assign(const mcp_remove_pt_game_basic_list_by_app_key_params& v);
// @@string app_key=in();
inline bool has_app_key() const;
inline const char* app_key(unsigned int* size=0) const;
inline mcp_remove_pt_game_basic_list_by_app_key_params& set_app_key(const char* s,ssize_t size=-1);
inline mcp_remove_pt_game_basic_list_by_app_key_params& set_ptr_app_key(const char* s,ssize_t size=-1);
inline void clear_app_key();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_app_key;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_remove_pt_game_basic_list_by_app_key_params
class mcp_remove_pt_game_basic_list_by_app_key_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_remove_pt_game_basic_list_by_app_key_result_params* create(bsl::mempool* pool);
static void destroy(mcp_remove_pt_game_basic_list_by_app_key_result_params* v);
explicit mcp_remove_pt_game_basic_list_by_app_key_result_params(bsl::mempool* pool);
mcp_remove_pt_game_basic_list_by_app_key_result_params(const mcp_remove_pt_game_basic_list_by_app_key_result_params& v);
~mcp_remove_pt_game_basic_list_by_app_key_result_params();
mcp_remove_pt_game_basic_list_by_app_key_result_params& operator=(const mcp_remove_pt_game_basic_list_by_app_key_result_params& v);
void clear();
void check() const;
void detach();
mcp_remove_pt_game_basic_list_by_app_key_result_params& assign(const mcp_remove_pt_game_basic_list_by_app_key_result_params& v);
// @@int32_t flag=out();
inline bool has_flag() const;
inline int32_t flag() const;
inline mcp_remove_pt_game_basic_list_by_app_key_result_params& set_flag(int32_t v);
inline void clear_flag();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_flag;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_remove_pt_game_basic_list_by_app_key_result_params
class mcp_remove_pt_game_basic_list_by_app_key_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_remove_pt_game_basic_list_by_app_key_response* create(bsl::mempool* pool);
static void destroy(mcp_remove_pt_game_basic_list_by_app_key_response* v);
explicit mcp_remove_pt_game_basic_list_by_app_key_response(bsl::mempool* pool);
mcp_remove_pt_game_basic_list_by_app_key_response(const mcp_remove_pt_game_basic_list_by_app_key_response& v);
~mcp_remove_pt_game_basic_list_by_app_key_response();
mcp_remove_pt_game_basic_list_by_app_key_response& operator=(const mcp_remove_pt_game_basic_list_by_app_key_response& v);
void clear();
void check() const;
void detach();
mcp_remove_pt_game_basic_list_by_app_key_response& assign(const mcp_remove_pt_game_basic_list_by_app_key_response& v);
// @@mcp_remove_pt_game_basic_list_by_app_key_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params& result_params() const;
inline ::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_remove_pt_game_basic_list_by_app_key_response
class mcp_add_new_user_consume_record_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_new_user_consume_record_params* create(bsl::mempool* pool);
static void destroy(mcp_add_new_user_consume_record_params* v);
explicit mcp_add_new_user_consume_record_params(bsl::mempool* pool);
mcp_add_new_user_consume_record_params(const mcp_add_new_user_consume_record_params& v);
~mcp_add_new_user_consume_record_params();
mcp_add_new_user_consume_record_params& operator=(const mcp_add_new_user_consume_record_params& v);
void clear();
void check() const;
void detach();
mcp_add_new_user_consume_record_params& assign(const mcp_add_new_user_consume_record_params& v);
// @@string imei_id=in();
inline bool has_imei_id() const;
inline const char* imei_id(unsigned int* size=0) const;
inline mcp_add_new_user_consume_record_params& set_imei_id(const char* s,ssize_t size=-1);
inline mcp_add_new_user_consume_record_params& set_ptr_imei_id(const char* s,ssize_t size=-1);
inline void clear_imei_id();
// @@string order_id=in();
inline bool has_order_id() const;
inline const char* order_id(unsigned int* size=0) const;
inline mcp_add_new_user_consume_record_params& set_order_id(const char* s,ssize_t size=-1);
inline mcp_add_new_user_consume_record_params& set_ptr_order_id(const char* s,ssize_t size=-1);
inline void clear_order_id();
// @@string goods_id=in();
inline bool has_goods_id() const;
inline const char* goods_id(unsigned int* size=0) const;
inline mcp_add_new_user_consume_record_params& set_goods_id(const char* s,ssize_t size=-1);
inline mcp_add_new_user_consume_record_params& set_ptr_goods_id(const char* s,ssize_t size=-1);
inline void clear_goods_id();
// @@string consume_date=in();
inline bool has_consume_date() const;
inline const char* consume_date(unsigned int* size=0) const;
inline mcp_add_new_user_consume_record_params& set_consume_date(const char* s,ssize_t size=-1);
inline mcp_add_new_user_consume_record_params& set_ptr_consume_date(const char* s,ssize_t size=-1);
inline void clear_consume_date();
// @@string udid=in();
inline bool has_udid() const;
inline const char* udid(unsigned int* size=0) const;
inline mcp_add_new_user_consume_record_params& set_udid(const char* s,ssize_t size=-1);
inline mcp_add_new_user_consume_record_params& set_ptr_udid(const char* s,ssize_t size=-1);
inline void clear_udid();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_imei_id;
 ::idl::string _m_order_id;
 ::idl::string _m_goods_id;
 ::idl::string _m_consume_date;
 ::idl::string _m_udid;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_new_user_consume_record_params
class mcp_add_new_user_consume_record_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_new_user_consume_record_result_params* create(bsl::mempool* pool);
static void destroy(mcp_add_new_user_consume_record_result_params* v);
explicit mcp_add_new_user_consume_record_result_params(bsl::mempool* pool);
mcp_add_new_user_consume_record_result_params(const mcp_add_new_user_consume_record_result_params& v);
~mcp_add_new_user_consume_record_result_params();
mcp_add_new_user_consume_record_result_params& operator=(const mcp_add_new_user_consume_record_result_params& v);
void clear();
void check() const;
void detach();
mcp_add_new_user_consume_record_result_params& assign(const mcp_add_new_user_consume_record_result_params& v);
// @@int32_t ret_code=out();
inline bool has_ret_code() const;
inline int32_t ret_code() const;
inline mcp_add_new_user_consume_record_result_params& set_ret_code(int32_t v);
inline void clear_ret_code();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_ret_code;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_new_user_consume_record_result_params
class mcp_add_new_user_consume_record_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_new_user_consume_record_response* create(bsl::mempool* pool);
static void destroy(mcp_add_new_user_consume_record_response* v);
explicit mcp_add_new_user_consume_record_response(bsl::mempool* pool);
mcp_add_new_user_consume_record_response(const mcp_add_new_user_consume_record_response& v);
~mcp_add_new_user_consume_record_response();
mcp_add_new_user_consume_record_response& operator=(const mcp_add_new_user_consume_record_response& v);
void clear();
void check() const;
void detach();
mcp_add_new_user_consume_record_response& assign(const mcp_add_new_user_consume_record_response& v);
// @@mcp_add_new_user_consume_record_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_add_new_user_consume_record_result_params& result_params() const;
inline ::idl::mcp_add_new_user_consume_record_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_add_new_user_consume_record_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_add_new_user_consume_record_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_new_user_consume_record_response
class mcp_get_game_news_info_list_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_news_info_list_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_news_info_list_params* v);
explicit mcp_get_game_news_info_list_params(bsl::mempool* pool);
mcp_get_game_news_info_list_params(const mcp_get_game_news_info_list_params& v);
~mcp_get_game_news_info_list_params();
mcp_get_game_news_info_list_params& operator=(const mcp_get_game_news_info_list_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_news_info_list_params& assign(const mcp_get_game_news_info_list_params& v);
// @@string game_id=in();
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline mcp_get_game_news_info_list_params& set_game_id(const char* s,ssize_t size=-1);
inline mcp_get_game_news_info_list_params& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
// @@string ov_id=in();
inline bool has_ov_id() const;
inline const char* ov_id(unsigned int* size=0) const;
inline mcp_get_game_news_info_list_params& set_ov_id(const char* s,ssize_t size=-1);
inline mcp_get_game_news_info_list_params& set_ptr_ov_id(const char* s,ssize_t size=-1);
inline void clear_ov_id();
// @@string news_type=in();
inline bool has_news_type() const;
inline const char* news_type(unsigned int* size=0) const;
inline mcp_get_game_news_info_list_params& set_news_type(const char* s,ssize_t size=-1);
inline mcp_get_game_news_info_list_params& set_ptr_news_type(const char* s,ssize_t size=-1);
inline void clear_news_type();
// @@string date_limit=in();
inline bool has_date_limit() const;
inline const char* date_limit(unsigned int* size=0) const;
inline mcp_get_game_news_info_list_params& set_date_limit(const char* s,ssize_t size=-1);
inline mcp_get_game_news_info_list_params& set_ptr_date_limit(const char* s,ssize_t size=-1);
inline void clear_date_limit();
// @@string game_imgtypes=in();
inline bool has_game_imgtypes() const;
inline const char* game_imgtypes(unsigned int* size=0) const;
inline mcp_get_game_news_info_list_params& set_game_imgtypes(const char* s,ssize_t size=-1);
inline mcp_get_game_news_info_list_params& set_ptr_game_imgtypes(const char* s,ssize_t size=-1);
inline void clear_game_imgtypes();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_game_news_info_list_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_game_news_info_list_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_game_id;
 ::idl::string _m_ov_id;
 ::idl::string _m_news_type;
 ::idl::string _m_date_limit;
 ::idl::string _m_game_imgtypes;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_news_info_list_params
class mcp_get_game_news_info_list_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_news_info_list_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_news_info_list_result_params* v);
explicit mcp_get_game_news_info_list_result_params(bsl::mempool* pool);
mcp_get_game_news_info_list_result_params(const mcp_get_game_news_info_list_result_params& v);
~mcp_get_game_news_info_list_result_params();
mcp_get_game_news_info_list_result_params& operator=(const mcp_get_game_news_info_list_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_news_info_list_result_params& assign(const mcp_get_game_news_info_list_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_game_news_info_list_result_params& set_count(int32_t v);
inline void clear_count();
// @@game_news_info_t game_news_info_list=out(),array(0);
inline bool has_game_news_info_list() const;
inline const ::idl::vector< ::idl::game_news_info_t >& game_news_info_list() const;
inline ::idl::vector< ::idl::game_news_info_t >* mutable_game_news_info_list();
inline void clear_game_news_info_list();
// deprecated.use 'mutable_game_news_info_list' instead.
inline ::idl::vector< ::idl::game_news_info_t >* m_game_news_info_list();
// deprecated.use 'game_news_info_list().size()' instead.
inline size_t game_news_info_list_size() const;
inline const ::idl::game_news_info_t& game_news_info_list(size_t i0) const;
inline ::idl::game_news_info_t* mutable_game_news_info_list(size_t i0);
// deprecated.use 'mutable_game_news_info_list' instead.
inline ::idl::game_news_info_t* m_game_news_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::game_news_info_t > _m_game_news_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_news_info_list_result_params
class mcp_get_game_news_info_list_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_news_info_list_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_news_info_list_response* v);
explicit mcp_get_game_news_info_list_response(bsl::mempool* pool);
mcp_get_game_news_info_list_response(const mcp_get_game_news_info_list_response& v);
~mcp_get_game_news_info_list_response();
mcp_get_game_news_info_list_response& operator=(const mcp_get_game_news_info_list_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_news_info_list_response& assign(const mcp_get_game_news_info_list_response& v);
// @@mcp_get_game_news_info_list_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_news_info_list_result_params& result_params() const;
inline ::idl::mcp_get_game_news_info_list_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_news_info_list_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_news_info_list_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_news_info_list_response
class mcp_get_game_news_entire_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_news_entire_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_news_entire_info_params* v);
explicit mcp_get_game_news_entire_info_params(bsl::mempool* pool);
mcp_get_game_news_entire_info_params(const mcp_get_game_news_entire_info_params& v);
~mcp_get_game_news_entire_info_params();
mcp_get_game_news_entire_info_params& operator=(const mcp_get_game_news_entire_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_news_entire_info_params& assign(const mcp_get_game_news_entire_info_params& v);
// @@string news_id=in();
inline bool has_news_id() const;
inline const char* news_id(unsigned int* size=0) const;
inline mcp_get_game_news_entire_info_params& set_news_id(const char* s,ssize_t size=-1);
inline mcp_get_game_news_entire_info_params& set_ptr_news_id(const char* s,ssize_t size=-1);
inline void clear_news_id();
// @@string game_id=in();
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline mcp_get_game_news_entire_info_params& set_game_id(const char* s,ssize_t size=-1);
inline mcp_get_game_news_entire_info_params& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
// @@string news_type=in();
inline bool has_news_type() const;
inline const char* news_type(unsigned int* size=0) const;
inline mcp_get_game_news_entire_info_params& set_news_type(const char* s,ssize_t size=-1);
inline mcp_get_game_news_entire_info_params& set_ptr_news_type(const char* s,ssize_t size=-1);
inline void clear_news_type();
// @@string date_limit=in();
inline bool has_date_limit() const;
inline const char* date_limit(unsigned int* size=0) const;
inline mcp_get_game_news_entire_info_params& set_date_limit(const char* s,ssize_t size=-1);
inline mcp_get_game_news_entire_info_params& set_ptr_date_limit(const char* s,ssize_t size=-1);
inline void clear_date_limit();
// @@string order_type=in();
inline bool has_order_type() const;
inline const char* order_type(unsigned int* size=0) const;
inline mcp_get_game_news_entire_info_params& set_order_type(const char* s,ssize_t size=-1);
inline mcp_get_game_news_entire_info_params& set_ptr_order_type(const char* s,ssize_t size=-1);
inline void clear_order_type();
// @@string game_imgtypes=in();
inline bool has_game_imgtypes() const;
inline const char* game_imgtypes(unsigned int* size=0) const;
inline mcp_get_game_news_entire_info_params& set_game_imgtypes(const char* s,ssize_t size=-1);
inline mcp_get_game_news_entire_info_params& set_ptr_game_imgtypes(const char* s,ssize_t size=-1);
inline void clear_game_imgtypes();
// @@string channel_info=in();
inline bool has_channel_info() const;
inline const char* channel_info(unsigned int* size=0) const;
inline mcp_get_game_news_entire_info_params& set_channel_info(const char* s,ssize_t size=-1);
inline mcp_get_game_news_entire_info_params& set_ptr_channel_info(const char* s,ssize_t size=-1);
inline void clear_channel_info();
// @@string channel_id=in();
inline bool has_channel_id() const;
inline const char* channel_id(unsigned int* size=0) const;
inline mcp_get_game_news_entire_info_params& set_channel_id(const char* s,ssize_t size=-1);
inline mcp_get_game_news_entire_info_params& set_ptr_channel_id(const char* s,ssize_t size=-1);
inline void clear_channel_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_game_news_entire_info_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_game_news_entire_info_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_news_id;
 ::idl::string _m_game_id;
 ::idl::string _m_news_type;
 ::idl::string _m_date_limit;
 ::idl::string _m_order_type;
 ::idl::string _m_game_imgtypes;
 ::idl::string _m_channel_info;
 ::idl::string _m_channel_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[2];
}; // class mcp_get_game_news_entire_info_params
class mcp_get_game_news_entire_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_news_entire_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_news_entire_info_result_params* v);
explicit mcp_get_game_news_entire_info_result_params(bsl::mempool* pool);
mcp_get_game_news_entire_info_result_params(const mcp_get_game_news_entire_info_result_params& v);
~mcp_get_game_news_entire_info_result_params();
mcp_get_game_news_entire_info_result_params& operator=(const mcp_get_game_news_entire_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_news_entire_info_result_params& assign(const mcp_get_game_news_entire_info_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_game_news_entire_info_result_params& set_count(int32_t v);
inline void clear_count();
// @@game_news_entire_info_t game_news_list=out(),array(0);
inline bool has_game_news_list() const;
inline const ::idl::vector< ::idl::game_news_entire_info_t >& game_news_list() const;
inline ::idl::vector< ::idl::game_news_entire_info_t >* mutable_game_news_list();
inline void clear_game_news_list();
// deprecated.use 'mutable_game_news_list' instead.
inline ::idl::vector< ::idl::game_news_entire_info_t >* m_game_news_list();
// deprecated.use 'game_news_list().size()' instead.
inline size_t game_news_list_size() const;
inline const ::idl::game_news_entire_info_t& game_news_list(size_t i0) const;
inline ::idl::game_news_entire_info_t* mutable_game_news_list(size_t i0);
// deprecated.use 'mutable_game_news_list' instead.
inline ::idl::game_news_entire_info_t* m_game_news_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::game_news_entire_info_t > _m_game_news_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_news_entire_info_result_params
class mcp_get_game_news_entire_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_news_entire_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_news_entire_info_response* v);
explicit mcp_get_game_news_entire_info_response(bsl::mempool* pool);
mcp_get_game_news_entire_info_response(const mcp_get_game_news_entire_info_response& v);
~mcp_get_game_news_entire_info_response();
mcp_get_game_news_entire_info_response& operator=(const mcp_get_game_news_entire_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_news_entire_info_response& assign(const mcp_get_game_news_entire_info_response& v);
// @@mcp_get_game_news_entire_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_news_entire_info_result_params& result_params() const;
inline ::idl::mcp_get_game_news_entire_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_news_entire_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_news_entire_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_news_entire_info_response
class mcp_get_netgame_activity_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_netgame_activity_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_netgame_activity_info_params* v);
explicit mcp_get_netgame_activity_info_params(bsl::mempool* pool);
mcp_get_netgame_activity_info_params(const mcp_get_netgame_activity_info_params& v);
~mcp_get_netgame_activity_info_params();
mcp_get_netgame_activity_info_params& operator=(const mcp_get_netgame_activity_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_netgame_activity_info_params& assign(const mcp_get_netgame_activity_info_params& v);
// @@string game_id=in();
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline mcp_get_netgame_activity_info_params& set_game_id(const char* s,ssize_t size=-1);
inline mcp_get_netgame_activity_info_params& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
// @@string act_id=in();
inline bool has_act_id() const;
inline const char* act_id(unsigned int* size=0) const;
inline mcp_get_netgame_activity_info_params& set_act_id(const char* s,ssize_t size=-1);
inline mcp_get_netgame_activity_info_params& set_ptr_act_id(const char* s,ssize_t size=-1);
inline void clear_act_id();
// @@string date_limit=in();
inline bool has_date_limit() const;
inline const char* date_limit(unsigned int* size=0) const;
inline mcp_get_netgame_activity_info_params& set_date_limit(const char* s,ssize_t size=-1);
inline mcp_get_netgame_activity_info_params& set_ptr_date_limit(const char* s,ssize_t size=-1);
inline void clear_date_limit();
// @@string channel=in();
inline bool has_channel() const;
inline const char* channel(unsigned int* size=0) const;
inline mcp_get_netgame_activity_info_params& set_channel(const char* s,ssize_t size=-1);
inline mcp_get_netgame_activity_info_params& set_ptr_channel(const char* s,ssize_t size=-1);
inline void clear_channel();
// @@string game_img_type=in();
inline bool has_game_img_type() const;
inline const char* game_img_type(unsigned int* size=0) const;
inline mcp_get_netgame_activity_info_params& set_game_img_type(const char* s,ssize_t size=-1);
inline mcp_get_netgame_activity_info_params& set_ptr_game_img_type(const char* s,ssize_t size=-1);
inline void clear_game_img_type();
// @@string act_img_type=in();
inline bool has_act_img_type() const;
inline const char* act_img_type(unsigned int* size=0) const;
inline mcp_get_netgame_activity_info_params& set_act_img_type(const char* s,ssize_t size=-1);
inline mcp_get_netgame_activity_info_params& set_ptr_act_img_type(const char* s,ssize_t size=-1);
inline void clear_act_img_type();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_netgame_activity_info_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_netgame_activity_info_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_game_id;
 ::idl::string _m_act_id;
 ::idl::string _m_date_limit;
 ::idl::string _m_channel;
 ::idl::string _m_game_img_type;
 ::idl::string _m_act_img_type;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_netgame_activity_info_params
class mcp_get_netgame_activity_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_netgame_activity_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_netgame_activity_info_result_params* v);
explicit mcp_get_netgame_activity_info_result_params(bsl::mempool* pool);
mcp_get_netgame_activity_info_result_params(const mcp_get_netgame_activity_info_result_params& v);
~mcp_get_netgame_activity_info_result_params();
mcp_get_netgame_activity_info_result_params& operator=(const mcp_get_netgame_activity_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_netgame_activity_info_result_params& assign(const mcp_get_netgame_activity_info_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_netgame_activity_info_result_params& set_count(int32_t v);
inline void clear_count();
// @@netgame_activity_info_t result_list=out(),array(0);
inline bool has_result_list() const;
inline const ::idl::vector< ::idl::netgame_activity_info_t >& result_list() const;
inline ::idl::vector< ::idl::netgame_activity_info_t >* mutable_result_list();
inline void clear_result_list();
// deprecated.use 'mutable_result_list' instead.
inline ::idl::vector< ::idl::netgame_activity_info_t >* m_result_list();
// deprecated.use 'result_list().size()' instead.
inline size_t result_list_size() const;
inline const ::idl::netgame_activity_info_t& result_list(size_t i0) const;
inline ::idl::netgame_activity_info_t* mutable_result_list(size_t i0);
// deprecated.use 'mutable_result_list' instead.
inline ::idl::netgame_activity_info_t* m_result_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::netgame_activity_info_t > _m_result_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_netgame_activity_info_result_params
class mcp_get_netgame_activity_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_netgame_activity_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_netgame_activity_info_response* v);
explicit mcp_get_netgame_activity_info_response(bsl::mempool* pool);
mcp_get_netgame_activity_info_response(const mcp_get_netgame_activity_info_response& v);
~mcp_get_netgame_activity_info_response();
mcp_get_netgame_activity_info_response& operator=(const mcp_get_netgame_activity_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_netgame_activity_info_response& assign(const mcp_get_netgame_activity_info_response& v);
// @@mcp_get_netgame_activity_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_netgame_activity_info_result_params& result_params() const;
inline ::idl::mcp_get_netgame_activity_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_netgame_activity_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_netgame_activity_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_netgame_activity_info_response
class mcp_get_game_download_app_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_download_app_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_download_app_info_params* v);
explicit mcp_get_game_download_app_info_params(bsl::mempool* pool);
mcp_get_game_download_app_info_params(const mcp_get_game_download_app_info_params& v);
~mcp_get_game_download_app_info_params();
mcp_get_game_download_app_info_params& operator=(const mcp_get_game_download_app_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_download_app_info_params& assign(const mcp_get_game_download_app_info_params& v);
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_get_game_download_app_info_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_get_game_download_app_info_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string package_name=in();
inline bool has_package_name() const;
inline const char* package_name(unsigned int* size=0) const;
inline mcp_get_game_download_app_info_params& set_package_name(const char* s,ssize_t size=-1);
inline mcp_get_game_download_app_info_params& set_ptr_package_name(const char* s,ssize_t size=-1);
inline void clear_package_name();
// @@string dev_version_code=in();
inline bool has_dev_version_code() const;
inline const char* dev_version_code(unsigned int* size=0) const;
inline mcp_get_game_download_app_info_params& set_dev_version_code(const char* s,ssize_t size=-1);
inline mcp_get_game_download_app_info_params& set_ptr_dev_version_code(const char* s,ssize_t size=-1);
inline void clear_dev_version_code();
// @@string dev_version=in();
inline bool has_dev_version() const;
inline const char* dev_version(unsigned int* size=0) const;
inline mcp_get_game_download_app_info_params& set_dev_version(const char* s,ssize_t size=-1);
inline mcp_get_game_download_app_info_params& set_ptr_dev_version(const char* s,ssize_t size=-1);
inline void clear_dev_version();
// @@string apk_md5=in();
inline bool has_apk_md5() const;
inline const char* apk_md5(unsigned int* size=0) const;
inline mcp_get_game_download_app_info_params& set_apk_md5(const char* s,ssize_t size=-1);
inline mcp_get_game_download_app_info_params& set_ptr_apk_md5(const char* s,ssize_t size=-1);
inline void clear_apk_md5();
// @@string file_md5=in();
inline bool has_file_md5() const;
inline const char* file_md5(unsigned int* size=0) const;
inline mcp_get_game_download_app_info_params& set_file_md5(const char* s,ssize_t size=-1);
inline mcp_get_game_download_app_info_params& set_ptr_file_md5(const char* s,ssize_t size=-1);
inline void clear_file_md5();
// @@string game_img=in();
inline bool has_game_img() const;
inline const char* game_img(unsigned int* size=0) const;
inline mcp_get_game_download_app_info_params& set_game_img(const char* s,ssize_t size=-1);
inline mcp_get_game_download_app_info_params& set_ptr_game_img(const char* s,ssize_t size=-1);
inline void clear_game_img();
// @@string filter=in();
inline bool has_filter() const;
inline const char* filter(unsigned int* size=0) const;
inline mcp_get_game_download_app_info_params& set_filter(const char* s,ssize_t size=-1);
inline mcp_get_game_download_app_info_params& set_ptr_filter(const char* s,ssize_t size=-1);
inline void clear_filter();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_c_id;
 ::idl::string _m_package_name;
 ::idl::string _m_dev_version_code;
 ::idl::string _m_dev_version;
 ::idl::string _m_apk_md5;
 ::idl::string _m_file_md5;
 ::idl::string _m_game_img;
 ::idl::string _m_filter;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_download_app_info_params
class mcp_get_game_download_app_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_download_app_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_download_app_info_result_params* v);
explicit mcp_get_game_download_app_info_result_params(bsl::mempool* pool);
mcp_get_game_download_app_info_result_params(const mcp_get_game_download_app_info_result_params& v);
~mcp_get_game_download_app_info_result_params();
mcp_get_game_download_app_info_result_params& operator=(const mcp_get_game_download_app_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_download_app_info_result_params& assign(const mcp_get_game_download_app_info_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_game_download_app_info_result_params& set_count(uint32_t v);
inline void clear_count();
// @@game_update_download_info result_list=out(),array(0);
inline bool has_result_list() const;
inline const ::idl::vector< ::idl::game_update_download_info >& result_list() const;
inline ::idl::vector< ::idl::game_update_download_info >* mutable_result_list();
inline void clear_result_list();
// deprecated.use 'mutable_result_list' instead.
inline ::idl::vector< ::idl::game_update_download_info >* m_result_list();
// deprecated.use 'result_list().size()' instead.
inline size_t result_list_size() const;
inline const ::idl::game_update_download_info& result_list(size_t i0) const;
inline ::idl::game_update_download_info* mutable_result_list(size_t i0);
// deprecated.use 'mutable_result_list' instead.
inline ::idl::game_update_download_info* m_result_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::game_update_download_info > _m_result_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_download_app_info_result_params
class mcp_get_game_download_app_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_download_app_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_download_app_info_response* v);
explicit mcp_get_game_download_app_info_response(bsl::mempool* pool);
mcp_get_game_download_app_info_response(const mcp_get_game_download_app_info_response& v);
~mcp_get_game_download_app_info_response();
mcp_get_game_download_app_info_response& operator=(const mcp_get_game_download_app_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_download_app_info_response& assign(const mcp_get_game_download_app_info_response& v);
// @@mcp_get_game_download_app_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_download_app_info_result_params& result_params() const;
inline ::idl::mcp_get_game_download_app_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_download_app_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_download_app_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_download_app_info_response
class mcp_get_game_dbapp_detail_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_dbapp_detail_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_dbapp_detail_info_params* v);
explicit mcp_get_game_dbapp_detail_info_params(bsl::mempool* pool);
mcp_get_game_dbapp_detail_info_params(const mcp_get_game_dbapp_detail_info_params& v);
~mcp_get_game_dbapp_detail_info_params();
mcp_get_game_dbapp_detail_info_params& operator=(const mcp_get_game_dbapp_detail_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_dbapp_detail_info_params& assign(const mcp_get_game_dbapp_detail_info_params& v);
// @@string package_name=in();
inline bool has_package_name() const;
inline const char* package_name(unsigned int* size=0) const;
inline mcp_get_game_dbapp_detail_info_params& set_package_name(const char* s,ssize_t size=-1);
inline mcp_get_game_dbapp_detail_info_params& set_ptr_package_name(const char* s,ssize_t size=-1);
inline void clear_package_name();
// @@string game_img=in();
inline bool has_game_img() const;
inline const char* game_img(unsigned int* size=0) const;
inline mcp_get_game_dbapp_detail_info_params& set_game_img(const char* s,ssize_t size=-1);
inline mcp_get_game_dbapp_detail_info_params& set_ptr_game_img(const char* s,ssize_t size=-1);
inline void clear_game_img();
// @@string filter=in();
inline bool has_filter() const;
inline const char* filter(unsigned int* size=0) const;
inline mcp_get_game_dbapp_detail_info_params& set_filter(const char* s,ssize_t size=-1);
inline mcp_get_game_dbapp_detail_info_params& set_ptr_filter(const char* s,ssize_t size=-1);
inline void clear_filter();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_package_name;
 ::idl::string _m_game_img;
 ::idl::string _m_filter;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_dbapp_detail_info_params
class mcp_get_game_dbapp_detail_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_dbapp_detail_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_dbapp_detail_info_result_params* v);
explicit mcp_get_game_dbapp_detail_info_result_params(bsl::mempool* pool);
mcp_get_game_dbapp_detail_info_result_params(const mcp_get_game_dbapp_detail_info_result_params& v);
~mcp_get_game_dbapp_detail_info_result_params();
mcp_get_game_dbapp_detail_info_result_params& operator=(const mcp_get_game_dbapp_detail_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_dbapp_detail_info_result_params& assign(const mcp_get_game_dbapp_detail_info_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_game_dbapp_detail_info_result_params& set_count(uint32_t v);
inline void clear_count();
// @@game_update_download_info result_list=out(),array(0);
inline bool has_result_list() const;
inline const ::idl::vector< ::idl::game_update_download_info >& result_list() const;
inline ::idl::vector< ::idl::game_update_download_info >* mutable_result_list();
inline void clear_result_list();
// deprecated.use 'mutable_result_list' instead.
inline ::idl::vector< ::idl::game_update_download_info >* m_result_list();
// deprecated.use 'result_list().size()' instead.
inline size_t result_list_size() const;
inline const ::idl::game_update_download_info& result_list(size_t i0) const;
inline ::idl::game_update_download_info* mutable_result_list(size_t i0);
// deprecated.use 'mutable_result_list' instead.
inline ::idl::game_update_download_info* m_result_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::game_update_download_info > _m_result_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_dbapp_detail_info_result_params
class mcp_get_game_dbapp_detail_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_dbapp_detail_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_dbapp_detail_info_response* v);
explicit mcp_get_game_dbapp_detail_info_response(bsl::mempool* pool);
mcp_get_game_dbapp_detail_info_response(const mcp_get_game_dbapp_detail_info_response& v);
~mcp_get_game_dbapp_detail_info_response();
mcp_get_game_dbapp_detail_info_response& operator=(const mcp_get_game_dbapp_detail_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_dbapp_detail_info_response& assign(const mcp_get_game_dbapp_detail_info_response& v);
// @@mcp_get_game_dbapp_detail_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_dbapp_detail_info_result_params& result_params() const;
inline ::idl::mcp_get_game_dbapp_detail_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_dbapp_detail_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_dbapp_detail_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_dbapp_detail_info_response
class mcp_get_device_download_games_info_by_udid_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_device_download_games_info_by_udid_params* create(bsl::mempool* pool);
static void destroy(mcp_get_device_download_games_info_by_udid_params* v);
explicit mcp_get_device_download_games_info_by_udid_params(bsl::mempool* pool);
mcp_get_device_download_games_info_by_udid_params(const mcp_get_device_download_games_info_by_udid_params& v);
~mcp_get_device_download_games_info_by_udid_params();
mcp_get_device_download_games_info_by_udid_params& operator=(const mcp_get_device_download_games_info_by_udid_params& v);
void clear();
void check() const;
void detach();
mcp_get_device_download_games_info_by_udid_params& assign(const mcp_get_device_download_games_info_by_udid_params& v);
// @@string udid=in();
inline bool has_udid() const;
inline const char* udid(unsigned int* size=0) const;
inline mcp_get_device_download_games_info_by_udid_params& set_udid(const char* s,ssize_t size=-1);
inline mcp_get_device_download_games_info_by_udid_params& set_ptr_udid(const char* s,ssize_t size=-1);
inline void clear_udid();
// @@string img_types=in();
inline bool has_img_types() const;
inline const char* img_types(unsigned int* size=0) const;
inline mcp_get_device_download_games_info_by_udid_params& set_img_types(const char* s,ssize_t size=-1);
inline mcp_get_device_download_games_info_by_udid_params& set_ptr_img_types(const char* s,ssize_t size=-1);
inline void clear_img_types();
// @@string filter=in();
inline bool has_filter() const;
inline const char* filter(unsigned int* size=0) const;
inline mcp_get_device_download_games_info_by_udid_params& set_filter(const char* s,ssize_t size=-1);
inline mcp_get_device_download_games_info_by_udid_params& set_ptr_filter(const char* s,ssize_t size=-1);
inline void clear_filter();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_udid;
 ::idl::string _m_img_types;
 ::idl::string _m_filter;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_device_download_games_info_by_udid_params
class mcp_get_device_download_games_info_by_udid_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_device_download_games_info_by_udid_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_device_download_games_info_by_udid_result_params* v);
explicit mcp_get_device_download_games_info_by_udid_result_params(bsl::mempool* pool);
mcp_get_device_download_games_info_by_udid_result_params(const mcp_get_device_download_games_info_by_udid_result_params& v);
~mcp_get_device_download_games_info_by_udid_result_params();
mcp_get_device_download_games_info_by_udid_result_params& operator=(const mcp_get_device_download_games_info_by_udid_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_device_download_games_info_by_udid_result_params& assign(const mcp_get_device_download_games_info_by_udid_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_device_download_games_info_by_udid_result_params& set_count(uint32_t v);
inline void clear_count();
// @@game_content_download_info_t result_list=out(),array(0);
inline bool has_result_list() const;
inline const ::idl::vector< ::idl::game_content_download_info_t >& result_list() const;
inline ::idl::vector< ::idl::game_content_download_info_t >* mutable_result_list();
inline void clear_result_list();
// deprecated.use 'mutable_result_list' instead.
inline ::idl::vector< ::idl::game_content_download_info_t >* m_result_list();
// deprecated.use 'result_list().size()' instead.
inline size_t result_list_size() const;
inline const ::idl::game_content_download_info_t& result_list(size_t i0) const;
inline ::idl::game_content_download_info_t* mutable_result_list(size_t i0);
// deprecated.use 'mutable_result_list' instead.
inline ::idl::game_content_download_info_t* m_result_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::game_content_download_info_t > _m_result_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_device_download_games_info_by_udid_result_params
class mcp_get_device_download_games_info_by_udid_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_device_download_games_info_by_udid_response* create(bsl::mempool* pool);
static void destroy(mcp_get_device_download_games_info_by_udid_response* v);
explicit mcp_get_device_download_games_info_by_udid_response(bsl::mempool* pool);
mcp_get_device_download_games_info_by_udid_response(const mcp_get_device_download_games_info_by_udid_response& v);
~mcp_get_device_download_games_info_by_udid_response();
mcp_get_device_download_games_info_by_udid_response& operator=(const mcp_get_device_download_games_info_by_udid_response& v);
void clear();
void check() const;
void detach();
mcp_get_device_download_games_info_by_udid_response& assign(const mcp_get_device_download_games_info_by_udid_response& v);
// @@mcp_get_device_download_games_info_by_udid_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_device_download_games_info_by_udid_result_params& result_params() const;
inline ::idl::mcp_get_device_download_games_info_by_udid_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_device_download_games_info_by_udid_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_device_download_games_info_by_udid_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_device_download_games_info_by_udid_response
class mcp_add_device_download_game_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_device_download_game_params* create(bsl::mempool* pool);
static void destroy(mcp_add_device_download_game_params* v);
explicit mcp_add_device_download_game_params(bsl::mempool* pool);
mcp_add_device_download_game_params(const mcp_add_device_download_game_params& v);
~mcp_add_device_download_game_params();
mcp_add_device_download_game_params& operator=(const mcp_add_device_download_game_params& v);
void clear();
void check() const;
void detach();
mcp_add_device_download_game_params& assign(const mcp_add_device_download_game_params& v);
// @@string udid=in();
inline bool has_udid() const;
inline const char* udid(unsigned int* size=0) const;
inline mcp_add_device_download_game_params& set_udid(const char* s,ssize_t size=-1);
inline mcp_add_device_download_game_params& set_ptr_udid(const char* s,ssize_t size=-1);
inline void clear_udid();
// @@string game_id=in();
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline mcp_add_device_download_game_params& set_game_id(const char* s,ssize_t size=-1);
inline mcp_add_device_download_game_params& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_udid;
 ::idl::string _m_game_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_device_download_game_params
class mcp_add_device_download_game_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_device_download_game_result_params* create(bsl::mempool* pool);
static void destroy(mcp_add_device_download_game_result_params* v);
explicit mcp_add_device_download_game_result_params(bsl::mempool* pool);
mcp_add_device_download_game_result_params(const mcp_add_device_download_game_result_params& v);
~mcp_add_device_download_game_result_params();
mcp_add_device_download_game_result_params& operator=(const mcp_add_device_download_game_result_params& v);
void clear();
void check() const;
void detach();
mcp_add_device_download_game_result_params& assign(const mcp_add_device_download_game_result_params& v);
// @@int32_t ret_code=out();
inline bool has_ret_code() const;
inline int32_t ret_code() const;
inline mcp_add_device_download_game_result_params& set_ret_code(int32_t v);
inline void clear_ret_code();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_ret_code;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_device_download_game_result_params
class mcp_add_device_download_game_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_add_device_download_game_response* create(bsl::mempool* pool);
static void destroy(mcp_add_device_download_game_response* v);
explicit mcp_add_device_download_game_response(bsl::mempool* pool);
mcp_add_device_download_game_response(const mcp_add_device_download_game_response& v);
~mcp_add_device_download_game_response();
mcp_add_device_download_game_response& operator=(const mcp_add_device_download_game_response& v);
void clear();
void check() const;
void detach();
mcp_add_device_download_game_response& assign(const mcp_add_device_download_game_response& v);
// @@mcp_add_device_download_game_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_add_device_download_game_result_params& result_params() const;
inline ::idl::mcp_add_device_download_game_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_add_device_download_game_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_add_device_download_game_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_add_device_download_game_response
class mcp_get_game_content_info_list_ext_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_content_info_list_ext_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_content_info_list_ext_params* v);
explicit mcp_get_game_content_info_list_ext_params(bsl::mempool* pool);
mcp_get_game_content_info_list_ext_params(const mcp_get_game_content_info_list_ext_params& v);
~mcp_get_game_content_info_list_ext_params();
mcp_get_game_content_info_list_ext_params& operator=(const mcp_get_game_content_info_list_ext_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_content_info_list_ext_params& assign(const mcp_get_game_content_info_list_ext_params& v);
// @@string input=in();
inline bool has_input() const;
inline const char* input(unsigned int* size=0) const;
inline mcp_get_game_content_info_list_ext_params& set_input(const char* s,ssize_t size=-1);
inline mcp_get_game_content_info_list_ext_params& set_ptr_input(const char* s,ssize_t size=-1);
inline void clear_input();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_game_content_info_list_ext_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_game_content_info_list_ext_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_input;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_content_info_list_ext_params
class mcp_get_game_content_info_list_ext_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_content_info_list_ext_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_content_info_list_ext_result_params* v);
explicit mcp_get_game_content_info_list_ext_result_params(bsl::mempool* pool);
mcp_get_game_content_info_list_ext_result_params(const mcp_get_game_content_info_list_ext_result_params& v);
~mcp_get_game_content_info_list_ext_result_params();
mcp_get_game_content_info_list_ext_result_params& operator=(const mcp_get_game_content_info_list_ext_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_content_info_list_ext_result_params& assign(const mcp_get_game_content_info_list_ext_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_game_content_info_list_ext_result_params& set_count(uint32_t v);
inline void clear_count();
// @@game_content_download_info_t result_list=out(),array(0);
inline bool has_result_list() const;
inline const ::idl::vector< ::idl::game_content_download_info_t >& result_list() const;
inline ::idl::vector< ::idl::game_content_download_info_t >* mutable_result_list();
inline void clear_result_list();
// deprecated.use 'mutable_result_list' instead.
inline ::idl::vector< ::idl::game_content_download_info_t >* m_result_list();
// deprecated.use 'result_list().size()' instead.
inline size_t result_list_size() const;
inline const ::idl::game_content_download_info_t& result_list(size_t i0) const;
inline ::idl::game_content_download_info_t* mutable_result_list(size_t i0);
// deprecated.use 'mutable_result_list' instead.
inline ::idl::game_content_download_info_t* m_result_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::game_content_download_info_t > _m_result_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_content_info_list_ext_result_params
class mcp_get_game_content_info_list_ext_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_content_info_list_ext_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_content_info_list_ext_response* v);
explicit mcp_get_game_content_info_list_ext_response(bsl::mempool* pool);
mcp_get_game_content_info_list_ext_response(const mcp_get_game_content_info_list_ext_response& v);
~mcp_get_game_content_info_list_ext_response();
mcp_get_game_content_info_list_ext_response& operator=(const mcp_get_game_content_info_list_ext_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_content_info_list_ext_response& assign(const mcp_get_game_content_info_list_ext_response& v);
// @@mcp_get_game_content_info_list_ext_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_content_info_list_ext_result_params& result_params() const;
inline ::idl::mcp_get_game_content_info_list_ext_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_content_info_list_ext_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_content_info_list_ext_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_content_info_list_ext_response
class mcp_get_game_currency_rate_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_currency_rate_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_currency_rate_params* v);
explicit mcp_get_game_currency_rate_params(bsl::mempool* pool);
mcp_get_game_currency_rate_params(const mcp_get_game_currency_rate_params& v);
~mcp_get_game_currency_rate_params();
mcp_get_game_currency_rate_params& operator=(const mcp_get_game_currency_rate_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_currency_rate_params& assign(const mcp_get_game_currency_rate_params& v);
// @@string input=in();
inline bool has_input() const;
inline const char* input(unsigned int* size=0) const;
inline mcp_get_game_currency_rate_params& set_input(const char* s,ssize_t size=-1);
inline mcp_get_game_currency_rate_params& set_ptr_input(const char* s,ssize_t size=-1);
inline void clear_input();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_input;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_currency_rate_params
class mcp_get_game_currency_rate_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_currency_rate_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_currency_rate_result_params* v);
explicit mcp_get_game_currency_rate_result_params(bsl::mempool* pool);
mcp_get_game_currency_rate_result_params(const mcp_get_game_currency_rate_result_params& v);
~mcp_get_game_currency_rate_result_params();
mcp_get_game_currency_rate_result_params& operator=(const mcp_get_game_currency_rate_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_currency_rate_result_params& assign(const mcp_get_game_currency_rate_result_params& v);
// @@game_dev_vir_currency_info currency_info=out();
inline bool has_currency_info() const;
inline const ::idl::game_dev_vir_currency_info& currency_info() const;
inline ::idl::game_dev_vir_currency_info* mutable_currency_info();
// deprecated.use 'mutable_currency_info()' instead.
inline ::idl::game_dev_vir_currency_info* m_currency_info();
inline void clear_currency_info();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::game_dev_vir_currency_info* _m_currency_info;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_currency_rate_result_params
class mcp_get_game_currency_rate_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_currency_rate_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_currency_rate_response* v);
explicit mcp_get_game_currency_rate_response(bsl::mempool* pool);
mcp_get_game_currency_rate_response(const mcp_get_game_currency_rate_response& v);
~mcp_get_game_currency_rate_response();
mcp_get_game_currency_rate_response& operator=(const mcp_get_game_currency_rate_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_currency_rate_response& assign(const mcp_get_game_currency_rate_response& v);
// @@mcp_get_game_currency_rate_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_currency_rate_result_params& result_params() const;
inline ::idl::mcp_get_game_currency_rate_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_currency_rate_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_currency_rate_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_currency_rate_response
class mcp_get_game_download_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_download_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_download_info_params* v);
explicit mcp_get_game_download_info_params(bsl::mempool* pool);
mcp_get_game_download_info_params(const mcp_get_game_download_info_params& v);
~mcp_get_game_download_info_params();
mcp_get_game_download_info_params& operator=(const mcp_get_game_download_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_download_info_params& assign(const mcp_get_game_download_info_params& v);
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_get_game_download_info_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_get_game_download_info_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string channel_info=in();
inline bool has_channel_info() const;
inline const char* channel_info(unsigned int* size=0) const;
inline mcp_get_game_download_info_params& set_channel_info(const char* s,ssize_t size=-1);
inline mcp_get_game_download_info_params& set_ptr_channel_info(const char* s,ssize_t size=-1);
inline void clear_channel_info();
// @@string channel_id=in();
inline bool has_channel_id() const;
inline const char* channel_id(unsigned int* size=0) const;
inline mcp_get_game_download_info_params& set_channel_id(const char* s,ssize_t size=-1);
inline mcp_get_game_download_info_params& set_ptr_channel_id(const char* s,ssize_t size=-1);
inline void clear_channel_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_c_id;
 ::idl::string _m_channel_info;
 ::idl::string _m_channel_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_download_info_params
class mcp_get_game_download_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_download_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_download_info_result_params* v);
explicit mcp_get_game_download_info_result_params(bsl::mempool* pool);
mcp_get_game_download_info_result_params(const mcp_get_game_download_info_result_params& v);
~mcp_get_game_download_info_result_params();
mcp_get_game_download_info_result_params& operator=(const mcp_get_game_download_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_download_info_result_params& assign(const mcp_get_game_download_info_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_game_download_info_result_params& set_count(uint32_t v);
inline void clear_count();
// @@download_detail_t download_list=out(),array(0);
inline bool has_download_list() const;
inline const ::idl::vector< ::idl::download_detail_t >& download_list() const;
inline ::idl::vector< ::idl::download_detail_t >* mutable_download_list();
inline void clear_download_list();
// deprecated.use 'mutable_download_list' instead.
inline ::idl::vector< ::idl::download_detail_t >* m_download_list();
// deprecated.use 'download_list().size()' instead.
inline size_t download_list_size() const;
inline const ::idl::download_detail_t& download_list(size_t i0) const;
inline ::idl::download_detail_t* mutable_download_list(size_t i0);
// deprecated.use 'mutable_download_list' instead.
inline ::idl::download_detail_t* m_download_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::download_detail_t > _m_download_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_download_info_result_params
class mcp_get_game_download_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_download_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_download_info_response* v);
explicit mcp_get_game_download_info_response(bsl::mempool* pool);
mcp_get_game_download_info_response(const mcp_get_game_download_info_response& v);
~mcp_get_game_download_info_response();
mcp_get_game_download_info_response& operator=(const mcp_get_game_download_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_download_info_response& assign(const mcp_get_game_download_info_response& v);
// @@mcp_get_game_download_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_download_info_result_params& result_params() const;
inline ::idl::mcp_get_game_download_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_download_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_download_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_download_info_response
class mcp_get_game_news_without_pbus_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_news_without_pbus_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_news_without_pbus_params* v);
explicit mcp_get_game_news_without_pbus_params(bsl::mempool* pool);
mcp_get_game_news_without_pbus_params(const mcp_get_game_news_without_pbus_params& v);
~mcp_get_game_news_without_pbus_params();
mcp_get_game_news_without_pbus_params& operator=(const mcp_get_game_news_without_pbus_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_news_without_pbus_params& assign(const mcp_get_game_news_without_pbus_params& v);
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_game_news_without_pbus_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_game_news_without_pbus_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_get_game_news_without_pbus_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_get_game_news_without_pbus_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string info_type=in();
inline bool has_info_type() const;
inline const char* info_type(unsigned int* size=0) const;
inline mcp_get_game_news_without_pbus_params& set_info_type(const char* s,ssize_t size=-1);
inline mcp_get_game_news_without_pbus_params& set_ptr_info_type(const char* s,ssize_t size=-1);
inline void clear_info_type();
// @@string game_type=in();
inline bool has_game_type() const;
inline const char* game_type(unsigned int* size=0) const;
inline mcp_get_game_news_without_pbus_params& set_game_type(const char* s,ssize_t size=-1);
inline mcp_get_game_news_without_pbus_params& set_ptr_game_type(const char* s,ssize_t size=-1);
inline void clear_game_type();
// @@string date_limit=in();
inline bool has_date_limit() const;
inline const char* date_limit(unsigned int* size=0) const;
inline mcp_get_game_news_without_pbus_params& set_date_limit(const char* s,ssize_t size=-1);
inline mcp_get_game_news_without_pbus_params& set_ptr_date_limit(const char* s,ssize_t size=-1);
inline void clear_date_limit();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_game_news_without_pbus_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_game_news_without_pbus_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_info_id;
 ::idl::string _m_c_id;
 ::idl::string _m_info_type;
 ::idl::string _m_game_type;
 ::idl::string _m_date_limit;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_news_without_pbus_params
class mcp_get_game_news_without_pbus_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_news_without_pbus_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_news_without_pbus_result_params* v);
explicit mcp_get_game_news_without_pbus_result_params(bsl::mempool* pool);
mcp_get_game_news_without_pbus_result_params(const mcp_get_game_news_without_pbus_result_params& v);
~mcp_get_game_news_without_pbus_result_params();
mcp_get_game_news_without_pbus_result_params& operator=(const mcp_get_game_news_without_pbus_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_news_without_pbus_result_params& assign(const mcp_get_game_news_without_pbus_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_game_news_without_pbus_result_params& set_count(int32_t v);
inline void clear_count();
// @@game_info_t game_info_list=out(),array(0);
inline bool has_game_info_list() const;
inline const ::idl::vector< ::idl::game_info_t >& game_info_list() const;
inline ::idl::vector< ::idl::game_info_t >* mutable_game_info_list();
inline void clear_game_info_list();
// deprecated.use 'mutable_game_info_list' instead.
inline ::idl::vector< ::idl::game_info_t >* m_game_info_list();
// deprecated.use 'game_info_list().size()' instead.
inline size_t game_info_list_size() const;
inline const ::idl::game_info_t& game_info_list(size_t i0) const;
inline ::idl::game_info_t* mutable_game_info_list(size_t i0);
// deprecated.use 'mutable_game_info_list' instead.
inline ::idl::game_info_t* m_game_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::game_info_t > _m_game_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_news_without_pbus_result_params
class mcp_get_game_news_without_pbus_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_news_without_pbus_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_news_without_pbus_response* v);
explicit mcp_get_game_news_without_pbus_response(bsl::mempool* pool);
mcp_get_game_news_without_pbus_response(const mcp_get_game_news_without_pbus_response& v);
~mcp_get_game_news_without_pbus_response();
mcp_get_game_news_without_pbus_response& operator=(const mcp_get_game_news_without_pbus_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_news_without_pbus_response& assign(const mcp_get_game_news_without_pbus_response& v);
// @@mcp_get_game_news_without_pbus_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_news_without_pbus_result_params& result_params() const;
inline ::idl::mcp_get_game_news_without_pbus_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_news_without_pbus_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_news_without_pbus_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_news_without_pbus_response
class mcp_get_mobile_music_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_mobile_music_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_mobile_music_info_params* v);
explicit mcp_get_mobile_music_info_params(bsl::mempool* pool);
mcp_get_mobile_music_info_params(const mcp_get_mobile_music_info_params& v);
~mcp_get_mobile_music_info_params();
mcp_get_mobile_music_info_params& operator=(const mcp_get_mobile_music_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_mobile_music_info_params& assign(const mcp_get_mobile_music_info_params& v);
// @@string name=in();
inline bool has_name() const;
inline const char* name(unsigned int* size=0) const;
inline mcp_get_mobile_music_info_params& set_name(const char* s,ssize_t size=-1);
inline mcp_get_mobile_music_info_params& set_ptr_name(const char* s,ssize_t size=-1);
inline void clear_name();
// @@string singer=in();
inline bool has_singer() const;
inline const char* singer(unsigned int* size=0) const;
inline mcp_get_mobile_music_info_params& set_singer(const char* s,ssize_t size=-1);
inline mcp_get_mobile_music_info_params& set_ptr_singer(const char* s,ssize_t size=-1);
inline void clear_singer();
// @@string ring_id=in();
inline bool has_ring_id() const;
inline const char* ring_id(unsigned int* size=0) const;
inline mcp_get_mobile_music_info_params& set_ring_id(const char* s,ssize_t size=-1);
inline mcp_get_mobile_music_info_params& set_ptr_ring_id(const char* s,ssize_t size=-1);
inline void clear_ring_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_name;
 ::idl::string _m_singer;
 ::idl::string _m_ring_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_mobile_music_info_params
class mcp_get_mobile_music_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_mobile_music_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_mobile_music_info_result_params* v);
explicit mcp_get_mobile_music_info_result_params(bsl::mempool* pool);
mcp_get_mobile_music_info_result_params(const mcp_get_mobile_music_info_result_params& v);
~mcp_get_mobile_music_info_result_params();
mcp_get_mobile_music_info_result_params& operator=(const mcp_get_mobile_music_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_mobile_music_info_result_params& assign(const mcp_get_mobile_music_info_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_mobile_music_info_result_params& set_count(uint32_t v);
inline void clear_count();
// @@mobile_music_info_t music_list=out(),array(0);
inline bool has_music_list() const;
inline const ::idl::vector< ::idl::mobile_music_info_t >& music_list() const;
inline ::idl::vector< ::idl::mobile_music_info_t >* mutable_music_list();
inline void clear_music_list();
// deprecated.use 'mutable_music_list' instead.
inline ::idl::vector< ::idl::mobile_music_info_t >* m_music_list();
// deprecated.use 'music_list().size()' instead.
inline size_t music_list_size() const;
inline const ::idl::mobile_music_info_t& music_list(size_t i0) const;
inline ::idl::mobile_music_info_t* mutable_music_list(size_t i0);
// deprecated.use 'mutable_music_list' instead.
inline ::idl::mobile_music_info_t* m_music_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::mobile_music_info_t > _m_music_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_mobile_music_info_result_params
class mcp_get_mobile_music_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_mobile_music_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_mobile_music_info_response* v);
explicit mcp_get_mobile_music_info_response(bsl::mempool* pool);
mcp_get_mobile_music_info_response(const mcp_get_mobile_music_info_response& v);
~mcp_get_mobile_music_info_response();
mcp_get_mobile_music_info_response& operator=(const mcp_get_mobile_music_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_mobile_music_info_response& assign(const mcp_get_mobile_music_info_response& v);
// @@mcp_get_mobile_music_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_mobile_music_info_result_params& result_params() const;
inline ::idl::mcp_get_mobile_music_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_mobile_music_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_mobile_music_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_mobile_music_info_response
class mcp_set_mobile_music_ptag_by_ring_id_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_set_mobile_music_ptag_by_ring_id_params* create(bsl::mempool* pool);
static void destroy(mcp_set_mobile_music_ptag_by_ring_id_params* v);
explicit mcp_set_mobile_music_ptag_by_ring_id_params(bsl::mempool* pool);
mcp_set_mobile_music_ptag_by_ring_id_params(const mcp_set_mobile_music_ptag_by_ring_id_params& v);
~mcp_set_mobile_music_ptag_by_ring_id_params();
mcp_set_mobile_music_ptag_by_ring_id_params& operator=(const mcp_set_mobile_music_ptag_by_ring_id_params& v);
void clear();
void check() const;
void detach();
mcp_set_mobile_music_ptag_by_ring_id_params& assign(const mcp_set_mobile_music_ptag_by_ring_id_params& v);
// @@string ring_id=in();
inline bool has_ring_id() const;
inline const char* ring_id(unsigned int* size=0) const;
inline mcp_set_mobile_music_ptag_by_ring_id_params& set_ring_id(const char* s,ssize_t size=-1);
inline mcp_set_mobile_music_ptag_by_ring_id_params& set_ptr_ring_id(const char* s,ssize_t size=-1);
inline void clear_ring_id();
// @@string ptag=in();
inline bool has_ptag() const;
inline const char* ptag(unsigned int* size=0) const;
inline mcp_set_mobile_music_ptag_by_ring_id_params& set_ptag(const char* s,ssize_t size=-1);
inline mcp_set_mobile_music_ptag_by_ring_id_params& set_ptr_ptag(const char* s,ssize_t size=-1);
inline void clear_ptag();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_ring_id;
 ::idl::string _m_ptag;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_set_mobile_music_ptag_by_ring_id_params
class mcp_set_mobile_music_ptag_by_ring_id_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_set_mobile_music_ptag_by_ring_id_result_params* create(bsl::mempool* pool);
static void destroy(mcp_set_mobile_music_ptag_by_ring_id_result_params* v);
explicit mcp_set_mobile_music_ptag_by_ring_id_result_params(bsl::mempool* pool);
mcp_set_mobile_music_ptag_by_ring_id_result_params(const mcp_set_mobile_music_ptag_by_ring_id_result_params& v);
~mcp_set_mobile_music_ptag_by_ring_id_result_params();
mcp_set_mobile_music_ptag_by_ring_id_result_params& operator=(const mcp_set_mobile_music_ptag_by_ring_id_result_params& v);
void clear();
void check() const;
void detach();
mcp_set_mobile_music_ptag_by_ring_id_result_params& assign(const mcp_set_mobile_music_ptag_by_ring_id_result_params& v);
// @@uint32_t result=out();
inline bool has_result() const;
inline uint32_t result() const;
inline mcp_set_mobile_music_ptag_by_ring_id_result_params& set_result(uint32_t v);
inline void clear_result();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_result;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_set_mobile_music_ptag_by_ring_id_result_params
class mcp_set_mobile_music_ptag_by_ring_id_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_set_mobile_music_ptag_by_ring_id_response* create(bsl::mempool* pool);
static void destroy(mcp_set_mobile_music_ptag_by_ring_id_response* v);
explicit mcp_set_mobile_music_ptag_by_ring_id_response(bsl::mempool* pool);
mcp_set_mobile_music_ptag_by_ring_id_response(const mcp_set_mobile_music_ptag_by_ring_id_response& v);
~mcp_set_mobile_music_ptag_by_ring_id_response();
mcp_set_mobile_music_ptag_by_ring_id_response& operator=(const mcp_set_mobile_music_ptag_by_ring_id_response& v);
void clear();
void check() const;
void detach();
mcp_set_mobile_music_ptag_by_ring_id_response& assign(const mcp_set_mobile_music_ptag_by_ring_id_response& v);
// @@mcp_set_mobile_music_ptag_by_ring_id_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params& result_params() const;
inline ::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_set_mobile_music_ptag_by_ring_id_response
class mcp_get_mobile_music_ring_id_by_ptag_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_mobile_music_ring_id_by_ptag_params* create(bsl::mempool* pool);
static void destroy(mcp_get_mobile_music_ring_id_by_ptag_params* v);
explicit mcp_get_mobile_music_ring_id_by_ptag_params(bsl::mempool* pool);
mcp_get_mobile_music_ring_id_by_ptag_params(const mcp_get_mobile_music_ring_id_by_ptag_params& v);
~mcp_get_mobile_music_ring_id_by_ptag_params();
mcp_get_mobile_music_ring_id_by_ptag_params& operator=(const mcp_get_mobile_music_ring_id_by_ptag_params& v);
void clear();
void check() const;
void detach();
mcp_get_mobile_music_ring_id_by_ptag_params& assign(const mcp_get_mobile_music_ring_id_by_ptag_params& v);
// @@string ptag=in();
inline bool has_ptag() const;
inline const char* ptag(unsigned int* size=0) const;
inline mcp_get_mobile_music_ring_id_by_ptag_params& set_ptag(const char* s,ssize_t size=-1);
inline mcp_get_mobile_music_ring_id_by_ptag_params& set_ptr_ptag(const char* s,ssize_t size=-1);
inline void clear_ptag();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_ptag;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_mobile_music_ring_id_by_ptag_params
class mcp_get_mobile_music_ring_id_by_ptag_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_mobile_music_ring_id_by_ptag_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_mobile_music_ring_id_by_ptag_result_params* v);
explicit mcp_get_mobile_music_ring_id_by_ptag_result_params(bsl::mempool* pool);
mcp_get_mobile_music_ring_id_by_ptag_result_params(const mcp_get_mobile_music_ring_id_by_ptag_result_params& v);
~mcp_get_mobile_music_ring_id_by_ptag_result_params();
mcp_get_mobile_music_ring_id_by_ptag_result_params& operator=(const mcp_get_mobile_music_ring_id_by_ptag_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_mobile_music_ring_id_by_ptag_result_params& assign(const mcp_get_mobile_music_ring_id_by_ptag_result_params& v);
// @@string ring_id=out();
inline bool has_ring_id() const;
inline const char* ring_id(unsigned int* size=0) const;
inline mcp_get_mobile_music_ring_id_by_ptag_result_params& set_ring_id(const char* s,ssize_t size=-1);
inline mcp_get_mobile_music_ring_id_by_ptag_result_params& set_ptr_ring_id(const char* s,ssize_t size=-1);
inline void clear_ring_id();
// @@uint32_t result=out();
inline bool has_result() const;
inline uint32_t result() const;
inline mcp_get_mobile_music_ring_id_by_ptag_result_params& set_result(uint32_t v);
inline void clear_result();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_ring_id;
 uint32_t _m_result;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_mobile_music_ring_id_by_ptag_result_params
class mcp_get_mobile_music_ring_id_by_ptag_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_mobile_music_ring_id_by_ptag_response* create(bsl::mempool* pool);
static void destroy(mcp_get_mobile_music_ring_id_by_ptag_response* v);
explicit mcp_get_mobile_music_ring_id_by_ptag_response(bsl::mempool* pool);
mcp_get_mobile_music_ring_id_by_ptag_response(const mcp_get_mobile_music_ring_id_by_ptag_response& v);
~mcp_get_mobile_music_ring_id_by_ptag_response();
mcp_get_mobile_music_ring_id_by_ptag_response& operator=(const mcp_get_mobile_music_ring_id_by_ptag_response& v);
void clear();
void check() const;
void detach();
mcp_get_mobile_music_ring_id_by_ptag_response& assign(const mcp_get_mobile_music_ring_id_by_ptag_response& v);
// @@mcp_get_mobile_music_ring_id_by_ptag_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params& result_params() const;
inline ::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_mobile_music_ring_id_by_ptag_response
class mcp_get_championship_info_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_championship_info_params* create(bsl::mempool* pool);
static void destroy(mcp_get_championship_info_params* v);
explicit mcp_get_championship_info_params(bsl::mempool* pool);
mcp_get_championship_info_params(const mcp_get_championship_info_params& v);
~mcp_get_championship_info_params();
mcp_get_championship_info_params& operator=(const mcp_get_championship_info_params& v);
void clear();
void check() const;
void detach();
mcp_get_championship_info_params& assign(const mcp_get_championship_info_params& v);
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_championship_info_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_championship_info_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_championship_info_params
class mcp_get_championship_info_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_championship_info_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_championship_info_result_params* v);
explicit mcp_get_championship_info_result_params(bsl::mempool* pool);
mcp_get_championship_info_result_params(const mcp_get_championship_info_result_params& v);
~mcp_get_championship_info_result_params();
mcp_get_championship_info_result_params& operator=(const mcp_get_championship_info_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_championship_info_result_params& assign(const mcp_get_championship_info_result_params& v);
// @@uint32_t count=out();
inline bool has_count() const;
inline uint32_t count() const;
inline mcp_get_championship_info_result_params& set_count(uint32_t v);
inline void clear_count();
// @@championship_info_t championship_list=out(),array(0);
inline bool has_championship_list() const;
inline const ::idl::vector< ::idl::championship_info_t >& championship_list() const;
inline ::idl::vector< ::idl::championship_info_t >* mutable_championship_list();
inline void clear_championship_list();
// deprecated.use 'mutable_championship_list' instead.
inline ::idl::vector< ::idl::championship_info_t >* m_championship_list();
// deprecated.use 'championship_list().size()' instead.
inline size_t championship_list_size() const;
inline const ::idl::championship_info_t& championship_list(size_t i0) const;
inline ::idl::championship_info_t* mutable_championship_list(size_t i0);
// deprecated.use 'mutable_championship_list' instead.
inline ::idl::championship_info_t* m_championship_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_count;
 ::idl::vector< ::idl::championship_info_t > _m_championship_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_championship_info_result_params
class mcp_get_championship_info_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_championship_info_response* create(bsl::mempool* pool);
static void destroy(mcp_get_championship_info_response* v);
explicit mcp_get_championship_info_response(bsl::mempool* pool);
mcp_get_championship_info_response(const mcp_get_championship_info_response& v);
~mcp_get_championship_info_response();
mcp_get_championship_info_response& operator=(const mcp_get_championship_info_response& v);
void clear();
void check() const;
void detach();
mcp_get_championship_info_response& assign(const mcp_get_championship_info_response& v);
// @@mcp_get_championship_info_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_championship_info_result_params& result_params() const;
inline ::idl::mcp_get_championship_info_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_championship_info_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_championship_info_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_championship_info_response
class mcp_user_add_coins_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_user_add_coins_params* create(bsl::mempool* pool);
static void destroy(mcp_user_add_coins_params* v);
explicit mcp_user_add_coins_params(bsl::mempool* pool);
mcp_user_add_coins_params(const mcp_user_add_coins_params& v);
~mcp_user_add_coins_params();
mcp_user_add_coins_params& operator=(const mcp_user_add_coins_params& v);
void clear();
void check() const;
void detach();
mcp_user_add_coins_params& assign(const mcp_user_add_coins_params& v);
// @@string user_id=in();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_user_add_coins_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_user_add_coins_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
// @@string game_id=in();
inline bool has_game_id() const;
inline const char* game_id(unsigned int* size=0) const;
inline mcp_user_add_coins_params& set_game_id(const char* s,ssize_t size=-1);
inline mcp_user_add_coins_params& set_ptr_game_id(const char* s,ssize_t size=-1);
inline void clear_game_id();
// @@uint32_t opt=in();
inline bool has_opt() const;
inline uint32_t opt() const;
inline mcp_user_add_coins_params& set_opt(uint32_t v);
inline void clear_opt();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_user_id;
 ::idl::string _m_game_id;
 uint32_t _m_opt;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_user_add_coins_params
class mcp_user_add_coins_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_user_add_coins_result_params* create(bsl::mempool* pool);
static void destroy(mcp_user_add_coins_result_params* v);
explicit mcp_user_add_coins_result_params(bsl::mempool* pool);
mcp_user_add_coins_result_params(const mcp_user_add_coins_result_params& v);
~mcp_user_add_coins_result_params();
mcp_user_add_coins_result_params& operator=(const mcp_user_add_coins_result_params& v);
void clear();
void check() const;
void detach();
mcp_user_add_coins_result_params& assign(const mcp_user_add_coins_result_params& v);
// @@uint32_t result=out();
inline bool has_result() const;
inline uint32_t result() const;
inline mcp_user_add_coins_result_params& set_result(uint32_t v);
inline void clear_result();
// @@uint32_t errorcode=out();
inline bool has_errorcode() const;
inline uint32_t errorcode() const;
inline mcp_user_add_coins_result_params& set_errorcode(uint32_t v);
inline void clear_errorcode();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_result;
 uint32_t _m_errorcode;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_user_add_coins_result_params
class mcp_user_add_coins_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_user_add_coins_response* create(bsl::mempool* pool);
static void destroy(mcp_user_add_coins_response* v);
explicit mcp_user_add_coins_response(bsl::mempool* pool);
mcp_user_add_coins_response(const mcp_user_add_coins_response& v);
~mcp_user_add_coins_response();
mcp_user_add_coins_response& operator=(const mcp_user_add_coins_response& v);
void clear();
void check() const;
void detach();
mcp_user_add_coins_response& assign(const mcp_user_add_coins_response& v);
// @@mcp_user_add_coins_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_user_add_coins_result_params& result_params() const;
inline ::idl::mcp_user_add_coins_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_user_add_coins_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_user_add_coins_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_user_add_coins_response
class mcp_get_game_news_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_news_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_news_params* v);
explicit mcp_get_game_news_params(bsl::mempool* pool);
mcp_get_game_news_params(const mcp_get_game_news_params& v);
~mcp_get_game_news_params();
mcp_get_game_news_params& operator=(const mcp_get_game_news_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_news_params& assign(const mcp_get_game_news_params& v);
// @@string info_id=in();
inline bool has_info_id() const;
inline const char* info_id(unsigned int* size=0) const;
inline mcp_get_game_news_params& set_info_id(const char* s,ssize_t size=-1);
inline mcp_get_game_news_params& set_ptr_info_id(const char* s,ssize_t size=-1);
inline void clear_info_id();
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_get_game_news_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_get_game_news_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string info_type=in();
inline bool has_info_type() const;
inline const char* info_type(unsigned int* size=0) const;
inline mcp_get_game_news_params& set_info_type(const char* s,ssize_t size=-1);
inline mcp_get_game_news_params& set_ptr_info_type(const char* s,ssize_t size=-1);
inline void clear_info_type();
// @@string game_type=in();
inline bool has_game_type() const;
inline const char* game_type(unsigned int* size=0) const;
inline mcp_get_game_news_params& set_game_type(const char* s,ssize_t size=-1);
inline mcp_get_game_news_params& set_ptr_game_type(const char* s,ssize_t size=-1);
inline void clear_game_type();
// @@string date_limit=in();
inline bool has_date_limit() const;
inline const char* date_limit(unsigned int* size=0) const;
inline mcp_get_game_news_params& set_date_limit(const char* s,ssize_t size=-1);
inline mcp_get_game_news_params& set_ptr_date_limit(const char* s,ssize_t size=-1);
inline void clear_date_limit();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_game_news_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_game_news_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_info_id;
 ::idl::string _m_c_id;
 ::idl::string _m_info_type;
 ::idl::string _m_game_type;
 ::idl::string _m_date_limit;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_news_params
class mcp_get_game_news_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_news_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_game_news_result_params* v);
explicit mcp_get_game_news_result_params(bsl::mempool* pool);
mcp_get_game_news_result_params(const mcp_get_game_news_result_params& v);
~mcp_get_game_news_result_params();
mcp_get_game_news_result_params& operator=(const mcp_get_game_news_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_game_news_result_params& assign(const mcp_get_game_news_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_game_news_result_params& set_count(int32_t v);
inline void clear_count();
// @@game_info_t_hall game_info_list=out(),array(0);
inline bool has_game_info_list() const;
inline const ::idl::vector< ::idl::game_info_t_hall >& game_info_list() const;
inline ::idl::vector< ::idl::game_info_t_hall >* mutable_game_info_list();
inline void clear_game_info_list();
// deprecated.use 'mutable_game_info_list' instead.
inline ::idl::vector< ::idl::game_info_t_hall >* m_game_info_list();
// deprecated.use 'game_info_list().size()' instead.
inline size_t game_info_list_size() const;
inline const ::idl::game_info_t_hall& game_info_list(size_t i0) const;
inline ::idl::game_info_t_hall* mutable_game_info_list(size_t i0);
// deprecated.use 'mutable_game_info_list' instead.
inline ::idl::game_info_t_hall* m_game_info_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::game_info_t_hall > _m_game_info_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_news_result_params
class mcp_get_game_news_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_game_news_response* create(bsl::mempool* pool);
static void destroy(mcp_get_game_news_response* v);
explicit mcp_get_game_news_response(bsl::mempool* pool);
mcp_get_game_news_response(const mcp_get_game_news_response& v);
~mcp_get_game_news_response();
mcp_get_game_news_response& operator=(const mcp_get_game_news_response& v);
void clear();
void check() const;
void detach();
mcp_get_game_news_response& assign(const mcp_get_game_news_response& v);
// @@mcp_get_game_news_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_game_news_result_params& result_params() const;
inline ::idl::mcp_get_game_news_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_game_news_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_game_news_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_game_news_response
class mcp_get_ip_province_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ip_province_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ip_province_params* v);
explicit mcp_get_ip_province_params(bsl::mempool* pool);
mcp_get_ip_province_params(const mcp_get_ip_province_params& v);
~mcp_get_ip_province_params();
mcp_get_ip_province_params& operator=(const mcp_get_ip_province_params& v);
void clear();
void check() const;
void detach();
mcp_get_ip_province_params& assign(const mcp_get_ip_province_params& v);
// @@string ip=in();
inline bool has_ip() const;
inline const char* ip(unsigned int* size=0) const;
inline mcp_get_ip_province_params& set_ip(const char* s,ssize_t size=-1);
inline mcp_get_ip_province_params& set_ptr_ip(const char* s,ssize_t size=-1);
inline void clear_ip();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_ip;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ip_province_params
class mcp_get_ip_province_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ip_province_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_ip_province_result_params* v);
explicit mcp_get_ip_province_result_params(bsl::mempool* pool);
mcp_get_ip_province_result_params(const mcp_get_ip_province_result_params& v);
~mcp_get_ip_province_result_params();
mcp_get_ip_province_result_params& operator=(const mcp_get_ip_province_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_ip_province_result_params& assign(const mcp_get_ip_province_result_params& v);
// @@string ip_scope=out();
inline bool has_ip_scope() const;
inline const char* ip_scope(unsigned int* size=0) const;
inline mcp_get_ip_province_result_params& set_ip_scope(const char* s,ssize_t size=-1);
inline mcp_get_ip_province_result_params& set_ptr_ip_scope(const char* s,ssize_t size=-1);
inline void clear_ip_scope();
// @@int32_t province=out();
inline bool has_province() const;
inline int32_t province() const;
inline mcp_get_ip_province_result_params& set_province(int32_t v);
inline void clear_province();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_ip_scope;
 int32_t _m_province;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ip_province_result_params
class mcp_get_ip_province_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_ip_province_response* create(bsl::mempool* pool);
static void destroy(mcp_get_ip_province_response* v);
explicit mcp_get_ip_province_response(bsl::mempool* pool);
mcp_get_ip_province_response(const mcp_get_ip_province_response& v);
~mcp_get_ip_province_response();
mcp_get_ip_province_response& operator=(const mcp_get_ip_province_response& v);
void clear();
void check() const;
void detach();
mcp_get_ip_province_response& assign(const mcp_get_ip_province_response& v);
// @@mcp_get_ip_province_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_ip_province_result_params& result_params() const;
inline ::idl::mcp_get_ip_province_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_ip_province_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_ip_province_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_ip_province_response
class mcp_get_question_type_name_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_question_type_name_params* create(bsl::mempool* pool);
static void destroy(mcp_get_question_type_name_params* v);
explicit mcp_get_question_type_name_params(bsl::mempool* pool);
mcp_get_question_type_name_params(const mcp_get_question_type_name_params& v);
~mcp_get_question_type_name_params();
mcp_get_question_type_name_params& operator=(const mcp_get_question_type_name_params& v);
void clear();
void check() const;
void detach();
mcp_get_question_type_name_params& assign(const mcp_get_question_type_name_params& v);
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_question_type_name_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_question_type_name_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_question_type_name_params
class mcp_get_question_type_name_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_question_type_name_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_question_type_name_result_params* v);
explicit mcp_get_question_type_name_result_params(bsl::mempool* pool);
mcp_get_question_type_name_result_params(const mcp_get_question_type_name_result_params& v);
~mcp_get_question_type_name_result_params();
mcp_get_question_type_name_result_params& operator=(const mcp_get_question_type_name_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_question_type_name_result_params& assign(const mcp_get_question_type_name_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_question_type_name_result_params& set_count(int32_t v);
inline void clear_count();
// @@question_type_name_t question_type_name_list=out(),array(0);
inline bool has_question_type_name_list() const;
inline const ::idl::vector< ::idl::question_type_name_t >& question_type_name_list() const;
inline ::idl::vector< ::idl::question_type_name_t >* mutable_question_type_name_list();
inline void clear_question_type_name_list();
// deprecated.use 'mutable_question_type_name_list' instead.
inline ::idl::vector< ::idl::question_type_name_t >* m_question_type_name_list();
// deprecated.use 'question_type_name_list().size()' instead.
inline size_t question_type_name_list_size() const;
inline const ::idl::question_type_name_t& question_type_name_list(size_t i0) const;
inline ::idl::question_type_name_t* mutable_question_type_name_list(size_t i0);
// deprecated.use 'mutable_question_type_name_list' instead.
inline ::idl::question_type_name_t* m_question_type_name_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::question_type_name_t > _m_question_type_name_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_question_type_name_result_params
class mcp_get_question_type_name_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_question_type_name_response* create(bsl::mempool* pool);
static void destroy(mcp_get_question_type_name_response* v);
explicit mcp_get_question_type_name_response(bsl::mempool* pool);
mcp_get_question_type_name_response(const mcp_get_question_type_name_response& v);
~mcp_get_question_type_name_response();
mcp_get_question_type_name_response& operator=(const mcp_get_question_type_name_response& v);
void clear();
void check() const;
void detach();
mcp_get_question_type_name_response& assign(const mcp_get_question_type_name_response& v);
// @@mcp_get_question_type_name_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_question_type_name_result_params& result_params() const;
inline ::idl::mcp_get_question_type_name_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_question_type_name_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_question_type_name_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_question_type_name_response
class mcp_submit_question_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_submit_question_params* create(bsl::mempool* pool);
static void destroy(mcp_submit_question_params* v);
explicit mcp_submit_question_params(bsl::mempool* pool);
mcp_submit_question_params(const mcp_submit_question_params& v);
~mcp_submit_question_params();
mcp_submit_question_params& operator=(const mcp_submit_question_params& v);
void clear();
void check() const;
void detach();
mcp_submit_question_params& assign(const mcp_submit_question_params& v);
// @@string user_id=in();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_submit_question_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_submit_question_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
// @@string c_id=in();
inline bool has_c_id() const;
inline const char* c_id(unsigned int* size=0) const;
inline mcp_submit_question_params& set_c_id(const char* s,ssize_t size=-1);
inline mcp_submit_question_params& set_ptr_c_id(const char* s,ssize_t size=-1);
inline void clear_c_id();
// @@string question_type=in();
inline bool has_question_type() const;
inline const char* question_type(unsigned int* size=0) const;
inline mcp_submit_question_params& set_question_type(const char* s,ssize_t size=-1);
inline mcp_submit_question_params& set_ptr_question_type(const char* s,ssize_t size=-1);
inline void clear_question_type();
// @@string question=in();
inline bool has_question() const;
inline const char* question(unsigned int* size=0) const;
inline mcp_submit_question_params& set_question(const char* s,ssize_t size=-1);
inline mcp_submit_question_params& set_ptr_question(const char* s,ssize_t size=-1);
inline void clear_question();
// @@string phone=in();
inline bool has_phone() const;
inline const char* phone(unsigned int* size=0) const;
inline mcp_submit_question_params& set_phone(const char* s,ssize_t size=-1);
inline mcp_submit_question_params& set_ptr_phone(const char* s,ssize_t size=-1);
inline void clear_phone();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_user_id;
 ::idl::string _m_c_id;
 ::idl::string _m_question_type;
 ::idl::string _m_question;
 ::idl::string _m_phone;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_submit_question_params
class mcp_submit_question_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_submit_question_result_params* create(bsl::mempool* pool);
static void destroy(mcp_submit_question_result_params* v);
explicit mcp_submit_question_result_params(bsl::mempool* pool);
mcp_submit_question_result_params(const mcp_submit_question_result_params& v);
~mcp_submit_question_result_params();
mcp_submit_question_result_params& operator=(const mcp_submit_question_result_params& v);
void clear();
void check() const;
void detach();
mcp_submit_question_result_params& assign(const mcp_submit_question_result_params& v);
// @@int32_t res=out();
inline bool has_res() const;
inline int32_t res() const;
inline mcp_submit_question_result_params& set_res(int32_t v);
inline void clear_res();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_res;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_submit_question_result_params
class mcp_submit_question_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_submit_question_response* create(bsl::mempool* pool);
static void destroy(mcp_submit_question_response* v);
explicit mcp_submit_question_response(bsl::mempool* pool);
mcp_submit_question_response(const mcp_submit_question_response& v);
~mcp_submit_question_response();
mcp_submit_question_response& operator=(const mcp_submit_question_response& v);
void clear();
void check() const;
void detach();
mcp_submit_question_response& assign(const mcp_submit_question_response& v);
// @@mcp_submit_question_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_submit_question_result_params& result_params() const;
inline ::idl::mcp_submit_question_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_submit_question_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_submit_question_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_submit_question_response
class mcp_get_user_question_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_user_question_params* create(bsl::mempool* pool);
static void destroy(mcp_get_user_question_params* v);
explicit mcp_get_user_question_params(bsl::mempool* pool);
mcp_get_user_question_params(const mcp_get_user_question_params& v);
~mcp_get_user_question_params();
mcp_get_user_question_params& operator=(const mcp_get_user_question_params& v);
void clear();
void check() const;
void detach();
mcp_get_user_question_params& assign(const mcp_get_user_question_params& v);
// @@string user_id=in();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_get_user_question_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_get_user_question_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_user_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_user_question_params
class mcp_get_user_question_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_user_question_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_user_question_result_params* v);
explicit mcp_get_user_question_result_params(bsl::mempool* pool);
mcp_get_user_question_result_params(const mcp_get_user_question_result_params& v);
~mcp_get_user_question_result_params();
mcp_get_user_question_result_params& operator=(const mcp_get_user_question_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_user_question_result_params& assign(const mcp_get_user_question_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_user_question_result_params& set_count(int32_t v);
inline void clear_count();
// @@user_question_answer_t user_question_answer_list=out(),array(0);
inline bool has_user_question_answer_list() const;
inline const ::idl::vector< ::idl::user_question_answer_t >& user_question_answer_list() const;
inline ::idl::vector< ::idl::user_question_answer_t >* mutable_user_question_answer_list();
inline void clear_user_question_answer_list();
// deprecated.use 'mutable_user_question_answer_list' instead.
inline ::idl::vector< ::idl::user_question_answer_t >* m_user_question_answer_list();
// deprecated.use 'user_question_answer_list().size()' instead.
inline size_t user_question_answer_list_size() const;
inline const ::idl::user_question_answer_t& user_question_answer_list(size_t i0) const;
inline ::idl::user_question_answer_t* mutable_user_question_answer_list(size_t i0);
// deprecated.use 'mutable_user_question_answer_list' instead.
inline ::idl::user_question_answer_t* m_user_question_answer_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::user_question_answer_t > _m_user_question_answer_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_user_question_result_params
class mcp_get_user_question_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_user_question_response* create(bsl::mempool* pool);
static void destroy(mcp_get_user_question_response* v);
explicit mcp_get_user_question_response(bsl::mempool* pool);
mcp_get_user_question_response(const mcp_get_user_question_response& v);
~mcp_get_user_question_response();
mcp_get_user_question_response& operator=(const mcp_get_user_question_response& v);
void clear();
void check() const;
void detach();
mcp_get_user_question_response& assign(const mcp_get_user_question_response& v);
// @@mcp_get_user_question_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_user_question_result_params& result_params() const;
inline ::idl::mcp_get_user_question_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_user_question_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_user_question_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_user_question_response
class mcp_get_qp_activity_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_qp_activity_params* create(bsl::mempool* pool);
static void destroy(mcp_get_qp_activity_params* v);
explicit mcp_get_qp_activity_params(bsl::mempool* pool);
mcp_get_qp_activity_params(const mcp_get_qp_activity_params& v);
~mcp_get_qp_activity_params();
mcp_get_qp_activity_params& operator=(const mcp_get_qp_activity_params& v);
void clear();
void check() const;
void detach();
mcp_get_qp_activity_params& assign(const mcp_get_qp_activity_params& v);
// @@string id=in();
inline bool has_id() const;
inline const char* id(unsigned int* size=0) const;
inline mcp_get_qp_activity_params& set_id(const char* s,ssize_t size=-1);
inline mcp_get_qp_activity_params& set_ptr_id(const char* s,ssize_t size=-1);
inline void clear_id();
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_qp_activity_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_qp_activity_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_id;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_qp_activity_params
class mcp_get_qp_activity_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_qp_activity_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_qp_activity_result_params* v);
explicit mcp_get_qp_activity_result_params(bsl::mempool* pool);
mcp_get_qp_activity_result_params(const mcp_get_qp_activity_result_params& v);
~mcp_get_qp_activity_result_params();
mcp_get_qp_activity_result_params& operator=(const mcp_get_qp_activity_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_qp_activity_result_params& assign(const mcp_get_qp_activity_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_qp_activity_result_params& set_count(int32_t v);
inline void clear_count();
// @@qp_activity_t qp_activity_list=out(),array(0);
inline bool has_qp_activity_list() const;
inline const ::idl::vector< ::idl::qp_activity_t >& qp_activity_list() const;
inline ::idl::vector< ::idl::qp_activity_t >* mutable_qp_activity_list();
inline void clear_qp_activity_list();
// deprecated.use 'mutable_qp_activity_list' instead.
inline ::idl::vector< ::idl::qp_activity_t >* m_qp_activity_list();
// deprecated.use 'qp_activity_list().size()' instead.
inline size_t qp_activity_list_size() const;
inline const ::idl::qp_activity_t& qp_activity_list(size_t i0) const;
inline ::idl::qp_activity_t* mutable_qp_activity_list(size_t i0);
// deprecated.use 'mutable_qp_activity_list' instead.
inline ::idl::qp_activity_t* m_qp_activity_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 ::idl::vector< ::idl::qp_activity_t > _m_qp_activity_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_qp_activity_result_params
class mcp_get_qp_activity_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_qp_activity_response* create(bsl::mempool* pool);
static void destroy(mcp_get_qp_activity_response* v);
explicit mcp_get_qp_activity_response(bsl::mempool* pool);
mcp_get_qp_activity_response(const mcp_get_qp_activity_response& v);
~mcp_get_qp_activity_response();
mcp_get_qp_activity_response& operator=(const mcp_get_qp_activity_response& v);
void clear();
void check() const;
void detach();
mcp_get_qp_activity_response& assign(const mcp_get_qp_activity_response& v);
// @@mcp_get_qp_activity_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_qp_activity_result_params& result_params() const;
inline ::idl::mcp_get_qp_activity_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_qp_activity_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_qp_activity_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_qp_activity_response
class mcp_get_qp_activity_person_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_qp_activity_person_params* create(bsl::mempool* pool);
static void destroy(mcp_get_qp_activity_person_params* v);
explicit mcp_get_qp_activity_person_params(bsl::mempool* pool);
mcp_get_qp_activity_person_params(const mcp_get_qp_activity_person_params& v);
~mcp_get_qp_activity_person_params();
mcp_get_qp_activity_person_params& operator=(const mcp_get_qp_activity_person_params& v);
void clear();
void check() const;
void detach();
mcp_get_qp_activity_person_params& assign(const mcp_get_qp_activity_person_params& v);
// @@string c_ids=in();
inline bool has_c_ids() const;
inline const char* c_ids(unsigned int* size=0) const;
inline mcp_get_qp_activity_person_params& set_c_ids(const char* s,ssize_t size=-1);
inline mcp_get_qp_activity_person_params& set_ptr_c_ids(const char* s,ssize_t size=-1);
inline void clear_c_ids();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_c_ids;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_qp_activity_person_params
class mcp_get_qp_activity_person_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_qp_activity_person_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_qp_activity_person_result_params* v);
explicit mcp_get_qp_activity_person_result_params(bsl::mempool* pool);
mcp_get_qp_activity_person_result_params(const mcp_get_qp_activity_person_result_params& v);
~mcp_get_qp_activity_person_result_params();
mcp_get_qp_activity_person_result_params& operator=(const mcp_get_qp_activity_person_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_qp_activity_person_result_params& assign(const mcp_get_qp_activity_person_result_params& v);
// @@int32_t res=out();
inline bool has_res() const;
inline int32_t res() const;
inline mcp_get_qp_activity_person_result_params& set_res(int32_t v);
inline void clear_res();
// @@int32_t total_person_num=out();
inline bool has_total_person_num() const;
inline int32_t total_person_num() const;
inline mcp_get_qp_activity_person_result_params& set_total_person_num(int32_t v);
inline void clear_total_person_num();
// @@qp_activity_person_t qp_activity_person_list=out(),array(0);
inline bool has_qp_activity_person_list() const;
inline const ::idl::vector< ::idl::qp_activity_person_t >& qp_activity_person_list() const;
inline ::idl::vector< ::idl::qp_activity_person_t >* mutable_qp_activity_person_list();
inline void clear_qp_activity_person_list();
// deprecated.use 'mutable_qp_activity_person_list' instead.
inline ::idl::vector< ::idl::qp_activity_person_t >* m_qp_activity_person_list();
// deprecated.use 'qp_activity_person_list().size()' instead.
inline size_t qp_activity_person_list_size() const;
inline const ::idl::qp_activity_person_t& qp_activity_person_list(size_t i0) const;
inline ::idl::qp_activity_person_t* mutable_qp_activity_person_list(size_t i0);
// deprecated.use 'mutable_qp_activity_person_list' instead.
inline ::idl::qp_activity_person_t* m_qp_activity_person_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_res;
 int32_t _m_total_person_num;
 ::idl::vector< ::idl::qp_activity_person_t > _m_qp_activity_person_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_qp_activity_person_result_params
class mcp_get_qp_activity_person_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_qp_activity_person_response* create(bsl::mempool* pool);
static void destroy(mcp_get_qp_activity_person_response* v);
explicit mcp_get_qp_activity_person_response(bsl::mempool* pool);
mcp_get_qp_activity_person_response(const mcp_get_qp_activity_person_response& v);
~mcp_get_qp_activity_person_response();
mcp_get_qp_activity_person_response& operator=(const mcp_get_qp_activity_person_response& v);
void clear();
void check() const;
void detach();
mcp_get_qp_activity_person_response& assign(const mcp_get_qp_activity_person_response& v);
// @@mcp_get_qp_activity_person_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_qp_activity_person_result_params& result_params() const;
inline ::idl::mcp_get_qp_activity_person_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_qp_activity_person_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_qp_activity_person_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_qp_activity_person_response
class mcp_get_person_award_list_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_person_award_list_params* create(bsl::mempool* pool);
static void destroy(mcp_get_person_award_list_params* v);
explicit mcp_get_person_award_list_params(bsl::mempool* pool);
mcp_get_person_award_list_params(const mcp_get_person_award_list_params& v);
~mcp_get_person_award_list_params();
mcp_get_person_award_list_params& operator=(const mcp_get_person_award_list_params& v);
void clear();
void check() const;
void detach();
mcp_get_person_award_list_params& assign(const mcp_get_person_award_list_params& v);
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_person_award_list_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_person_award_list_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_page;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_person_award_list_params
class mcp_get_person_award_list_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_person_award_list_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_person_award_list_result_params* v);
explicit mcp_get_person_award_list_result_params(bsl::mempool* pool);
mcp_get_person_award_list_result_params(const mcp_get_person_award_list_result_params& v);
~mcp_get_person_award_list_result_params();
mcp_get_person_award_list_result_params& operator=(const mcp_get_person_award_list_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_person_award_list_result_params& assign(const mcp_get_person_award_list_result_params& v);
// @@int32_t res=out();
inline bool has_res() const;
inline int32_t res() const;
inline mcp_get_person_award_list_result_params& set_res(int32_t v);
inline void clear_res();
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_person_award_list_result_params& set_count(int32_t v);
inline void clear_count();
// @@person_award_info_t person_award_list=out(),array(0);
inline bool has_person_award_list() const;
inline const ::idl::vector< ::idl::person_award_info_t >& person_award_list() const;
inline ::idl::vector< ::idl::person_award_info_t >* mutable_person_award_list();
inline void clear_person_award_list();
// deprecated.use 'mutable_person_award_list' instead.
inline ::idl::vector< ::idl::person_award_info_t >* m_person_award_list();
// deprecated.use 'person_award_list().size()' instead.
inline size_t person_award_list_size() const;
inline const ::idl::person_award_info_t& person_award_list(size_t i0) const;
inline ::idl::person_award_info_t* mutable_person_award_list(size_t i0);
// deprecated.use 'mutable_person_award_list' instead.
inline ::idl::person_award_info_t* m_person_award_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_res;
 int32_t _m_count;
 ::idl::vector< ::idl::person_award_info_t > _m_person_award_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_person_award_list_result_params
class mcp_get_person_award_list_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_person_award_list_response* create(bsl::mempool* pool);
static void destroy(mcp_get_person_award_list_response* v);
explicit mcp_get_person_award_list_response(bsl::mempool* pool);
mcp_get_person_award_list_response(const mcp_get_person_award_list_response& v);
~mcp_get_person_award_list_response();
mcp_get_person_award_list_response& operator=(const mcp_get_person_award_list_response& v);
void clear();
void check() const;
void detach();
mcp_get_person_award_list_response& assign(const mcp_get_person_award_list_response& v);
// @@mcp_get_person_award_list_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_person_award_list_result_params& result_params() const;
inline ::idl::mcp_get_person_award_list_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_person_award_list_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_person_award_list_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_person_award_list_response
class mcp_get_person_all_awards_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_person_all_awards_params* create(bsl::mempool* pool);
static void destroy(mcp_get_person_all_awards_params* v);
explicit mcp_get_person_all_awards_params(bsl::mempool* pool);
mcp_get_person_all_awards_params(const mcp_get_person_all_awards_params& v);
~mcp_get_person_all_awards_params();
mcp_get_person_all_awards_params& operator=(const mcp_get_person_all_awards_params& v);
void clear();
void check() const;
void detach();
mcp_get_person_all_awards_params& assign(const mcp_get_person_all_awards_params& v);
// @@uint32_t page=in();
inline bool has_page() const;
inline uint32_t page() const;
inline mcp_get_person_all_awards_params& set_page(uint32_t v);
inline void clear_page();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_person_all_awards_params& set_page_size(uint32_t v);
inline void clear_page_size();
// @@string user_id=in();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_get_person_all_awards_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_get_person_all_awards_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 uint32_t _m_page;
 uint32_t _m_page_size;
 ::idl::string _m_user_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_person_all_awards_params
class mcp_get_person_all_awards_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_person_all_awards_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_person_all_awards_result_params* v);
explicit mcp_get_person_all_awards_result_params(bsl::mempool* pool);
mcp_get_person_all_awards_result_params(const mcp_get_person_all_awards_result_params& v);
~mcp_get_person_all_awards_result_params();
mcp_get_person_all_awards_result_params& operator=(const mcp_get_person_all_awards_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_person_all_awards_result_params& assign(const mcp_get_person_all_awards_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_person_all_awards_result_params& set_count(int32_t v);
inline void clear_count();
// @@int32_t res=out();
inline bool has_res() const;
inline int32_t res() const;
inline mcp_get_person_all_awards_result_params& set_res(int32_t v);
inline void clear_res();
// @@person_all_award_info_t person_all_award_list=out(),array(0);
inline bool has_person_all_award_list() const;
inline const ::idl::vector< ::idl::person_all_award_info_t >& person_all_award_list() const;
inline ::idl::vector< ::idl::person_all_award_info_t >* mutable_person_all_award_list();
inline void clear_person_all_award_list();
// deprecated.use 'mutable_person_all_award_list' instead.
inline ::idl::vector< ::idl::person_all_award_info_t >* m_person_all_award_list();
// deprecated.use 'person_all_award_list().size()' instead.
inline size_t person_all_award_list_size() const;
inline const ::idl::person_all_award_info_t& person_all_award_list(size_t i0) const;
inline ::idl::person_all_award_info_t* mutable_person_all_award_list(size_t i0);
// deprecated.use 'mutable_person_all_award_list' instead.
inline ::idl::person_all_award_info_t* m_person_all_award_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 int32_t _m_res;
 ::idl::vector< ::idl::person_all_award_info_t > _m_person_all_award_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_person_all_awards_result_params
class mcp_get_person_all_awards_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_person_all_awards_response* create(bsl::mempool* pool);
static void destroy(mcp_get_person_all_awards_response* v);
explicit mcp_get_person_all_awards_response(bsl::mempool* pool);
mcp_get_person_all_awards_response(const mcp_get_person_all_awards_response& v);
~mcp_get_person_all_awards_response();
mcp_get_person_all_awards_response& operator=(const mcp_get_person_all_awards_response& v);
void clear();
void check() const;
void detach();
mcp_get_person_all_awards_response& assign(const mcp_get_person_all_awards_response& v);
// @@mcp_get_person_all_awards_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_person_all_awards_result_params& result_params() const;
inline ::idl::mcp_get_person_all_awards_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_person_all_awards_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_person_all_awards_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_person_all_awards_response
class mcp_get_person_award_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_person_award_params* create(bsl::mempool* pool);
static void destroy(mcp_get_person_award_params* v);
explicit mcp_get_person_award_params(bsl::mempool* pool);
mcp_get_person_award_params(const mcp_get_person_award_params& v);
~mcp_get_person_award_params();
mcp_get_person_award_params& operator=(const mcp_get_person_award_params& v);
void clear();
void check() const;
void detach();
mcp_get_person_award_params& assign(const mcp_get_person_award_params& v);
// @@string user_id=in();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_get_person_award_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_get_person_award_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_user_id;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_person_award_params
class mcp_get_person_award_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_person_award_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_person_award_result_params* v);
explicit mcp_get_person_award_result_params(bsl::mempool* pool);
mcp_get_person_award_result_params(const mcp_get_person_award_result_params& v);
~mcp_get_person_award_result_params();
mcp_get_person_award_result_params& operator=(const mcp_get_person_award_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_person_award_result_params& assign(const mcp_get_person_award_result_params& v);
// @@int32_t rank=out();
inline bool has_rank() const;
inline int32_t rank() const;
inline mcp_get_person_award_result_params& set_rank(int32_t v);
inline void clear_rank();
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_person_award_result_params& set_count(int32_t v);
inline void clear_count();
// @@int32_t res=out();
inline bool has_res() const;
inline int32_t res() const;
inline mcp_get_person_award_result_params& set_res(int32_t v);
inline void clear_res();
// @@person_award_info_t person_award_list=out(),array(0);
inline bool has_person_award_list() const;
inline const ::idl::vector< ::idl::person_award_info_t >& person_award_list() const;
inline ::idl::vector< ::idl::person_award_info_t >* mutable_person_award_list();
inline void clear_person_award_list();
// deprecated.use 'mutable_person_award_list' instead.
inline ::idl::vector< ::idl::person_award_info_t >* m_person_award_list();
// deprecated.use 'person_award_list().size()' instead.
inline size_t person_award_list_size() const;
inline const ::idl::person_award_info_t& person_award_list(size_t i0) const;
inline ::idl::person_award_info_t* mutable_person_award_list(size_t i0);
// deprecated.use 'mutable_person_award_list' instead.
inline ::idl::person_award_info_t* m_person_award_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_rank;
 int32_t _m_count;
 int32_t _m_res;
 ::idl::vector< ::idl::person_award_info_t > _m_person_award_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_person_award_result_params
class mcp_get_person_award_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_person_award_response* create(bsl::mempool* pool);
static void destroy(mcp_get_person_award_response* v);
explicit mcp_get_person_award_response(bsl::mempool* pool);
mcp_get_person_award_response(const mcp_get_person_award_response& v);
~mcp_get_person_award_response();
mcp_get_person_award_response& operator=(const mcp_get_person_award_response& v);
void clear();
void check() const;
void detach();
mcp_get_person_award_response& assign(const mcp_get_person_award_response& v);
// @@mcp_get_person_award_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_person_award_result_params& result_params() const;
inline ::idl::mcp_get_person_award_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_person_award_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_person_award_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_person_award_response
class mcp_get_award_list_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_award_list_params* create(bsl::mempool* pool);
static void destroy(mcp_get_award_list_params* v);
explicit mcp_get_award_list_params(bsl::mempool* pool);
mcp_get_award_list_params(const mcp_get_award_list_params& v);
~mcp_get_award_list_params();
mcp_get_award_list_params& operator=(const mcp_get_award_list_params& v);
void clear();
void check() const;
void detach();
mcp_get_award_list_params& assign(const mcp_get_award_list_params& v);
// @@string award_channel=in();
inline bool has_award_channel() const;
inline const char* award_channel(unsigned int* size=0) const;
inline mcp_get_award_list_params& set_award_channel(const char* s,ssize_t size=-1);
inline mcp_get_award_list_params& set_ptr_award_channel(const char* s,ssize_t size=-1);
inline void clear_award_channel();
// @@uint32_t page_size=in();
inline bool has_page_size() const;
inline uint32_t page_size() const;
inline mcp_get_award_list_params& set_page_size(uint32_t v);
inline void clear_page_size();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_award_channel;
 uint32_t _m_page_size;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_award_list_params
class mcp_get_award_list_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_award_list_result_params* create(bsl::mempool* pool);
static void destroy(mcp_get_award_list_result_params* v);
explicit mcp_get_award_list_result_params(bsl::mempool* pool);
mcp_get_award_list_result_params(const mcp_get_award_list_result_params& v);
~mcp_get_award_list_result_params();
mcp_get_award_list_result_params& operator=(const mcp_get_award_list_result_params& v);
void clear();
void check() const;
void detach();
mcp_get_award_list_result_params& assign(const mcp_get_award_list_result_params& v);
// @@int32_t count=out();
inline bool has_count() const;
inline int32_t count() const;
inline mcp_get_award_list_result_params& set_count(int32_t v);
inline void clear_count();
// @@int32_t res=out();
inline bool has_res() const;
inline int32_t res() const;
inline mcp_get_award_list_result_params& set_res(int32_t v);
inline void clear_res();
// @@award_info_t award_list=out(),array(0);
inline bool has_award_list() const;
inline const ::idl::vector< ::idl::award_info_t >& award_list() const;
inline ::idl::vector< ::idl::award_info_t >* mutable_award_list();
inline void clear_award_list();
// deprecated.use 'mutable_award_list' instead.
inline ::idl::vector< ::idl::award_info_t >* m_award_list();
// deprecated.use 'award_list().size()' instead.
inline size_t award_list_size() const;
inline const ::idl::award_info_t& award_list(size_t i0) const;
inline ::idl::award_info_t* mutable_award_list(size_t i0);
// deprecated.use 'mutable_award_list' instead.
inline ::idl::award_info_t* m_award_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_count;
 int32_t _m_res;
 ::idl::vector< ::idl::award_info_t > _m_award_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_award_list_result_params
class mcp_get_award_list_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_get_award_list_response* create(bsl::mempool* pool);
static void destroy(mcp_get_award_list_response* v);
explicit mcp_get_award_list_response(bsl::mempool* pool);
mcp_get_award_list_response(const mcp_get_award_list_response& v);
~mcp_get_award_list_response();
mcp_get_award_list_response& operator=(const mcp_get_award_list_response& v);
void clear();
void check() const;
void detach();
mcp_get_award_list_response& assign(const mcp_get_award_list_response& v);
// @@mcp_get_award_list_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_get_award_list_result_params& result_params() const;
inline ::idl::mcp_get_award_list_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_get_award_list_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_get_award_list_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_get_award_list_response
class mcp_grab_award_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_grab_award_params* create(bsl::mempool* pool);
static void destroy(mcp_grab_award_params* v);
explicit mcp_grab_award_params(bsl::mempool* pool);
mcp_grab_award_params(const mcp_grab_award_params& v);
~mcp_grab_award_params();
mcp_grab_award_params& operator=(const mcp_grab_award_params& v);
void clear();
void check() const;
void detach();
mcp_grab_award_params& assign(const mcp_grab_award_params& v);
// @@string user_id=in();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_grab_award_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_grab_award_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
// @@string award_channel=in();
inline bool has_award_channel() const;
inline const char* award_channel(unsigned int* size=0) const;
inline mcp_grab_award_params& set_award_channel(const char* s,ssize_t size=-1);
inline mcp_grab_award_params& set_ptr_award_channel(const char* s,ssize_t size=-1);
inline void clear_award_channel();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_user_id;
 ::idl::string _m_award_channel;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_grab_award_params
class mcp_grab_award_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_grab_award_result_params* create(bsl::mempool* pool);
static void destroy(mcp_grab_award_result_params* v);
explicit mcp_grab_award_result_params(bsl::mempool* pool);
mcp_grab_award_result_params(const mcp_grab_award_result_params& v);
~mcp_grab_award_result_params();
mcp_grab_award_result_params& operator=(const mcp_grab_award_result_params& v);
void clear();
void check() const;
void detach();
mcp_grab_award_result_params& assign(const mcp_grab_award_result_params& v);
// @@int32_t res=out();
inline bool has_res() const;
inline int32_t res() const;
inline mcp_grab_award_result_params& set_res(int32_t v);
inline void clear_res();
// @@string user_id=out();
inline bool has_user_id() const;
inline const char* user_id(unsigned int* size=0) const;
inline mcp_grab_award_result_params& set_user_id(const char* s,ssize_t size=-1);
inline mcp_grab_award_result_params& set_ptr_user_id(const char* s,ssize_t size=-1);
inline void clear_user_id();
// @@award_info_t award_list=out(),array(0);
inline bool has_award_list() const;
inline const ::idl::vector< ::idl::award_info_t >& award_list() const;
inline ::idl::vector< ::idl::award_info_t >* mutable_award_list();
inline void clear_award_list();
// deprecated.use 'mutable_award_list' instead.
inline ::idl::vector< ::idl::award_info_t >* m_award_list();
// deprecated.use 'award_list().size()' instead.
inline size_t award_list_size() const;
inline const ::idl::award_info_t& award_list(size_t i0) const;
inline ::idl::award_info_t* mutable_award_list(size_t i0);
// deprecated.use 'mutable_award_list' instead.
inline ::idl::award_info_t* m_award_list(size_t i0);
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_res;
 ::idl::string _m_user_id;
 ::idl::vector< ::idl::award_info_t > _m_award_list;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_grab_award_result_params
class mcp_grab_award_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static mcp_grab_award_response* create(bsl::mempool* pool);
static void destroy(mcp_grab_award_response* v);
explicit mcp_grab_award_response(bsl::mempool* pool);
mcp_grab_award_response(const mcp_grab_award_response& v);
~mcp_grab_award_response();
mcp_grab_award_response& operator=(const mcp_grab_award_response& v);
void clear();
void check() const;
void detach();
mcp_grab_award_response& assign(const mcp_grab_award_response& v);
// @@mcp_grab_award_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::mcp_grab_award_result_params& result_params() const;
inline ::idl::mcp_grab_award_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::mcp_grab_award_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::mcp_grab_award_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class mcp_grab_award_response
class Notify_addSystemNotify_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static Notify_addSystemNotify_params* create(bsl::mempool* pool);
static void destroy(Notify_addSystemNotify_params* v);
explicit Notify_addSystemNotify_params(bsl::mempool* pool);
Notify_addSystemNotify_params(const Notify_addSystemNotify_params& v);
~Notify_addSystemNotify_params();
Notify_addSystemNotify_params& operator=(const Notify_addSystemNotify_params& v);
void clear();
void check() const;
void detach();
Notify_addSystemNotify_params& assign(const Notify_addSystemNotify_params& v);
// @@string sourceId=in();
inline bool has_sourceId() const;
inline const char* sourceId(unsigned int* size=0) const;
inline Notify_addSystemNotify_params& set_sourceId(const char* s,ssize_t size=-1);
inline Notify_addSystemNotify_params& set_ptr_sourceId(const char* s,ssize_t size=-1);
inline void clear_sourceId();
// @@string titleId=in();
inline bool has_titleId() const;
inline const char* titleId(unsigned int* size=0) const;
inline Notify_addSystemNotify_params& set_titleId(const char* s,ssize_t size=-1);
inline Notify_addSystemNotify_params& set_ptr_titleId(const char* s,ssize_t size=-1);
inline void clear_titleId();
// @@int32_t targetUid=in(),array(0);
inline bool has_targetUid() const;
inline const ::idl::vector< int32_t >& targetUid() const;
inline ::idl::vector< int32_t >* mutable_targetUid();
inline void clear_targetUid();
// deprecated.use 'mutable_targetUid' instead.
inline ::idl::vector< int32_t >* m_targetUid();
// deprecated.use 'targetUid().size()' instead.
inline size_t targetUid_size() const;
inline int32_t targetUid(size_t i0) const;
inline Notify_addSystemNotify_params& set_targetUid(size_t i0,int32_t v);
// @@string messageContent=in();
inline bool has_messageContent() const;
inline const char* messageContent(unsigned int* size=0) const;
inline Notify_addSystemNotify_params& set_messageContent(const char* s,ssize_t size=-1);
inline Notify_addSystemNotify_params& set_ptr_messageContent(const char* s,ssize_t size=-1);
inline void clear_messageContent();
// @@int32_t bussiness=in();
inline bool has_bussiness() const;
inline int32_t bussiness() const;
inline Notify_addSystemNotify_params& set_bussiness(int32_t v);
inline void clear_bussiness();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 ::idl::string _m_sourceId;
 ::idl::string _m_titleId;
 ::idl::vector< int32_t > _m_targetUid;
 ::idl::string _m_messageContent;
 int32_t _m_bussiness;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class Notify_addSystemNotify_params
class Notify_addSystemNotify_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static Notify_addSystemNotify_result_params* create(bsl::mempool* pool);
static void destroy(Notify_addSystemNotify_result_params* v);
explicit Notify_addSystemNotify_result_params(bsl::mempool* pool);
Notify_addSystemNotify_result_params(const Notify_addSystemNotify_result_params& v);
~Notify_addSystemNotify_result_params();
Notify_addSystemNotify_result_params& operator=(const Notify_addSystemNotify_result_params& v);
void clear();
void check() const;
void detach();
Notify_addSystemNotify_result_params& assign(const Notify_addSystemNotify_result_params& v);
// @@bool resault=out();
inline bool has_resault() const;
inline bool resault() const;
inline Notify_addSystemNotify_result_params& set_resault(bool v);
inline void clear_resault();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 bool _m_resault;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class Notify_addSystemNotify_result_params
class Notify_addSystemNotify_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static Notify_addSystemNotify_response* create(bsl::mempool* pool);
static void destroy(Notify_addSystemNotify_response* v);
explicit Notify_addSystemNotify_response(bsl::mempool* pool);
Notify_addSystemNotify_response(const Notify_addSystemNotify_response& v);
~Notify_addSystemNotify_response();
Notify_addSystemNotify_response& operator=(const Notify_addSystemNotify_response& v);
void clear();
void check() const;
void detach();
Notify_addSystemNotify_response& assign(const Notify_addSystemNotify_response& v);
// @@Notify_addSystemNotify_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::Notify_addSystemNotify_result_params& result_params() const;
inline ::idl::Notify_addSystemNotify_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::Notify_addSystemNotify_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::Notify_addSystemNotify_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class Notify_addSystemNotify_response
class GameHallPoint_addGameHallScore_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static GameHallPoint_addGameHallScore_params* create(bsl::mempool* pool);
static void destroy(GameHallPoint_addGameHallScore_params* v);
explicit GameHallPoint_addGameHallScore_params(bsl::mempool* pool);
GameHallPoint_addGameHallScore_params(const GameHallPoint_addGameHallScore_params& v);
~GameHallPoint_addGameHallScore_params();
GameHallPoint_addGameHallScore_params& operator=(const GameHallPoint_addGameHallScore_params& v);
void clear();
void check() const;
void detach();
GameHallPoint_addGameHallScore_params& assign(const GameHallPoint_addGameHallScore_params& v);
// @@int32_t userId=in();
inline bool has_userId() const;
inline int32_t userId() const;
inline GameHallPoint_addGameHallScore_params& set_userId(int32_t v);
inline void clear_userId();
// @@int32_t opId=in();
inline bool has_opId() const;
inline int32_t opId() const;
inline GameHallPoint_addGameHallScore_params& set_opId(int32_t v);
inline void clear_opId();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_userId;
 int32_t _m_opId;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class GameHallPoint_addGameHallScore_params
class GameHallPoint_addGameHallScore_result_params : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static GameHallPoint_addGameHallScore_result_params* create(bsl::mempool* pool);
static void destroy(GameHallPoint_addGameHallScore_result_params* v);
explicit GameHallPoint_addGameHallScore_result_params(bsl::mempool* pool);
GameHallPoint_addGameHallScore_result_params(const GameHallPoint_addGameHallScore_result_params& v);
~GameHallPoint_addGameHallScore_result_params();
GameHallPoint_addGameHallScore_result_params& operator=(const GameHallPoint_addGameHallScore_result_params& v);
void clear();
void check() const;
void detach();
GameHallPoint_addGameHallScore_result_params& assign(const GameHallPoint_addGameHallScore_result_params& v);
// @@int32_t score=out();
inline bool has_score() const;
inline int32_t score() const;
inline GameHallPoint_addGameHallScore_result_params& set_score(int32_t v);
inline void clear_score();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
 int32_t _m_score;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class GameHallPoint_addGameHallScore_result_params
class GameHallPoint_addGameHallScore_response : public ::idl::IDLObject , public ::idl::McpackBean {
public:
static GameHallPoint_addGameHallScore_response* create(bsl::mempool* pool);
static void destroy(GameHallPoint_addGameHallScore_response* v);
explicit GameHallPoint_addGameHallScore_response(bsl::mempool* pool);
GameHallPoint_addGameHallScore_response(const GameHallPoint_addGameHallScore_response& v);
~GameHallPoint_addGameHallScore_response();
GameHallPoint_addGameHallScore_response& operator=(const GameHallPoint_addGameHallScore_response& v);
void clear();
void check() const;
void detach();
GameHallPoint_addGameHallScore_response& assign(const GameHallPoint_addGameHallScore_response& v);
// @@GameHallPoint_addGameHallScore_result_params result_params;
inline bool has_result_params() const;
inline const ::idl::GameHallPoint_addGameHallScore_result_params& result_params() const;
inline ::idl::GameHallPoint_addGameHallScore_result_params* mutable_result_params();
// deprecated.use 'mutable_result_params()' instead.
inline ::idl::GameHallPoint_addGameHallScore_result_params* m_result_params();
inline void clear_result_params();
inline ::idl::Unknown* mutable_unknown();
inline const ::idl::Unknown& unknown() const;
// deprecated.use 'mutable_unknown' instead.
inline ::idl::Unknown& unknown();
// deprecated.use 'unknown().size()' instead.
inline size_t unknown_size() const;
//============================================================
// mcpack2 load/save.
void load(const mc_pack_t* pack);
void LoadWithoutCheck(const mc_pack_t* pack);
//for compatiblity.return 0 when it accepts item,else return -1
int load(const mc_pack_item_t& item);
size_t save(mc_pack_t* pack) const;
public:
bsl::mempool* _pool;
mutable ::idl::GameHallPoint_addGameHallScore_result_params* _m_result_params;
mutable ::idl::Unknown _unknown;
char _flag[1];
}; // class GameHallPoint_addGameHallScore_response
inline sub_class_t* sub_class_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
sub_class_t* tmp=(sub_class_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)sub_class_t(pool);
return tmp;
}
inline void sub_class_t::destroy(sub_class_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~sub_class_t();
pool->free(v,sizeof(*v));
}
}
inline sub_class_t::sub_class_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_icon(_pool)
,_m_content_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline sub_class_t::sub_class_t(const sub_class_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_icon(_pool)
,_m_content_list(_pool)
,_unknown(_pool){
assign(v);
}
inline sub_class_t::~sub_class_t(){
}
inline sub_class_t& sub_class_t::operator=(const sub_class_t& v){
assign(v);
return *this;
}
inline void sub_class_t::clear(){
_m_id.clear();
_m_name.clear();
_m_icon.clear();
_m_content_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void sub_class_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string icon;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "icon" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_icon.get();

}
// @@string content_list=array(0,0);
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_list" << "' not found";
}
{
// level 0 begin
typeof(_m_content_list)& lr0=(_m_content_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void sub_class_t::detach(){
_m_id.detach();
_m_name.detach();
_m_icon.detach();
_m_content_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline sub_class_t& sub_class_t::assign(const sub_class_t& v){
_m_id=v._m_id;
_m_name=v._m_name;
_m_icon=v._m_icon;
_m_content_list=v._m_content_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool sub_class_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* sub_class_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline sub_class_t& sub_class_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline sub_class_t& sub_class_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void sub_class_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool sub_class_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* sub_class_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline sub_class_t& sub_class_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline sub_class_t& sub_class_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void sub_class_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool sub_class_t::has_icon() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* sub_class_t::icon(unsigned int* size) const{
return _m_icon.get(size);
}
inline sub_class_t& sub_class_t::set_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_icon.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline sub_class_t& sub_class_t::set_ptr_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_icon.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void sub_class_t::clear_icon(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_icon.clear();
}
inline bool sub_class_t::has_content_list() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& sub_class_t::content_list() const{
 return _m_content_list;
}
inline void sub_class_t::clear_content_list(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_content_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* sub_class_t::mutable_content_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_content_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* sub_class_t::m_content_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_content_list);
}
inline size_t sub_class_t::content_list_size() const{
/*  */ return _m_content_list.size();
}
inline const char* sub_class_t::content_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_content_list.get(i0).get(i1).get(size);
}
inline sub_class_t& sub_class_t::set_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline sub_class_t& sub_class_t::set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* sub_class_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& sub_class_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& sub_class_t::unknown(){
return _unknown;
}
inline size_t sub_class_t::unknown_size() const{
return _unknown.size();
}
inline class_info_t* class_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
class_info_t* tmp=(class_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)class_info_t(pool);
return tmp;
}
inline void class_info_t::destroy(class_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~class_info_t();
pool->free(v,sizeof(*v));
}
}
inline class_info_t::class_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_name(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline class_info_t::class_info_t(const class_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_name(_pool)
,_unknown(_pool){
assign(v);
}
inline class_info_t::~class_info_t(){
}
inline class_info_t& class_info_t::operator=(const class_info_t& v){
assign(v);
return *this;
}
inline void class_info_t::clear(){
_m_id.clear();
_m_name.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void class_info_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}

::idl::McpackBean::check();
}
inline void class_info_t::detach(){
_m_id.detach();
_m_name.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline class_info_t& class_info_t::assign(const class_info_t& v){
_m_id=v._m_id;
_m_name=v._m_name;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool class_info_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* class_info_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline class_info_t& class_info_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline class_info_t& class_info_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void class_info_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool class_info_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* class_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline class_info_t& class_info_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline class_info_t& class_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void class_info_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline ::idl::Unknown* class_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& class_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& class_info_t::unknown(){
return _unknown;
}
inline size_t class_info_t::unknown_size() const{
return _unknown.size();
}
inline class_detail_count_t* class_detail_count_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
class_detail_count_t* tmp=(class_detail_count_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)class_detail_count_t(pool);
return tmp;
}
inline void class_detail_count_t::destroy(class_detail_count_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~class_detail_count_t();
pool->free(v,sizeof(*v));
}
}
inline class_detail_count_t::class_detail_count_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_icon(_pool)
,_m_count(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline class_detail_count_t::class_detail_count_t(const class_detail_count_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_icon(_pool)
,_m_count(_pool)
,_unknown(_pool){
assign(v);
}
inline class_detail_count_t::~class_detail_count_t(){
}
inline class_detail_count_t& class_detail_count_t::operator=(const class_detail_count_t& v){
assign(v);
return *this;
}
inline void class_detail_count_t::clear(){
_m_id.clear();
_m_name.clear();
_m_icon.clear();
_m_count.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void class_detail_count_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string icon;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "icon" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_icon.get();

}
// @@string count;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_count.get();

}

::idl::McpackBean::check();
}
inline void class_detail_count_t::detach(){
_m_id.detach();
_m_name.detach();
_m_icon.detach();
_m_count.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline class_detail_count_t& class_detail_count_t::assign(const class_detail_count_t& v){
_m_id=v._m_id;
_m_name=v._m_name;
_m_icon=v._m_icon;
_m_count=v._m_count;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool class_detail_count_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* class_detail_count_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline class_detail_count_t& class_detail_count_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline class_detail_count_t& class_detail_count_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void class_detail_count_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool class_detail_count_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* class_detail_count_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline class_detail_count_t& class_detail_count_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline class_detail_count_t& class_detail_count_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void class_detail_count_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool class_detail_count_t::has_icon() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* class_detail_count_t::icon(unsigned int* size) const{
return _m_icon.get(size);
}
inline class_detail_count_t& class_detail_count_t::set_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_icon.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline class_detail_count_t& class_detail_count_t::set_ptr_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_icon.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void class_detail_count_t::clear_icon(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_icon.clear();
}
inline bool class_detail_count_t::has_count() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* class_detail_count_t::count(unsigned int* size) const{
return _m_count.get(size);
}
inline class_detail_count_t& class_detail_count_t::set_count(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_count.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline class_detail_count_t& class_detail_count_t::set_ptr_count(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_count.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void class_detail_count_t::clear_count(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_count.clear();
}
inline ::idl::Unknown* class_detail_count_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& class_detail_count_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& class_detail_count_t::unknown(){
return _unknown;
}
inline size_t class_detail_count_t::unknown_size() const{
return _unknown.size();
}
inline img_info_t* img_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
img_info_t* tmp=(img_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)img_info_t(pool);
return tmp;
}
inline void img_info_t::destroy(img_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~img_info_t();
pool->free(v,sizeof(*v));
}
}
inline img_info_t::img_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_type(_pool)
,_m_url(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline img_info_t::img_info_t(const img_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_type(_pool)
,_m_url(_pool)
,_unknown(_pool){
assign(v);
}
inline img_info_t::~img_info_t(){
}
inline img_info_t& img_info_t::operator=(const img_info_t& v){
assign(v);
return *this;
}
inline void img_info_t::clear(){
_m_type.clear();
_m_url.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void img_info_t::check() const{
// @@string type;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type.get();

}
// @@string url;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_url.get();

}

::idl::McpackBean::check();
}
inline void img_info_t::detach(){
_m_type.detach();
_m_url.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline img_info_t& img_info_t::assign(const img_info_t& v){
_m_type=v._m_type;
_m_url=v._m_url;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool img_info_t::has_type() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* img_info_t::type(unsigned int* size) const{
return _m_type.get(size);
}
inline img_info_t& img_info_t::set_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline img_info_t& img_info_t::set_ptr_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void img_info_t::clear_type(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_type.clear();
}
inline bool img_info_t::has_url() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* img_info_t::url(unsigned int* size) const{
return _m_url.get(size);
}
inline img_info_t& img_info_t::set_url(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline img_info_t& img_info_t::set_ptr_url(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void img_info_t::clear_url(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_url.clear();
}
inline ::idl::Unknown* img_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& img_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& img_info_t::unknown(){
return _unknown;
}
inline size_t img_info_t::unknown_size() const{
return _unknown.size();
}
inline attribute_info_t* attribute_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
attribute_info_t* tmp=(attribute_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)attribute_info_t(pool);
return tmp;
}
inline void attribute_info_t::destroy(attribute_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~attribute_info_t();
pool->free(v,sizeof(*v));
}
}
inline attribute_info_t::attribute_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_name(_pool)
,_m_content(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline attribute_info_t::attribute_info_t(const attribute_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_name(_pool)
,_m_content(_pool)
,_unknown(_pool){
assign(v);
}
inline attribute_info_t::~attribute_info_t(){
}
inline attribute_info_t& attribute_info_t::operator=(const attribute_info_t& v){
assign(v);
return *this;
}
inline void attribute_info_t::clear(){
_m_name.clear();
_m_content.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void attribute_info_t::check() const{
// @@string name;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string content;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content.get();

}

::idl::McpackBean::check();
}
inline void attribute_info_t::detach(){
_m_name.detach();
_m_content.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline attribute_info_t& attribute_info_t::assign(const attribute_info_t& v){
_m_name=v._m_name;
_m_content=v._m_content;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool attribute_info_t::has_name() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* attribute_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline attribute_info_t& attribute_info_t::set_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline attribute_info_t& attribute_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void attribute_info_t::clear_name(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_name.clear();
}
inline bool attribute_info_t::has_content() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* attribute_info_t::content(unsigned int* size) const{
return _m_content.get(size);
}
inline attribute_info_t& attribute_info_t::set_content(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline attribute_info_t& attribute_info_t::set_ptr_content(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void attribute_info_t::clear_content(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content.clear();
}
inline ::idl::Unknown* attribute_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& attribute_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& attribute_info_t::unknown(){
return _unknown;
}
inline size_t attribute_info_t::unknown_size() const{
return _unknown.size();
}
inline ios_content_info_t* ios_content_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
ios_content_info_t* tmp=(ios_content_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)ios_content_info_t(pool);
return tmp;
}
inline void ios_content_info_t::destroy(ios_content_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~ios_content_info_t();
pool->free(v,sizeof(*v));
}
}
inline ios_content_info_t::ios_content_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_icon(_pool)
,_m_type(_pool)
,_m_itunes_id(_pool)
,_m_info(_pool)
,_m_version(_pool)
,_m_cp_id(_pool)
,_m_cp_name(_pool)
,_m_star(_pool)
,_m_gdate(_pool)
,_m_mdate(_pool)
,_m_adapt(_pool)
,_m_url(_pool)
,_m_jump_url(_pool)
,_m_size(_pool)
,_m_now_price(_pool)
,_m_original_price(_pool)
,_m_rating(_pool)
,_m_count(_pool)
,_m_crt_rating(_pool)
,_m_crt_count(_pool)
,_m_language(_pool)
,_m_img_list(_pool)
,_m_class_info(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline ios_content_info_t::ios_content_info_t(const ios_content_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_icon(_pool)
,_m_type(_pool)
,_m_itunes_id(_pool)
,_m_info(_pool)
,_m_version(_pool)
,_m_cp_id(_pool)
,_m_cp_name(_pool)
,_m_star(_pool)
,_m_gdate(_pool)
,_m_mdate(_pool)
,_m_adapt(_pool)
,_m_url(_pool)
,_m_jump_url(_pool)
,_m_size(_pool)
,_m_now_price(_pool)
,_m_original_price(_pool)
,_m_rating(_pool)
,_m_count(_pool)
,_m_crt_rating(_pool)
,_m_crt_count(_pool)
,_m_language(_pool)
,_m_img_list(_pool)
,_m_class_info(_pool)
,_unknown(_pool){
assign(v);
}
inline ios_content_info_t::~ios_content_info_t(){
}
inline ios_content_info_t& ios_content_info_t::operator=(const ios_content_info_t& v){
assign(v);
return *this;
}
inline void ios_content_info_t::clear(){
_m_id.clear();
_m_name.clear();
_m_icon.clear();
_m_type.clear();
_m_itunes_id.clear();
_m_info.clear();
_m_version.clear();
_m_cp_id.clear();
_m_cp_name.clear();
_m_star.clear();
_m_gdate.clear();
_m_mdate.clear();
_m_adapt.clear();
_m_url.clear();
_m_jump_url.clear();
_m_size.clear();
_m_now_price.clear();
_m_original_price.clear();
_m_rating.clear();
_m_count.clear();
_m_crt_rating.clear();
_m_crt_count.clear();
_m_language.clear();
_m_img_list.clear();
_m_class_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void ios_content_info_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string icon;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "icon" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_icon.get();

}
// @@string type;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type.get();

}
// @@string itunes_id;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "itunes_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_itunes_id.get();

}
// @@string info;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info.get();

}
// @@string version;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "version" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_version.get();

}
// @@string cp_id;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cp_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_cp_id.get();

}
// @@string cp_name;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cp_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_cp_name.get();

}
// @@string star;
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "star" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_star.get();

}
// @@string gdate;
if(!(_flag[10 >> 3] & (1 << (10 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "gdate" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_gdate.get();

}
// @@string mdate;
if(!(_flag[11 >> 3] & (1 << (11 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "mdate" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_mdate.get();

}
// @@string adapt;
if(!(_flag[12 >> 3] & (1 << (12 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "adapt" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_adapt.get();

}
// @@string url;
if(!(_flag[13 >> 3] & (1 << (13 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_url.get();

}
// @@string jump_url;
if(!(_flag[14 >> 3] & (1 << (14 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "jump_url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_jump_url.get();

}
// @@string size;
if(!(_flag[15 >> 3] & (1 << (15 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "size" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_size.get();

}
// @@string now_price;
if(!(_flag[16 >> 3] & (1 << (16 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "now_price" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_now_price.get();

}
// @@string original_price;
if(!(_flag[17 >> 3] & (1 << (17 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "original_price" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_original_price.get();

}
// @@string rating;
if(!(_flag[18 >> 3] & (1 << (18 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "rating" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_rating.get();

}
// @@string count;
if(!(_flag[19 >> 3] & (1 << (19 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_count.get();

}
// @@string crt_rating;
if(!(_flag[20 >> 3] & (1 << (20 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "crt_rating" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_crt_rating.get();

}
// @@string crt_count;
if(!(_flag[21 >> 3] & (1 << (21 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "crt_count" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_crt_count.get();

}
// @@string language;
if(!(_flag[22 >> 3] & (1 << (22 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "language" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_language.get();

}
// @@string img_list=array(0);
if(!(_flag[23 >> 3] & (1 << (23 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "img_list" << "' not found";
}
{
// level 0 begin
typeof(_m_img_list)& lr0=(_m_img_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@class_info_t class_info=array(0);
if(!(_flag[24 >> 3] & (1 << (24 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_info" << "' not found";
}
{
// level 0 begin
typeof(_m_class_info)& lr0=(_m_class_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::class_info_t& item=const_cast< ::idl::class_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void ios_content_info_t::detach(){
_m_id.detach();
_m_name.detach();
_m_icon.detach();
_m_type.detach();
_m_itunes_id.detach();
_m_info.detach();
_m_version.detach();
_m_cp_id.detach();
_m_cp_name.detach();
_m_star.detach();
_m_gdate.detach();
_m_mdate.detach();
_m_adapt.detach();
_m_url.detach();
_m_jump_url.detach();
_m_size.detach();
_m_now_price.detach();
_m_original_price.detach();
_m_rating.detach();
_m_count.detach();
_m_crt_rating.detach();
_m_crt_count.detach();
_m_language.detach();
_m_img_list.detach();
_m_class_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline ios_content_info_t& ios_content_info_t::assign(const ios_content_info_t& v){
_m_id=v._m_id;
_m_name=v._m_name;
_m_icon=v._m_icon;
_m_type=v._m_type;
_m_itunes_id=v._m_itunes_id;
_m_info=v._m_info;
_m_version=v._m_version;
_m_cp_id=v._m_cp_id;
_m_cp_name=v._m_cp_name;
_m_star=v._m_star;
_m_gdate=v._m_gdate;
_m_mdate=v._m_mdate;
_m_adapt=v._m_adapt;
_m_url=v._m_url;
_m_jump_url=v._m_jump_url;
_m_size=v._m_size;
_m_now_price=v._m_now_price;
_m_original_price=v._m_original_price;
_m_rating=v._m_rating;
_m_count=v._m_count;
_m_crt_rating=v._m_crt_rating;
_m_crt_count=v._m_crt_count;
_m_language=v._m_language;
_m_img_list=v._m_img_list;
_m_class_info=v._m_class_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool ios_content_info_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* ios_content_info_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool ios_content_info_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* ios_content_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool ios_content_info_t::has_icon() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* ios_content_info_t::icon(unsigned int* size) const{
return _m_icon.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_icon.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_icon.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_icon(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_icon.clear();
}
inline bool ios_content_info_t::has_type() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* ios_content_info_t::type(unsigned int* size) const{
return _m_type.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_type(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_type(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_type(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_type.clear();
}
inline bool ios_content_info_t::has_itunes_id() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* ios_content_info_t::itunes_id(unsigned int* size) const{
return _m_itunes_id.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_itunes_id(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_itunes_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_itunes_id(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_itunes_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_itunes_id(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_itunes_id.clear();
}
inline bool ios_content_info_t::has_info() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* ios_content_info_t::info(unsigned int* size) const{
return _m_info.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_info(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_info(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_info(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_info.clear();
}
inline bool ios_content_info_t::has_version() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* ios_content_info_t::version(unsigned int* size) const{
return _m_version.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_version(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_version.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_version(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_version.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_version(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_version.clear();
}
inline bool ios_content_info_t::has_cp_id() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* ios_content_info_t::cp_id(unsigned int* size) const{
return _m_cp_id.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_cp_id(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_cp_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_cp_id(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_cp_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_cp_id(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_cp_id.clear();
}
inline bool ios_content_info_t::has_cp_name() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* ios_content_info_t::cp_name(unsigned int* size) const{
return _m_cp_name.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_cp_name(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_cp_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_cp_name(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_cp_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_cp_name(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_cp_name.clear();
}
inline bool ios_content_info_t::has_star() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline const char* ios_content_info_t::star(unsigned int* size) const{
return _m_star.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_star(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_star.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_star(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_star.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_star(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_star.clear();
}
inline bool ios_content_info_t::has_gdate() const{
return (_flag[10 >> 3] & (1 << (10 & 0x7)));
}
inline const char* ios_content_info_t::gdate(unsigned int* size) const{
return _m_gdate.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_gdate(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_gdate.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_gdate(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_gdate.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_gdate(){
_flag[10 >> 3] &= ~(1 << (10 & 0x7));
 _m_gdate.clear();
}
inline bool ios_content_info_t::has_mdate() const{
return (_flag[11 >> 3] & (1 << (11 & 0x7)));
}
inline const char* ios_content_info_t::mdate(unsigned int* size) const{
return _m_mdate.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_mdate(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_mdate.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_mdate(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_mdate.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_mdate(){
_flag[11 >> 3] &= ~(1 << (11 & 0x7));
 _m_mdate.clear();
}
inline bool ios_content_info_t::has_adapt() const{
return (_flag[12 >> 3] & (1 << (12 & 0x7)));
}
inline const char* ios_content_info_t::adapt(unsigned int* size) const{
return _m_adapt.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_adapt(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_adapt.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_adapt(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_adapt.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_adapt(){
_flag[12 >> 3] &= ~(1 << (12 & 0x7));
 _m_adapt.clear();
}
inline bool ios_content_info_t::has_url() const{
return (_flag[13 >> 3] & (1 << (13 & 0x7)));
}
inline const char* ios_content_info_t::url(unsigned int* size) const{
return _m_url.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_url(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_url(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_url(){
_flag[13 >> 3] &= ~(1 << (13 & 0x7));
 _m_url.clear();
}
inline bool ios_content_info_t::has_jump_url() const{
return (_flag[14 >> 3] & (1 << (14 & 0x7)));
}
inline const char* ios_content_info_t::jump_url(unsigned int* size) const{
return _m_jump_url.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_jump_url(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_jump_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_jump_url(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_jump_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_jump_url(){
_flag[14 >> 3] &= ~(1 << (14 & 0x7));
 _m_jump_url.clear();
}
inline bool ios_content_info_t::has_size() const{
return (_flag[15 >> 3] & (1 << (15 & 0x7)));
}
inline const char* ios_content_info_t::size(unsigned int* size) const{
return _m_size.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_size(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_size.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_size(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_size.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_size(){
_flag[15 >> 3] &= ~(1 << (15 & 0x7));
 _m_size.clear();
}
inline bool ios_content_info_t::has_now_price() const{
return (_flag[16 >> 3] & (1 << (16 & 0x7)));
}
inline const char* ios_content_info_t::now_price(unsigned int* size) const{
return _m_now_price.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_now_price(const char* s,ssize_t size){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 _m_now_price.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_now_price(const char* s,ssize_t size){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 _m_now_price.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_now_price(){
_flag[16 >> 3] &= ~(1 << (16 & 0x7));
 _m_now_price.clear();
}
inline bool ios_content_info_t::has_original_price() const{
return (_flag[17 >> 3] & (1 << (17 & 0x7)));
}
inline const char* ios_content_info_t::original_price(unsigned int* size) const{
return _m_original_price.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_original_price(const char* s,ssize_t size){
_flag[17 >> 3] |= (1 << (17 & 0x7));
 _m_original_price.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_original_price(const char* s,ssize_t size){
_flag[17 >> 3] |= (1 << (17 & 0x7));
 _m_original_price.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_original_price(){
_flag[17 >> 3] &= ~(1 << (17 & 0x7));
 _m_original_price.clear();
}
inline bool ios_content_info_t::has_rating() const{
return (_flag[18 >> 3] & (1 << (18 & 0x7)));
}
inline const char* ios_content_info_t::rating(unsigned int* size) const{
return _m_rating.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_rating(const char* s,ssize_t size){
_flag[18 >> 3] |= (1 << (18 & 0x7));
 _m_rating.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_rating(const char* s,ssize_t size){
_flag[18 >> 3] |= (1 << (18 & 0x7));
 _m_rating.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_rating(){
_flag[18 >> 3] &= ~(1 << (18 & 0x7));
 _m_rating.clear();
}
inline bool ios_content_info_t::has_count() const{
return (_flag[19 >> 3] & (1 << (19 & 0x7)));
}
inline const char* ios_content_info_t::count(unsigned int* size) const{
return _m_count.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_count(const char* s,ssize_t size){
_flag[19 >> 3] |= (1 << (19 & 0x7));
 _m_count.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_count(const char* s,ssize_t size){
_flag[19 >> 3] |= (1 << (19 & 0x7));
 _m_count.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_count(){
_flag[19 >> 3] &= ~(1 << (19 & 0x7));
 _m_count.clear();
}
inline bool ios_content_info_t::has_crt_rating() const{
return (_flag[20 >> 3] & (1 << (20 & 0x7)));
}
inline const char* ios_content_info_t::crt_rating(unsigned int* size) const{
return _m_crt_rating.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_crt_rating(const char* s,ssize_t size){
_flag[20 >> 3] |= (1 << (20 & 0x7));
 _m_crt_rating.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_crt_rating(const char* s,ssize_t size){
_flag[20 >> 3] |= (1 << (20 & 0x7));
 _m_crt_rating.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_crt_rating(){
_flag[20 >> 3] &= ~(1 << (20 & 0x7));
 _m_crt_rating.clear();
}
inline bool ios_content_info_t::has_crt_count() const{
return (_flag[21 >> 3] & (1 << (21 & 0x7)));
}
inline const char* ios_content_info_t::crt_count(unsigned int* size) const{
return _m_crt_count.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_crt_count(const char* s,ssize_t size){
_flag[21 >> 3] |= (1 << (21 & 0x7));
 _m_crt_count.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_crt_count(const char* s,ssize_t size){
_flag[21 >> 3] |= (1 << (21 & 0x7));
 _m_crt_count.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_crt_count(){
_flag[21 >> 3] &= ~(1 << (21 & 0x7));
 _m_crt_count.clear();
}
inline bool ios_content_info_t::has_language() const{
return (_flag[22 >> 3] & (1 << (22 & 0x7)));
}
inline const char* ios_content_info_t::language(unsigned int* size) const{
return _m_language.get(size);
}
inline ios_content_info_t& ios_content_info_t::set_language(const char* s,ssize_t size){
_flag[22 >> 3] |= (1 << (22 & 0x7));
 _m_language.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_language(const char* s,ssize_t size){
_flag[22 >> 3] |= (1 << (22 & 0x7));
 _m_language.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void ios_content_info_t::clear_language(){
_flag[22 >> 3] &= ~(1 << (22 & 0x7));
 _m_language.clear();
}
inline bool ios_content_info_t::has_img_list() const{
return (_flag[23 >> 3] & (1 << (23 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& ios_content_info_t::img_list() const{
 return _m_img_list;
}
inline void ios_content_info_t::clear_img_list(){
_flag[23 >> 3] &= ~(1 << (23 & 0x7));
 _m_img_list.clear();
}
inline ::idl::vector< ::idl::string >* ios_content_info_t::mutable_img_list(){
_flag[23 >> 3] |= (1 << (23 & 0x7));
 return &(_m_img_list);
}
inline ::idl::vector< ::idl::string >* ios_content_info_t::m_img_list(){
_flag[23 >> 3] |= (1 << (23 & 0x7));
 return &(_m_img_list);
}
inline size_t ios_content_info_t::img_list_size() const{
/*  */ return _m_img_list.size();
}
inline const char* ios_content_info_t::img_list(size_t i0,unsigned int* size) const{
 return _m_img_list.get(i0).get(size);
}
inline ios_content_info_t& ios_content_info_t::set_img_list(size_t i0,const char* s,ssize_t size){
_flag[23 >> 3] |= (1 << (23 & 0x7));
 _m_img_list.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline ios_content_info_t& ios_content_info_t::set_ptr_img_list(size_t i0,const char* s,ssize_t size){
_flag[23 >> 3] |= (1 << (23 & 0x7));
 _m_img_list.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool ios_content_info_t::has_class_info() const{
return (_flag[24 >> 3] & (1 << (24 & 0x7)));
}
inline const ::idl::vector< ::idl::class_info_t >& ios_content_info_t::class_info() const{
 return _m_class_info;
}
inline void ios_content_info_t::clear_class_info(){
_flag[24 >> 3] &= ~(1 << (24 & 0x7));
 _m_class_info.clear();
}
inline ::idl::vector< ::idl::class_info_t >* ios_content_info_t::mutable_class_info(){
_flag[24 >> 3] |= (1 << (24 & 0x7));
 return &(_m_class_info);
}
inline ::idl::vector< ::idl::class_info_t >* ios_content_info_t::m_class_info(){
_flag[24 >> 3] |= (1 << (24 & 0x7));
 return &(_m_class_info);
}
inline size_t ios_content_info_t::class_info_size() const{
/*  */ return _m_class_info.size();
}
inline const ::idl::class_info_t& ios_content_info_t::class_info(size_t i0) const{
 return _m_class_info.get(i0);
}
inline ::idl::class_info_t* ios_content_info_t::mutable_class_info(size_t i0){
_flag[24 >> 3] |= (1 << (24 & 0x7));
 return _m_class_info.mutable_get(i0);
}
inline ::idl::class_info_t* ios_content_info_t::m_class_info(size_t i0){
_flag[24 >> 3] |= (1 << (24 & 0x7));
 return _m_class_info.mutable_get(i0);
}
inline ::idl::Unknown* ios_content_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& ios_content_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& ios_content_info_t::unknown(){
return _unknown;
}
inline size_t ios_content_info_t::unknown_size() const{
return _unknown.size();
}
inline game_brief_info_t* game_brief_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
game_brief_info_t* tmp=(game_brief_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)game_brief_info_t(pool);
return tmp;
}
inline void game_brief_info_t::destroy(game_brief_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~game_brief_info_t();
pool->free(v,sizeof(*v));
}
}
inline game_brief_info_t::game_brief_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_type(_pool)
,_m_info_id(_pool)
,_m_info_title(_pool)
,_m_info_datetime(_pool)
,_m_type_name(_pool)
,_m_game_type(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline game_brief_info_t::game_brief_info_t(const game_brief_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_type(_pool)
,_m_info_id(_pool)
,_m_info_title(_pool)
,_m_info_datetime(_pool)
,_m_type_name(_pool)
,_m_game_type(_pool)
,_unknown(_pool){
assign(v);
}
inline game_brief_info_t::~game_brief_info_t(){
}
inline game_brief_info_t& game_brief_info_t::operator=(const game_brief_info_t& v){
assign(v);
return *this;
}
inline void game_brief_info_t::clear(){
_m_info_type.clear();
_m_info_id.clear();
_m_info_title.clear();
_m_info_datetime.clear();
_m_type_name.clear();
_m_game_type.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void game_brief_info_t::check() const{
// @@string info_type;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_type.get();

}
// @@string info_id;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@string info_title;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_title" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_title.get();

}
// @@string info_datetime;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_datetime" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_datetime.get();

}
// @@string type_name;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_name.get();

}
// @@string game_type;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_type.get();

}

::idl::McpackBean::check();
}
inline void game_brief_info_t::detach(){
_m_info_type.detach();
_m_info_id.detach();
_m_info_title.detach();
_m_info_datetime.detach();
_m_type_name.detach();
_m_game_type.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline game_brief_info_t& game_brief_info_t::assign(const game_brief_info_t& v){
_m_info_type=v._m_info_type;
_m_info_id=v._m_info_id;
_m_info_title=v._m_info_title;
_m_info_datetime=v._m_info_datetime;
_m_type_name=v._m_type_name;
_m_game_type=v._m_game_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool game_brief_info_t::has_info_type() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* game_brief_info_t::info_type(unsigned int* size) const{
return _m_info_type.get(size);
}
inline game_brief_info_t& game_brief_info_t::set_info_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_brief_info_t& game_brief_info_t::set_ptr_info_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_brief_info_t::clear_info_type(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_type.clear();
}
inline bool game_brief_info_t::has_info_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* game_brief_info_t::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline game_brief_info_t& game_brief_info_t::set_info_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_brief_info_t& game_brief_info_t::set_ptr_info_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_brief_info_t::clear_info_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_id.clear();
}
inline bool game_brief_info_t::has_info_title() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* game_brief_info_t::info_title(unsigned int* size) const{
return _m_info_title.get(size);
}
inline game_brief_info_t& game_brief_info_t::set_info_title(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_title.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_brief_info_t& game_brief_info_t::set_ptr_info_title(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_title.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_brief_info_t::clear_info_title(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_title.clear();
}
inline bool game_brief_info_t::has_info_datetime() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* game_brief_info_t::info_datetime(unsigned int* size) const{
return _m_info_datetime.get(size);
}
inline game_brief_info_t& game_brief_info_t::set_info_datetime(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_datetime.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_brief_info_t& game_brief_info_t::set_ptr_info_datetime(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_datetime.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_brief_info_t::clear_info_datetime(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_info_datetime.clear();
}
inline bool game_brief_info_t::has_type_name() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* game_brief_info_t::type_name(unsigned int* size) const{
return _m_type_name.get(size);
}
inline game_brief_info_t& game_brief_info_t::set_type_name(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_type_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_brief_info_t& game_brief_info_t::set_ptr_type_name(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_type_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_brief_info_t::clear_type_name(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_type_name.clear();
}
inline bool game_brief_info_t::has_game_type() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* game_brief_info_t::game_type(unsigned int* size) const{
return _m_game_type.get(size);
}
inline game_brief_info_t& game_brief_info_t::set_game_type(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_game_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_brief_info_t& game_brief_info_t::set_ptr_game_type(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_game_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_brief_info_t::clear_game_type(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_game_type.clear();
}
inline ::idl::Unknown* game_brief_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& game_brief_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& game_brief_info_t::unknown(){
return _unknown;
}
inline size_t game_brief_info_t::unknown_size() const{
return _unknown.size();
}
inline game_info_t* game_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
game_info_t* tmp=(game_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)game_info_t(pool);
return tmp;
}
inline void game_info_t::destroy(game_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~game_info_t();
pool->free(v,sizeof(*v));
}
}
inline game_info_t::game_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_type(_pool)
,_m_info_id(_pool)
,_m_c_id(_pool)
,_m_info_title(_pool)
,_m_info_content(_pool)
,_m_info_date(_pool)
,_m_type_name(_pool)
,_m_game_type(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline game_info_t::game_info_t(const game_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_type(_pool)
,_m_info_id(_pool)
,_m_c_id(_pool)
,_m_info_title(_pool)
,_m_info_content(_pool)
,_m_info_date(_pool)
,_m_type_name(_pool)
,_m_game_type(_pool)
,_unknown(_pool){
assign(v);
}
inline game_info_t::~game_info_t(){
}
inline game_info_t& game_info_t::operator=(const game_info_t& v){
assign(v);
return *this;
}
inline void game_info_t::clear(){
_m_info_type.clear();
_m_info_id.clear();
_m_c_id.clear();
_m_info_title.clear();
_m_info_content.clear();
_m_info_date.clear();
_m_type_name.clear();
_m_game_type.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void game_info_t::check() const{
// @@string info_type;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_type.get();

}
// @@string info_id;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@string c_id;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string info_title;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_title" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_title.get();

}
// @@string info_content;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_content" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_content.get();

}
// @@string info_date;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_date.get();

}
// @@string type_name;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_name.get();

}
// @@string game_type;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_type.get();

}

::idl::McpackBean::check();
}
inline void game_info_t::detach(){
_m_info_type.detach();
_m_info_id.detach();
_m_c_id.detach();
_m_info_title.detach();
_m_info_content.detach();
_m_info_date.detach();
_m_type_name.detach();
_m_game_type.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline game_info_t& game_info_t::assign(const game_info_t& v){
_m_info_type=v._m_info_type;
_m_info_id=v._m_info_id;
_m_c_id=v._m_c_id;
_m_info_title=v._m_info_title;
_m_info_content=v._m_info_content;
_m_info_date=v._m_info_date;
_m_type_name=v._m_type_name;
_m_game_type=v._m_game_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool game_info_t::has_info_type() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* game_info_t::info_type(unsigned int* size) const{
return _m_info_type.get(size);
}
inline game_info_t& game_info_t::set_info_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t& game_info_t::set_ptr_info_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t::clear_info_type(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_type.clear();
}
inline bool game_info_t::has_info_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* game_info_t::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline game_info_t& game_info_t::set_info_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t& game_info_t::set_ptr_info_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t::clear_info_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_id.clear();
}
inline bool game_info_t::has_c_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* game_info_t::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline game_info_t& game_info_t::set_c_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t& game_info_t::set_ptr_c_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t::clear_c_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_c_id.clear();
}
inline bool game_info_t::has_info_title() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* game_info_t::info_title(unsigned int* size) const{
return _m_info_title.get(size);
}
inline game_info_t& game_info_t::set_info_title(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_title.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t& game_info_t::set_ptr_info_title(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_title.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t::clear_info_title(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_info_title.clear();
}
inline bool game_info_t::has_info_content() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* game_info_t::info_content(unsigned int* size) const{
return _m_info_content.get(size);
}
inline game_info_t& game_info_t::set_info_content(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_info_content.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t& game_info_t::set_ptr_info_content(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_info_content.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t::clear_info_content(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_info_content.clear();
}
inline bool game_info_t::has_info_date() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* game_info_t::info_date(unsigned int* size) const{
return _m_info_date.get(size);
}
inline game_info_t& game_info_t::set_info_date(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_info_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t& game_info_t::set_ptr_info_date(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_info_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t::clear_info_date(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_info_date.clear();
}
inline bool game_info_t::has_type_name() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* game_info_t::type_name(unsigned int* size) const{
return _m_type_name.get(size);
}
inline game_info_t& game_info_t::set_type_name(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_type_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t& game_info_t::set_ptr_type_name(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_type_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t::clear_type_name(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_type_name.clear();
}
inline bool game_info_t::has_game_type() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* game_info_t::game_type(unsigned int* size) const{
return _m_game_type.get(size);
}
inline game_info_t& game_info_t::set_game_type(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_game_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t& game_info_t::set_ptr_game_type(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_game_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t::clear_game_type(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_game_type.clear();
}
inline ::idl::Unknown* game_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& game_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& game_info_t::unknown(){
return _unknown;
}
inline size_t game_info_t::unknown_size() const{
return _unknown.size();
}
inline pub_prop_info_t* pub_prop_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
pub_prop_info_t* tmp=(pub_prop_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)pub_prop_info_t(pool);
return tmp;
}
inline void pub_prop_info_t::destroy(pub_prop_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~pub_prop_info_t();
pool->free(v,sizeof(*v));
}
}
inline pub_prop_info_t::pub_prop_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_prop_url(_pool)
,_m_name(_pool)
,_m_color(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline pub_prop_info_t::pub_prop_info_t(const pub_prop_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_prop_url(_pool)
,_m_name(_pool)
,_m_color(_pool)
,_unknown(_pool){
assign(v);
}
inline pub_prop_info_t::~pub_prop_info_t(){
}
inline pub_prop_info_t& pub_prop_info_t::operator=(const pub_prop_info_t& v){
assign(v);
return *this;
}
inline void pub_prop_info_t::clear(){
_m_prop_url.clear();
_m_name.clear();
_m_color.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void pub_prop_info_t::check() const{
// @@string prop_url;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "prop_url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_prop_url.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string color;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "color" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_color.get();

}

::idl::McpackBean::check();
}
inline void pub_prop_info_t::detach(){
_m_prop_url.detach();
_m_name.detach();
_m_color.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline pub_prop_info_t& pub_prop_info_t::assign(const pub_prop_info_t& v){
_m_prop_url=v._m_prop_url;
_m_name=v._m_name;
_m_color=v._m_color;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool pub_prop_info_t::has_prop_url() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* pub_prop_info_t::prop_url(unsigned int* size) const{
return _m_prop_url.get(size);
}
inline pub_prop_info_t& pub_prop_info_t::set_prop_url(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_prop_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline pub_prop_info_t& pub_prop_info_t::set_ptr_prop_url(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_prop_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void pub_prop_info_t::clear_prop_url(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_prop_url.clear();
}
inline bool pub_prop_info_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* pub_prop_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline pub_prop_info_t& pub_prop_info_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline pub_prop_info_t& pub_prop_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void pub_prop_info_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool pub_prop_info_t::has_color() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* pub_prop_info_t::color(unsigned int* size) const{
return _m_color.get(size);
}
inline pub_prop_info_t& pub_prop_info_t::set_color(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_color.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline pub_prop_info_t& pub_prop_info_t::set_ptr_color(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_color.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void pub_prop_info_t::clear_color(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_color.clear();
}
inline ::idl::Unknown* pub_prop_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& pub_prop_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& pub_prop_info_t::unknown(){
return _unknown;
}
inline size_t pub_prop_info_t::unknown_size() const{
return _unknown.size();
}
inline game_info_t_hall* game_info_t_hall::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
game_info_t_hall* tmp=(game_info_t_hall*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)game_info_t_hall(pool);
return tmp;
}
inline void game_info_t_hall::destroy(game_info_t_hall* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~game_info_t_hall();
pool->free(v,sizeof(*v));
}
}
inline game_info_t_hall::game_info_t_hall(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_type(_pool)
,_m_info_id(_pool)
,_m_c_id(_pool)
,_m_info_title(_pool)
,_m_info_content(_pool)
,_m_info_date(_pool)
,_m_type_name(_pool)
,_m_game_type(_pool)
,_m_news_source(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline game_info_t_hall::game_info_t_hall(const game_info_t_hall& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_type(_pool)
,_m_info_id(_pool)
,_m_c_id(_pool)
,_m_info_title(_pool)
,_m_info_content(_pool)
,_m_info_date(_pool)
,_m_type_name(_pool)
,_m_game_type(_pool)
,_m_news_source(_pool)
,_unknown(_pool){
assign(v);
}
inline game_info_t_hall::~game_info_t_hall(){
}
inline game_info_t_hall& game_info_t_hall::operator=(const game_info_t_hall& v){
assign(v);
return *this;
}
inline void game_info_t_hall::clear(){
_m_info_type.clear();
_m_info_id.clear();
_m_c_id.clear();
_m_info_title.clear();
_m_info_content.clear();
_m_info_date.clear();
_m_type_name.clear();
_m_game_type.clear();
_m_news_source.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void game_info_t_hall::check() const{
// @@string info_type;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_type.get();

}
// @@string info_id;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@string c_id;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string info_title;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_title" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_title.get();

}
// @@string info_content;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_content" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_content.get();

}
// @@string info_date;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_date.get();

}
// @@string type_name;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_name.get();

}
// @@string game_type;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_type.get();

}
// @@string news_source;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "news_source" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_news_source.get();

}

::idl::McpackBean::check();
}
inline void game_info_t_hall::detach(){
_m_info_type.detach();
_m_info_id.detach();
_m_c_id.detach();
_m_info_title.detach();
_m_info_content.detach();
_m_info_date.detach();
_m_type_name.detach();
_m_game_type.detach();
_m_news_source.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline game_info_t_hall& game_info_t_hall::assign(const game_info_t_hall& v){
_m_info_type=v._m_info_type;
_m_info_id=v._m_info_id;
_m_c_id=v._m_c_id;
_m_info_title=v._m_info_title;
_m_info_content=v._m_info_content;
_m_info_date=v._m_info_date;
_m_type_name=v._m_type_name;
_m_game_type=v._m_game_type;
_m_news_source=v._m_news_source;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool game_info_t_hall::has_info_type() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* game_info_t_hall::info_type(unsigned int* size) const{
return _m_info_type.get(size);
}
inline game_info_t_hall& game_info_t_hall::set_info_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t_hall& game_info_t_hall::set_ptr_info_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t_hall::clear_info_type(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_type.clear();
}
inline bool game_info_t_hall::has_info_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* game_info_t_hall::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline game_info_t_hall& game_info_t_hall::set_info_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t_hall& game_info_t_hall::set_ptr_info_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t_hall::clear_info_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_id.clear();
}
inline bool game_info_t_hall::has_c_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* game_info_t_hall::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline game_info_t_hall& game_info_t_hall::set_c_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t_hall& game_info_t_hall::set_ptr_c_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t_hall::clear_c_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_c_id.clear();
}
inline bool game_info_t_hall::has_info_title() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* game_info_t_hall::info_title(unsigned int* size) const{
return _m_info_title.get(size);
}
inline game_info_t_hall& game_info_t_hall::set_info_title(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_title.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t_hall& game_info_t_hall::set_ptr_info_title(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_title.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t_hall::clear_info_title(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_info_title.clear();
}
inline bool game_info_t_hall::has_info_content() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* game_info_t_hall::info_content(unsigned int* size) const{
return _m_info_content.get(size);
}
inline game_info_t_hall& game_info_t_hall::set_info_content(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_info_content.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t_hall& game_info_t_hall::set_ptr_info_content(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_info_content.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t_hall::clear_info_content(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_info_content.clear();
}
inline bool game_info_t_hall::has_info_date() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* game_info_t_hall::info_date(unsigned int* size) const{
return _m_info_date.get(size);
}
inline game_info_t_hall& game_info_t_hall::set_info_date(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_info_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t_hall& game_info_t_hall::set_ptr_info_date(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_info_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t_hall::clear_info_date(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_info_date.clear();
}
inline bool game_info_t_hall::has_type_name() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* game_info_t_hall::type_name(unsigned int* size) const{
return _m_type_name.get(size);
}
inline game_info_t_hall& game_info_t_hall::set_type_name(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_type_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t_hall& game_info_t_hall::set_ptr_type_name(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_type_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t_hall::clear_type_name(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_type_name.clear();
}
inline bool game_info_t_hall::has_game_type() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* game_info_t_hall::game_type(unsigned int* size) const{
return _m_game_type.get(size);
}
inline game_info_t_hall& game_info_t_hall::set_game_type(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_game_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t_hall& game_info_t_hall::set_ptr_game_type(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_game_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t_hall::clear_game_type(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_game_type.clear();
}
inline bool game_info_t_hall::has_news_source() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* game_info_t_hall::news_source(unsigned int* size) const{
return _m_news_source.get(size);
}
inline game_info_t_hall& game_info_t_hall::set_news_source(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_news_source.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_info_t_hall& game_info_t_hall::set_ptr_news_source(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_news_source.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_info_t_hall::clear_news_source(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_news_source.clear();
}
inline ::idl::Unknown* game_info_t_hall::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& game_info_t_hall::unknown() const{
return _unknown;
}
inline ::idl::Unknown& game_info_t_hall::unknown(){
return _unknown;
}
inline size_t game_info_t_hall::unknown_size() const{
return _unknown.size();
}
inline online_game_info_t* online_game_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
online_game_info_t* tmp=(online_game_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)online_game_info_t(pool);
return tmp;
}
inline void online_game_info_t::destroy(online_game_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~online_game_info_t();
pool->free(v,sizeof(*v));
}
}
inline online_game_info_t::online_game_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_icon(_pool)
,_m_thumb(_pool)
,_m_type(_pool)
,_m_info(_pool)
,_m_version(_pool)
,_m_system_req(_pool)
,_m_cp_id(_pool)
,_m_cp_name(_pool)
,_m_star(_pool)
,_m_popularity(_pool)
,_m_language(_pool)
,_m_gdate(_pool)
,_m_mdate(_pool)
,_m_ldate(_pool)
,_m_url(_pool)
,_m_size(_pool)
,_m_label_list(_pool)
,_m_img_list(_pool)
,_m_apk_flag(_pool)
,_m_editor_recom(_pool)
,_m_class_info(_pool)
,_m_attribute_list(_pool)
,_m_pub_prop_ids(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline online_game_info_t::online_game_info_t(const online_game_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_icon(_pool)
,_m_thumb(_pool)
,_m_type(_pool)
,_m_info(_pool)
,_m_version(_pool)
,_m_system_req(_pool)
,_m_cp_id(_pool)
,_m_cp_name(_pool)
,_m_star(_pool)
,_m_popularity(_pool)
,_m_language(_pool)
,_m_gdate(_pool)
,_m_mdate(_pool)
,_m_ldate(_pool)
,_m_url(_pool)
,_m_size(_pool)
,_m_label_list(_pool)
,_m_img_list(_pool)
,_m_apk_flag(_pool)
,_m_editor_recom(_pool)
,_m_class_info(_pool)
,_m_attribute_list(_pool)
,_m_pub_prop_ids(_pool)
,_unknown(_pool){
assign(v);
}
inline online_game_info_t::~online_game_info_t(){
}
inline online_game_info_t& online_game_info_t::operator=(const online_game_info_t& v){
assign(v);
return *this;
}
inline void online_game_info_t::clear(){
_m_id.clear();
_m_name.clear();
_m_icon.clear();
_m_thumb.clear();
_m_type.clear();
_m_info.clear();
_m_version.clear();
_m_system_req.clear();
_m_cp_id.clear();
_m_cp_name.clear();
_m_star.clear();
_m_popularity.clear();
_m_language.clear();
_m_gdate.clear();
_m_mdate.clear();
_m_ldate.clear();
_m_url.clear();
_m_size.clear();
_m_label_list.clear();
_m_img_list.clear();
_m_apk_flag.clear();
_m_editor_recom.clear();
_m_class_info.clear();
_m_attribute_list.clear();
_m_pub_prop_ids.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void online_game_info_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string icon;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "icon" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_icon.get();

}
// @@string thumb;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "thumb" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_thumb.get();

}
// @@string type;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type.get();

}
// @@string info;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info.get();

}
// @@string version;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "version" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_version.get();

}
// @@string system_req;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "system_req" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_system_req.get();

}
// @@string cp_id;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cp_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_cp_id.get();

}
// @@string cp_name;
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cp_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_cp_name.get();

}
// @@string star;
if(!(_flag[10 >> 3] & (1 << (10 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "star" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_star.get();

}
// @@string popularity;
if(!(_flag[11 >> 3] & (1 << (11 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "popularity" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_popularity.get();

}
// @@string language;
if(!(_flag[12 >> 3] & (1 << (12 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "language" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_language.get();

}
// @@string gdate;
if(!(_flag[13 >> 3] & (1 << (13 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "gdate" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_gdate.get();

}
// @@string mdate;
if(!(_flag[14 >> 3] & (1 << (14 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "mdate" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_mdate.get();

}
// @@string ldate;
if(!(_flag[15 >> 3] & (1 << (15 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ldate" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ldate.get();

}
// @@string url;
if(!(_flag[16 >> 3] & (1 << (16 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_url.get();

}
// @@string size;
if(!(_flag[17 >> 3] & (1 << (17 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "size" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_size.get();

}
// @@string label_list=array(0);
if(!(_flag[18 >> 3] & (1 << (18 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "label_list" << "' not found";
}
{
// level 0 begin
typeof(_m_label_list)& lr0=(_m_label_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@string img_list=array(0);
if(!(_flag[19 >> 3] & (1 << (19 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "img_list" << "' not found";
}
{
// level 0 begin
typeof(_m_img_list)& lr0=(_m_img_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@string apk_flag;
if(!(_flag[20 >> 3] & (1 << (20 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "apk_flag" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_apk_flag.get();

}
// @@string editor_recom;
if(!(_flag[21 >> 3] & (1 << (21 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "editor_recom" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_editor_recom.get();

}
// @@class_info_t class_info=array(0);
if(!(_flag[22 >> 3] & (1 << (22 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_info" << "' not found";
}
{
// level 0 begin
typeof(_m_class_info)& lr0=(_m_class_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::class_info_t& item=const_cast< ::idl::class_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@attribute_info_t attribute_list=array(0);
if(!(_flag[23 >> 3] & (1 << (23 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "attribute_list" << "' not found";
}
{
// level 0 begin
typeof(_m_attribute_list)& lr0=(_m_attribute_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::attribute_info_t& item=const_cast< ::idl::attribute_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@string pub_prop_ids;
if(!(_flag[24 >> 3] & (1 << (24 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "pub_prop_ids" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_pub_prop_ids.get();

}

::idl::McpackBean::check();
}
inline void online_game_info_t::detach(){
_m_id.detach();
_m_name.detach();
_m_icon.detach();
_m_thumb.detach();
_m_type.detach();
_m_info.detach();
_m_version.detach();
_m_system_req.detach();
_m_cp_id.detach();
_m_cp_name.detach();
_m_star.detach();
_m_popularity.detach();
_m_language.detach();
_m_gdate.detach();
_m_mdate.detach();
_m_ldate.detach();
_m_url.detach();
_m_size.detach();
_m_label_list.detach();
_m_img_list.detach();
_m_apk_flag.detach();
_m_editor_recom.detach();
_m_class_info.detach();
_m_attribute_list.detach();
_m_pub_prop_ids.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline online_game_info_t& online_game_info_t::assign(const online_game_info_t& v){
_m_id=v._m_id;
_m_name=v._m_name;
_m_icon=v._m_icon;
_m_thumb=v._m_thumb;
_m_type=v._m_type;
_m_info=v._m_info;
_m_version=v._m_version;
_m_system_req=v._m_system_req;
_m_cp_id=v._m_cp_id;
_m_cp_name=v._m_cp_name;
_m_star=v._m_star;
_m_popularity=v._m_popularity;
_m_language=v._m_language;
_m_gdate=v._m_gdate;
_m_mdate=v._m_mdate;
_m_ldate=v._m_ldate;
_m_url=v._m_url;
_m_size=v._m_size;
_m_label_list=v._m_label_list;
_m_img_list=v._m_img_list;
_m_apk_flag=v._m_apk_flag;
_m_editor_recom=v._m_editor_recom;
_m_class_info=v._m_class_info;
_m_attribute_list=v._m_attribute_list;
_m_pub_prop_ids=v._m_pub_prop_ids;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool online_game_info_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* online_game_info_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline online_game_info_t& online_game_info_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool online_game_info_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* online_game_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline online_game_info_t& online_game_info_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool online_game_info_t::has_icon() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* online_game_info_t::icon(unsigned int* size) const{
return _m_icon.get(size);
}
inline online_game_info_t& online_game_info_t::set_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_icon.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_icon.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_icon(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_icon.clear();
}
inline bool online_game_info_t::has_thumb() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* online_game_info_t::thumb(unsigned int* size) const{
return _m_thumb.get(size);
}
inline online_game_info_t& online_game_info_t::set_thumb(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_thumb.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_thumb(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_thumb.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_thumb(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_thumb.clear();
}
inline bool online_game_info_t::has_type() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* online_game_info_t::type(unsigned int* size) const{
return _m_type.get(size);
}
inline online_game_info_t& online_game_info_t::set_type(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_type(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_type(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_type.clear();
}
inline bool online_game_info_t::has_info() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* online_game_info_t::info(unsigned int* size) const{
return _m_info.get(size);
}
inline online_game_info_t& online_game_info_t::set_info(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_info(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_info(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_info.clear();
}
inline bool online_game_info_t::has_version() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* online_game_info_t::version(unsigned int* size) const{
return _m_version.get(size);
}
inline online_game_info_t& online_game_info_t::set_version(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_version.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_version(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_version.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_version(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_version.clear();
}
inline bool online_game_info_t::has_system_req() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* online_game_info_t::system_req(unsigned int* size) const{
return _m_system_req.get(size);
}
inline online_game_info_t& online_game_info_t::set_system_req(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_system_req.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_system_req(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_system_req.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_system_req(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_system_req.clear();
}
inline bool online_game_info_t::has_cp_id() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* online_game_info_t::cp_id(unsigned int* size) const{
return _m_cp_id.get(size);
}
inline online_game_info_t& online_game_info_t::set_cp_id(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_cp_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_cp_id(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_cp_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_cp_id(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_cp_id.clear();
}
inline bool online_game_info_t::has_cp_name() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline const char* online_game_info_t::cp_name(unsigned int* size) const{
return _m_cp_name.get(size);
}
inline online_game_info_t& online_game_info_t::set_cp_name(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_cp_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_cp_name(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_cp_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_cp_name(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_cp_name.clear();
}
inline bool online_game_info_t::has_star() const{
return (_flag[10 >> 3] & (1 << (10 & 0x7)));
}
inline const char* online_game_info_t::star(unsigned int* size) const{
return _m_star.get(size);
}
inline online_game_info_t& online_game_info_t::set_star(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_star.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_star(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_star.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_star(){
_flag[10 >> 3] &= ~(1 << (10 & 0x7));
 _m_star.clear();
}
inline bool online_game_info_t::has_popularity() const{
return (_flag[11 >> 3] & (1 << (11 & 0x7)));
}
inline const char* online_game_info_t::popularity(unsigned int* size) const{
return _m_popularity.get(size);
}
inline online_game_info_t& online_game_info_t::set_popularity(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_popularity.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_popularity(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_popularity.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_popularity(){
_flag[11 >> 3] &= ~(1 << (11 & 0x7));
 _m_popularity.clear();
}
inline bool online_game_info_t::has_language() const{
return (_flag[12 >> 3] & (1 << (12 & 0x7)));
}
inline const char* online_game_info_t::language(unsigned int* size) const{
return _m_language.get(size);
}
inline online_game_info_t& online_game_info_t::set_language(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_language.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_language(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_language.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_language(){
_flag[12 >> 3] &= ~(1 << (12 & 0x7));
 _m_language.clear();
}
inline bool online_game_info_t::has_gdate() const{
return (_flag[13 >> 3] & (1 << (13 & 0x7)));
}
inline const char* online_game_info_t::gdate(unsigned int* size) const{
return _m_gdate.get(size);
}
inline online_game_info_t& online_game_info_t::set_gdate(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_gdate.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_gdate(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_gdate.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_gdate(){
_flag[13 >> 3] &= ~(1 << (13 & 0x7));
 _m_gdate.clear();
}
inline bool online_game_info_t::has_mdate() const{
return (_flag[14 >> 3] & (1 << (14 & 0x7)));
}
inline const char* online_game_info_t::mdate(unsigned int* size) const{
return _m_mdate.get(size);
}
inline online_game_info_t& online_game_info_t::set_mdate(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_mdate.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_mdate(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_mdate.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_mdate(){
_flag[14 >> 3] &= ~(1 << (14 & 0x7));
 _m_mdate.clear();
}
inline bool online_game_info_t::has_ldate() const{
return (_flag[15 >> 3] & (1 << (15 & 0x7)));
}
inline const char* online_game_info_t::ldate(unsigned int* size) const{
return _m_ldate.get(size);
}
inline online_game_info_t& online_game_info_t::set_ldate(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_ldate.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_ldate(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_ldate.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_ldate(){
_flag[15 >> 3] &= ~(1 << (15 & 0x7));
 _m_ldate.clear();
}
inline bool online_game_info_t::has_url() const{
return (_flag[16 >> 3] & (1 << (16 & 0x7)));
}
inline const char* online_game_info_t::url(unsigned int* size) const{
return _m_url.get(size);
}
inline online_game_info_t& online_game_info_t::set_url(const char* s,ssize_t size){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 _m_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_url(const char* s,ssize_t size){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 _m_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_url(){
_flag[16 >> 3] &= ~(1 << (16 & 0x7));
 _m_url.clear();
}
inline bool online_game_info_t::has_size() const{
return (_flag[17 >> 3] & (1 << (17 & 0x7)));
}
inline const char* online_game_info_t::size(unsigned int* size) const{
return _m_size.get(size);
}
inline online_game_info_t& online_game_info_t::set_size(const char* s,ssize_t size){
_flag[17 >> 3] |= (1 << (17 & 0x7));
 _m_size.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_size(const char* s,ssize_t size){
_flag[17 >> 3] |= (1 << (17 & 0x7));
 _m_size.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_size(){
_flag[17 >> 3] &= ~(1 << (17 & 0x7));
 _m_size.clear();
}
inline bool online_game_info_t::has_label_list() const{
return (_flag[18 >> 3] & (1 << (18 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& online_game_info_t::label_list() const{
 return _m_label_list;
}
inline void online_game_info_t::clear_label_list(){
_flag[18 >> 3] &= ~(1 << (18 & 0x7));
 _m_label_list.clear();
}
inline ::idl::vector< ::idl::string >* online_game_info_t::mutable_label_list(){
_flag[18 >> 3] |= (1 << (18 & 0x7));
 return &(_m_label_list);
}
inline ::idl::vector< ::idl::string >* online_game_info_t::m_label_list(){
_flag[18 >> 3] |= (1 << (18 & 0x7));
 return &(_m_label_list);
}
inline size_t online_game_info_t::label_list_size() const{
/*  */ return _m_label_list.size();
}
inline const char* online_game_info_t::label_list(size_t i0,unsigned int* size) const{
 return _m_label_list.get(i0).get(size);
}
inline online_game_info_t& online_game_info_t::set_label_list(size_t i0,const char* s,ssize_t size){
_flag[18 >> 3] |= (1 << (18 & 0x7));
 _m_label_list.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_label_list(size_t i0,const char* s,ssize_t size){
_flag[18 >> 3] |= (1 << (18 & 0x7));
 _m_label_list.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool online_game_info_t::has_img_list() const{
return (_flag[19 >> 3] & (1 << (19 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& online_game_info_t::img_list() const{
 return _m_img_list;
}
inline void online_game_info_t::clear_img_list(){
_flag[19 >> 3] &= ~(1 << (19 & 0x7));
 _m_img_list.clear();
}
inline ::idl::vector< ::idl::string >* online_game_info_t::mutable_img_list(){
_flag[19 >> 3] |= (1 << (19 & 0x7));
 return &(_m_img_list);
}
inline ::idl::vector< ::idl::string >* online_game_info_t::m_img_list(){
_flag[19 >> 3] |= (1 << (19 & 0x7));
 return &(_m_img_list);
}
inline size_t online_game_info_t::img_list_size() const{
/*  */ return _m_img_list.size();
}
inline const char* online_game_info_t::img_list(size_t i0,unsigned int* size) const{
 return _m_img_list.get(i0).get(size);
}
inline online_game_info_t& online_game_info_t::set_img_list(size_t i0,const char* s,ssize_t size){
_flag[19 >> 3] |= (1 << (19 & 0x7));
 _m_img_list.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_img_list(size_t i0,const char* s,ssize_t size){
_flag[19 >> 3] |= (1 << (19 & 0x7));
 _m_img_list.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool online_game_info_t::has_apk_flag() const{
return (_flag[20 >> 3] & (1 << (20 & 0x7)));
}
inline const char* online_game_info_t::apk_flag(unsigned int* size) const{
return _m_apk_flag.get(size);
}
inline online_game_info_t& online_game_info_t::set_apk_flag(const char* s,ssize_t size){
_flag[20 >> 3] |= (1 << (20 & 0x7));
 _m_apk_flag.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_apk_flag(const char* s,ssize_t size){
_flag[20 >> 3] |= (1 << (20 & 0x7));
 _m_apk_flag.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_apk_flag(){
_flag[20 >> 3] &= ~(1 << (20 & 0x7));
 _m_apk_flag.clear();
}
inline bool online_game_info_t::has_editor_recom() const{
return (_flag[21 >> 3] & (1 << (21 & 0x7)));
}
inline const char* online_game_info_t::editor_recom(unsigned int* size) const{
return _m_editor_recom.get(size);
}
inline online_game_info_t& online_game_info_t::set_editor_recom(const char* s,ssize_t size){
_flag[21 >> 3] |= (1 << (21 & 0x7));
 _m_editor_recom.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_editor_recom(const char* s,ssize_t size){
_flag[21 >> 3] |= (1 << (21 & 0x7));
 _m_editor_recom.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_editor_recom(){
_flag[21 >> 3] &= ~(1 << (21 & 0x7));
 _m_editor_recom.clear();
}
inline bool online_game_info_t::has_class_info() const{
return (_flag[22 >> 3] & (1 << (22 & 0x7)));
}
inline const ::idl::vector< ::idl::class_info_t >& online_game_info_t::class_info() const{
 return _m_class_info;
}
inline void online_game_info_t::clear_class_info(){
_flag[22 >> 3] &= ~(1 << (22 & 0x7));
 _m_class_info.clear();
}
inline ::idl::vector< ::idl::class_info_t >* online_game_info_t::mutable_class_info(){
_flag[22 >> 3] |= (1 << (22 & 0x7));
 return &(_m_class_info);
}
inline ::idl::vector< ::idl::class_info_t >* online_game_info_t::m_class_info(){
_flag[22 >> 3] |= (1 << (22 & 0x7));
 return &(_m_class_info);
}
inline size_t online_game_info_t::class_info_size() const{
/*  */ return _m_class_info.size();
}
inline const ::idl::class_info_t& online_game_info_t::class_info(size_t i0) const{
 return _m_class_info.get(i0);
}
inline ::idl::class_info_t* online_game_info_t::mutable_class_info(size_t i0){
_flag[22 >> 3] |= (1 << (22 & 0x7));
 return _m_class_info.mutable_get(i0);
}
inline ::idl::class_info_t* online_game_info_t::m_class_info(size_t i0){
_flag[22 >> 3] |= (1 << (22 & 0x7));
 return _m_class_info.mutable_get(i0);
}
inline bool online_game_info_t::has_attribute_list() const{
return (_flag[23 >> 3] & (1 << (23 & 0x7)));
}
inline const ::idl::vector< ::idl::attribute_info_t >& online_game_info_t::attribute_list() const{
 return _m_attribute_list;
}
inline void online_game_info_t::clear_attribute_list(){
_flag[23 >> 3] &= ~(1 << (23 & 0x7));
 _m_attribute_list.clear();
}
inline ::idl::vector< ::idl::attribute_info_t >* online_game_info_t::mutable_attribute_list(){
_flag[23 >> 3] |= (1 << (23 & 0x7));
 return &(_m_attribute_list);
}
inline ::idl::vector< ::idl::attribute_info_t >* online_game_info_t::m_attribute_list(){
_flag[23 >> 3] |= (1 << (23 & 0x7));
 return &(_m_attribute_list);
}
inline size_t online_game_info_t::attribute_list_size() const{
/*  */ return _m_attribute_list.size();
}
inline const ::idl::attribute_info_t& online_game_info_t::attribute_list(size_t i0) const{
 return _m_attribute_list.get(i0);
}
inline ::idl::attribute_info_t* online_game_info_t::mutable_attribute_list(size_t i0){
_flag[23 >> 3] |= (1 << (23 & 0x7));
 return _m_attribute_list.mutable_get(i0);
}
inline ::idl::attribute_info_t* online_game_info_t::m_attribute_list(size_t i0){
_flag[23 >> 3] |= (1 << (23 & 0x7));
 return _m_attribute_list.mutable_get(i0);
}
inline bool online_game_info_t::has_pub_prop_ids() const{
return (_flag[24 >> 3] & (1 << (24 & 0x7)));
}
inline const char* online_game_info_t::pub_prop_ids(unsigned int* size) const{
return _m_pub_prop_ids.get(size);
}
inline online_game_info_t& online_game_info_t::set_pub_prop_ids(const char* s,ssize_t size){
_flag[24 >> 3] |= (1 << (24 & 0x7));
 _m_pub_prop_ids.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline online_game_info_t& online_game_info_t::set_ptr_pub_prop_ids(const char* s,ssize_t size){
_flag[24 >> 3] |= (1 << (24 & 0x7));
 _m_pub_prop_ids.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void online_game_info_t::clear_pub_prop_ids(){
_flag[24 >> 3] &= ~(1 << (24 & 0x7));
 _m_pub_prop_ids.clear();
}
inline ::idl::Unknown* online_game_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& online_game_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& online_game_info_t::unknown(){
return _unknown;
}
inline size_t online_game_info_t::unknown_size() const{
return _unknown.size();
}
inline grab_info_t* grab_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
grab_info_t* tmp=(grab_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)grab_info_t(pool);
return tmp;
}
inline void grab_info_t::destroy(grab_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~grab_info_t();
pool->free(v,sizeof(*v));
}
}
inline grab_info_t::grab_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(0)
,_m_c_id(_pool)
,_m_name(_pool)
,_m_amount(0)
,_m_send_amount(0)
,_m_create_time(_pool)
,_m_start_time(_pool)
,_m_end_time(_pool)
,_m_info(_pool)
,_m_num(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline grab_info_t::grab_info_t(const grab_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(0)
,_m_c_id(_pool)
,_m_name(_pool)
,_m_amount(0)
,_m_send_amount(0)
,_m_create_time(_pool)
,_m_start_time(_pool)
,_m_end_time(_pool)
,_m_info(_pool)
,_m_num(_pool)
,_unknown(_pool){
assign(v);
}
inline grab_info_t::~grab_info_t(){
}
inline grab_info_t& grab_info_t::operator=(const grab_info_t& v){
assign(v);
return *this;
}
inline void grab_info_t::clear(){
// _m_id=0;
_m_c_id.clear();
_m_name.clear();
// _m_amount=0;
// _m_send_amount=0;
_m_create_time.clear();
_m_start_time.clear();
_m_end_time.clear();
_m_info.clear();
_m_num.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void grab_info_t::check() const{
// @@uint32_t id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_id;

}
// @@string c_id;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string name;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@uint32_t amount;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "amount" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_amount;

}
// @@uint32_t send_amount;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "send_amount" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_send_amount;

}
// @@string create_time;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "create_time" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_create_time.get();

}
// @@string start_time;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "start_time" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_start_time.get();

}
// @@string end_time;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "end_time" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_end_time.get();

}
// @@string info;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info.get();

}
// @@string num;
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "num" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_num.get();

}

::idl::McpackBean::check();
}
inline void grab_info_t::detach(){
_m_c_id.detach();
_m_name.detach();
_m_create_time.detach();
_m_start_time.detach();
_m_end_time.detach();
_m_info.detach();
_m_num.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline grab_info_t& grab_info_t::assign(const grab_info_t& v){
_m_id=v._m_id;
_m_c_id=v._m_c_id;
_m_name=v._m_name;
_m_amount=v._m_amount;
_m_send_amount=v._m_send_amount;
_m_create_time=v._m_create_time;
_m_start_time=v._m_start_time;
_m_end_time=v._m_end_time;
_m_info=v._m_info;
_m_num=v._m_num;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool grab_info_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t grab_info_t::id() const{
return _m_id;
}
inline grab_info_t& grab_info_t::set_id(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id=v;
return *this;
}
inline void grab_info_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id=0;
}
inline bool grab_info_t::has_c_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* grab_info_t::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline grab_info_t& grab_info_t::set_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline grab_info_t& grab_info_t::set_ptr_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void grab_info_t::clear_c_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_c_id.clear();
}
inline bool grab_info_t::has_name() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* grab_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline grab_info_t& grab_info_t::set_name(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline grab_info_t& grab_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void grab_info_t::clear_name(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_name.clear();
}
inline bool grab_info_t::has_amount() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t grab_info_t::amount() const{
return _m_amount;
}
inline grab_info_t& grab_info_t::set_amount(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_amount=v;
return *this;
}
inline void grab_info_t::clear_amount(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_amount=0;
}
inline bool grab_info_t::has_send_amount() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t grab_info_t::send_amount() const{
return _m_send_amount;
}
inline grab_info_t& grab_info_t::set_send_amount(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_send_amount=v;
return *this;
}
inline void grab_info_t::clear_send_amount(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_send_amount=0;
}
inline bool grab_info_t::has_create_time() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* grab_info_t::create_time(unsigned int* size) const{
return _m_create_time.get(size);
}
inline grab_info_t& grab_info_t::set_create_time(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_create_time.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline grab_info_t& grab_info_t::set_ptr_create_time(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_create_time.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void grab_info_t::clear_create_time(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_create_time.clear();
}
inline bool grab_info_t::has_start_time() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* grab_info_t::start_time(unsigned int* size) const{
return _m_start_time.get(size);
}
inline grab_info_t& grab_info_t::set_start_time(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_start_time.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline grab_info_t& grab_info_t::set_ptr_start_time(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_start_time.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void grab_info_t::clear_start_time(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_start_time.clear();
}
inline bool grab_info_t::has_end_time() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* grab_info_t::end_time(unsigned int* size) const{
return _m_end_time.get(size);
}
inline grab_info_t& grab_info_t::set_end_time(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_end_time.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline grab_info_t& grab_info_t::set_ptr_end_time(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_end_time.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void grab_info_t::clear_end_time(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_end_time.clear();
}
inline bool grab_info_t::has_info() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* grab_info_t::info(unsigned int* size) const{
return _m_info.get(size);
}
inline grab_info_t& grab_info_t::set_info(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline grab_info_t& grab_info_t::set_ptr_info(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void grab_info_t::clear_info(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_info.clear();
}
inline bool grab_info_t::has_num() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline const char* grab_info_t::num(unsigned int* size) const{
return _m_num.get(size);
}
inline grab_info_t& grab_info_t::set_num(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_num.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline grab_info_t& grab_info_t::set_ptr_num(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_num.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void grab_info_t::clear_num(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_num.clear();
}
inline ::idl::Unknown* grab_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& grab_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& grab_info_t::unknown(){
return _unknown;
}
inline size_t grab_info_t::unknown_size() const{
return _unknown.size();
}
inline user_grab_number_t* user_grab_number_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
user_grab_number_t* tmp=(user_grab_number_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)user_grab_number_t(pool);
return tmp;
}
inline void user_grab_number_t::destroy(user_grab_number_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~user_grab_number_t();
pool->free(v,sizeof(*v));
}
}
inline user_grab_number_t::user_grab_number_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_grab_id(0)
,_m_num(_pool)
,_m_c_id(_pool)
,_m_name(_pool)
,_m_create_time(_pool)
,_m_start_time(_pool)
,_m_end_time(_pool)
,_m_info(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline user_grab_number_t::user_grab_number_t(const user_grab_number_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_grab_id(0)
,_m_num(_pool)
,_m_c_id(_pool)
,_m_name(_pool)
,_m_create_time(_pool)
,_m_start_time(_pool)
,_m_end_time(_pool)
,_m_info(_pool)
,_unknown(_pool){
assign(v);
}
inline user_grab_number_t::~user_grab_number_t(){
}
inline user_grab_number_t& user_grab_number_t::operator=(const user_grab_number_t& v){
assign(v);
return *this;
}
inline void user_grab_number_t::clear(){
// _m_grab_id=0;
_m_num.clear();
_m_c_id.clear();
_m_name.clear();
_m_create_time.clear();
_m_start_time.clear();
_m_end_time.clear();
_m_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void user_grab_number_t::check() const{
// @@uint32_t grab_id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "grab_id" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_grab_id;

}
// @@string num;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "num" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_num.get();

}
// @@string c_id;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string name;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string create_time;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "create_time" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_create_time.get();

}
// @@string start_time;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "start_time" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_start_time.get();

}
// @@string end_time;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "end_time" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_end_time.get();

}
// @@string info;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info.get();

}

::idl::McpackBean::check();
}
inline void user_grab_number_t::detach(){
_m_num.detach();
_m_c_id.detach();
_m_name.detach();
_m_create_time.detach();
_m_start_time.detach();
_m_end_time.detach();
_m_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline user_grab_number_t& user_grab_number_t::assign(const user_grab_number_t& v){
_m_grab_id=v._m_grab_id;
_m_num=v._m_num;
_m_c_id=v._m_c_id;
_m_name=v._m_name;
_m_create_time=v._m_create_time;
_m_start_time=v._m_start_time;
_m_end_time=v._m_end_time;
_m_info=v._m_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool user_grab_number_t::has_grab_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t user_grab_number_t::grab_id() const{
return _m_grab_id;
}
inline user_grab_number_t& user_grab_number_t::set_grab_id(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_grab_id=v;
return *this;
}
inline void user_grab_number_t::clear_grab_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_grab_id=0;
}
inline bool user_grab_number_t::has_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* user_grab_number_t::num(unsigned int* size) const{
return _m_num.get(size);
}
inline user_grab_number_t& user_grab_number_t::set_num(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_num.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_grab_number_t& user_grab_number_t::set_ptr_num(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_num.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_grab_number_t::clear_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_num.clear();
}
inline bool user_grab_number_t::has_c_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* user_grab_number_t::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline user_grab_number_t& user_grab_number_t::set_c_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_grab_number_t& user_grab_number_t::set_ptr_c_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_grab_number_t::clear_c_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_c_id.clear();
}
inline bool user_grab_number_t::has_name() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* user_grab_number_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline user_grab_number_t& user_grab_number_t::set_name(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_grab_number_t& user_grab_number_t::set_ptr_name(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_grab_number_t::clear_name(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_name.clear();
}
inline bool user_grab_number_t::has_create_time() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* user_grab_number_t::create_time(unsigned int* size) const{
return _m_create_time.get(size);
}
inline user_grab_number_t& user_grab_number_t::set_create_time(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_create_time.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_grab_number_t& user_grab_number_t::set_ptr_create_time(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_create_time.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_grab_number_t::clear_create_time(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_create_time.clear();
}
inline bool user_grab_number_t::has_start_time() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* user_grab_number_t::start_time(unsigned int* size) const{
return _m_start_time.get(size);
}
inline user_grab_number_t& user_grab_number_t::set_start_time(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_start_time.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_grab_number_t& user_grab_number_t::set_ptr_start_time(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_start_time.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_grab_number_t::clear_start_time(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_start_time.clear();
}
inline bool user_grab_number_t::has_end_time() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* user_grab_number_t::end_time(unsigned int* size) const{
return _m_end_time.get(size);
}
inline user_grab_number_t& user_grab_number_t::set_end_time(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_end_time.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_grab_number_t& user_grab_number_t::set_ptr_end_time(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_end_time.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_grab_number_t::clear_end_time(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_end_time.clear();
}
inline bool user_grab_number_t::has_info() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* user_grab_number_t::info(unsigned int* size) const{
return _m_info.get(size);
}
inline user_grab_number_t& user_grab_number_t::set_info(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_grab_number_t& user_grab_number_t::set_ptr_info(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_grab_number_t::clear_info(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_info.clear();
}
inline ::idl::Unknown* user_grab_number_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& user_grab_number_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& user_grab_number_t::unknown(){
return _unknown;
}
inline size_t user_grab_number_t::unknown_size() const{
return _unknown.size();
}
inline mobile_music_info_t* mobile_music_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mobile_music_info_t* tmp=(mobile_music_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mobile_music_info_t(pool);
return tmp;
}
inline void mobile_music_info_t::destroy(mobile_music_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mobile_music_info_t();
pool->free(v,sizeof(*v));
}
}
inline mobile_music_info_t::mobile_music_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ring_id(_pool)
,_m_name(_pool)
,_m_singer(_pool)
,_m_bell_id(_pool)
,_m_song_id(_pool)
,_m_cp_id(_pool)
,_m_date(_pool)
,_m_dolby_flag(_pool)
,_m_status(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mobile_music_info_t::mobile_music_info_t(const mobile_music_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ring_id(_pool)
,_m_name(_pool)
,_m_singer(_pool)
,_m_bell_id(_pool)
,_m_song_id(_pool)
,_m_cp_id(_pool)
,_m_date(_pool)
,_m_dolby_flag(_pool)
,_m_status(_pool)
,_unknown(_pool){
assign(v);
}
inline mobile_music_info_t::~mobile_music_info_t(){
}
inline mobile_music_info_t& mobile_music_info_t::operator=(const mobile_music_info_t& v){
assign(v);
return *this;
}
inline void mobile_music_info_t::clear(){
_m_ring_id.clear();
_m_name.clear();
_m_singer.clear();
_m_bell_id.clear();
_m_song_id.clear();
_m_cp_id.clear();
_m_date.clear();
_m_dolby_flag.clear();
_m_status.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mobile_music_info_t::check() const{
// @@string ring_id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ring_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ring_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string singer;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "singer" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_singer.get();

}
// @@string bell_id;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "bell_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_bell_id.get();

}
// @@string song_id;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "song_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_song_id.get();

}
// @@string cp_id;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cp_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_cp_id.get();

}
// @@string date;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_date.get();

}
// @@string dolby_flag;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "dolby_flag" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_dolby_flag.get();

}
// @@string status;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "status" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_status.get();

}

::idl::McpackBean::check();
}
inline void mobile_music_info_t::detach(){
_m_ring_id.detach();
_m_name.detach();
_m_singer.detach();
_m_bell_id.detach();
_m_song_id.detach();
_m_cp_id.detach();
_m_date.detach();
_m_dolby_flag.detach();
_m_status.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mobile_music_info_t& mobile_music_info_t::assign(const mobile_music_info_t& v){
_m_ring_id=v._m_ring_id;
_m_name=v._m_name;
_m_singer=v._m_singer;
_m_bell_id=v._m_bell_id;
_m_song_id=v._m_song_id;
_m_cp_id=v._m_cp_id;
_m_date=v._m_date;
_m_dolby_flag=v._m_dolby_flag;
_m_status=v._m_status;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mobile_music_info_t::has_ring_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mobile_music_info_t::ring_id(unsigned int* size) const{
return _m_ring_id.get(size);
}
inline mobile_music_info_t& mobile_music_info_t::set_ring_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ring_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mobile_music_info_t& mobile_music_info_t::set_ptr_ring_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ring_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mobile_music_info_t::clear_ring_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ring_id.clear();
}
inline bool mobile_music_info_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mobile_music_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline mobile_music_info_t& mobile_music_info_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mobile_music_info_t& mobile_music_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mobile_music_info_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool mobile_music_info_t::has_singer() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mobile_music_info_t::singer(unsigned int* size) const{
return _m_singer.get(size);
}
inline mobile_music_info_t& mobile_music_info_t::set_singer(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_singer.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mobile_music_info_t& mobile_music_info_t::set_ptr_singer(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_singer.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mobile_music_info_t::clear_singer(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_singer.clear();
}
inline bool mobile_music_info_t::has_bell_id() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mobile_music_info_t::bell_id(unsigned int* size) const{
return _m_bell_id.get(size);
}
inline mobile_music_info_t& mobile_music_info_t::set_bell_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_bell_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mobile_music_info_t& mobile_music_info_t::set_ptr_bell_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_bell_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mobile_music_info_t::clear_bell_id(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_bell_id.clear();
}
inline bool mobile_music_info_t::has_song_id() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mobile_music_info_t::song_id(unsigned int* size) const{
return _m_song_id.get(size);
}
inline mobile_music_info_t& mobile_music_info_t::set_song_id(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_song_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mobile_music_info_t& mobile_music_info_t::set_ptr_song_id(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_song_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mobile_music_info_t::clear_song_id(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_song_id.clear();
}
inline bool mobile_music_info_t::has_cp_id() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* mobile_music_info_t::cp_id(unsigned int* size) const{
return _m_cp_id.get(size);
}
inline mobile_music_info_t& mobile_music_info_t::set_cp_id(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_cp_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mobile_music_info_t& mobile_music_info_t::set_ptr_cp_id(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_cp_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mobile_music_info_t::clear_cp_id(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_cp_id.clear();
}
inline bool mobile_music_info_t::has_date() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* mobile_music_info_t::date(unsigned int* size) const{
return _m_date.get(size);
}
inline mobile_music_info_t& mobile_music_info_t::set_date(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mobile_music_info_t& mobile_music_info_t::set_ptr_date(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mobile_music_info_t::clear_date(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_date.clear();
}
inline bool mobile_music_info_t::has_dolby_flag() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* mobile_music_info_t::dolby_flag(unsigned int* size) const{
return _m_dolby_flag.get(size);
}
inline mobile_music_info_t& mobile_music_info_t::set_dolby_flag(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_dolby_flag.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mobile_music_info_t& mobile_music_info_t::set_ptr_dolby_flag(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_dolby_flag.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mobile_music_info_t::clear_dolby_flag(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_dolby_flag.clear();
}
inline bool mobile_music_info_t::has_status() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* mobile_music_info_t::status(unsigned int* size) const{
return _m_status.get(size);
}
inline mobile_music_info_t& mobile_music_info_t::set_status(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_status.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mobile_music_info_t& mobile_music_info_t::set_ptr_status(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_status.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mobile_music_info_t::clear_status(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_status.clear();
}
inline ::idl::Unknown* mobile_music_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mobile_music_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mobile_music_info_t::unknown(){
return _unknown;
}
inline size_t mobile_music_info_t::unknown_size() const{
return _unknown.size();
}
inline pt_game_basic_info_t* pt_game_basic_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
pt_game_basic_info_t* tmp=(pt_game_basic_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)pt_game_basic_info_t(pool);
return tmp;
}
inline void pt_game_basic_info_t::destroy(pt_game_basic_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~pt_game_basic_info_t();
pool->free(v,sizeof(*v));
}
}
inline pt_game_basic_info_t::pt_game_basic_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_game_id(_pool)
,_m_name(_pool)
,_m_app_key(_pool)
,_m_app_secret(_pool)
,_m_notify_url(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline pt_game_basic_info_t::pt_game_basic_info_t(const pt_game_basic_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_game_id(_pool)
,_m_name(_pool)
,_m_app_key(_pool)
,_m_app_secret(_pool)
,_m_notify_url(_pool)
,_unknown(_pool){
assign(v);
}
inline pt_game_basic_info_t::~pt_game_basic_info_t(){
}
inline pt_game_basic_info_t& pt_game_basic_info_t::operator=(const pt_game_basic_info_t& v){
assign(v);
return *this;
}
inline void pt_game_basic_info_t::clear(){
_m_game_id.clear();
_m_name.clear();
_m_app_key.clear();
_m_app_secret.clear();
_m_notify_url.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void pt_game_basic_info_t::check() const{
// @@string game_id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string app_key;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "app_key" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_app_key.get();

}
// @@string app_secret;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "app_secret" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_app_secret.get();

}
// @@string notify_url;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "notify_url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_notify_url.get();

}

::idl::McpackBean::check();
}
inline void pt_game_basic_info_t::detach(){
_m_game_id.detach();
_m_name.detach();
_m_app_key.detach();
_m_app_secret.detach();
_m_notify_url.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline pt_game_basic_info_t& pt_game_basic_info_t::assign(const pt_game_basic_info_t& v){
_m_game_id=v._m_game_id;
_m_name=v._m_name;
_m_app_key=v._m_app_key;
_m_app_secret=v._m_app_secret;
_m_notify_url=v._m_notify_url;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool pt_game_basic_info_t::has_game_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* pt_game_basic_info_t::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline pt_game_basic_info_t& pt_game_basic_info_t::set_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline pt_game_basic_info_t& pt_game_basic_info_t::set_ptr_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void pt_game_basic_info_t::clear_game_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_game_id.clear();
}
inline bool pt_game_basic_info_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* pt_game_basic_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline pt_game_basic_info_t& pt_game_basic_info_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline pt_game_basic_info_t& pt_game_basic_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void pt_game_basic_info_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool pt_game_basic_info_t::has_app_key() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* pt_game_basic_info_t::app_key(unsigned int* size) const{
return _m_app_key.get(size);
}
inline pt_game_basic_info_t& pt_game_basic_info_t::set_app_key(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_app_key.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline pt_game_basic_info_t& pt_game_basic_info_t::set_ptr_app_key(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_app_key.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void pt_game_basic_info_t::clear_app_key(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_app_key.clear();
}
inline bool pt_game_basic_info_t::has_app_secret() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* pt_game_basic_info_t::app_secret(unsigned int* size) const{
return _m_app_secret.get(size);
}
inline pt_game_basic_info_t& pt_game_basic_info_t::set_app_secret(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_app_secret.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline pt_game_basic_info_t& pt_game_basic_info_t::set_ptr_app_secret(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_app_secret.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void pt_game_basic_info_t::clear_app_secret(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_app_secret.clear();
}
inline bool pt_game_basic_info_t::has_notify_url() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* pt_game_basic_info_t::notify_url(unsigned int* size) const{
return _m_notify_url.get(size);
}
inline pt_game_basic_info_t& pt_game_basic_info_t::set_notify_url(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_notify_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline pt_game_basic_info_t& pt_game_basic_info_t::set_ptr_notify_url(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_notify_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void pt_game_basic_info_t::clear_notify_url(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_notify_url.clear();
}
inline ::idl::Unknown* pt_game_basic_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& pt_game_basic_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& pt_game_basic_info_t::unknown(){
return _unknown;
}
inline size_t pt_game_basic_info_t::unknown_size() const{
return _unknown.size();
}
inline calender_info_t* calender_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
calender_info_t* tmp=(calender_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)calender_info_t(pool);
return tmp;
}
inline void calender_info_t::destroy(calender_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~calender_info_t();
pool->free(v,sizeof(*v));
}
}
inline calender_info_t::calender_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_title(_pool)
,_m_type(0)
,_m_c_id(_pool)
,_m_date(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline calender_info_t::calender_info_t(const calender_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_title(_pool)
,_m_type(0)
,_m_c_id(_pool)
,_m_date(_pool)
,_unknown(_pool){
assign(v);
}
inline calender_info_t::~calender_info_t(){
}
inline calender_info_t& calender_info_t::operator=(const calender_info_t& v){
assign(v);
return *this;
}
inline void calender_info_t::clear(){
_m_id.clear();
_m_title.clear();
// _m_type=0;
_m_c_id.clear();
_m_date.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void calender_info_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string title;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "title" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_title.get();

}
// @@uint32_t type;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_type;

}
// @@string c_id;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string date;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_date.get();

}

::idl::McpackBean::check();
}
inline void calender_info_t::detach(){
_m_id.detach();
_m_title.detach();
_m_c_id.detach();
_m_date.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline calender_info_t& calender_info_t::assign(const calender_info_t& v){
_m_id=v._m_id;
_m_title=v._m_title;
_m_type=v._m_type;
_m_c_id=v._m_c_id;
_m_date=v._m_date;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool calender_info_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* calender_info_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline calender_info_t& calender_info_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline calender_info_t& calender_info_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void calender_info_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool calender_info_t::has_title() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* calender_info_t::title(unsigned int* size) const{
return _m_title.get(size);
}
inline calender_info_t& calender_info_t::set_title(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_title.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline calender_info_t& calender_info_t::set_ptr_title(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_title.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void calender_info_t::clear_title(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_title.clear();
}
inline bool calender_info_t::has_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t calender_info_t::type() const{
return _m_type;
}
inline calender_info_t& calender_info_t::set_type(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_type=v;
return *this;
}
inline void calender_info_t::clear_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_type=0;
}
inline bool calender_info_t::has_c_id() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* calender_info_t::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline calender_info_t& calender_info_t::set_c_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline calender_info_t& calender_info_t::set_ptr_c_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void calender_info_t::clear_c_id(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_c_id.clear();
}
inline bool calender_info_t::has_date() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* calender_info_t::date(unsigned int* size) const{
return _m_date.get(size);
}
inline calender_info_t& calender_info_t::set_date(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline calender_info_t& calender_info_t::set_ptr_date(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void calender_info_t::clear_date(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_date.clear();
}
inline ::idl::Unknown* calender_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& calender_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& calender_info_t::unknown(){
return _unknown;
}
inline size_t calender_info_t::unknown_size() const{
return _unknown.size();
}
inline soft_info_t* soft_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
soft_info_t* tmp=(soft_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)soft_info_t(pool);
return tmp;
}
inline void soft_info_t::destroy(soft_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~soft_info_t();
pool->free(v,sizeof(*v));
}
}
inline soft_info_t::soft_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_type_id(_pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_icon(_pool)
,_m_preview(_pool)
,_m_version(_pool)
,_m_size(_pool)
,_m_pop(_pool)
,_m_adapt(_pool)
,_m_date(_pool)
,_m_froms(_pool)
,_m_info(_pool)
,_m_down_url(_pool)
,_m_star(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline soft_info_t::soft_info_t(const soft_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_type_id(_pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_icon(_pool)
,_m_preview(_pool)
,_m_version(_pool)
,_m_size(_pool)
,_m_pop(_pool)
,_m_adapt(_pool)
,_m_date(_pool)
,_m_froms(_pool)
,_m_info(_pool)
,_m_down_url(_pool)
,_m_star(_pool)
,_unknown(_pool){
assign(v);
}
inline soft_info_t::~soft_info_t(){
}
inline soft_info_t& soft_info_t::operator=(const soft_info_t& v){
assign(v);
return *this;
}
inline void soft_info_t::clear(){
_m_type_id.clear();
_m_id.clear();
_m_name.clear();
_m_icon.clear();
_m_preview.clear();
_m_version.clear();
_m_size.clear();
_m_pop.clear();
_m_adapt.clear();
_m_date.clear();
_m_froms.clear();
_m_info.clear();
_m_down_url.clear();
_m_star.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void soft_info_t::check() const{
// @@string type_id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@string id;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string icon;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "icon" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_icon.get();

}
// @@string preview;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "preview" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_preview.get();

}
// @@string version;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "version" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_version.get();

}
// @@string size;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "size" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_size.get();

}
// @@string pop;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "pop" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_pop.get();

}
// @@string adapt;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "adapt" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_adapt.get();

}
// @@string date;
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_date.get();

}
// @@string froms;
if(!(_flag[10 >> 3] & (1 << (10 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "froms" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_froms.get();

}
// @@string info;
if(!(_flag[11 >> 3] & (1 << (11 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info.get();

}
// @@string down_url;
if(!(_flag[12 >> 3] & (1 << (12 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "down_url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_down_url.get();

}
// @@string star;
if(!(_flag[13 >> 3] & (1 << (13 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "star" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_star.get();

}

::idl::McpackBean::check();
}
inline void soft_info_t::detach(){
_m_type_id.detach();
_m_id.detach();
_m_name.detach();
_m_icon.detach();
_m_preview.detach();
_m_version.detach();
_m_size.detach();
_m_pop.detach();
_m_adapt.detach();
_m_date.detach();
_m_froms.detach();
_m_info.detach();
_m_down_url.detach();
_m_star.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline soft_info_t& soft_info_t::assign(const soft_info_t& v){
_m_type_id=v._m_type_id;
_m_id=v._m_id;
_m_name=v._m_name;
_m_icon=v._m_icon;
_m_preview=v._m_preview;
_m_version=v._m_version;
_m_size=v._m_size;
_m_pop=v._m_pop;
_m_adapt=v._m_adapt;
_m_date=v._m_date;
_m_froms=v._m_froms;
_m_info=v._m_info;
_m_down_url=v._m_down_url;
_m_star=v._m_star;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool soft_info_t::has_type_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* soft_info_t::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline soft_info_t& soft_info_t::set_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_type_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_type_id.clear();
}
inline bool soft_info_t::has_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* soft_info_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline soft_info_t& soft_info_t::set_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_id.clear();
}
inline bool soft_info_t::has_name() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* soft_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline soft_info_t& soft_info_t::set_name(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_name(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_name.clear();
}
inline bool soft_info_t::has_icon() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* soft_info_t::icon(unsigned int* size) const{
return _m_icon.get(size);
}
inline soft_info_t& soft_info_t::set_icon(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_icon.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_icon(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_icon.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_icon(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_icon.clear();
}
inline bool soft_info_t::has_preview() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* soft_info_t::preview(unsigned int* size) const{
return _m_preview.get(size);
}
inline soft_info_t& soft_info_t::set_preview(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_preview.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_preview(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_preview.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_preview(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_preview.clear();
}
inline bool soft_info_t::has_version() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* soft_info_t::version(unsigned int* size) const{
return _m_version.get(size);
}
inline soft_info_t& soft_info_t::set_version(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_version.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_version(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_version.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_version(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_version.clear();
}
inline bool soft_info_t::has_size() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* soft_info_t::size(unsigned int* size) const{
return _m_size.get(size);
}
inline soft_info_t& soft_info_t::set_size(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_size.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_size(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_size.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_size(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_size.clear();
}
inline bool soft_info_t::has_pop() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* soft_info_t::pop(unsigned int* size) const{
return _m_pop.get(size);
}
inline soft_info_t& soft_info_t::set_pop(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_pop.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_pop(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_pop.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_pop(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_pop.clear();
}
inline bool soft_info_t::has_adapt() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* soft_info_t::adapt(unsigned int* size) const{
return _m_adapt.get(size);
}
inline soft_info_t& soft_info_t::set_adapt(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_adapt.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_adapt(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_adapt.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_adapt(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_adapt.clear();
}
inline bool soft_info_t::has_date() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline const char* soft_info_t::date(unsigned int* size) const{
return _m_date.get(size);
}
inline soft_info_t& soft_info_t::set_date(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_date(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_date(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_date.clear();
}
inline bool soft_info_t::has_froms() const{
return (_flag[10 >> 3] & (1 << (10 & 0x7)));
}
inline const char* soft_info_t::froms(unsigned int* size) const{
return _m_froms.get(size);
}
inline soft_info_t& soft_info_t::set_froms(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_froms.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_froms(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_froms.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_froms(){
_flag[10 >> 3] &= ~(1 << (10 & 0x7));
 _m_froms.clear();
}
inline bool soft_info_t::has_info() const{
return (_flag[11 >> 3] & (1 << (11 & 0x7)));
}
inline const char* soft_info_t::info(unsigned int* size) const{
return _m_info.get(size);
}
inline soft_info_t& soft_info_t::set_info(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_info(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_info(){
_flag[11 >> 3] &= ~(1 << (11 & 0x7));
 _m_info.clear();
}
inline bool soft_info_t::has_down_url() const{
return (_flag[12 >> 3] & (1 << (12 & 0x7)));
}
inline const char* soft_info_t::down_url(unsigned int* size) const{
return _m_down_url.get(size);
}
inline soft_info_t& soft_info_t::set_down_url(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_down_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_down_url(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_down_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_down_url(){
_flag[12 >> 3] &= ~(1 << (12 & 0x7));
 _m_down_url.clear();
}
inline bool soft_info_t::has_star() const{
return (_flag[13 >> 3] & (1 << (13 & 0x7)));
}
inline const char* soft_info_t::star(unsigned int* size) const{
return _m_star.get(size);
}
inline soft_info_t& soft_info_t::set_star(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_star.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline soft_info_t& soft_info_t::set_ptr_star(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_star.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void soft_info_t::clear_star(){
_flag[13 >> 3] &= ~(1 << (13 & 0x7));
 _m_star.clear();
}
inline ::idl::Unknown* soft_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& soft_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& soft_info_t::unknown(){
return _unknown;
}
inline size_t soft_info_t::unknown_size() const{
return _unknown.size();
}
inline theme_info_t* theme_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
theme_info_t* tmp=(theme_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)theme_info_t(pool);
return tmp;
}
inline void theme_info_t::destroy(theme_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~theme_info_t();
pool->free(v,sizeof(*v));
}
}
inline theme_info_t::theme_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_type_id(_pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_icon(_pool)
,_m_preview(_pool)
,_m_size(_pool)
,_m_pop(_pool)
,_m_adapt(_pool)
,_m_date(_pool)
,_m_froms(_pool)
,_m_info(_pool)
,_m_down_url(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline theme_info_t::theme_info_t(const theme_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_type_id(_pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_icon(_pool)
,_m_preview(_pool)
,_m_size(_pool)
,_m_pop(_pool)
,_m_adapt(_pool)
,_m_date(_pool)
,_m_froms(_pool)
,_m_info(_pool)
,_m_down_url(_pool)
,_unknown(_pool){
assign(v);
}
inline theme_info_t::~theme_info_t(){
}
inline theme_info_t& theme_info_t::operator=(const theme_info_t& v){
assign(v);
return *this;
}
inline void theme_info_t::clear(){
_m_type_id.clear();
_m_id.clear();
_m_name.clear();
_m_icon.clear();
_m_preview.clear();
_m_size.clear();
_m_pop.clear();
_m_adapt.clear();
_m_date.clear();
_m_froms.clear();
_m_info.clear();
_m_down_url.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void theme_info_t::check() const{
// @@string type_id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@string id;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string icon;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "icon" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_icon.get();

}
// @@string preview;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "preview" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_preview.get();

}
// @@string size;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "size" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_size.get();

}
// @@string pop;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "pop" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_pop.get();

}
// @@string adapt;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "adapt" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_adapt.get();

}
// @@string date;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_date.get();

}
// @@string froms;
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "froms" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_froms.get();

}
// @@string info;
if(!(_flag[10 >> 3] & (1 << (10 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info.get();

}
// @@string down_url;
if(!(_flag[11 >> 3] & (1 << (11 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "down_url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_down_url.get();

}

::idl::McpackBean::check();
}
inline void theme_info_t::detach(){
_m_type_id.detach();
_m_id.detach();
_m_name.detach();
_m_icon.detach();
_m_preview.detach();
_m_size.detach();
_m_pop.detach();
_m_adapt.detach();
_m_date.detach();
_m_froms.detach();
_m_info.detach();
_m_down_url.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline theme_info_t& theme_info_t::assign(const theme_info_t& v){
_m_type_id=v._m_type_id;
_m_id=v._m_id;
_m_name=v._m_name;
_m_icon=v._m_icon;
_m_preview=v._m_preview;
_m_size=v._m_size;
_m_pop=v._m_pop;
_m_adapt=v._m_adapt;
_m_date=v._m_date;
_m_froms=v._m_froms;
_m_info=v._m_info;
_m_down_url=v._m_down_url;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool theme_info_t::has_type_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* theme_info_t::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline theme_info_t& theme_info_t::set_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline theme_info_t& theme_info_t::set_ptr_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void theme_info_t::clear_type_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_type_id.clear();
}
inline bool theme_info_t::has_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* theme_info_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline theme_info_t& theme_info_t::set_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline theme_info_t& theme_info_t::set_ptr_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void theme_info_t::clear_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_id.clear();
}
inline bool theme_info_t::has_name() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* theme_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline theme_info_t& theme_info_t::set_name(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline theme_info_t& theme_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void theme_info_t::clear_name(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_name.clear();
}
inline bool theme_info_t::has_icon() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* theme_info_t::icon(unsigned int* size) const{
return _m_icon.get(size);
}
inline theme_info_t& theme_info_t::set_icon(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_icon.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline theme_info_t& theme_info_t::set_ptr_icon(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_icon.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void theme_info_t::clear_icon(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_icon.clear();
}
inline bool theme_info_t::has_preview() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* theme_info_t::preview(unsigned int* size) const{
return _m_preview.get(size);
}
inline theme_info_t& theme_info_t::set_preview(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_preview.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline theme_info_t& theme_info_t::set_ptr_preview(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_preview.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void theme_info_t::clear_preview(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_preview.clear();
}
inline bool theme_info_t::has_size() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* theme_info_t::size(unsigned int* size) const{
return _m_size.get(size);
}
inline theme_info_t& theme_info_t::set_size(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_size.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline theme_info_t& theme_info_t::set_ptr_size(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_size.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void theme_info_t::clear_size(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_size.clear();
}
inline bool theme_info_t::has_pop() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* theme_info_t::pop(unsigned int* size) const{
return _m_pop.get(size);
}
inline theme_info_t& theme_info_t::set_pop(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_pop.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline theme_info_t& theme_info_t::set_ptr_pop(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_pop.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void theme_info_t::clear_pop(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_pop.clear();
}
inline bool theme_info_t::has_adapt() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* theme_info_t::adapt(unsigned int* size) const{
return _m_adapt.get(size);
}
inline theme_info_t& theme_info_t::set_adapt(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_adapt.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline theme_info_t& theme_info_t::set_ptr_adapt(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_adapt.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void theme_info_t::clear_adapt(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_adapt.clear();
}
inline bool theme_info_t::has_date() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* theme_info_t::date(unsigned int* size) const{
return _m_date.get(size);
}
inline theme_info_t& theme_info_t::set_date(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline theme_info_t& theme_info_t::set_ptr_date(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void theme_info_t::clear_date(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_date.clear();
}
inline bool theme_info_t::has_froms() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline const char* theme_info_t::froms(unsigned int* size) const{
return _m_froms.get(size);
}
inline theme_info_t& theme_info_t::set_froms(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_froms.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline theme_info_t& theme_info_t::set_ptr_froms(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_froms.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void theme_info_t::clear_froms(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_froms.clear();
}
inline bool theme_info_t::has_info() const{
return (_flag[10 >> 3] & (1 << (10 & 0x7)));
}
inline const char* theme_info_t::info(unsigned int* size) const{
return _m_info.get(size);
}
inline theme_info_t& theme_info_t::set_info(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline theme_info_t& theme_info_t::set_ptr_info(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void theme_info_t::clear_info(){
_flag[10 >> 3] &= ~(1 << (10 & 0x7));
 _m_info.clear();
}
inline bool theme_info_t::has_down_url() const{
return (_flag[11 >> 3] & (1 << (11 & 0x7)));
}
inline const char* theme_info_t::down_url(unsigned int* size) const{
return _m_down_url.get(size);
}
inline theme_info_t& theme_info_t::set_down_url(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_down_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline theme_info_t& theme_info_t::set_ptr_down_url(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_down_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void theme_info_t::clear_down_url(){
_flag[11 >> 3] &= ~(1 << (11 & 0x7));
 _m_down_url.clear();
}
inline ::idl::Unknown* theme_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& theme_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& theme_info_t::unknown(){
return _unknown;
}
inline size_t theme_info_t::unknown_size() const{
return _unknown.size();
}
inline music_info_t* music_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
music_info_t* tmp=(music_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)music_info_t(pool);
return tmp;
}
inline void music_info_t::destroy(music_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~music_info_t();
pool->free(v,sizeof(*v));
}
}
inline music_info_t::music_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_music_id(_pool)
,_m_songname(_pool)
,_m_area_id(_pool)
,_m_area_name(_pool)
,_m_cp_id(_pool)
,_m_cp_name(_pool)
,_m_language_id(_pool)
,_m_language(_pool)
,_m_publish_date(_pool)
,_m_intro(_pool)
,_m_lyric_writer(_pool)
,_m_composer(_pool)
,_m_price(_pool)
,_m_discount(_pool)
,_m_download_base(_pool)
,_m_lyric_txt(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline music_info_t::music_info_t(const music_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_music_id(_pool)
,_m_songname(_pool)
,_m_area_id(_pool)
,_m_area_name(_pool)
,_m_cp_id(_pool)
,_m_cp_name(_pool)
,_m_language_id(_pool)
,_m_language(_pool)
,_m_publish_date(_pool)
,_m_intro(_pool)
,_m_lyric_writer(_pool)
,_m_composer(_pool)
,_m_price(_pool)
,_m_discount(_pool)
,_m_download_base(_pool)
,_m_lyric_txt(_pool)
,_unknown(_pool){
assign(v);
}
inline music_info_t::~music_info_t(){
}
inline music_info_t& music_info_t::operator=(const music_info_t& v){
assign(v);
return *this;
}
inline void music_info_t::clear(){
_m_music_id.clear();
_m_songname.clear();
_m_area_id.clear();
_m_area_name.clear();
_m_cp_id.clear();
_m_cp_name.clear();
_m_language_id.clear();
_m_language.clear();
_m_publish_date.clear();
_m_intro.clear();
_m_lyric_writer.clear();
_m_composer.clear();
_m_price.clear();
_m_discount.clear();
_m_download_base.clear();
_m_lyric_txt.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void music_info_t::check() const{
// @@string music_id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "music_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_music_id.get();

}
// @@string songname;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "songname" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_songname.get();

}
// @@string area_id;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "area_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_area_id.get();

}
// @@string area_name;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "area_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_area_name.get();

}
// @@string cp_id;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cp_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_cp_id.get();

}
// @@string cp_name;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cp_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_cp_name.get();

}
// @@string language_id;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "language_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_language_id.get();

}
// @@string language;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "language" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_language.get();

}
// @@string publish_date;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "publish_date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_publish_date.get();

}
// @@string intro;
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "intro" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_intro.get();

}
// @@string lyric_writer;
if(!(_flag[10 >> 3] & (1 << (10 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "lyric_writer" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_lyric_writer.get();

}
// @@string composer;
if(!(_flag[11 >> 3] & (1 << (11 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "composer" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_composer.get();

}
// @@string price;
if(!(_flag[12 >> 3] & (1 << (12 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "price" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_price.get();

}
// @@string discount;
if(!(_flag[13 >> 3] & (1 << (13 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "discount" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_discount.get();

}
// @@string download_base;
if(!(_flag[14 >> 3] & (1 << (14 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "download_base" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_download_base.get();

}
// @@string lyric_txt;
if(!(_flag[15 >> 3] & (1 << (15 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "lyric_txt" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_lyric_txt.get();

}

::idl::McpackBean::check();
}
inline void music_info_t::detach(){
_m_music_id.detach();
_m_songname.detach();
_m_area_id.detach();
_m_area_name.detach();
_m_cp_id.detach();
_m_cp_name.detach();
_m_language_id.detach();
_m_language.detach();
_m_publish_date.detach();
_m_intro.detach();
_m_lyric_writer.detach();
_m_composer.detach();
_m_price.detach();
_m_discount.detach();
_m_download_base.detach();
_m_lyric_txt.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline music_info_t& music_info_t::assign(const music_info_t& v){
_m_music_id=v._m_music_id;
_m_songname=v._m_songname;
_m_area_id=v._m_area_id;
_m_area_name=v._m_area_name;
_m_cp_id=v._m_cp_id;
_m_cp_name=v._m_cp_name;
_m_language_id=v._m_language_id;
_m_language=v._m_language;
_m_publish_date=v._m_publish_date;
_m_intro=v._m_intro;
_m_lyric_writer=v._m_lyric_writer;
_m_composer=v._m_composer;
_m_price=v._m_price;
_m_discount=v._m_discount;
_m_download_base=v._m_download_base;
_m_lyric_txt=v._m_lyric_txt;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool music_info_t::has_music_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* music_info_t::music_id(unsigned int* size) const{
return _m_music_id.get(size);
}
inline music_info_t& music_info_t::set_music_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_music_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_music_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_music_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_music_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_music_id.clear();
}
inline bool music_info_t::has_songname() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* music_info_t::songname(unsigned int* size) const{
return _m_songname.get(size);
}
inline music_info_t& music_info_t::set_songname(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_songname.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_songname(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_songname.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_songname(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_songname.clear();
}
inline bool music_info_t::has_area_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* music_info_t::area_id(unsigned int* size) const{
return _m_area_id.get(size);
}
inline music_info_t& music_info_t::set_area_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_area_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_area_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_area_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_area_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_area_id.clear();
}
inline bool music_info_t::has_area_name() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* music_info_t::area_name(unsigned int* size) const{
return _m_area_name.get(size);
}
inline music_info_t& music_info_t::set_area_name(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_area_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_area_name(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_area_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_area_name(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_area_name.clear();
}
inline bool music_info_t::has_cp_id() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* music_info_t::cp_id(unsigned int* size) const{
return _m_cp_id.get(size);
}
inline music_info_t& music_info_t::set_cp_id(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_cp_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_cp_id(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_cp_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_cp_id(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_cp_id.clear();
}
inline bool music_info_t::has_cp_name() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* music_info_t::cp_name(unsigned int* size) const{
return _m_cp_name.get(size);
}
inline music_info_t& music_info_t::set_cp_name(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_cp_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_cp_name(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_cp_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_cp_name(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_cp_name.clear();
}
inline bool music_info_t::has_language_id() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* music_info_t::language_id(unsigned int* size) const{
return _m_language_id.get(size);
}
inline music_info_t& music_info_t::set_language_id(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_language_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_language_id(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_language_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_language_id(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_language_id.clear();
}
inline bool music_info_t::has_language() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* music_info_t::language(unsigned int* size) const{
return _m_language.get(size);
}
inline music_info_t& music_info_t::set_language(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_language.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_language(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_language.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_language(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_language.clear();
}
inline bool music_info_t::has_publish_date() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* music_info_t::publish_date(unsigned int* size) const{
return _m_publish_date.get(size);
}
inline music_info_t& music_info_t::set_publish_date(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_publish_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_publish_date(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_publish_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_publish_date(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_publish_date.clear();
}
inline bool music_info_t::has_intro() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline const char* music_info_t::intro(unsigned int* size) const{
return _m_intro.get(size);
}
inline music_info_t& music_info_t::set_intro(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_intro.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_intro(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_intro.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_intro(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_intro.clear();
}
inline bool music_info_t::has_lyric_writer() const{
return (_flag[10 >> 3] & (1 << (10 & 0x7)));
}
inline const char* music_info_t::lyric_writer(unsigned int* size) const{
return _m_lyric_writer.get(size);
}
inline music_info_t& music_info_t::set_lyric_writer(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_lyric_writer.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_lyric_writer(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_lyric_writer.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_lyric_writer(){
_flag[10 >> 3] &= ~(1 << (10 & 0x7));
 _m_lyric_writer.clear();
}
inline bool music_info_t::has_composer() const{
return (_flag[11 >> 3] & (1 << (11 & 0x7)));
}
inline const char* music_info_t::composer(unsigned int* size) const{
return _m_composer.get(size);
}
inline music_info_t& music_info_t::set_composer(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_composer.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_composer(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_composer.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_composer(){
_flag[11 >> 3] &= ~(1 << (11 & 0x7));
 _m_composer.clear();
}
inline bool music_info_t::has_price() const{
return (_flag[12 >> 3] & (1 << (12 & 0x7)));
}
inline const char* music_info_t::price(unsigned int* size) const{
return _m_price.get(size);
}
inline music_info_t& music_info_t::set_price(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_price.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_price(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_price.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_price(){
_flag[12 >> 3] &= ~(1 << (12 & 0x7));
 _m_price.clear();
}
inline bool music_info_t::has_discount() const{
return (_flag[13 >> 3] & (1 << (13 & 0x7)));
}
inline const char* music_info_t::discount(unsigned int* size) const{
return _m_discount.get(size);
}
inline music_info_t& music_info_t::set_discount(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_discount.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_discount(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_discount.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_discount(){
_flag[13 >> 3] &= ~(1 << (13 & 0x7));
 _m_discount.clear();
}
inline bool music_info_t::has_download_base() const{
return (_flag[14 >> 3] & (1 << (14 & 0x7)));
}
inline const char* music_info_t::download_base(unsigned int* size) const{
return _m_download_base.get(size);
}
inline music_info_t& music_info_t::set_download_base(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_download_base.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_download_base(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_download_base.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_download_base(){
_flag[14 >> 3] &= ~(1 << (14 & 0x7));
 _m_download_base.clear();
}
inline bool music_info_t::has_lyric_txt() const{
return (_flag[15 >> 3] & (1 << (15 & 0x7)));
}
inline const char* music_info_t::lyric_txt(unsigned int* size) const{
return _m_lyric_txt.get(size);
}
inline music_info_t& music_info_t::set_lyric_txt(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_lyric_txt.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline music_info_t& music_info_t::set_ptr_lyric_txt(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_lyric_txt.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void music_info_t::clear_lyric_txt(){
_flag[15 >> 3] &= ~(1 << (15 & 0x7));
 _m_lyric_txt.clear();
}
inline ::idl::Unknown* music_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& music_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& music_info_t::unknown(){
return _unknown;
}
inline size_t music_info_t::unknown_size() const{
return _unknown.size();
}
inline cp_info_t* cp_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
cp_info_t* tmp=(cp_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)cp_info_t(pool);
return tmp;
}
inline void cp_info_t::destroy(cp_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~cp_info_t();
pool->free(v,sizeof(*v));
}
}
inline cp_info_t::cp_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_name(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline cp_info_t::cp_info_t(const cp_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_name(_pool)
,_unknown(_pool){
assign(v);
}
inline cp_info_t::~cp_info_t(){
}
inline cp_info_t& cp_info_t::operator=(const cp_info_t& v){
assign(v);
return *this;
}
inline void cp_info_t::clear(){
_m_id.clear();
_m_name.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void cp_info_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}

::idl::McpackBean::check();
}
inline void cp_info_t::detach(){
_m_id.detach();
_m_name.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline cp_info_t& cp_info_t::assign(const cp_info_t& v){
_m_id=v._m_id;
_m_name=v._m_name;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool cp_info_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* cp_info_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline cp_info_t& cp_info_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline cp_info_t& cp_info_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void cp_info_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool cp_info_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* cp_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline cp_info_t& cp_info_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline cp_info_t& cp_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void cp_info_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline ::idl::Unknown* cp_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& cp_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& cp_info_t::unknown(){
return _unknown;
}
inline size_t cp_info_t::unknown_size() const{
return _unknown.size();
}
inline grant_detail_t* grant_detail_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
grant_detail_t* tmp=(grant_detail_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)grant_detail_t(pool);
return tmp;
}
inline void grant_detail_t::destroy(grant_detail_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~grant_detail_t();
pool->free(v,sizeof(*v));
}
}
inline grant_detail_t::grant_detail_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_grant_time(_pool)
,_m_valid_time(_pool)
,_m_modify_time(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline grant_detail_t::grant_detail_t(const grant_detail_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_grant_time(_pool)
,_m_valid_time(_pool)
,_m_modify_time(_pool)
,_unknown(_pool){
assign(v);
}
inline grant_detail_t::~grant_detail_t(){
}
inline grant_detail_t& grant_detail_t::operator=(const grant_detail_t& v){
assign(v);
return *this;
}
inline void grant_detail_t::clear(){
_m_id.clear();
_m_grant_time.clear();
_m_valid_time.clear();
_m_modify_time.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void grant_detail_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string grant_time;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "grant_time" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_grant_time.get();

}
// @@string valid_time;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "valid_time" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_valid_time.get();

}
// @@string modify_time;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "modify_time" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_modify_time.get();

}

::idl::McpackBean::check();
}
inline void grant_detail_t::detach(){
_m_id.detach();
_m_grant_time.detach();
_m_valid_time.detach();
_m_modify_time.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline grant_detail_t& grant_detail_t::assign(const grant_detail_t& v){
_m_id=v._m_id;
_m_grant_time=v._m_grant_time;
_m_valid_time=v._m_valid_time;
_m_modify_time=v._m_modify_time;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool grant_detail_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* grant_detail_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline grant_detail_t& grant_detail_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline grant_detail_t& grant_detail_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void grant_detail_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool grant_detail_t::has_grant_time() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* grant_detail_t::grant_time(unsigned int* size) const{
return _m_grant_time.get(size);
}
inline grant_detail_t& grant_detail_t::set_grant_time(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_grant_time.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline grant_detail_t& grant_detail_t::set_ptr_grant_time(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_grant_time.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void grant_detail_t::clear_grant_time(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_grant_time.clear();
}
inline bool grant_detail_t::has_valid_time() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* grant_detail_t::valid_time(unsigned int* size) const{
return _m_valid_time.get(size);
}
inline grant_detail_t& grant_detail_t::set_valid_time(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_valid_time.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline grant_detail_t& grant_detail_t::set_ptr_valid_time(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_valid_time.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void grant_detail_t::clear_valid_time(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_valid_time.clear();
}
inline bool grant_detail_t::has_modify_time() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* grant_detail_t::modify_time(unsigned int* size) const{
return _m_modify_time.get(size);
}
inline grant_detail_t& grant_detail_t::set_modify_time(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_modify_time.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline grant_detail_t& grant_detail_t::set_ptr_modify_time(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_modify_time.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void grant_detail_t::clear_modify_time(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_modify_time.clear();
}
inline ::idl::Unknown* grant_detail_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& grant_detail_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& grant_detail_t::unknown(){
return _unknown;
}
inline size_t grant_detail_t::unknown_size() const{
return _unknown.size();
}
inline download_detail_t* download_detail_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
download_detail_t* tmp=(download_detail_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)download_detail_t(pool);
return tmp;
}
inline void download_detail_t::destroy(download_detail_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~download_detail_t();
pool->free(v,sizeof(*v));
}
}
inline download_detail_t::download_detail_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_url(_pool)
,_m_baidu_url(_pool)
,_m_url_type(_pool)
,_m_media_format(_pool)
,_m_size(_pool)
,_m_mtype(_pool)
,_m_charge_id(_pool)
,_m_charge_value(_pool)
,_m_apk_flag(_pool)
,_m_channel_info(_pool)
,_m_channel_id(_pool)
,_m_package_name(_pool)
,_m_int_version(_pool)
,_m_string_version(_pool)
,_m_sdk_version(_pool)
,_m_apk_md5(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline download_detail_t::download_detail_t(const download_detail_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_url(_pool)
,_m_baidu_url(_pool)
,_m_url_type(_pool)
,_m_media_format(_pool)
,_m_size(_pool)
,_m_mtype(_pool)
,_m_charge_id(_pool)
,_m_charge_value(_pool)
,_m_apk_flag(_pool)
,_m_channel_info(_pool)
,_m_channel_id(_pool)
,_m_package_name(_pool)
,_m_int_version(_pool)
,_m_string_version(_pool)
,_m_sdk_version(_pool)
,_m_apk_md5(_pool)
,_unknown(_pool){
assign(v);
}
inline download_detail_t::~download_detail_t(){
}
inline download_detail_t& download_detail_t::operator=(const download_detail_t& v){
assign(v);
return *this;
}
inline void download_detail_t::clear(){
_m_id.clear();
_m_url.clear();
_m_baidu_url.clear();
_m_url_type.clear();
_m_media_format.clear();
_m_size.clear();
_m_mtype.clear();
_m_charge_id.clear();
_m_charge_value.clear();
_m_apk_flag.clear();
_m_channel_info.clear();
_m_channel_id.clear();
_m_package_name.clear();
_m_int_version.clear();
_m_string_version.clear();
_m_sdk_version.clear();
_m_apk_md5.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void download_detail_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string url;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_url.get();

}
// @@string baidu_url;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "baidu_url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_baidu_url.get();

}
// @@string url_type;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "url_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_url_type.get();

}
// @@string media_format;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "media_format" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_media_format.get();

}
// @@string size;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "size" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_size.get();

}
// @@string mtype;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "mtype" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_mtype.get();

}
// @@string charge_id;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "charge_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_charge_id.get();

}
// @@string charge_value;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "charge_value" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_charge_value.get();

}
// @@string apk_flag;
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "apk_flag" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_apk_flag.get();

}
// @@string channel_info;
if(!(_flag[10 >> 3] & (1 << (10 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "channel_info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_channel_info.get();

}
// @@string channel_id;
if(!(_flag[11 >> 3] & (1 << (11 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "channel_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_channel_id.get();

}
// @@string package_name;
if(!(_flag[12 >> 3] & (1 << (12 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "package_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_package_name.get();

}
// @@string int_version;
if(!(_flag[13 >> 3] & (1 << (13 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "int_version" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_int_version.get();

}
// @@string string_version;
if(!(_flag[14 >> 3] & (1 << (14 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "string_version" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_string_version.get();

}
// @@string sdk_version;
if(!(_flag[15 >> 3] & (1 << (15 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "sdk_version" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_sdk_version.get();

}
// @@string apk_md5;
if(!(_flag[16 >> 3] & (1 << (16 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "apk_md5" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_apk_md5.get();

}

::idl::McpackBean::check();
}
inline void download_detail_t::detach(){
_m_id.detach();
_m_url.detach();
_m_baidu_url.detach();
_m_url_type.detach();
_m_media_format.detach();
_m_size.detach();
_m_mtype.detach();
_m_charge_id.detach();
_m_charge_value.detach();
_m_apk_flag.detach();
_m_channel_info.detach();
_m_channel_id.detach();
_m_package_name.detach();
_m_int_version.detach();
_m_string_version.detach();
_m_sdk_version.detach();
_m_apk_md5.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline download_detail_t& download_detail_t::assign(const download_detail_t& v){
_m_id=v._m_id;
_m_url=v._m_url;
_m_baidu_url=v._m_baidu_url;
_m_url_type=v._m_url_type;
_m_media_format=v._m_media_format;
_m_size=v._m_size;
_m_mtype=v._m_mtype;
_m_charge_id=v._m_charge_id;
_m_charge_value=v._m_charge_value;
_m_apk_flag=v._m_apk_flag;
_m_channel_info=v._m_channel_info;
_m_channel_id=v._m_channel_id;
_m_package_name=v._m_package_name;
_m_int_version=v._m_int_version;
_m_string_version=v._m_string_version;
_m_sdk_version=v._m_sdk_version;
_m_apk_md5=v._m_apk_md5;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool download_detail_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* download_detail_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline download_detail_t& download_detail_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool download_detail_t::has_url() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* download_detail_t::url(unsigned int* size) const{
return _m_url.get(size);
}
inline download_detail_t& download_detail_t::set_url(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_url(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_url(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_url.clear();
}
inline bool download_detail_t::has_baidu_url() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* download_detail_t::baidu_url(unsigned int* size) const{
return _m_baidu_url.get(size);
}
inline download_detail_t& download_detail_t::set_baidu_url(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_baidu_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_baidu_url(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_baidu_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_baidu_url(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_baidu_url.clear();
}
inline bool download_detail_t::has_url_type() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* download_detail_t::url_type(unsigned int* size) const{
return _m_url_type.get(size);
}
inline download_detail_t& download_detail_t::set_url_type(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_url_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_url_type(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_url_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_url_type(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_url_type.clear();
}
inline bool download_detail_t::has_media_format() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* download_detail_t::media_format(unsigned int* size) const{
return _m_media_format.get(size);
}
inline download_detail_t& download_detail_t::set_media_format(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_media_format.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_media_format(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_media_format.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_media_format(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_media_format.clear();
}
inline bool download_detail_t::has_size() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* download_detail_t::size(unsigned int* size) const{
return _m_size.get(size);
}
inline download_detail_t& download_detail_t::set_size(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_size.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_size(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_size.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_size(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_size.clear();
}
inline bool download_detail_t::has_mtype() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* download_detail_t::mtype(unsigned int* size) const{
return _m_mtype.get(size);
}
inline download_detail_t& download_detail_t::set_mtype(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_mtype.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_mtype(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_mtype.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_mtype(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_mtype.clear();
}
inline bool download_detail_t::has_charge_id() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* download_detail_t::charge_id(unsigned int* size) const{
return _m_charge_id.get(size);
}
inline download_detail_t& download_detail_t::set_charge_id(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_charge_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_charge_id(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_charge_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_charge_id(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_charge_id.clear();
}
inline bool download_detail_t::has_charge_value() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* download_detail_t::charge_value(unsigned int* size) const{
return _m_charge_value.get(size);
}
inline download_detail_t& download_detail_t::set_charge_value(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_charge_value.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_charge_value(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_charge_value.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_charge_value(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_charge_value.clear();
}
inline bool download_detail_t::has_apk_flag() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline const char* download_detail_t::apk_flag(unsigned int* size) const{
return _m_apk_flag.get(size);
}
inline download_detail_t& download_detail_t::set_apk_flag(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_apk_flag.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_apk_flag(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_apk_flag.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_apk_flag(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_apk_flag.clear();
}
inline bool download_detail_t::has_channel_info() const{
return (_flag[10 >> 3] & (1 << (10 & 0x7)));
}
inline const char* download_detail_t::channel_info(unsigned int* size) const{
return _m_channel_info.get(size);
}
inline download_detail_t& download_detail_t::set_channel_info(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_channel_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_channel_info(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_channel_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_channel_info(){
_flag[10 >> 3] &= ~(1 << (10 & 0x7));
 _m_channel_info.clear();
}
inline bool download_detail_t::has_channel_id() const{
return (_flag[11 >> 3] & (1 << (11 & 0x7)));
}
inline const char* download_detail_t::channel_id(unsigned int* size) const{
return _m_channel_id.get(size);
}
inline download_detail_t& download_detail_t::set_channel_id(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_channel_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_channel_id(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_channel_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_channel_id(){
_flag[11 >> 3] &= ~(1 << (11 & 0x7));
 _m_channel_id.clear();
}
inline bool download_detail_t::has_package_name() const{
return (_flag[12 >> 3] & (1 << (12 & 0x7)));
}
inline const char* download_detail_t::package_name(unsigned int* size) const{
return _m_package_name.get(size);
}
inline download_detail_t& download_detail_t::set_package_name(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_package_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_package_name(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_package_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_package_name(){
_flag[12 >> 3] &= ~(1 << (12 & 0x7));
 _m_package_name.clear();
}
inline bool download_detail_t::has_int_version() const{
return (_flag[13 >> 3] & (1 << (13 & 0x7)));
}
inline const char* download_detail_t::int_version(unsigned int* size) const{
return _m_int_version.get(size);
}
inline download_detail_t& download_detail_t::set_int_version(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_int_version.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_int_version(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_int_version.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_int_version(){
_flag[13 >> 3] &= ~(1 << (13 & 0x7));
 _m_int_version.clear();
}
inline bool download_detail_t::has_string_version() const{
return (_flag[14 >> 3] & (1 << (14 & 0x7)));
}
inline const char* download_detail_t::string_version(unsigned int* size) const{
return _m_string_version.get(size);
}
inline download_detail_t& download_detail_t::set_string_version(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_string_version.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_string_version(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_string_version.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_string_version(){
_flag[14 >> 3] &= ~(1 << (14 & 0x7));
 _m_string_version.clear();
}
inline bool download_detail_t::has_sdk_version() const{
return (_flag[15 >> 3] & (1 << (15 & 0x7)));
}
inline const char* download_detail_t::sdk_version(unsigned int* size) const{
return _m_sdk_version.get(size);
}
inline download_detail_t& download_detail_t::set_sdk_version(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_sdk_version.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_sdk_version(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_sdk_version.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_sdk_version(){
_flag[15 >> 3] &= ~(1 << (15 & 0x7));
 _m_sdk_version.clear();
}
inline bool download_detail_t::has_apk_md5() const{
return (_flag[16 >> 3] & (1 << (16 & 0x7)));
}
inline const char* download_detail_t::apk_md5(unsigned int* size) const{
return _m_apk_md5.get(size);
}
inline download_detail_t& download_detail_t::set_apk_md5(const char* s,ssize_t size){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 _m_apk_md5.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline download_detail_t& download_detail_t::set_ptr_apk_md5(const char* s,ssize_t size){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 _m_apk_md5.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void download_detail_t::clear_apk_md5(){
_flag[16 >> 3] &= ~(1 << (16 & 0x7));
 _m_apk_md5.clear();
}
inline ::idl::Unknown* download_detail_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& download_detail_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& download_detail_t::unknown(){
return _unknown;
}
inline size_t download_detail_t::unknown_size() const{
return _unknown.size();
}
inline championship_info_t* championship_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
championship_info_t* tmp=(championship_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)championship_info_t(pool);
return tmp;
}
inline void championship_info_t::destroy(championship_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~championship_info_t();
pool->free(v,sizeof(*v));
}
}
inline championship_info_t::championship_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_name(_pool)
,_m_game_name(_pool)
,_m_union_start_action(_pool)
,_m_has_account(_pool)
,_m_c_id(_pool)
,_m_log_date(_pool)
,_m_channel_info(_pool)
,_m_start_time(_pool)
,_m_end_time(_pool)
,_m_join_num(_pool)
,_m_award(_pool)
,_m_rule(_pool)
,_m_total_coins(_pool)
,_m_pic_url(_pool)
,_m_enable(_pool)
,_m_top_award(_pool)
,_m_championship_download_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline championship_info_t::championship_info_t(const championship_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_name(_pool)
,_m_game_name(_pool)
,_m_union_start_action(_pool)
,_m_has_account(_pool)
,_m_c_id(_pool)
,_m_log_date(_pool)
,_m_channel_info(_pool)
,_m_start_time(_pool)
,_m_end_time(_pool)
,_m_join_num(_pool)
,_m_award(_pool)
,_m_rule(_pool)
,_m_total_coins(_pool)
,_m_pic_url(_pool)
,_m_enable(_pool)
,_m_top_award(_pool)
,_m_championship_download_list(_pool)
,_unknown(_pool){
assign(v);
}
inline championship_info_t::~championship_info_t(){
}
inline championship_info_t& championship_info_t::operator=(const championship_info_t& v){
assign(v);
return *this;
}
inline void championship_info_t::clear(){
_m_name.clear();
_m_game_name.clear();
_m_union_start_action.clear();
_m_has_account.clear();
_m_c_id.clear();
_m_log_date.clear();
_m_channel_info.clear();
_m_start_time.clear();
_m_end_time.clear();
_m_join_num.clear();
_m_award.clear();
_m_rule.clear();
_m_total_coins.clear();
_m_pic_url.clear();
_m_enable.clear();
_m_top_award.clear();
_m_championship_download_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void championship_info_t::check() const{
// @@string name;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string game_name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_name.get();

}
// @@string union_start_action;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "union_start_action" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_union_start_action.get();

}
// @@string has_account;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "has_account" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_has_account.get();

}
// @@string c_id;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string log_date;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "log_date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_log_date.get();

}
// @@string channel_info;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "channel_info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_channel_info.get();

}
// @@string start_time;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "start_time" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_start_time.get();

}
// @@string end_time;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "end_time" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_end_time.get();

}
// @@string join_num;
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "join_num" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_join_num.get();

}
// @@string award;
if(!(_flag[10 >> 3] & (1 << (10 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "award" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_award.get();

}
// @@string rule;
if(!(_flag[11 >> 3] & (1 << (11 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "rule" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_rule.get();

}
// @@string total_coins;
if(!(_flag[12 >> 3] & (1 << (12 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "total_coins" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_total_coins.get();

}
// @@string pic_url;
if(!(_flag[13 >> 3] & (1 << (13 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "pic_url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_pic_url.get();

}
// @@string enable;
if(!(_flag[14 >> 3] & (1 << (14 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "enable" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_enable.get();

}
// @@string top_award;
if(!(_flag[15 >> 3] & (1 << (15 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "top_award" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_top_award.get();

}
// @@download_detail_t championship_download_list=array(0);
if(!(_flag[16 >> 3] & (1 << (16 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "championship_download_list" << "' not found";
}
{
// level 0 begin
typeof(_m_championship_download_list)& lr0=(_m_championship_download_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::download_detail_t& item=const_cast< ::idl::download_detail_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void championship_info_t::detach(){
_m_name.detach();
_m_game_name.detach();
_m_union_start_action.detach();
_m_has_account.detach();
_m_c_id.detach();
_m_log_date.detach();
_m_channel_info.detach();
_m_start_time.detach();
_m_end_time.detach();
_m_join_num.detach();
_m_award.detach();
_m_rule.detach();
_m_total_coins.detach();
_m_pic_url.detach();
_m_enable.detach();
_m_top_award.detach();
_m_championship_download_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline championship_info_t& championship_info_t::assign(const championship_info_t& v){
_m_name=v._m_name;
_m_game_name=v._m_game_name;
_m_union_start_action=v._m_union_start_action;
_m_has_account=v._m_has_account;
_m_c_id=v._m_c_id;
_m_log_date=v._m_log_date;
_m_channel_info=v._m_channel_info;
_m_start_time=v._m_start_time;
_m_end_time=v._m_end_time;
_m_join_num=v._m_join_num;
_m_award=v._m_award;
_m_rule=v._m_rule;
_m_total_coins=v._m_total_coins;
_m_pic_url=v._m_pic_url;
_m_enable=v._m_enable;
_m_top_award=v._m_top_award;
_m_championship_download_list=v._m_championship_download_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool championship_info_t::has_name() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* championship_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline championship_info_t& championship_info_t::set_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_name(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_name.clear();
}
inline bool championship_info_t::has_game_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* championship_info_t::game_name(unsigned int* size) const{
return _m_game_name.get(size);
}
inline championship_info_t& championship_info_t::set_game_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_game_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_game_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_name.clear();
}
inline bool championship_info_t::has_union_start_action() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* championship_info_t::union_start_action(unsigned int* size) const{
return _m_union_start_action.get(size);
}
inline championship_info_t& championship_info_t::set_union_start_action(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_union_start_action.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_union_start_action(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_union_start_action.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_union_start_action(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_union_start_action.clear();
}
inline bool championship_info_t::has_has_account() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* championship_info_t::has_account(unsigned int* size) const{
return _m_has_account.get(size);
}
inline championship_info_t& championship_info_t::set_has_account(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_has_account.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_has_account(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_has_account.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_has_account(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_has_account.clear();
}
inline bool championship_info_t::has_c_id() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* championship_info_t::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline championship_info_t& championship_info_t::set_c_id(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_c_id(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_c_id(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_c_id.clear();
}
inline bool championship_info_t::has_log_date() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* championship_info_t::log_date(unsigned int* size) const{
return _m_log_date.get(size);
}
inline championship_info_t& championship_info_t::set_log_date(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_log_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_log_date(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_log_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_log_date(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_log_date.clear();
}
inline bool championship_info_t::has_channel_info() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* championship_info_t::channel_info(unsigned int* size) const{
return _m_channel_info.get(size);
}
inline championship_info_t& championship_info_t::set_channel_info(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_channel_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_channel_info(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_channel_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_channel_info(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_channel_info.clear();
}
inline bool championship_info_t::has_start_time() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* championship_info_t::start_time(unsigned int* size) const{
return _m_start_time.get(size);
}
inline championship_info_t& championship_info_t::set_start_time(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_start_time.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_start_time(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_start_time.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_start_time(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_start_time.clear();
}
inline bool championship_info_t::has_end_time() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* championship_info_t::end_time(unsigned int* size) const{
return _m_end_time.get(size);
}
inline championship_info_t& championship_info_t::set_end_time(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_end_time.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_end_time(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_end_time.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_end_time(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_end_time.clear();
}
inline bool championship_info_t::has_join_num() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline const char* championship_info_t::join_num(unsigned int* size) const{
return _m_join_num.get(size);
}
inline championship_info_t& championship_info_t::set_join_num(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_join_num.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_join_num(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_join_num.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_join_num(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_join_num.clear();
}
inline bool championship_info_t::has_award() const{
return (_flag[10 >> 3] & (1 << (10 & 0x7)));
}
inline const char* championship_info_t::award(unsigned int* size) const{
return _m_award.get(size);
}
inline championship_info_t& championship_info_t::set_award(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_award.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_award(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_award.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_award(){
_flag[10 >> 3] &= ~(1 << (10 & 0x7));
 _m_award.clear();
}
inline bool championship_info_t::has_rule() const{
return (_flag[11 >> 3] & (1 << (11 & 0x7)));
}
inline const char* championship_info_t::rule(unsigned int* size) const{
return _m_rule.get(size);
}
inline championship_info_t& championship_info_t::set_rule(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_rule.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_rule(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_rule.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_rule(){
_flag[11 >> 3] &= ~(1 << (11 & 0x7));
 _m_rule.clear();
}
inline bool championship_info_t::has_total_coins() const{
return (_flag[12 >> 3] & (1 << (12 & 0x7)));
}
inline const char* championship_info_t::total_coins(unsigned int* size) const{
return _m_total_coins.get(size);
}
inline championship_info_t& championship_info_t::set_total_coins(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_total_coins.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_total_coins(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_total_coins.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_total_coins(){
_flag[12 >> 3] &= ~(1 << (12 & 0x7));
 _m_total_coins.clear();
}
inline bool championship_info_t::has_pic_url() const{
return (_flag[13 >> 3] & (1 << (13 & 0x7)));
}
inline const char* championship_info_t::pic_url(unsigned int* size) const{
return _m_pic_url.get(size);
}
inline championship_info_t& championship_info_t::set_pic_url(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_pic_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_pic_url(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_pic_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_pic_url(){
_flag[13 >> 3] &= ~(1 << (13 & 0x7));
 _m_pic_url.clear();
}
inline bool championship_info_t::has_enable() const{
return (_flag[14 >> 3] & (1 << (14 & 0x7)));
}
inline const char* championship_info_t::enable(unsigned int* size) const{
return _m_enable.get(size);
}
inline championship_info_t& championship_info_t::set_enable(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_enable.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_enable(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_enable.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_enable(){
_flag[14 >> 3] &= ~(1 << (14 & 0x7));
 _m_enable.clear();
}
inline bool championship_info_t::has_top_award() const{
return (_flag[15 >> 3] & (1 << (15 & 0x7)));
}
inline const char* championship_info_t::top_award(unsigned int* size) const{
return _m_top_award.get(size);
}
inline championship_info_t& championship_info_t::set_top_award(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_top_award.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline championship_info_t& championship_info_t::set_ptr_top_award(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_top_award.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void championship_info_t::clear_top_award(){
_flag[15 >> 3] &= ~(1 << (15 & 0x7));
 _m_top_award.clear();
}
inline bool championship_info_t::has_championship_download_list() const{
return (_flag[16 >> 3] & (1 << (16 & 0x7)));
}
inline const ::idl::vector< ::idl::download_detail_t >& championship_info_t::championship_download_list() const{
 return _m_championship_download_list;
}
inline void championship_info_t::clear_championship_download_list(){
_flag[16 >> 3] &= ~(1 << (16 & 0x7));
 _m_championship_download_list.clear();
}
inline ::idl::vector< ::idl::download_detail_t >* championship_info_t::mutable_championship_download_list(){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 return &(_m_championship_download_list);
}
inline ::idl::vector< ::idl::download_detail_t >* championship_info_t::m_championship_download_list(){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 return &(_m_championship_download_list);
}
inline size_t championship_info_t::championship_download_list_size() const{
/*  */ return _m_championship_download_list.size();
}
inline const ::idl::download_detail_t& championship_info_t::championship_download_list(size_t i0) const{
 return _m_championship_download_list.get(i0);
}
inline ::idl::download_detail_t* championship_info_t::mutable_championship_download_list(size_t i0){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 return _m_championship_download_list.mutable_get(i0);
}
inline ::idl::download_detail_t* championship_info_t::m_championship_download_list(size_t i0){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 return _m_championship_download_list.mutable_get(i0);
}
inline ::idl::Unknown* championship_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& championship_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& championship_info_t::unknown(){
return _unknown;
}
inline size_t championship_info_t::unknown_size() const{
return _unknown.size();
}
inline content_basic_info_t* content_basic_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
content_basic_info_t* tmp=(content_basic_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)content_basic_info_t(pool);
return tmp;
}
inline void content_basic_info_t::destroy(content_basic_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~content_basic_info_t();
pool->free(v,sizeof(*v));
}
}
inline content_basic_info_t::content_basic_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_type(_pool)
,_m_ext_id(_pool)
,_m_abstract_(_pool)
,_m_version(_pool)
,_m_method(_pool)
,_m_star(_pool)
,_m_network(_pool)
,_m_code(_pool)
,_m_log_date(_pool)
,_m_mod_date(_pool)
,_m_dft_charge_type(_pool)
,_m_dft_charge_val(_pool)
,_m_enName(_pool)
,_m_language(_pool)
,_m_adapt(_pool)
,_m_package_name(_pool)
,_m_version_appinfo(_pool)
,_m_sdk_version(_pool)
,_m_version_code(_pool)
,_m_ptype_0(_pool)
,_m_ptype_1(_pool)
,_m_ptype_2(_pool)
,_m_ptype_3(_pool)
,_m_ptype_4(_pool)
,_m_pub_props(_pool)
,_m_pub_prop_info(_pool)
,_m_union_start_action(_pool)
,_m_has_account(_pool)
,_m_editor_recom(_pool)
,_m_show_highspeed(_pool)
,_m_bind_resource_id(_pool)
,_m_class_info(_pool)
,_m_img_info(_pool)
,_m_cp_info(0)
,_m_grant_info(0)
,_unknown(_pool){
_m_cp_info=::idl::cp_info_t::create(_pool);
_m_grant_info=::idl::grant_detail_t::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline content_basic_info_t::content_basic_info_t(const content_basic_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_type(_pool)
,_m_ext_id(_pool)
,_m_abstract_(_pool)
,_m_version(_pool)
,_m_method(_pool)
,_m_star(_pool)
,_m_network(_pool)
,_m_code(_pool)
,_m_log_date(_pool)
,_m_mod_date(_pool)
,_m_dft_charge_type(_pool)
,_m_dft_charge_val(_pool)
,_m_enName(_pool)
,_m_language(_pool)
,_m_adapt(_pool)
,_m_package_name(_pool)
,_m_version_appinfo(_pool)
,_m_sdk_version(_pool)
,_m_version_code(_pool)
,_m_ptype_0(_pool)
,_m_ptype_1(_pool)
,_m_ptype_2(_pool)
,_m_ptype_3(_pool)
,_m_ptype_4(_pool)
,_m_pub_props(_pool)
,_m_pub_prop_info(_pool)
,_m_union_start_action(_pool)
,_m_has_account(_pool)
,_m_editor_recom(_pool)
,_m_show_highspeed(_pool)
,_m_bind_resource_id(_pool)
,_m_class_info(_pool)
,_m_img_info(_pool)
,_m_cp_info(0)
,_m_grant_info(0)
,_unknown(_pool){
_m_cp_info=::idl::cp_info_t::create(_pool);
_m_grant_info=::idl::grant_detail_t::create(_pool);
assign(v);
}
inline content_basic_info_t::~content_basic_info_t(){
if(_m_cp_info){
::idl::cp_info_t::destroy(_m_cp_info);
_m_cp_info=0;
}
if(_m_grant_info){
::idl::grant_detail_t::destroy(_m_grant_info);
_m_grant_info=0;
}
}
inline content_basic_info_t& content_basic_info_t::operator=(const content_basic_info_t& v){
assign(v);
return *this;
}
inline void content_basic_info_t::clear(){
_m_id.clear();
_m_name.clear();
_m_type.clear();
_m_ext_id.clear();
_m_abstract_.clear();
_m_version.clear();
_m_method.clear();
_m_star.clear();
_m_network.clear();
_m_code.clear();
_m_log_date.clear();
_m_mod_date.clear();
_m_dft_charge_type.clear();
_m_dft_charge_val.clear();
_m_enName.clear();
_m_language.clear();
_m_adapt.clear();
_m_package_name.clear();
_m_version_appinfo.clear();
_m_sdk_version.clear();
_m_version_code.clear();
_m_ptype_0.clear();
_m_ptype_1.clear();
_m_ptype_2.clear();
_m_ptype_3.clear();
_m_ptype_4.clear();
_m_pub_props.clear();
_m_pub_prop_info.clear();
_m_union_start_action.clear();
_m_has_account.clear();
_m_editor_recom.clear();
_m_show_highspeed.clear();
_m_bind_resource_id.clear();
_m_class_info.clear();
_m_img_info.clear();
if(_m_cp_info){
_m_cp_info->clear();
}
if(_m_grant_info){
_m_grant_info->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void content_basic_info_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string type;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type.get();

}
// @@string ext_id;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ext_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ext_id.get();

}
// @@string abstract_;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "abstract_" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_abstract_.get();

}
// @@string version;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "version" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_version.get();

}
// @@string method;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "method" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_method.get();

}
// @@string star;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "star" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_star.get();

}
// @@string network;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "network" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_network.get();

}
// @@string code;
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "code" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_code.get();

}
// @@string log_date;
if(!(_flag[10 >> 3] & (1 << (10 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "log_date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_log_date.get();

}
// @@string mod_date;
if(!(_flag[11 >> 3] & (1 << (11 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "mod_date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_mod_date.get();

}
// @@string dft_charge_type;
if(!(_flag[12 >> 3] & (1 << (12 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "dft_charge_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_dft_charge_type.get();

}
// @@string dft_charge_val;
if(!(_flag[13 >> 3] & (1 << (13 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "dft_charge_val" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_dft_charge_val.get();

}
// @@string enName;
if(!(_flag[14 >> 3] & (1 << (14 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "enName" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_enName.get();

}
// @@string language;
if(!(_flag[15 >> 3] & (1 << (15 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "language" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_language.get();

}
// @@string adapt;
if(!(_flag[16 >> 3] & (1 << (16 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "adapt" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_adapt.get();

}
// @@string package_name;
if(!(_flag[17 >> 3] & (1 << (17 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "package_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_package_name.get();

}
// @@string version_appinfo;
if(!(_flag[18 >> 3] & (1 << (18 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "version_appinfo" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_version_appinfo.get();

}
// @@string sdk_version;
if(!(_flag[19 >> 3] & (1 << (19 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "sdk_version" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_sdk_version.get();

}
// @@string version_code;
if(!(_flag[20 >> 3] & (1 << (20 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "version_code" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_version_code.get();

}
// @@string ptype_0;
if(!(_flag[21 >> 3] & (1 << (21 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ptype_0" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ptype_0.get();

}
// @@string ptype_1;
if(!(_flag[22 >> 3] & (1 << (22 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ptype_1" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ptype_1.get();

}
// @@string ptype_2;
if(!(_flag[23 >> 3] & (1 << (23 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ptype_2" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ptype_2.get();

}
// @@string ptype_3;
if(!(_flag[24 >> 3] & (1 << (24 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ptype_3" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ptype_3.get();

}
// @@string ptype_4;
if(!(_flag[25 >> 3] & (1 << (25 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ptype_4" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ptype_4.get();

}
// @@string pub_props=array(0);
if(!(_flag[26 >> 3] & (1 << (26 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "pub_props" << "' not found";
}
{
// level 0 begin
typeof(_m_pub_props)& lr0=(_m_pub_props);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@pub_prop_info_t pub_prop_info=array(0);
if(!(_flag[27 >> 3] & (1 << (27 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "pub_prop_info" << "' not found";
}
{
// level 0 begin
typeof(_m_pub_prop_info)& lr0=(_m_pub_prop_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::pub_prop_info_t& item=const_cast< ::idl::pub_prop_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@string union_start_action;
if(!(_flag[28 >> 3] & (1 << (28 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "union_start_action" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_union_start_action.get();

}
// @@string has_account;
if(!(_flag[29 >> 3] & (1 << (29 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "has_account" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_has_account.get();

}
// @@string editor_recom;
if(!(_flag[30 >> 3] & (1 << (30 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "editor_recom" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_editor_recom.get();

}
// @@string show_highspeed;
if(!(_flag[31 >> 3] & (1 << (31 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "show_highspeed" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_show_highspeed.get();

}
// @@string bind_resource_id;
if(!(_flag[32 >> 3] & (1 << (32 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "bind_resource_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_bind_resource_id.get();

}
// @@class_info_t class_info=array(0);
if(!(_flag[33 >> 3] & (1 << (33 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_info" << "' not found";
}
{
// level 0 begin
typeof(_m_class_info)& lr0=(_m_class_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::class_info_t& item=const_cast< ::idl::class_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@img_info_t img_info=array(0);
if(!(_flag[34 >> 3] & (1 << (34 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "img_info" << "' not found";
}
{
// level 0 begin
typeof(_m_img_info)& lr0=(_m_img_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::img_info_t& item=const_cast< ::idl::img_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@cp_info_t cp_info;
if(!(_flag[35 >> 3] & (1 << (35 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cp_info" << "' not found";
}
{
::idl::cp_info_t& item=const_cast< ::idl::cp_info_t& >(*_m_cp_info);
item.check();

}
// @@grant_detail_t grant_info;
if(!(_flag[36 >> 3] & (1 << (36 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "grant_info" << "' not found";
}
{
::idl::grant_detail_t& item=const_cast< ::idl::grant_detail_t& >(*_m_grant_info);
item.check();

}

::idl::McpackBean::check();
}
inline void content_basic_info_t::detach(){
_m_id.detach();
_m_name.detach();
_m_type.detach();
_m_ext_id.detach();
_m_abstract_.detach();
_m_version.detach();
_m_method.detach();
_m_star.detach();
_m_network.detach();
_m_code.detach();
_m_log_date.detach();
_m_mod_date.detach();
_m_dft_charge_type.detach();
_m_dft_charge_val.detach();
_m_enName.detach();
_m_language.detach();
_m_adapt.detach();
_m_package_name.detach();
_m_version_appinfo.detach();
_m_sdk_version.detach();
_m_version_code.detach();
_m_ptype_0.detach();
_m_ptype_1.detach();
_m_ptype_2.detach();
_m_ptype_3.detach();
_m_ptype_4.detach();
_m_pub_props.detach();
_m_pub_prop_info.detach();
_m_union_start_action.detach();
_m_has_account.detach();
_m_editor_recom.detach();
_m_show_highspeed.detach();
_m_bind_resource_id.detach();
_m_class_info.detach();
_m_img_info.detach();
if(_m_cp_info){
_m_cp_info->detach();
}
if(_m_grant_info){
_m_grant_info->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline content_basic_info_t& content_basic_info_t::assign(const content_basic_info_t& v){
_m_id=v._m_id;
_m_name=v._m_name;
_m_type=v._m_type;
_m_ext_id=v._m_ext_id;
_m_abstract_=v._m_abstract_;
_m_version=v._m_version;
_m_method=v._m_method;
_m_star=v._m_star;
_m_network=v._m_network;
_m_code=v._m_code;
_m_log_date=v._m_log_date;
_m_mod_date=v._m_mod_date;
_m_dft_charge_type=v._m_dft_charge_type;
_m_dft_charge_val=v._m_dft_charge_val;
_m_enName=v._m_enName;
_m_language=v._m_language;
_m_adapt=v._m_adapt;
_m_package_name=v._m_package_name;
_m_version_appinfo=v._m_version_appinfo;
_m_sdk_version=v._m_sdk_version;
_m_version_code=v._m_version_code;
_m_ptype_0=v._m_ptype_0;
_m_ptype_1=v._m_ptype_1;
_m_ptype_2=v._m_ptype_2;
_m_ptype_3=v._m_ptype_3;
_m_ptype_4=v._m_ptype_4;
_m_pub_props=v._m_pub_props;
_m_pub_prop_info=v._m_pub_prop_info;
_m_union_start_action=v._m_union_start_action;
_m_has_account=v._m_has_account;
_m_editor_recom=v._m_editor_recom;
_m_show_highspeed=v._m_show_highspeed;
_m_bind_resource_id=v._m_bind_resource_id;
_m_class_info=v._m_class_info;
_m_img_info=v._m_img_info;
if(!v._m_cp_info){
if(_m_cp_info){
::idl::cp_info_t::destroy(_m_cp_info);
}
_m_cp_info=0;
}else{
if(!_m_cp_info){
_m_cp_info=::idl::cp_info_t::create(_pool);
}
*_m_cp_info=*v._m_cp_info;
}
if(!v._m_grant_info){
if(_m_grant_info){
::idl::grant_detail_t::destroy(_m_grant_info);
}
_m_grant_info=0;
}else{
if(!_m_grant_info){
_m_grant_info=::idl::grant_detail_t::create(_pool);
}
*_m_grant_info=*v._m_grant_info;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool content_basic_info_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* content_basic_info_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool content_basic_info_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* content_basic_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool content_basic_info_t::has_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* content_basic_info_t::type(unsigned int* size) const{
return _m_type.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_type.clear();
}
inline bool content_basic_info_t::has_ext_id() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* content_basic_info_t::ext_id(unsigned int* size) const{
return _m_ext_id.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_ext_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_ext_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_ext_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_ext_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_ext_id(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_ext_id.clear();
}
inline bool content_basic_info_t::has_abstract_() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* content_basic_info_t::abstract_(unsigned int* size) const{
return _m_abstract_.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_abstract_(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_abstract_.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_abstract_(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_abstract_.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_abstract_(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_abstract_.clear();
}
inline bool content_basic_info_t::has_version() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* content_basic_info_t::version(unsigned int* size) const{
return _m_version.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_version(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_version.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_version(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_version.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_version(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_version.clear();
}
inline bool content_basic_info_t::has_method() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* content_basic_info_t::method(unsigned int* size) const{
return _m_method.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_method(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_method.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_method(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_method.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_method(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_method.clear();
}
inline bool content_basic_info_t::has_star() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* content_basic_info_t::star(unsigned int* size) const{
return _m_star.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_star(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_star.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_star(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_star.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_star(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_star.clear();
}
inline bool content_basic_info_t::has_network() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* content_basic_info_t::network(unsigned int* size) const{
return _m_network.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_network(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_network.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_network(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_network.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_network(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_network.clear();
}
inline bool content_basic_info_t::has_code() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline const char* content_basic_info_t::code(unsigned int* size) const{
return _m_code.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_code(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_code.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_code(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_code.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_code(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_code.clear();
}
inline bool content_basic_info_t::has_log_date() const{
return (_flag[10 >> 3] & (1 << (10 & 0x7)));
}
inline const char* content_basic_info_t::log_date(unsigned int* size) const{
return _m_log_date.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_log_date(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_log_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_log_date(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_log_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_log_date(){
_flag[10 >> 3] &= ~(1 << (10 & 0x7));
 _m_log_date.clear();
}
inline bool content_basic_info_t::has_mod_date() const{
return (_flag[11 >> 3] & (1 << (11 & 0x7)));
}
inline const char* content_basic_info_t::mod_date(unsigned int* size) const{
return _m_mod_date.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_mod_date(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_mod_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_mod_date(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_mod_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_mod_date(){
_flag[11 >> 3] &= ~(1 << (11 & 0x7));
 _m_mod_date.clear();
}
inline bool content_basic_info_t::has_dft_charge_type() const{
return (_flag[12 >> 3] & (1 << (12 & 0x7)));
}
inline const char* content_basic_info_t::dft_charge_type(unsigned int* size) const{
return _m_dft_charge_type.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_dft_charge_type(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_dft_charge_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_dft_charge_type(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_dft_charge_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_dft_charge_type(){
_flag[12 >> 3] &= ~(1 << (12 & 0x7));
 _m_dft_charge_type.clear();
}
inline bool content_basic_info_t::has_dft_charge_val() const{
return (_flag[13 >> 3] & (1 << (13 & 0x7)));
}
inline const char* content_basic_info_t::dft_charge_val(unsigned int* size) const{
return _m_dft_charge_val.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_dft_charge_val(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_dft_charge_val.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_dft_charge_val(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_dft_charge_val.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_dft_charge_val(){
_flag[13 >> 3] &= ~(1 << (13 & 0x7));
 _m_dft_charge_val.clear();
}
inline bool content_basic_info_t::has_enName() const{
return (_flag[14 >> 3] & (1 << (14 & 0x7)));
}
inline const char* content_basic_info_t::enName(unsigned int* size) const{
return _m_enName.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_enName(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_enName.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_enName(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_enName.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_enName(){
_flag[14 >> 3] &= ~(1 << (14 & 0x7));
 _m_enName.clear();
}
inline bool content_basic_info_t::has_language() const{
return (_flag[15 >> 3] & (1 << (15 & 0x7)));
}
inline const char* content_basic_info_t::language(unsigned int* size) const{
return _m_language.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_language(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_language.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_language(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_language.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_language(){
_flag[15 >> 3] &= ~(1 << (15 & 0x7));
 _m_language.clear();
}
inline bool content_basic_info_t::has_adapt() const{
return (_flag[16 >> 3] & (1 << (16 & 0x7)));
}
inline const char* content_basic_info_t::adapt(unsigned int* size) const{
return _m_adapt.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_adapt(const char* s,ssize_t size){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 _m_adapt.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_adapt(const char* s,ssize_t size){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 _m_adapt.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_adapt(){
_flag[16 >> 3] &= ~(1 << (16 & 0x7));
 _m_adapt.clear();
}
inline bool content_basic_info_t::has_package_name() const{
return (_flag[17 >> 3] & (1 << (17 & 0x7)));
}
inline const char* content_basic_info_t::package_name(unsigned int* size) const{
return _m_package_name.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_package_name(const char* s,ssize_t size){
_flag[17 >> 3] |= (1 << (17 & 0x7));
 _m_package_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_package_name(const char* s,ssize_t size){
_flag[17 >> 3] |= (1 << (17 & 0x7));
 _m_package_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_package_name(){
_flag[17 >> 3] &= ~(1 << (17 & 0x7));
 _m_package_name.clear();
}
inline bool content_basic_info_t::has_version_appinfo() const{
return (_flag[18 >> 3] & (1 << (18 & 0x7)));
}
inline const char* content_basic_info_t::version_appinfo(unsigned int* size) const{
return _m_version_appinfo.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_version_appinfo(const char* s,ssize_t size){
_flag[18 >> 3] |= (1 << (18 & 0x7));
 _m_version_appinfo.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_version_appinfo(const char* s,ssize_t size){
_flag[18 >> 3] |= (1 << (18 & 0x7));
 _m_version_appinfo.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_version_appinfo(){
_flag[18 >> 3] &= ~(1 << (18 & 0x7));
 _m_version_appinfo.clear();
}
inline bool content_basic_info_t::has_sdk_version() const{
return (_flag[19 >> 3] & (1 << (19 & 0x7)));
}
inline const char* content_basic_info_t::sdk_version(unsigned int* size) const{
return _m_sdk_version.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_sdk_version(const char* s,ssize_t size){
_flag[19 >> 3] |= (1 << (19 & 0x7));
 _m_sdk_version.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_sdk_version(const char* s,ssize_t size){
_flag[19 >> 3] |= (1 << (19 & 0x7));
 _m_sdk_version.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_sdk_version(){
_flag[19 >> 3] &= ~(1 << (19 & 0x7));
 _m_sdk_version.clear();
}
inline bool content_basic_info_t::has_version_code() const{
return (_flag[20 >> 3] & (1 << (20 & 0x7)));
}
inline const char* content_basic_info_t::version_code(unsigned int* size) const{
return _m_version_code.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_version_code(const char* s,ssize_t size){
_flag[20 >> 3] |= (1 << (20 & 0x7));
 _m_version_code.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_version_code(const char* s,ssize_t size){
_flag[20 >> 3] |= (1 << (20 & 0x7));
 _m_version_code.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_version_code(){
_flag[20 >> 3] &= ~(1 << (20 & 0x7));
 _m_version_code.clear();
}
inline bool content_basic_info_t::has_ptype_0() const{
return (_flag[21 >> 3] & (1 << (21 & 0x7)));
}
inline const char* content_basic_info_t::ptype_0(unsigned int* size) const{
return _m_ptype_0.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_ptype_0(const char* s,ssize_t size){
_flag[21 >> 3] |= (1 << (21 & 0x7));
 _m_ptype_0.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_ptype_0(const char* s,ssize_t size){
_flag[21 >> 3] |= (1 << (21 & 0x7));
 _m_ptype_0.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_ptype_0(){
_flag[21 >> 3] &= ~(1 << (21 & 0x7));
 _m_ptype_0.clear();
}
inline bool content_basic_info_t::has_ptype_1() const{
return (_flag[22 >> 3] & (1 << (22 & 0x7)));
}
inline const char* content_basic_info_t::ptype_1(unsigned int* size) const{
return _m_ptype_1.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_ptype_1(const char* s,ssize_t size){
_flag[22 >> 3] |= (1 << (22 & 0x7));
 _m_ptype_1.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_ptype_1(const char* s,ssize_t size){
_flag[22 >> 3] |= (1 << (22 & 0x7));
 _m_ptype_1.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_ptype_1(){
_flag[22 >> 3] &= ~(1 << (22 & 0x7));
 _m_ptype_1.clear();
}
inline bool content_basic_info_t::has_ptype_2() const{
return (_flag[23 >> 3] & (1 << (23 & 0x7)));
}
inline const char* content_basic_info_t::ptype_2(unsigned int* size) const{
return _m_ptype_2.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_ptype_2(const char* s,ssize_t size){
_flag[23 >> 3] |= (1 << (23 & 0x7));
 _m_ptype_2.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_ptype_2(const char* s,ssize_t size){
_flag[23 >> 3] |= (1 << (23 & 0x7));
 _m_ptype_2.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_ptype_2(){
_flag[23 >> 3] &= ~(1 << (23 & 0x7));
 _m_ptype_2.clear();
}
inline bool content_basic_info_t::has_ptype_3() const{
return (_flag[24 >> 3] & (1 << (24 & 0x7)));
}
inline const char* content_basic_info_t::ptype_3(unsigned int* size) const{
return _m_ptype_3.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_ptype_3(const char* s,ssize_t size){
_flag[24 >> 3] |= (1 << (24 & 0x7));
 _m_ptype_3.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_ptype_3(const char* s,ssize_t size){
_flag[24 >> 3] |= (1 << (24 & 0x7));
 _m_ptype_3.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_ptype_3(){
_flag[24 >> 3] &= ~(1 << (24 & 0x7));
 _m_ptype_3.clear();
}
inline bool content_basic_info_t::has_ptype_4() const{
return (_flag[25 >> 3] & (1 << (25 & 0x7)));
}
inline const char* content_basic_info_t::ptype_4(unsigned int* size) const{
return _m_ptype_4.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_ptype_4(const char* s,ssize_t size){
_flag[25 >> 3] |= (1 << (25 & 0x7));
 _m_ptype_4.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_ptype_4(const char* s,ssize_t size){
_flag[25 >> 3] |= (1 << (25 & 0x7));
 _m_ptype_4.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_ptype_4(){
_flag[25 >> 3] &= ~(1 << (25 & 0x7));
 _m_ptype_4.clear();
}
inline bool content_basic_info_t::has_pub_props() const{
return (_flag[26 >> 3] & (1 << (26 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& content_basic_info_t::pub_props() const{
 return _m_pub_props;
}
inline void content_basic_info_t::clear_pub_props(){
_flag[26 >> 3] &= ~(1 << (26 & 0x7));
 _m_pub_props.clear();
}
inline ::idl::vector< ::idl::string >* content_basic_info_t::mutable_pub_props(){
_flag[26 >> 3] |= (1 << (26 & 0x7));
 return &(_m_pub_props);
}
inline ::idl::vector< ::idl::string >* content_basic_info_t::m_pub_props(){
_flag[26 >> 3] |= (1 << (26 & 0x7));
 return &(_m_pub_props);
}
inline size_t content_basic_info_t::pub_props_size() const{
/*  */ return _m_pub_props.size();
}
inline const char* content_basic_info_t::pub_props(size_t i0,unsigned int* size) const{
 return _m_pub_props.get(i0).get(size);
}
inline content_basic_info_t& content_basic_info_t::set_pub_props(size_t i0,const char* s,ssize_t size){
_flag[26 >> 3] |= (1 << (26 & 0x7));
 _m_pub_props.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_pub_props(size_t i0,const char* s,ssize_t size){
_flag[26 >> 3] |= (1 << (26 & 0x7));
 _m_pub_props.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool content_basic_info_t::has_pub_prop_info() const{
return (_flag[27 >> 3] & (1 << (27 & 0x7)));
}
inline const ::idl::vector< ::idl::pub_prop_info_t >& content_basic_info_t::pub_prop_info() const{
 return _m_pub_prop_info;
}
inline void content_basic_info_t::clear_pub_prop_info(){
_flag[27 >> 3] &= ~(1 << (27 & 0x7));
 _m_pub_prop_info.clear();
}
inline ::idl::vector< ::idl::pub_prop_info_t >* content_basic_info_t::mutable_pub_prop_info(){
_flag[27 >> 3] |= (1 << (27 & 0x7));
 return &(_m_pub_prop_info);
}
inline ::idl::vector< ::idl::pub_prop_info_t >* content_basic_info_t::m_pub_prop_info(){
_flag[27 >> 3] |= (1 << (27 & 0x7));
 return &(_m_pub_prop_info);
}
inline size_t content_basic_info_t::pub_prop_info_size() const{
/*  */ return _m_pub_prop_info.size();
}
inline const ::idl::pub_prop_info_t& content_basic_info_t::pub_prop_info(size_t i0) const{
 return _m_pub_prop_info.get(i0);
}
inline ::idl::pub_prop_info_t* content_basic_info_t::mutable_pub_prop_info(size_t i0){
_flag[27 >> 3] |= (1 << (27 & 0x7));
 return _m_pub_prop_info.mutable_get(i0);
}
inline ::idl::pub_prop_info_t* content_basic_info_t::m_pub_prop_info(size_t i0){
_flag[27 >> 3] |= (1 << (27 & 0x7));
 return _m_pub_prop_info.mutable_get(i0);
}
inline bool content_basic_info_t::has_union_start_action() const{
return (_flag[28 >> 3] & (1 << (28 & 0x7)));
}
inline const char* content_basic_info_t::union_start_action(unsigned int* size) const{
return _m_union_start_action.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_union_start_action(const char* s,ssize_t size){
_flag[28 >> 3] |= (1 << (28 & 0x7));
 _m_union_start_action.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_union_start_action(const char* s,ssize_t size){
_flag[28 >> 3] |= (1 << (28 & 0x7));
 _m_union_start_action.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_union_start_action(){
_flag[28 >> 3] &= ~(1 << (28 & 0x7));
 _m_union_start_action.clear();
}
inline bool content_basic_info_t::has_has_account() const{
return (_flag[29 >> 3] & (1 << (29 & 0x7)));
}
inline const char* content_basic_info_t::has_account(unsigned int* size) const{
return _m_has_account.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_has_account(const char* s,ssize_t size){
_flag[29 >> 3] |= (1 << (29 & 0x7));
 _m_has_account.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_has_account(const char* s,ssize_t size){
_flag[29 >> 3] |= (1 << (29 & 0x7));
 _m_has_account.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_has_account(){
_flag[29 >> 3] &= ~(1 << (29 & 0x7));
 _m_has_account.clear();
}
inline bool content_basic_info_t::has_editor_recom() const{
return (_flag[30 >> 3] & (1 << (30 & 0x7)));
}
inline const char* content_basic_info_t::editor_recom(unsigned int* size) const{
return _m_editor_recom.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_editor_recom(const char* s,ssize_t size){
_flag[30 >> 3] |= (1 << (30 & 0x7));
 _m_editor_recom.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_editor_recom(const char* s,ssize_t size){
_flag[30 >> 3] |= (1 << (30 & 0x7));
 _m_editor_recom.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_editor_recom(){
_flag[30 >> 3] &= ~(1 << (30 & 0x7));
 _m_editor_recom.clear();
}
inline bool content_basic_info_t::has_show_highspeed() const{
return (_flag[31 >> 3] & (1 << (31 & 0x7)));
}
inline const char* content_basic_info_t::show_highspeed(unsigned int* size) const{
return _m_show_highspeed.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_show_highspeed(const char* s,ssize_t size){
_flag[31 >> 3] |= (1 << (31 & 0x7));
 _m_show_highspeed.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_show_highspeed(const char* s,ssize_t size){
_flag[31 >> 3] |= (1 << (31 & 0x7));
 _m_show_highspeed.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_show_highspeed(){
_flag[31 >> 3] &= ~(1 << (31 & 0x7));
 _m_show_highspeed.clear();
}
inline bool content_basic_info_t::has_bind_resource_id() const{
return (_flag[32 >> 3] & (1 << (32 & 0x7)));
}
inline const char* content_basic_info_t::bind_resource_id(unsigned int* size) const{
return _m_bind_resource_id.get(size);
}
inline content_basic_info_t& content_basic_info_t::set_bind_resource_id(const char* s,ssize_t size){
_flag[32 >> 3] |= (1 << (32 & 0x7));
 _m_bind_resource_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_basic_info_t& content_basic_info_t::set_ptr_bind_resource_id(const char* s,ssize_t size){
_flag[32 >> 3] |= (1 << (32 & 0x7));
 _m_bind_resource_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_basic_info_t::clear_bind_resource_id(){
_flag[32 >> 3] &= ~(1 << (32 & 0x7));
 _m_bind_resource_id.clear();
}
inline bool content_basic_info_t::has_class_info() const{
return (_flag[33 >> 3] & (1 << (33 & 0x7)));
}
inline const ::idl::vector< ::idl::class_info_t >& content_basic_info_t::class_info() const{
 return _m_class_info;
}
inline void content_basic_info_t::clear_class_info(){
_flag[33 >> 3] &= ~(1 << (33 & 0x7));
 _m_class_info.clear();
}
inline ::idl::vector< ::idl::class_info_t >* content_basic_info_t::mutable_class_info(){
_flag[33 >> 3] |= (1 << (33 & 0x7));
 return &(_m_class_info);
}
inline ::idl::vector< ::idl::class_info_t >* content_basic_info_t::m_class_info(){
_flag[33 >> 3] |= (1 << (33 & 0x7));
 return &(_m_class_info);
}
inline size_t content_basic_info_t::class_info_size() const{
/*  */ return _m_class_info.size();
}
inline const ::idl::class_info_t& content_basic_info_t::class_info(size_t i0) const{
 return _m_class_info.get(i0);
}
inline ::idl::class_info_t* content_basic_info_t::mutable_class_info(size_t i0){
_flag[33 >> 3] |= (1 << (33 & 0x7));
 return _m_class_info.mutable_get(i0);
}
inline ::idl::class_info_t* content_basic_info_t::m_class_info(size_t i0){
_flag[33 >> 3] |= (1 << (33 & 0x7));
 return _m_class_info.mutable_get(i0);
}
inline bool content_basic_info_t::has_img_info() const{
return (_flag[34 >> 3] & (1 << (34 & 0x7)));
}
inline const ::idl::vector< ::idl::img_info_t >& content_basic_info_t::img_info() const{
 return _m_img_info;
}
inline void content_basic_info_t::clear_img_info(){
_flag[34 >> 3] &= ~(1 << (34 & 0x7));
 _m_img_info.clear();
}
inline ::idl::vector< ::idl::img_info_t >* content_basic_info_t::mutable_img_info(){
_flag[34 >> 3] |= (1 << (34 & 0x7));
 return &(_m_img_info);
}
inline ::idl::vector< ::idl::img_info_t >* content_basic_info_t::m_img_info(){
_flag[34 >> 3] |= (1 << (34 & 0x7));
 return &(_m_img_info);
}
inline size_t content_basic_info_t::img_info_size() const{
/*  */ return _m_img_info.size();
}
inline const ::idl::img_info_t& content_basic_info_t::img_info(size_t i0) const{
 return _m_img_info.get(i0);
}
inline ::idl::img_info_t* content_basic_info_t::mutable_img_info(size_t i0){
_flag[34 >> 3] |= (1 << (34 & 0x7));
 return _m_img_info.mutable_get(i0);
}
inline ::idl::img_info_t* content_basic_info_t::m_img_info(size_t i0){
_flag[34 >> 3] |= (1 << (34 & 0x7));
 return _m_img_info.mutable_get(i0);
}
inline bool content_basic_info_t::has_cp_info() const{
return (_flag[35 >> 3] & (1 << (35 & 0x7)));
}
inline const ::idl::cp_info_t& content_basic_info_t::cp_info() const{
 return *_m_cp_info;
}
inline ::idl::cp_info_t* content_basic_info_t::mutable_cp_info(){
_flag[35 >> 3] |= (1 << (35 & 0x7));
 if(!_m_cp_info){
_m_cp_info=::idl::cp_info_t::create(_pool);
}
return _m_cp_info;
}
inline ::idl::cp_info_t* content_basic_info_t::m_cp_info(){
_flag[35 >> 3] |= (1 << (35 & 0x7));
 if(!_m_cp_info){
_m_cp_info=::idl::cp_info_t::create(_pool);
}
return _m_cp_info;
}
inline void content_basic_info_t::clear_cp_info(){
if(_m_cp_info){
_flag[35 >> 3] &= ~(1 << (35 & 0x7));
 _m_cp_info->clear();
}
}
inline bool content_basic_info_t::has_grant_info() const{
return (_flag[36 >> 3] & (1 << (36 & 0x7)));
}
inline const ::idl::grant_detail_t& content_basic_info_t::grant_info() const{
 return *_m_grant_info;
}
inline ::idl::grant_detail_t* content_basic_info_t::mutable_grant_info(){
_flag[36 >> 3] |= (1 << (36 & 0x7));
 if(!_m_grant_info){
_m_grant_info=::idl::grant_detail_t::create(_pool);
}
return _m_grant_info;
}
inline ::idl::grant_detail_t* content_basic_info_t::m_grant_info(){
_flag[36 >> 3] |= (1 << (36 & 0x7));
 if(!_m_grant_info){
_m_grant_info=::idl::grant_detail_t::create(_pool);
}
return _m_grant_info;
}
inline void content_basic_info_t::clear_grant_info(){
if(_m_grant_info){
_flag[36 >> 3] &= ~(1 << (36 & 0x7));
 _m_grant_info->clear();
}
}
inline ::idl::Unknown* content_basic_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& content_basic_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& content_basic_info_t::unknown(){
return _unknown;
}
inline size_t content_basic_info_t::unknown_size() const{
return _unknown.size();
}
inline content_detail_t* content_detail_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
content_detail_t* tmp=(content_detail_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)content_detail_t(pool);
return tmp;
}
inline void content_detail_t::destroy(content_detail_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~content_detail_t();
pool->free(v,sizeof(*v));
}
}
inline content_detail_t::content_detail_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_type(_pool)
,_m_class_info(_pool)
,_m_img_info(_pool)
,_m_ext_id(_pool)
,_m_abstract_(_pool)
,_m_version(_pool)
,_m_method(_pool)
,_m_star(_pool)
,_m_network(_pool)
,_m_code(_pool)
,_m_log_date(_pool)
,_m_mod_date(_pool)
,_m_dft_charge_type(_pool)
,_m_dft_charge_val(_pool)
,_m_enName(_pool)
,_m_language(_pool)
,_m_adapt(_pool)
,_m_package_name(_pool)
,_m_version_appinfo(_pool)
,_m_sdk_version(_pool)
,_m_version_code(_pool)
,_m_ptype_0(_pool)
,_m_ptype_1(_pool)
,_m_ptype_2(_pool)
,_m_ptype_3(_pool)
,_m_ptype_4(_pool)
,_m_pub_props(_pool)
,_m_pub_prop_info(_pool)
,_m_union_start_action(_pool)
,_m_has_account(_pool)
,_m_editor_recom(_pool)
,_m_show_highspeed(_pool)
,_m_cp_info(0)
,_m_grant_info(0)
,_m_download_info(_pool)
,_unknown(_pool){
_m_cp_info=::idl::cp_info_t::create(_pool);
_m_grant_info=::idl::grant_detail_t::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline content_detail_t::content_detail_t(const content_detail_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_type(_pool)
,_m_class_info(_pool)
,_m_img_info(_pool)
,_m_ext_id(_pool)
,_m_abstract_(_pool)
,_m_version(_pool)
,_m_method(_pool)
,_m_star(_pool)
,_m_network(_pool)
,_m_code(_pool)
,_m_log_date(_pool)
,_m_mod_date(_pool)
,_m_dft_charge_type(_pool)
,_m_dft_charge_val(_pool)
,_m_enName(_pool)
,_m_language(_pool)
,_m_adapt(_pool)
,_m_package_name(_pool)
,_m_version_appinfo(_pool)
,_m_sdk_version(_pool)
,_m_version_code(_pool)
,_m_ptype_0(_pool)
,_m_ptype_1(_pool)
,_m_ptype_2(_pool)
,_m_ptype_3(_pool)
,_m_ptype_4(_pool)
,_m_pub_props(_pool)
,_m_pub_prop_info(_pool)
,_m_union_start_action(_pool)
,_m_has_account(_pool)
,_m_editor_recom(_pool)
,_m_show_highspeed(_pool)
,_m_cp_info(0)
,_m_grant_info(0)
,_m_download_info(_pool)
,_unknown(_pool){
_m_cp_info=::idl::cp_info_t::create(_pool);
_m_grant_info=::idl::grant_detail_t::create(_pool);
assign(v);
}
inline content_detail_t::~content_detail_t(){
if(_m_cp_info){
::idl::cp_info_t::destroy(_m_cp_info);
_m_cp_info=0;
}
if(_m_grant_info){
::idl::grant_detail_t::destroy(_m_grant_info);
_m_grant_info=0;
}
}
inline content_detail_t& content_detail_t::operator=(const content_detail_t& v){
assign(v);
return *this;
}
inline void content_detail_t::clear(){
_m_id.clear();
_m_name.clear();
_m_type.clear();
_m_class_info.clear();
_m_img_info.clear();
_m_ext_id.clear();
_m_abstract_.clear();
_m_version.clear();
_m_method.clear();
_m_star.clear();
_m_network.clear();
_m_code.clear();
_m_log_date.clear();
_m_mod_date.clear();
_m_dft_charge_type.clear();
_m_dft_charge_val.clear();
_m_enName.clear();
_m_language.clear();
_m_adapt.clear();
_m_package_name.clear();
_m_version_appinfo.clear();
_m_sdk_version.clear();
_m_version_code.clear();
_m_ptype_0.clear();
_m_ptype_1.clear();
_m_ptype_2.clear();
_m_ptype_3.clear();
_m_ptype_4.clear();
_m_pub_props.clear();
_m_pub_prop_info.clear();
_m_union_start_action.clear();
_m_has_account.clear();
_m_editor_recom.clear();
_m_show_highspeed.clear();
if(_m_cp_info){
_m_cp_info->clear();
}
if(_m_grant_info){
_m_grant_info->clear();
}
_m_download_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void content_detail_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string type;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type.get();

}
// @@class_info_t class_info=array(0);
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_info" << "' not found";
}
{
// level 0 begin
typeof(_m_class_info)& lr0=(_m_class_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::class_info_t& item=const_cast< ::idl::class_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@img_info_t img_info=array(0);
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "img_info" << "' not found";
}
{
// level 0 begin
typeof(_m_img_info)& lr0=(_m_img_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::img_info_t& item=const_cast< ::idl::img_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@string ext_id;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ext_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ext_id.get();

}
// @@string abstract_;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "abstract_" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_abstract_.get();

}
// @@string version;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "version" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_version.get();

}
// @@string method;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "method" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_method.get();

}
// @@string star;
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "star" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_star.get();

}
// @@string network;
if(!(_flag[10 >> 3] & (1 << (10 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "network" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_network.get();

}
// @@string code;
if(!(_flag[11 >> 3] & (1 << (11 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "code" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_code.get();

}
// @@string log_date;
if(!(_flag[12 >> 3] & (1 << (12 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "log_date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_log_date.get();

}
// @@string mod_date;
if(!(_flag[13 >> 3] & (1 << (13 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "mod_date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_mod_date.get();

}
// @@string dft_charge_type;
if(!(_flag[14 >> 3] & (1 << (14 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "dft_charge_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_dft_charge_type.get();

}
// @@string dft_charge_val;
if(!(_flag[15 >> 3] & (1 << (15 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "dft_charge_val" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_dft_charge_val.get();

}
// @@string enName;
if(!(_flag[16 >> 3] & (1 << (16 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "enName" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_enName.get();

}
// @@string language;
if(!(_flag[17 >> 3] & (1 << (17 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "language" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_language.get();

}
// @@string adapt;
if(!(_flag[18 >> 3] & (1 << (18 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "adapt" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_adapt.get();

}
// @@string package_name;
if(!(_flag[19 >> 3] & (1 << (19 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "package_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_package_name.get();

}
// @@string version_appinfo;
if(!(_flag[20 >> 3] & (1 << (20 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "version_appinfo" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_version_appinfo.get();

}
// @@string sdk_version;
if(!(_flag[21 >> 3] & (1 << (21 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "sdk_version" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_sdk_version.get();

}
// @@string version_code;
if(!(_flag[22 >> 3] & (1 << (22 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "version_code" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_version_code.get();

}
// @@string ptype_0;
if(!(_flag[23 >> 3] & (1 << (23 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ptype_0" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ptype_0.get();

}
// @@string ptype_1;
if(!(_flag[24 >> 3] & (1 << (24 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ptype_1" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ptype_1.get();

}
// @@string ptype_2;
if(!(_flag[25 >> 3] & (1 << (25 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ptype_2" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ptype_2.get();

}
// @@string ptype_3;
if(!(_flag[26 >> 3] & (1 << (26 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ptype_3" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ptype_3.get();

}
// @@string ptype_4;
if(!(_flag[27 >> 3] & (1 << (27 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ptype_4" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ptype_4.get();

}
// @@string pub_props=array(0);
if(!(_flag[28 >> 3] & (1 << (28 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "pub_props" << "' not found";
}
{
// level 0 begin
typeof(_m_pub_props)& lr0=(_m_pub_props);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@pub_prop_info_t pub_prop_info=array(0);
if(!(_flag[29 >> 3] & (1 << (29 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "pub_prop_info" << "' not found";
}
{
// level 0 begin
typeof(_m_pub_prop_info)& lr0=(_m_pub_prop_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::pub_prop_info_t& item=const_cast< ::idl::pub_prop_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@string union_start_action;
if(!(_flag[30 >> 3] & (1 << (30 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "union_start_action" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_union_start_action.get();

}
// @@string has_account;
if(!(_flag[31 >> 3] & (1 << (31 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "has_account" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_has_account.get();

}
// @@string editor_recom;
if(!(_flag[32 >> 3] & (1 << (32 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "editor_recom" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_editor_recom.get();

}
// @@string show_highspeed;
if(!(_flag[33 >> 3] & (1 << (33 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "show_highspeed" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_show_highspeed.get();

}
// @@cp_info_t cp_info;
if(!(_flag[34 >> 3] & (1 << (34 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cp_info" << "' not found";
}
{
::idl::cp_info_t& item=const_cast< ::idl::cp_info_t& >(*_m_cp_info);
item.check();

}
// @@grant_detail_t grant_info;
if(!(_flag[35 >> 3] & (1 << (35 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "grant_info" << "' not found";
}
{
::idl::grant_detail_t& item=const_cast< ::idl::grant_detail_t& >(*_m_grant_info);
item.check();

}
// @@download_detail_t download_info=array(0);
if(!(_flag[36 >> 3] & (1 << (36 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "download_info" << "' not found";
}
{
// level 0 begin
typeof(_m_download_info)& lr0=(_m_download_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::download_detail_t& item=const_cast< ::idl::download_detail_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void content_detail_t::detach(){
_m_id.detach();
_m_name.detach();
_m_type.detach();
_m_class_info.detach();
_m_img_info.detach();
_m_ext_id.detach();
_m_abstract_.detach();
_m_version.detach();
_m_method.detach();
_m_star.detach();
_m_network.detach();
_m_code.detach();
_m_log_date.detach();
_m_mod_date.detach();
_m_dft_charge_type.detach();
_m_dft_charge_val.detach();
_m_enName.detach();
_m_language.detach();
_m_adapt.detach();
_m_package_name.detach();
_m_version_appinfo.detach();
_m_sdk_version.detach();
_m_version_code.detach();
_m_ptype_0.detach();
_m_ptype_1.detach();
_m_ptype_2.detach();
_m_ptype_3.detach();
_m_ptype_4.detach();
_m_pub_props.detach();
_m_pub_prop_info.detach();
_m_union_start_action.detach();
_m_has_account.detach();
_m_editor_recom.detach();
_m_show_highspeed.detach();
if(_m_cp_info){
_m_cp_info->detach();
}
if(_m_grant_info){
_m_grant_info->detach();
}
_m_download_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline content_detail_t& content_detail_t::assign(const content_detail_t& v){
_m_id=v._m_id;
_m_name=v._m_name;
_m_type=v._m_type;
_m_class_info=v._m_class_info;
_m_img_info=v._m_img_info;
_m_ext_id=v._m_ext_id;
_m_abstract_=v._m_abstract_;
_m_version=v._m_version;
_m_method=v._m_method;
_m_star=v._m_star;
_m_network=v._m_network;
_m_code=v._m_code;
_m_log_date=v._m_log_date;
_m_mod_date=v._m_mod_date;
_m_dft_charge_type=v._m_dft_charge_type;
_m_dft_charge_val=v._m_dft_charge_val;
_m_enName=v._m_enName;
_m_language=v._m_language;
_m_adapt=v._m_adapt;
_m_package_name=v._m_package_name;
_m_version_appinfo=v._m_version_appinfo;
_m_sdk_version=v._m_sdk_version;
_m_version_code=v._m_version_code;
_m_ptype_0=v._m_ptype_0;
_m_ptype_1=v._m_ptype_1;
_m_ptype_2=v._m_ptype_2;
_m_ptype_3=v._m_ptype_3;
_m_ptype_4=v._m_ptype_4;
_m_pub_props=v._m_pub_props;
_m_pub_prop_info=v._m_pub_prop_info;
_m_union_start_action=v._m_union_start_action;
_m_has_account=v._m_has_account;
_m_editor_recom=v._m_editor_recom;
_m_show_highspeed=v._m_show_highspeed;
if(!v._m_cp_info){
if(_m_cp_info){
::idl::cp_info_t::destroy(_m_cp_info);
}
_m_cp_info=0;
}else{
if(!_m_cp_info){
_m_cp_info=::idl::cp_info_t::create(_pool);
}
*_m_cp_info=*v._m_cp_info;
}
if(!v._m_grant_info){
if(_m_grant_info){
::idl::grant_detail_t::destroy(_m_grant_info);
}
_m_grant_info=0;
}else{
if(!_m_grant_info){
_m_grant_info=::idl::grant_detail_t::create(_pool);
}
*_m_grant_info=*v._m_grant_info;
}
_m_download_info=v._m_download_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool content_detail_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* content_detail_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline content_detail_t& content_detail_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool content_detail_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* content_detail_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline content_detail_t& content_detail_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool content_detail_t::has_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* content_detail_t::type(unsigned int* size) const{
return _m_type.get(size);
}
inline content_detail_t& content_detail_t::set_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_type.clear();
}
inline bool content_detail_t::has_class_info() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const ::idl::vector< ::idl::class_info_t >& content_detail_t::class_info() const{
 return _m_class_info;
}
inline void content_detail_t::clear_class_info(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_class_info.clear();
}
inline ::idl::vector< ::idl::class_info_t >* content_detail_t::mutable_class_info(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_class_info);
}
inline ::idl::vector< ::idl::class_info_t >* content_detail_t::m_class_info(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_class_info);
}
inline size_t content_detail_t::class_info_size() const{
/*  */ return _m_class_info.size();
}
inline const ::idl::class_info_t& content_detail_t::class_info(size_t i0) const{
 return _m_class_info.get(i0);
}
inline ::idl::class_info_t* content_detail_t::mutable_class_info(size_t i0){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return _m_class_info.mutable_get(i0);
}
inline ::idl::class_info_t* content_detail_t::m_class_info(size_t i0){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return _m_class_info.mutable_get(i0);
}
inline bool content_detail_t::has_img_info() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const ::idl::vector< ::idl::img_info_t >& content_detail_t::img_info() const{
 return _m_img_info;
}
inline void content_detail_t::clear_img_info(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_img_info.clear();
}
inline ::idl::vector< ::idl::img_info_t >* content_detail_t::mutable_img_info(){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return &(_m_img_info);
}
inline ::idl::vector< ::idl::img_info_t >* content_detail_t::m_img_info(){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return &(_m_img_info);
}
inline size_t content_detail_t::img_info_size() const{
/*  */ return _m_img_info.size();
}
inline const ::idl::img_info_t& content_detail_t::img_info(size_t i0) const{
 return _m_img_info.get(i0);
}
inline ::idl::img_info_t* content_detail_t::mutable_img_info(size_t i0){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return _m_img_info.mutable_get(i0);
}
inline ::idl::img_info_t* content_detail_t::m_img_info(size_t i0){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return _m_img_info.mutable_get(i0);
}
inline bool content_detail_t::has_ext_id() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* content_detail_t::ext_id(unsigned int* size) const{
return _m_ext_id.get(size);
}
inline content_detail_t& content_detail_t::set_ext_id(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_ext_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_ext_id(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_ext_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_ext_id(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_ext_id.clear();
}
inline bool content_detail_t::has_abstract_() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* content_detail_t::abstract_(unsigned int* size) const{
return _m_abstract_.get(size);
}
inline content_detail_t& content_detail_t::set_abstract_(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_abstract_.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_abstract_(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_abstract_.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_abstract_(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_abstract_.clear();
}
inline bool content_detail_t::has_version() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* content_detail_t::version(unsigned int* size) const{
return _m_version.get(size);
}
inline content_detail_t& content_detail_t::set_version(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_version.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_version(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_version.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_version(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_version.clear();
}
inline bool content_detail_t::has_method() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* content_detail_t::method(unsigned int* size) const{
return _m_method.get(size);
}
inline content_detail_t& content_detail_t::set_method(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_method.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_method(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_method.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_method(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_method.clear();
}
inline bool content_detail_t::has_star() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline const char* content_detail_t::star(unsigned int* size) const{
return _m_star.get(size);
}
inline content_detail_t& content_detail_t::set_star(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_star.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_star(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_star.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_star(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_star.clear();
}
inline bool content_detail_t::has_network() const{
return (_flag[10 >> 3] & (1 << (10 & 0x7)));
}
inline const char* content_detail_t::network(unsigned int* size) const{
return _m_network.get(size);
}
inline content_detail_t& content_detail_t::set_network(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_network.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_network(const char* s,ssize_t size){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 _m_network.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_network(){
_flag[10 >> 3] &= ~(1 << (10 & 0x7));
 _m_network.clear();
}
inline bool content_detail_t::has_code() const{
return (_flag[11 >> 3] & (1 << (11 & 0x7)));
}
inline const char* content_detail_t::code(unsigned int* size) const{
return _m_code.get(size);
}
inline content_detail_t& content_detail_t::set_code(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_code.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_code(const char* s,ssize_t size){
_flag[11 >> 3] |= (1 << (11 & 0x7));
 _m_code.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_code(){
_flag[11 >> 3] &= ~(1 << (11 & 0x7));
 _m_code.clear();
}
inline bool content_detail_t::has_log_date() const{
return (_flag[12 >> 3] & (1 << (12 & 0x7)));
}
inline const char* content_detail_t::log_date(unsigned int* size) const{
return _m_log_date.get(size);
}
inline content_detail_t& content_detail_t::set_log_date(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_log_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_log_date(const char* s,ssize_t size){
_flag[12 >> 3] |= (1 << (12 & 0x7));
 _m_log_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_log_date(){
_flag[12 >> 3] &= ~(1 << (12 & 0x7));
 _m_log_date.clear();
}
inline bool content_detail_t::has_mod_date() const{
return (_flag[13 >> 3] & (1 << (13 & 0x7)));
}
inline const char* content_detail_t::mod_date(unsigned int* size) const{
return _m_mod_date.get(size);
}
inline content_detail_t& content_detail_t::set_mod_date(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_mod_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_mod_date(const char* s,ssize_t size){
_flag[13 >> 3] |= (1 << (13 & 0x7));
 _m_mod_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_mod_date(){
_flag[13 >> 3] &= ~(1 << (13 & 0x7));
 _m_mod_date.clear();
}
inline bool content_detail_t::has_dft_charge_type() const{
return (_flag[14 >> 3] & (1 << (14 & 0x7)));
}
inline const char* content_detail_t::dft_charge_type(unsigned int* size) const{
return _m_dft_charge_type.get(size);
}
inline content_detail_t& content_detail_t::set_dft_charge_type(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_dft_charge_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_dft_charge_type(const char* s,ssize_t size){
_flag[14 >> 3] |= (1 << (14 & 0x7));
 _m_dft_charge_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_dft_charge_type(){
_flag[14 >> 3] &= ~(1 << (14 & 0x7));
 _m_dft_charge_type.clear();
}
inline bool content_detail_t::has_dft_charge_val() const{
return (_flag[15 >> 3] & (1 << (15 & 0x7)));
}
inline const char* content_detail_t::dft_charge_val(unsigned int* size) const{
return _m_dft_charge_val.get(size);
}
inline content_detail_t& content_detail_t::set_dft_charge_val(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_dft_charge_val.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_dft_charge_val(const char* s,ssize_t size){
_flag[15 >> 3] |= (1 << (15 & 0x7));
 _m_dft_charge_val.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_dft_charge_val(){
_flag[15 >> 3] &= ~(1 << (15 & 0x7));
 _m_dft_charge_val.clear();
}
inline bool content_detail_t::has_enName() const{
return (_flag[16 >> 3] & (1 << (16 & 0x7)));
}
inline const char* content_detail_t::enName(unsigned int* size) const{
return _m_enName.get(size);
}
inline content_detail_t& content_detail_t::set_enName(const char* s,ssize_t size){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 _m_enName.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_enName(const char* s,ssize_t size){
_flag[16 >> 3] |= (1 << (16 & 0x7));
 _m_enName.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_enName(){
_flag[16 >> 3] &= ~(1 << (16 & 0x7));
 _m_enName.clear();
}
inline bool content_detail_t::has_language() const{
return (_flag[17 >> 3] & (1 << (17 & 0x7)));
}
inline const char* content_detail_t::language(unsigned int* size) const{
return _m_language.get(size);
}
inline content_detail_t& content_detail_t::set_language(const char* s,ssize_t size){
_flag[17 >> 3] |= (1 << (17 & 0x7));
 _m_language.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_language(const char* s,ssize_t size){
_flag[17 >> 3] |= (1 << (17 & 0x7));
 _m_language.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_language(){
_flag[17 >> 3] &= ~(1 << (17 & 0x7));
 _m_language.clear();
}
inline bool content_detail_t::has_adapt() const{
return (_flag[18 >> 3] & (1 << (18 & 0x7)));
}
inline const char* content_detail_t::adapt(unsigned int* size) const{
return _m_adapt.get(size);
}
inline content_detail_t& content_detail_t::set_adapt(const char* s,ssize_t size){
_flag[18 >> 3] |= (1 << (18 & 0x7));
 _m_adapt.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_adapt(const char* s,ssize_t size){
_flag[18 >> 3] |= (1 << (18 & 0x7));
 _m_adapt.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_adapt(){
_flag[18 >> 3] &= ~(1 << (18 & 0x7));
 _m_adapt.clear();
}
inline bool content_detail_t::has_package_name() const{
return (_flag[19 >> 3] & (1 << (19 & 0x7)));
}
inline const char* content_detail_t::package_name(unsigned int* size) const{
return _m_package_name.get(size);
}
inline content_detail_t& content_detail_t::set_package_name(const char* s,ssize_t size){
_flag[19 >> 3] |= (1 << (19 & 0x7));
 _m_package_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_package_name(const char* s,ssize_t size){
_flag[19 >> 3] |= (1 << (19 & 0x7));
 _m_package_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_package_name(){
_flag[19 >> 3] &= ~(1 << (19 & 0x7));
 _m_package_name.clear();
}
inline bool content_detail_t::has_version_appinfo() const{
return (_flag[20 >> 3] & (1 << (20 & 0x7)));
}
inline const char* content_detail_t::version_appinfo(unsigned int* size) const{
return _m_version_appinfo.get(size);
}
inline content_detail_t& content_detail_t::set_version_appinfo(const char* s,ssize_t size){
_flag[20 >> 3] |= (1 << (20 & 0x7));
 _m_version_appinfo.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_version_appinfo(const char* s,ssize_t size){
_flag[20 >> 3] |= (1 << (20 & 0x7));
 _m_version_appinfo.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_version_appinfo(){
_flag[20 >> 3] &= ~(1 << (20 & 0x7));
 _m_version_appinfo.clear();
}
inline bool content_detail_t::has_sdk_version() const{
return (_flag[21 >> 3] & (1 << (21 & 0x7)));
}
inline const char* content_detail_t::sdk_version(unsigned int* size) const{
return _m_sdk_version.get(size);
}
inline content_detail_t& content_detail_t::set_sdk_version(const char* s,ssize_t size){
_flag[21 >> 3] |= (1 << (21 & 0x7));
 _m_sdk_version.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_sdk_version(const char* s,ssize_t size){
_flag[21 >> 3] |= (1 << (21 & 0x7));
 _m_sdk_version.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_sdk_version(){
_flag[21 >> 3] &= ~(1 << (21 & 0x7));
 _m_sdk_version.clear();
}
inline bool content_detail_t::has_version_code() const{
return (_flag[22 >> 3] & (1 << (22 & 0x7)));
}
inline const char* content_detail_t::version_code(unsigned int* size) const{
return _m_version_code.get(size);
}
inline content_detail_t& content_detail_t::set_version_code(const char* s,ssize_t size){
_flag[22 >> 3] |= (1 << (22 & 0x7));
 _m_version_code.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_version_code(const char* s,ssize_t size){
_flag[22 >> 3] |= (1 << (22 & 0x7));
 _m_version_code.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_version_code(){
_flag[22 >> 3] &= ~(1 << (22 & 0x7));
 _m_version_code.clear();
}
inline bool content_detail_t::has_ptype_0() const{
return (_flag[23 >> 3] & (1 << (23 & 0x7)));
}
inline const char* content_detail_t::ptype_0(unsigned int* size) const{
return _m_ptype_0.get(size);
}
inline content_detail_t& content_detail_t::set_ptype_0(const char* s,ssize_t size){
_flag[23 >> 3] |= (1 << (23 & 0x7));
 _m_ptype_0.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_ptype_0(const char* s,ssize_t size){
_flag[23 >> 3] |= (1 << (23 & 0x7));
 _m_ptype_0.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_ptype_0(){
_flag[23 >> 3] &= ~(1 << (23 & 0x7));
 _m_ptype_0.clear();
}
inline bool content_detail_t::has_ptype_1() const{
return (_flag[24 >> 3] & (1 << (24 & 0x7)));
}
inline const char* content_detail_t::ptype_1(unsigned int* size) const{
return _m_ptype_1.get(size);
}
inline content_detail_t& content_detail_t::set_ptype_1(const char* s,ssize_t size){
_flag[24 >> 3] |= (1 << (24 & 0x7));
 _m_ptype_1.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_ptype_1(const char* s,ssize_t size){
_flag[24 >> 3] |= (1 << (24 & 0x7));
 _m_ptype_1.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_ptype_1(){
_flag[24 >> 3] &= ~(1 << (24 & 0x7));
 _m_ptype_1.clear();
}
inline bool content_detail_t::has_ptype_2() const{
return (_flag[25 >> 3] & (1 << (25 & 0x7)));
}
inline const char* content_detail_t::ptype_2(unsigned int* size) const{
return _m_ptype_2.get(size);
}
inline content_detail_t& content_detail_t::set_ptype_2(const char* s,ssize_t size){
_flag[25 >> 3] |= (1 << (25 & 0x7));
 _m_ptype_2.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_ptype_2(const char* s,ssize_t size){
_flag[25 >> 3] |= (1 << (25 & 0x7));
 _m_ptype_2.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_ptype_2(){
_flag[25 >> 3] &= ~(1 << (25 & 0x7));
 _m_ptype_2.clear();
}
inline bool content_detail_t::has_ptype_3() const{
return (_flag[26 >> 3] & (1 << (26 & 0x7)));
}
inline const char* content_detail_t::ptype_3(unsigned int* size) const{
return _m_ptype_3.get(size);
}
inline content_detail_t& content_detail_t::set_ptype_3(const char* s,ssize_t size){
_flag[26 >> 3] |= (1 << (26 & 0x7));
 _m_ptype_3.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_ptype_3(const char* s,ssize_t size){
_flag[26 >> 3] |= (1 << (26 & 0x7));
 _m_ptype_3.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_ptype_3(){
_flag[26 >> 3] &= ~(1 << (26 & 0x7));
 _m_ptype_3.clear();
}
inline bool content_detail_t::has_ptype_4() const{
return (_flag[27 >> 3] & (1 << (27 & 0x7)));
}
inline const char* content_detail_t::ptype_4(unsigned int* size) const{
return _m_ptype_4.get(size);
}
inline content_detail_t& content_detail_t::set_ptype_4(const char* s,ssize_t size){
_flag[27 >> 3] |= (1 << (27 & 0x7));
 _m_ptype_4.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_ptype_4(const char* s,ssize_t size){
_flag[27 >> 3] |= (1 << (27 & 0x7));
 _m_ptype_4.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_ptype_4(){
_flag[27 >> 3] &= ~(1 << (27 & 0x7));
 _m_ptype_4.clear();
}
inline bool content_detail_t::has_pub_props() const{
return (_flag[28 >> 3] & (1 << (28 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& content_detail_t::pub_props() const{
 return _m_pub_props;
}
inline void content_detail_t::clear_pub_props(){
_flag[28 >> 3] &= ~(1 << (28 & 0x7));
 _m_pub_props.clear();
}
inline ::idl::vector< ::idl::string >* content_detail_t::mutable_pub_props(){
_flag[28 >> 3] |= (1 << (28 & 0x7));
 return &(_m_pub_props);
}
inline ::idl::vector< ::idl::string >* content_detail_t::m_pub_props(){
_flag[28 >> 3] |= (1 << (28 & 0x7));
 return &(_m_pub_props);
}
inline size_t content_detail_t::pub_props_size() const{
/*  */ return _m_pub_props.size();
}
inline const char* content_detail_t::pub_props(size_t i0,unsigned int* size) const{
 return _m_pub_props.get(i0).get(size);
}
inline content_detail_t& content_detail_t::set_pub_props(size_t i0,const char* s,ssize_t size){
_flag[28 >> 3] |= (1 << (28 & 0x7));
 _m_pub_props.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_pub_props(size_t i0,const char* s,ssize_t size){
_flag[28 >> 3] |= (1 << (28 & 0x7));
 _m_pub_props.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool content_detail_t::has_pub_prop_info() const{
return (_flag[29 >> 3] & (1 << (29 & 0x7)));
}
inline const ::idl::vector< ::idl::pub_prop_info_t >& content_detail_t::pub_prop_info() const{
 return _m_pub_prop_info;
}
inline void content_detail_t::clear_pub_prop_info(){
_flag[29 >> 3] &= ~(1 << (29 & 0x7));
 _m_pub_prop_info.clear();
}
inline ::idl::vector< ::idl::pub_prop_info_t >* content_detail_t::mutable_pub_prop_info(){
_flag[29 >> 3] |= (1 << (29 & 0x7));
 return &(_m_pub_prop_info);
}
inline ::idl::vector< ::idl::pub_prop_info_t >* content_detail_t::m_pub_prop_info(){
_flag[29 >> 3] |= (1 << (29 & 0x7));
 return &(_m_pub_prop_info);
}
inline size_t content_detail_t::pub_prop_info_size() const{
/*  */ return _m_pub_prop_info.size();
}
inline const ::idl::pub_prop_info_t& content_detail_t::pub_prop_info(size_t i0) const{
 return _m_pub_prop_info.get(i0);
}
inline ::idl::pub_prop_info_t* content_detail_t::mutable_pub_prop_info(size_t i0){
_flag[29 >> 3] |= (1 << (29 & 0x7));
 return _m_pub_prop_info.mutable_get(i0);
}
inline ::idl::pub_prop_info_t* content_detail_t::m_pub_prop_info(size_t i0){
_flag[29 >> 3] |= (1 << (29 & 0x7));
 return _m_pub_prop_info.mutable_get(i0);
}
inline bool content_detail_t::has_union_start_action() const{
return (_flag[30 >> 3] & (1 << (30 & 0x7)));
}
inline const char* content_detail_t::union_start_action(unsigned int* size) const{
return _m_union_start_action.get(size);
}
inline content_detail_t& content_detail_t::set_union_start_action(const char* s,ssize_t size){
_flag[30 >> 3] |= (1 << (30 & 0x7));
 _m_union_start_action.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_union_start_action(const char* s,ssize_t size){
_flag[30 >> 3] |= (1 << (30 & 0x7));
 _m_union_start_action.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_union_start_action(){
_flag[30 >> 3] &= ~(1 << (30 & 0x7));
 _m_union_start_action.clear();
}
inline bool content_detail_t::has_has_account() const{
return (_flag[31 >> 3] & (1 << (31 & 0x7)));
}
inline const char* content_detail_t::has_account(unsigned int* size) const{
return _m_has_account.get(size);
}
inline content_detail_t& content_detail_t::set_has_account(const char* s,ssize_t size){
_flag[31 >> 3] |= (1 << (31 & 0x7));
 _m_has_account.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_has_account(const char* s,ssize_t size){
_flag[31 >> 3] |= (1 << (31 & 0x7));
 _m_has_account.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_has_account(){
_flag[31 >> 3] &= ~(1 << (31 & 0x7));
 _m_has_account.clear();
}
inline bool content_detail_t::has_editor_recom() const{
return (_flag[32 >> 3] & (1 << (32 & 0x7)));
}
inline const char* content_detail_t::editor_recom(unsigned int* size) const{
return _m_editor_recom.get(size);
}
inline content_detail_t& content_detail_t::set_editor_recom(const char* s,ssize_t size){
_flag[32 >> 3] |= (1 << (32 & 0x7));
 _m_editor_recom.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_editor_recom(const char* s,ssize_t size){
_flag[32 >> 3] |= (1 << (32 & 0x7));
 _m_editor_recom.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_editor_recom(){
_flag[32 >> 3] &= ~(1 << (32 & 0x7));
 _m_editor_recom.clear();
}
inline bool content_detail_t::has_show_highspeed() const{
return (_flag[33 >> 3] & (1 << (33 & 0x7)));
}
inline const char* content_detail_t::show_highspeed(unsigned int* size) const{
return _m_show_highspeed.get(size);
}
inline content_detail_t& content_detail_t::set_show_highspeed(const char* s,ssize_t size){
_flag[33 >> 3] |= (1 << (33 & 0x7));
 _m_show_highspeed.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline content_detail_t& content_detail_t::set_ptr_show_highspeed(const char* s,ssize_t size){
_flag[33 >> 3] |= (1 << (33 & 0x7));
 _m_show_highspeed.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void content_detail_t::clear_show_highspeed(){
_flag[33 >> 3] &= ~(1 << (33 & 0x7));
 _m_show_highspeed.clear();
}
inline bool content_detail_t::has_cp_info() const{
return (_flag[34 >> 3] & (1 << (34 & 0x7)));
}
inline const ::idl::cp_info_t& content_detail_t::cp_info() const{
 return *_m_cp_info;
}
inline ::idl::cp_info_t* content_detail_t::mutable_cp_info(){
_flag[34 >> 3] |= (1 << (34 & 0x7));
 if(!_m_cp_info){
_m_cp_info=::idl::cp_info_t::create(_pool);
}
return _m_cp_info;
}
inline ::idl::cp_info_t* content_detail_t::m_cp_info(){
_flag[34 >> 3] |= (1 << (34 & 0x7));
 if(!_m_cp_info){
_m_cp_info=::idl::cp_info_t::create(_pool);
}
return _m_cp_info;
}
inline void content_detail_t::clear_cp_info(){
if(_m_cp_info){
_flag[34 >> 3] &= ~(1 << (34 & 0x7));
 _m_cp_info->clear();
}
}
inline bool content_detail_t::has_grant_info() const{
return (_flag[35 >> 3] & (1 << (35 & 0x7)));
}
inline const ::idl::grant_detail_t& content_detail_t::grant_info() const{
 return *_m_grant_info;
}
inline ::idl::grant_detail_t* content_detail_t::mutable_grant_info(){
_flag[35 >> 3] |= (1 << (35 & 0x7));
 if(!_m_grant_info){
_m_grant_info=::idl::grant_detail_t::create(_pool);
}
return _m_grant_info;
}
inline ::idl::grant_detail_t* content_detail_t::m_grant_info(){
_flag[35 >> 3] |= (1 << (35 & 0x7));
 if(!_m_grant_info){
_m_grant_info=::idl::grant_detail_t::create(_pool);
}
return _m_grant_info;
}
inline void content_detail_t::clear_grant_info(){
if(_m_grant_info){
_flag[35 >> 3] &= ~(1 << (35 & 0x7));
 _m_grant_info->clear();
}
}
inline bool content_detail_t::has_download_info() const{
return (_flag[36 >> 3] & (1 << (36 & 0x7)));
}
inline const ::idl::vector< ::idl::download_detail_t >& content_detail_t::download_info() const{
 return _m_download_info;
}
inline void content_detail_t::clear_download_info(){
_flag[36 >> 3] &= ~(1 << (36 & 0x7));
 _m_download_info.clear();
}
inline ::idl::vector< ::idl::download_detail_t >* content_detail_t::mutable_download_info(){
_flag[36 >> 3] |= (1 << (36 & 0x7));
 return &(_m_download_info);
}
inline ::idl::vector< ::idl::download_detail_t >* content_detail_t::m_download_info(){
_flag[36 >> 3] |= (1 << (36 & 0x7));
 return &(_m_download_info);
}
inline size_t content_detail_t::download_info_size() const{
/*  */ return _m_download_info.size();
}
inline const ::idl::download_detail_t& content_detail_t::download_info(size_t i0) const{
 return _m_download_info.get(i0);
}
inline ::idl::download_detail_t* content_detail_t::mutable_download_info(size_t i0){
_flag[36 >> 3] |= (1 << (36 & 0x7));
 return _m_download_info.mutable_get(i0);
}
inline ::idl::download_detail_t* content_detail_t::m_download_info(size_t i0){
_flag[36 >> 3] |= (1 << (36 & 0x7));
 return _m_download_info.mutable_get(i0);
}
inline ::idl::Unknown* content_detail_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& content_detail_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& content_detail_t::unknown(){
return _unknown;
}
inline size_t content_detail_t::unknown_size() const{
return _unknown.size();
}
inline mcp_content_in_param* mcp_content_in_param::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_content_in_param* tmp=(mcp_content_in_param*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_content_in_param(pool);
return tmp;
}
inline void mcp_content_in_param::destroy(mcp_content_in_param* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_content_in_param();
pool->free(v,sizeof(*v));
}
}
inline mcp_content_in_param::mcp_content_in_param(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_type_id(_pool)
,_m_class_id(_pool)
,_m_weight_order(_pool)
,_m_label_id(_pool)
,_m_img_type(_pool)
,_m_column_id(_pool)
,_m_content_id(_pool)
,_m_channel_id(_pool)
,_m_channel_info(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_content_in_param::mcp_content_in_param(const mcp_content_in_param& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_type_id(_pool)
,_m_class_id(_pool)
,_m_weight_order(_pool)
,_m_label_id(_pool)
,_m_img_type(_pool)
,_m_column_id(_pool)
,_m_content_id(_pool)
,_m_channel_id(_pool)
,_m_channel_info(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_content_in_param::~mcp_content_in_param(){
}
inline mcp_content_in_param& mcp_content_in_param::operator=(const mcp_content_in_param& v){
assign(v);
return *this;
}
inline void mcp_content_in_param::clear(){
_m_type_id.clear();
_m_class_id.clear();
_m_weight_order.clear();
_m_label_id.clear();
_m_img_type.clear();
_m_column_id.clear();
_m_content_id.clear();
_m_channel_id.clear();
_m_channel_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_content_in_param::check() const{
// @@string type_id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@string class_id;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}
// @@string weight_order;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "weight_order" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_weight_order.get();

}
// @@string label_id;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "label_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_label_id.get();

}
// @@string img_type;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "img_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_img_type.get();

}
// @@string column_id;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "column_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_column_id.get();

}
// @@string content_id;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_id.get();

}
// @@string channel_id;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "channel_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_channel_id.get();

}
// @@string channel_info;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "channel_info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_channel_info.get();

}

::idl::McpackBean::check();
}
inline void mcp_content_in_param::detach(){
_m_type_id.detach();
_m_class_id.detach();
_m_weight_order.detach();
_m_label_id.detach();
_m_img_type.detach();
_m_column_id.detach();
_m_content_id.detach();
_m_channel_id.detach();
_m_channel_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_content_in_param& mcp_content_in_param::assign(const mcp_content_in_param& v){
_m_type_id=v._m_type_id;
_m_class_id=v._m_class_id;
_m_weight_order=v._m_weight_order;
_m_label_id=v._m_label_id;
_m_img_type=v._m_img_type;
_m_column_id=v._m_column_id;
_m_content_id=v._m_content_id;
_m_channel_id=v._m_channel_id;
_m_channel_info=v._m_channel_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_content_in_param::has_type_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_content_in_param::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_content_in_param& mcp_content_in_param::set_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_content_in_param& mcp_content_in_param::set_ptr_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_content_in_param::clear_type_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_content_in_param::has_class_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_content_in_param::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_content_in_param& mcp_content_in_param::set_class_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_content_in_param& mcp_content_in_param::set_ptr_class_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_content_in_param::clear_class_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_class_id.clear();
}
inline bool mcp_content_in_param::has_weight_order() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_content_in_param::weight_order(unsigned int* size) const{
return _m_weight_order.get(size);
}
inline mcp_content_in_param& mcp_content_in_param::set_weight_order(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_weight_order.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_content_in_param& mcp_content_in_param::set_ptr_weight_order(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_weight_order.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_content_in_param::clear_weight_order(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_weight_order.clear();
}
inline bool mcp_content_in_param::has_label_id() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_content_in_param::label_id(unsigned int* size) const{
return _m_label_id.get(size);
}
inline mcp_content_in_param& mcp_content_in_param::set_label_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_label_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_content_in_param& mcp_content_in_param::set_ptr_label_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_label_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_content_in_param::clear_label_id(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_label_id.clear();
}
inline bool mcp_content_in_param::has_img_type() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_content_in_param::img_type(unsigned int* size) const{
return _m_img_type.get(size);
}
inline mcp_content_in_param& mcp_content_in_param::set_img_type(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_img_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_content_in_param& mcp_content_in_param::set_ptr_img_type(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_img_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_content_in_param::clear_img_type(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_img_type.clear();
}
inline bool mcp_content_in_param::has_column_id() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* mcp_content_in_param::column_id(unsigned int* size) const{
return _m_column_id.get(size);
}
inline mcp_content_in_param& mcp_content_in_param::set_column_id(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_column_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_content_in_param& mcp_content_in_param::set_ptr_column_id(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_column_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_content_in_param::clear_column_id(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_column_id.clear();
}
inline bool mcp_content_in_param::has_content_id() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* mcp_content_in_param::content_id(unsigned int* size) const{
return _m_content_id.get(size);
}
inline mcp_content_in_param& mcp_content_in_param::set_content_id(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_content_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_content_in_param& mcp_content_in_param::set_ptr_content_id(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_content_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_content_in_param::clear_content_id(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_content_id.clear();
}
inline bool mcp_content_in_param::has_channel_id() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* mcp_content_in_param::channel_id(unsigned int* size) const{
return _m_channel_id.get(size);
}
inline mcp_content_in_param& mcp_content_in_param::set_channel_id(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_channel_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_content_in_param& mcp_content_in_param::set_ptr_channel_id(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_channel_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_content_in_param::clear_channel_id(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_channel_id.clear();
}
inline bool mcp_content_in_param::has_channel_info() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* mcp_content_in_param::channel_info(unsigned int* size) const{
return _m_channel_info.get(size);
}
inline mcp_content_in_param& mcp_content_in_param::set_channel_info(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_channel_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_content_in_param& mcp_content_in_param::set_ptr_channel_info(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_channel_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_content_in_param::clear_channel_info(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_channel_info.clear();
}
inline ::idl::Unknown* mcp_content_in_param::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_content_in_param::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_content_in_param::unknown(){
return _unknown;
}
inline size_t mcp_content_in_param::unknown_size() const{
return _unknown.size();
}
inline once_consume_goods_t* once_consume_goods_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
once_consume_goods_t* tmp=(once_consume_goods_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)once_consume_goods_t(pool);
return tmp;
}
inline void once_consume_goods_t::destroy(once_consume_goods_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~once_consume_goods_t();
pool->free(v,sizeof(*v));
}
}
inline once_consume_goods_t::once_consume_goods_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_orderid(_pool)
,_m_itemid(_pool)
,_m_ordertime(_pool)
,_m_udid(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline once_consume_goods_t::once_consume_goods_t(const once_consume_goods_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_orderid(_pool)
,_m_itemid(_pool)
,_m_ordertime(_pool)
,_m_udid(_pool)
,_unknown(_pool){
assign(v);
}
inline once_consume_goods_t::~once_consume_goods_t(){
}
inline once_consume_goods_t& once_consume_goods_t::operator=(const once_consume_goods_t& v){
assign(v);
return *this;
}
inline void once_consume_goods_t::clear(){
_m_orderid.clear();
_m_itemid.clear();
_m_ordertime.clear();
_m_udid.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void once_consume_goods_t::check() const{
// @@string orderid;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "orderid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_orderid.get();

}
// @@string itemid;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "itemid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_itemid.get();

}
// @@string ordertime;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ordertime" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ordertime.get();

}
// @@string udid;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "udid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_udid.get();

}

::idl::McpackBean::check();
}
inline void once_consume_goods_t::detach(){
_m_orderid.detach();
_m_itemid.detach();
_m_ordertime.detach();
_m_udid.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline once_consume_goods_t& once_consume_goods_t::assign(const once_consume_goods_t& v){
_m_orderid=v._m_orderid;
_m_itemid=v._m_itemid;
_m_ordertime=v._m_ordertime;
_m_udid=v._m_udid;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool once_consume_goods_t::has_orderid() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* once_consume_goods_t::orderid(unsigned int* size) const{
return _m_orderid.get(size);
}
inline once_consume_goods_t& once_consume_goods_t::set_orderid(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_orderid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline once_consume_goods_t& once_consume_goods_t::set_ptr_orderid(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_orderid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void once_consume_goods_t::clear_orderid(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_orderid.clear();
}
inline bool once_consume_goods_t::has_itemid() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* once_consume_goods_t::itemid(unsigned int* size) const{
return _m_itemid.get(size);
}
inline once_consume_goods_t& once_consume_goods_t::set_itemid(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_itemid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline once_consume_goods_t& once_consume_goods_t::set_ptr_itemid(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_itemid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void once_consume_goods_t::clear_itemid(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_itemid.clear();
}
inline bool once_consume_goods_t::has_ordertime() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* once_consume_goods_t::ordertime(unsigned int* size) const{
return _m_ordertime.get(size);
}
inline once_consume_goods_t& once_consume_goods_t::set_ordertime(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_ordertime.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline once_consume_goods_t& once_consume_goods_t::set_ptr_ordertime(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_ordertime.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void once_consume_goods_t::clear_ordertime(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_ordertime.clear();
}
inline bool once_consume_goods_t::has_udid() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* once_consume_goods_t::udid(unsigned int* size) const{
return _m_udid.get(size);
}
inline once_consume_goods_t& once_consume_goods_t::set_udid(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_udid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline once_consume_goods_t& once_consume_goods_t::set_ptr_udid(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_udid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void once_consume_goods_t::clear_udid(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_udid.clear();
}
inline ::idl::Unknown* once_consume_goods_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& once_consume_goods_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& once_consume_goods_t::unknown(){
return _unknown;
}
inline size_t once_consume_goods_t::unknown_size() const{
return _unknown.size();
}
inline game_news_entire_info_t* game_news_entire_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
game_news_entire_info_t* tmp=(game_news_entire_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)game_news_entire_info_t(pool);
return tmp;
}
inline void game_news_entire_info_t::destroy(game_news_entire_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~game_news_entire_info_t();
pool->free(v,sizeof(*v));
}
}
inline game_news_entire_info_t::game_news_entire_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_news_info(0)
,_m_game_basic_info(0)
,_m_game_download_list(_pool)
,_unknown(_pool){
_m_news_info=::idl::game_info_t::create(_pool);
_m_game_basic_info=::idl::content_basic_info_t::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline game_news_entire_info_t::game_news_entire_info_t(const game_news_entire_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_news_info(0)
,_m_game_basic_info(0)
,_m_game_download_list(_pool)
,_unknown(_pool){
_m_news_info=::idl::game_info_t::create(_pool);
_m_game_basic_info=::idl::content_basic_info_t::create(_pool);
assign(v);
}
inline game_news_entire_info_t::~game_news_entire_info_t(){
if(_m_news_info){
::idl::game_info_t::destroy(_m_news_info);
_m_news_info=0;
}
if(_m_game_basic_info){
::idl::content_basic_info_t::destroy(_m_game_basic_info);
_m_game_basic_info=0;
}
}
inline game_news_entire_info_t& game_news_entire_info_t::operator=(const game_news_entire_info_t& v){
assign(v);
return *this;
}
inline void game_news_entire_info_t::clear(){
if(_m_news_info){
_m_news_info->clear();
}
if(_m_game_basic_info){
_m_game_basic_info->clear();
}
_m_game_download_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void game_news_entire_info_t::check() const{
// @@game_info_t news_info;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "news_info" << "' not found";
}
{
::idl::game_info_t& item=const_cast< ::idl::game_info_t& >(*_m_news_info);
item.check();

}
// @@content_basic_info_t game_basic_info;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_basic_info" << "' not found";
}
{
::idl::content_basic_info_t& item=const_cast< ::idl::content_basic_info_t& >(*_m_game_basic_info);
item.check();

}
// @@download_detail_t game_download_list=array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_download_list" << "' not found";
}
{
// level 0 begin
typeof(_m_game_download_list)& lr0=(_m_game_download_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::download_detail_t& item=const_cast< ::idl::download_detail_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void game_news_entire_info_t::detach(){
if(_m_news_info){
_m_news_info->detach();
}
if(_m_game_basic_info){
_m_game_basic_info->detach();
}
_m_game_download_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline game_news_entire_info_t& game_news_entire_info_t::assign(const game_news_entire_info_t& v){
if(!v._m_news_info){
if(_m_news_info){
::idl::game_info_t::destroy(_m_news_info);
}
_m_news_info=0;
}else{
if(!_m_news_info){
_m_news_info=::idl::game_info_t::create(_pool);
}
*_m_news_info=*v._m_news_info;
}
if(!v._m_game_basic_info){
if(_m_game_basic_info){
::idl::content_basic_info_t::destroy(_m_game_basic_info);
}
_m_game_basic_info=0;
}else{
if(!_m_game_basic_info){
_m_game_basic_info=::idl::content_basic_info_t::create(_pool);
}
*_m_game_basic_info=*v._m_game_basic_info;
}
_m_game_download_list=v._m_game_download_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool game_news_entire_info_t::has_news_info() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::game_info_t& game_news_entire_info_t::news_info() const{
 return *_m_news_info;
}
inline ::idl::game_info_t* game_news_entire_info_t::mutable_news_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_news_info){
_m_news_info=::idl::game_info_t::create(_pool);
}
return _m_news_info;
}
inline ::idl::game_info_t* game_news_entire_info_t::m_news_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_news_info){
_m_news_info=::idl::game_info_t::create(_pool);
}
return _m_news_info;
}
inline void game_news_entire_info_t::clear_news_info(){
if(_m_news_info){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_news_info->clear();
}
}
inline bool game_news_entire_info_t::has_game_basic_info() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::content_basic_info_t& game_news_entire_info_t::game_basic_info() const{
 return *_m_game_basic_info;
}
inline ::idl::content_basic_info_t* game_news_entire_info_t::mutable_game_basic_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 if(!_m_game_basic_info){
_m_game_basic_info=::idl::content_basic_info_t::create(_pool);
}
return _m_game_basic_info;
}
inline ::idl::content_basic_info_t* game_news_entire_info_t::m_game_basic_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 if(!_m_game_basic_info){
_m_game_basic_info=::idl::content_basic_info_t::create(_pool);
}
return _m_game_basic_info;
}
inline void game_news_entire_info_t::clear_game_basic_info(){
if(_m_game_basic_info){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_basic_info->clear();
}
}
inline bool game_news_entire_info_t::has_game_download_list() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::download_detail_t >& game_news_entire_info_t::game_download_list() const{
 return _m_game_download_list;
}
inline void game_news_entire_info_t::clear_game_download_list(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_game_download_list.clear();
}
inline ::idl::vector< ::idl::download_detail_t >* game_news_entire_info_t::mutable_game_download_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_game_download_list);
}
inline ::idl::vector< ::idl::download_detail_t >* game_news_entire_info_t::m_game_download_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_game_download_list);
}
inline size_t game_news_entire_info_t::game_download_list_size() const{
/*  */ return _m_game_download_list.size();
}
inline const ::idl::download_detail_t& game_news_entire_info_t::game_download_list(size_t i0) const{
 return _m_game_download_list.get(i0);
}
inline ::idl::download_detail_t* game_news_entire_info_t::mutable_game_download_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_game_download_list.mutable_get(i0);
}
inline ::idl::download_detail_t* game_news_entire_info_t::m_game_download_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_game_download_list.mutable_get(i0);
}
inline ::idl::Unknown* game_news_entire_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& game_news_entire_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& game_news_entire_info_t::unknown(){
return _unknown;
}
inline size_t game_news_entire_info_t::unknown_size() const{
return _unknown.size();
}
inline game_news_info_t* game_news_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
game_news_info_t* tmp=(game_news_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)game_news_info_t(pool);
return tmp;
}
inline void game_news_info_t::destroy(game_news_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~game_news_info_t();
pool->free(v,sizeof(*v));
}
}
inline game_news_info_t::game_news_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_news_id(_pool)
,_m_news_type(_pool)
,_m_news_time(_pool)
,_m_news_content(_pool)
,_m_news_title(_pool)
,_m_news_type_name(_pool)
,_m_game_id(_pool)
,_m_game_type(_pool)
,_m_game_name(_pool)
,_m_game_img_info(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline game_news_info_t::game_news_info_t(const game_news_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_news_id(_pool)
,_m_news_type(_pool)
,_m_news_time(_pool)
,_m_news_content(_pool)
,_m_news_title(_pool)
,_m_news_type_name(_pool)
,_m_game_id(_pool)
,_m_game_type(_pool)
,_m_game_name(_pool)
,_m_game_img_info(_pool)
,_unknown(_pool){
assign(v);
}
inline game_news_info_t::~game_news_info_t(){
}
inline game_news_info_t& game_news_info_t::operator=(const game_news_info_t& v){
assign(v);
return *this;
}
inline void game_news_info_t::clear(){
_m_news_id.clear();
_m_news_type.clear();
_m_news_time.clear();
_m_news_content.clear();
_m_news_title.clear();
_m_news_type_name.clear();
_m_game_id.clear();
_m_game_type.clear();
_m_game_name.clear();
_m_game_img_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void game_news_info_t::check() const{
// @@string news_id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "news_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_news_id.get();

}
// @@string news_type;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "news_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_news_type.get();

}
// @@string news_time;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "news_time" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_news_time.get();

}
// @@string news_content;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "news_content" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_news_content.get();

}
// @@string news_title;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "news_title" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_news_title.get();

}
// @@string news_type_name;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "news_type_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_news_type_name.get();

}
// @@string game_id;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}
// @@string game_type;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_type.get();

}
// @@string game_name;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_name.get();

}
// @@img_info_t game_img_info=array(0);
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_img_info" << "' not found";
}
{
// level 0 begin
typeof(_m_game_img_info)& lr0=(_m_game_img_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::img_info_t& item=const_cast< ::idl::img_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void game_news_info_t::detach(){
_m_news_id.detach();
_m_news_type.detach();
_m_news_time.detach();
_m_news_content.detach();
_m_news_title.detach();
_m_news_type_name.detach();
_m_game_id.detach();
_m_game_type.detach();
_m_game_name.detach();
_m_game_img_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline game_news_info_t& game_news_info_t::assign(const game_news_info_t& v){
_m_news_id=v._m_news_id;
_m_news_type=v._m_news_type;
_m_news_time=v._m_news_time;
_m_news_content=v._m_news_content;
_m_news_title=v._m_news_title;
_m_news_type_name=v._m_news_type_name;
_m_game_id=v._m_game_id;
_m_game_type=v._m_game_type;
_m_game_name=v._m_game_name;
_m_game_img_info=v._m_game_img_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool game_news_info_t::has_news_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* game_news_info_t::news_id(unsigned int* size) const{
return _m_news_id.get(size);
}
inline game_news_info_t& game_news_info_t::set_news_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_news_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_news_info_t& game_news_info_t::set_ptr_news_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_news_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_news_info_t::clear_news_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_news_id.clear();
}
inline bool game_news_info_t::has_news_type() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* game_news_info_t::news_type(unsigned int* size) const{
return _m_news_type.get(size);
}
inline game_news_info_t& game_news_info_t::set_news_type(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_news_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_news_info_t& game_news_info_t::set_ptr_news_type(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_news_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_news_info_t::clear_news_type(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_news_type.clear();
}
inline bool game_news_info_t::has_news_time() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* game_news_info_t::news_time(unsigned int* size) const{
return _m_news_time.get(size);
}
inline game_news_info_t& game_news_info_t::set_news_time(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_news_time.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_news_info_t& game_news_info_t::set_ptr_news_time(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_news_time.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_news_info_t::clear_news_time(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_news_time.clear();
}
inline bool game_news_info_t::has_news_content() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* game_news_info_t::news_content(unsigned int* size) const{
return _m_news_content.get(size);
}
inline game_news_info_t& game_news_info_t::set_news_content(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_news_content.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_news_info_t& game_news_info_t::set_ptr_news_content(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_news_content.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_news_info_t::clear_news_content(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_news_content.clear();
}
inline bool game_news_info_t::has_news_title() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* game_news_info_t::news_title(unsigned int* size) const{
return _m_news_title.get(size);
}
inline game_news_info_t& game_news_info_t::set_news_title(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_news_title.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_news_info_t& game_news_info_t::set_ptr_news_title(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_news_title.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_news_info_t::clear_news_title(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_news_title.clear();
}
inline bool game_news_info_t::has_news_type_name() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* game_news_info_t::news_type_name(unsigned int* size) const{
return _m_news_type_name.get(size);
}
inline game_news_info_t& game_news_info_t::set_news_type_name(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_news_type_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_news_info_t& game_news_info_t::set_ptr_news_type_name(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_news_type_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_news_info_t::clear_news_type_name(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_news_type_name.clear();
}
inline bool game_news_info_t::has_game_id() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* game_news_info_t::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline game_news_info_t& game_news_info_t::set_game_id(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_news_info_t& game_news_info_t::set_ptr_game_id(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_news_info_t::clear_game_id(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_game_id.clear();
}
inline bool game_news_info_t::has_game_type() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* game_news_info_t::game_type(unsigned int* size) const{
return _m_game_type.get(size);
}
inline game_news_info_t& game_news_info_t::set_game_type(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_game_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_news_info_t& game_news_info_t::set_ptr_game_type(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_game_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_news_info_t::clear_game_type(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_game_type.clear();
}
inline bool game_news_info_t::has_game_name() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* game_news_info_t::game_name(unsigned int* size) const{
return _m_game_name.get(size);
}
inline game_news_info_t& game_news_info_t::set_game_name(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_game_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_news_info_t& game_news_info_t::set_ptr_game_name(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_game_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_news_info_t::clear_game_name(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_game_name.clear();
}
inline bool game_news_info_t::has_game_img_info() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline const ::idl::vector< ::idl::img_info_t >& game_news_info_t::game_img_info() const{
 return _m_game_img_info;
}
inline void game_news_info_t::clear_game_img_info(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_game_img_info.clear();
}
inline ::idl::vector< ::idl::img_info_t >* game_news_info_t::mutable_game_img_info(){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 return &(_m_game_img_info);
}
inline ::idl::vector< ::idl::img_info_t >* game_news_info_t::m_game_img_info(){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 return &(_m_game_img_info);
}
inline size_t game_news_info_t::game_img_info_size() const{
/*  */ return _m_game_img_info.size();
}
inline const ::idl::img_info_t& game_news_info_t::game_img_info(size_t i0) const{
 return _m_game_img_info.get(i0);
}
inline ::idl::img_info_t* game_news_info_t::mutable_game_img_info(size_t i0){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 return _m_game_img_info.mutable_get(i0);
}
inline ::idl::img_info_t* game_news_info_t::m_game_img_info(size_t i0){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 return _m_game_img_info.mutable_get(i0);
}
inline ::idl::Unknown* game_news_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& game_news_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& game_news_info_t::unknown(){
return _unknown;
}
inline size_t game_news_info_t::unknown_size() const{
return _unknown.size();
}
inline netgame_activity_info_t* netgame_activity_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
netgame_activity_info_t* tmp=(netgame_activity_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)netgame_activity_info_t(pool);
return tmp;
}
inline void netgame_activity_info_t::destroy(netgame_activity_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~netgame_activity_info_t();
pool->free(v,sizeof(*v));
}
}
inline netgame_activity_info_t::netgame_activity_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_act_id(_pool)
,_m_act_title(_pool)
,_m_act_content(_pool)
,_m_act_logdate(_pool)
,_m_act_img_info(_pool)
,_m_game_news_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline netgame_activity_info_t::netgame_activity_info_t(const netgame_activity_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_act_id(_pool)
,_m_act_title(_pool)
,_m_act_content(_pool)
,_m_act_logdate(_pool)
,_m_act_img_info(_pool)
,_m_game_news_list(_pool)
,_unknown(_pool){
assign(v);
}
inline netgame_activity_info_t::~netgame_activity_info_t(){
}
inline netgame_activity_info_t& netgame_activity_info_t::operator=(const netgame_activity_info_t& v){
assign(v);
return *this;
}
inline void netgame_activity_info_t::clear(){
_m_act_id.clear();
_m_act_title.clear();
_m_act_content.clear();
_m_act_logdate.clear();
_m_act_img_info.clear();
_m_game_news_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void netgame_activity_info_t::check() const{
// @@string act_id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "act_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_act_id.get();

}
// @@string act_title;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "act_title" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_act_title.get();

}
// @@string act_content;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "act_content" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_act_content.get();

}
// @@string act_logdate;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "act_logdate" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_act_logdate.get();

}
// @@img_info_t act_img_info=array(0);
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "act_img_info" << "' not found";
}
{
// level 0 begin
typeof(_m_act_img_info)& lr0=(_m_act_img_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::img_info_t& item=const_cast< ::idl::img_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@game_news_info_t game_news_list=array(0);
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_news_list" << "' not found";
}
{
// level 0 begin
typeof(_m_game_news_list)& lr0=(_m_game_news_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_news_info_t& item=const_cast< ::idl::game_news_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void netgame_activity_info_t::detach(){
_m_act_id.detach();
_m_act_title.detach();
_m_act_content.detach();
_m_act_logdate.detach();
_m_act_img_info.detach();
_m_game_news_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline netgame_activity_info_t& netgame_activity_info_t::assign(const netgame_activity_info_t& v){
_m_act_id=v._m_act_id;
_m_act_title=v._m_act_title;
_m_act_content=v._m_act_content;
_m_act_logdate=v._m_act_logdate;
_m_act_img_info=v._m_act_img_info;
_m_game_news_list=v._m_game_news_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool netgame_activity_info_t::has_act_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* netgame_activity_info_t::act_id(unsigned int* size) const{
return _m_act_id.get(size);
}
inline netgame_activity_info_t& netgame_activity_info_t::set_act_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_act_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline netgame_activity_info_t& netgame_activity_info_t::set_ptr_act_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_act_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void netgame_activity_info_t::clear_act_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_act_id.clear();
}
inline bool netgame_activity_info_t::has_act_title() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* netgame_activity_info_t::act_title(unsigned int* size) const{
return _m_act_title.get(size);
}
inline netgame_activity_info_t& netgame_activity_info_t::set_act_title(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_act_title.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline netgame_activity_info_t& netgame_activity_info_t::set_ptr_act_title(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_act_title.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void netgame_activity_info_t::clear_act_title(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_act_title.clear();
}
inline bool netgame_activity_info_t::has_act_content() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* netgame_activity_info_t::act_content(unsigned int* size) const{
return _m_act_content.get(size);
}
inline netgame_activity_info_t& netgame_activity_info_t::set_act_content(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_act_content.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline netgame_activity_info_t& netgame_activity_info_t::set_ptr_act_content(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_act_content.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void netgame_activity_info_t::clear_act_content(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_act_content.clear();
}
inline bool netgame_activity_info_t::has_act_logdate() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* netgame_activity_info_t::act_logdate(unsigned int* size) const{
return _m_act_logdate.get(size);
}
inline netgame_activity_info_t& netgame_activity_info_t::set_act_logdate(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_act_logdate.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline netgame_activity_info_t& netgame_activity_info_t::set_ptr_act_logdate(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_act_logdate.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void netgame_activity_info_t::clear_act_logdate(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_act_logdate.clear();
}
inline bool netgame_activity_info_t::has_act_img_info() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const ::idl::vector< ::idl::img_info_t >& netgame_activity_info_t::act_img_info() const{
 return _m_act_img_info;
}
inline void netgame_activity_info_t::clear_act_img_info(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_act_img_info.clear();
}
inline ::idl::vector< ::idl::img_info_t >* netgame_activity_info_t::mutable_act_img_info(){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return &(_m_act_img_info);
}
inline ::idl::vector< ::idl::img_info_t >* netgame_activity_info_t::m_act_img_info(){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return &(_m_act_img_info);
}
inline size_t netgame_activity_info_t::act_img_info_size() const{
/*  */ return _m_act_img_info.size();
}
inline const ::idl::img_info_t& netgame_activity_info_t::act_img_info(size_t i0) const{
 return _m_act_img_info.get(i0);
}
inline ::idl::img_info_t* netgame_activity_info_t::mutable_act_img_info(size_t i0){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return _m_act_img_info.mutable_get(i0);
}
inline ::idl::img_info_t* netgame_activity_info_t::m_act_img_info(size_t i0){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return _m_act_img_info.mutable_get(i0);
}
inline bool netgame_activity_info_t::has_game_news_list() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const ::idl::vector< ::idl::game_news_info_t >& netgame_activity_info_t::game_news_list() const{
 return _m_game_news_list;
}
inline void netgame_activity_info_t::clear_game_news_list(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_game_news_list.clear();
}
inline ::idl::vector< ::idl::game_news_info_t >* netgame_activity_info_t::mutable_game_news_list(){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 return &(_m_game_news_list);
}
inline ::idl::vector< ::idl::game_news_info_t >* netgame_activity_info_t::m_game_news_list(){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 return &(_m_game_news_list);
}
inline size_t netgame_activity_info_t::game_news_list_size() const{
/*  */ return _m_game_news_list.size();
}
inline const ::idl::game_news_info_t& netgame_activity_info_t::game_news_list(size_t i0) const{
 return _m_game_news_list.get(i0);
}
inline ::idl::game_news_info_t* netgame_activity_info_t::mutable_game_news_list(size_t i0){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 return _m_game_news_list.mutable_get(i0);
}
inline ::idl::game_news_info_t* netgame_activity_info_t::m_game_news_list(size_t i0){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 return _m_game_news_list.mutable_get(i0);
}
inline ::idl::Unknown* netgame_activity_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& netgame_activity_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& netgame_activity_info_t::unknown(){
return _unknown;
}
inline size_t netgame_activity_info_t::unknown_size() const{
return _unknown.size();
}
inline column_info_t* column_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
column_info_t* tmp=(column_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)column_info_t(pool);
return tmp;
}
inline void column_info_t::destroy(column_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~column_info_t();
pool->free(v,sizeof(*v));
}
}
inline column_info_t::column_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_type_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline column_info_t::column_info_t(const column_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_type_id(_pool)
,_unknown(_pool){
assign(v);
}
inline column_info_t::~column_info_t(){
}
inline column_info_t& column_info_t::operator=(const column_info_t& v){
assign(v);
return *this;
}
inline void column_info_t::clear(){
_m_id.clear();
_m_name.clear();
_m_type_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void column_info_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string type_id;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}

::idl::McpackBean::check();
}
inline void column_info_t::detach(){
_m_id.detach();
_m_name.detach();
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline column_info_t& column_info_t::assign(const column_info_t& v){
_m_id=v._m_id;
_m_name=v._m_name;
_m_type_id=v._m_type_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool column_info_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* column_info_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline column_info_t& column_info_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline column_info_t& column_info_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void column_info_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool column_info_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* column_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline column_info_t& column_info_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline column_info_t& column_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void column_info_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool column_info_t::has_type_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* column_info_t::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline column_info_t& column_info_t::set_type_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline column_info_t& column_info_t::set_ptr_type_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void column_info_t::clear_type_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_type_id.clear();
}
inline ::idl::Unknown* column_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& column_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& column_info_t::unknown(){
return _unknown;
}
inline size_t column_info_t::unknown_size() const{
return _unknown.size();
}
inline game_ext_update_info_t* game_ext_update_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
game_ext_update_info_t* tmp=(game_ext_update_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)game_ext_update_info_t(pool);
return tmp;
}
inline void game_ext_update_info_t::destroy(game_ext_update_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~game_ext_update_info_t();
pool->free(v,sizeof(*v));
}
}
inline game_ext_update_info_t::game_ext_update_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_c_id(_pool)
,_m_update_url(_pool)
,_m_diff_pkg_size(_pool)
,_m_channel_info(_pool)
,_m_channel_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline game_ext_update_info_t::game_ext_update_info_t(const game_ext_update_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_c_id(_pool)
,_m_update_url(_pool)
,_m_diff_pkg_size(_pool)
,_m_channel_info(_pool)
,_m_channel_id(_pool)
,_unknown(_pool){
assign(v);
}
inline game_ext_update_info_t::~game_ext_update_info_t(){
}
inline game_ext_update_info_t& game_ext_update_info_t::operator=(const game_ext_update_info_t& v){
assign(v);
return *this;
}
inline void game_ext_update_info_t::clear(){
_m_c_id.clear();
_m_update_url.clear();
_m_diff_pkg_size.clear();
_m_channel_info.clear();
_m_channel_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void game_ext_update_info_t::check() const{
// @@string c_id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string update_url;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "update_url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_update_url.get();

}
// @@string diff_pkg_size;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "diff_pkg_size" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_diff_pkg_size.get();

}
// @@string channel_info;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "channel_info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_channel_info.get();

}
// @@string channel_id;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "channel_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_channel_id.get();

}

::idl::McpackBean::check();
}
inline void game_ext_update_info_t::detach(){
_m_c_id.detach();
_m_update_url.detach();
_m_diff_pkg_size.detach();
_m_channel_info.detach();
_m_channel_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline game_ext_update_info_t& game_ext_update_info_t::assign(const game_ext_update_info_t& v){
_m_c_id=v._m_c_id;
_m_update_url=v._m_update_url;
_m_diff_pkg_size=v._m_diff_pkg_size;
_m_channel_info=v._m_channel_info;
_m_channel_id=v._m_channel_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool game_ext_update_info_t::has_c_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* game_ext_update_info_t::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline game_ext_update_info_t& game_ext_update_info_t::set_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_ext_update_info_t& game_ext_update_info_t::set_ptr_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_ext_update_info_t::clear_c_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_c_id.clear();
}
inline bool game_ext_update_info_t::has_update_url() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* game_ext_update_info_t::update_url(unsigned int* size) const{
return _m_update_url.get(size);
}
inline game_ext_update_info_t& game_ext_update_info_t::set_update_url(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_update_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_ext_update_info_t& game_ext_update_info_t::set_ptr_update_url(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_update_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_ext_update_info_t::clear_update_url(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_update_url.clear();
}
inline bool game_ext_update_info_t::has_diff_pkg_size() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* game_ext_update_info_t::diff_pkg_size(unsigned int* size) const{
return _m_diff_pkg_size.get(size);
}
inline game_ext_update_info_t& game_ext_update_info_t::set_diff_pkg_size(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_diff_pkg_size.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_ext_update_info_t& game_ext_update_info_t::set_ptr_diff_pkg_size(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_diff_pkg_size.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_ext_update_info_t::clear_diff_pkg_size(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_diff_pkg_size.clear();
}
inline bool game_ext_update_info_t::has_channel_info() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* game_ext_update_info_t::channel_info(unsigned int* size) const{
return _m_channel_info.get(size);
}
inline game_ext_update_info_t& game_ext_update_info_t::set_channel_info(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_channel_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_ext_update_info_t& game_ext_update_info_t::set_ptr_channel_info(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_channel_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_ext_update_info_t::clear_channel_info(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_channel_info.clear();
}
inline bool game_ext_update_info_t::has_channel_id() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* game_ext_update_info_t::channel_id(unsigned int* size) const{
return _m_channel_id.get(size);
}
inline game_ext_update_info_t& game_ext_update_info_t::set_channel_id(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_channel_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_ext_update_info_t& game_ext_update_info_t::set_ptr_channel_id(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_channel_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_ext_update_info_t::clear_channel_id(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_channel_id.clear();
}
inline ::idl::Unknown* game_ext_update_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& game_ext_update_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& game_ext_update_info_t::unknown(){
return _unknown;
}
inline size_t game_ext_update_info_t::unknown_size() const{
return _unknown.size();
}
inline game_update_download_info* game_update_download_info::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
game_update_download_info* tmp=(game_update_download_info*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)game_update_download_info(pool);
return tmp;
}
inline void game_update_download_info::destroy(game_update_download_info* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~game_update_download_info();
pool->free(v,sizeof(*v));
}
}
inline game_update_download_info::game_update_download_info(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_basic_info(0)
,_m_download_info(_pool)
,_m_update_info(_pool)
,_unknown(_pool){
_m_basic_info=::idl::content_basic_info_t::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline game_update_download_info::game_update_download_info(const game_update_download_info& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_basic_info(0)
,_m_download_info(_pool)
,_m_update_info(_pool)
,_unknown(_pool){
_m_basic_info=::idl::content_basic_info_t::create(_pool);
assign(v);
}
inline game_update_download_info::~game_update_download_info(){
if(_m_basic_info){
::idl::content_basic_info_t::destroy(_m_basic_info);
_m_basic_info=0;
}
}
inline game_update_download_info& game_update_download_info::operator=(const game_update_download_info& v){
assign(v);
return *this;
}
inline void game_update_download_info::clear(){
if(_m_basic_info){
_m_basic_info->clear();
}
_m_download_info.clear();
_m_update_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void game_update_download_info::check() const{
// @@content_basic_info_t basic_info;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "basic_info" << "' not found";
}
{
::idl::content_basic_info_t& item=const_cast< ::idl::content_basic_info_t& >(*_m_basic_info);
item.check();

}
// @@download_detail_t download_info=array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "download_info" << "' not found";
}
{
// level 0 begin
typeof(_m_download_info)& lr0=(_m_download_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::download_detail_t& item=const_cast< ::idl::download_detail_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@game_ext_update_info_t update_info=array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "update_info" << "' not found";
}
{
// level 0 begin
typeof(_m_update_info)& lr0=(_m_update_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_ext_update_info_t& item=const_cast< ::idl::game_ext_update_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void game_update_download_info::detach(){
if(_m_basic_info){
_m_basic_info->detach();
}
_m_download_info.detach();
_m_update_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline game_update_download_info& game_update_download_info::assign(const game_update_download_info& v){
if(!v._m_basic_info){
if(_m_basic_info){
::idl::content_basic_info_t::destroy(_m_basic_info);
}
_m_basic_info=0;
}else{
if(!_m_basic_info){
_m_basic_info=::idl::content_basic_info_t::create(_pool);
}
*_m_basic_info=*v._m_basic_info;
}
_m_download_info=v._m_download_info;
_m_update_info=v._m_update_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool game_update_download_info::has_basic_info() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::content_basic_info_t& game_update_download_info::basic_info() const{
 return *_m_basic_info;
}
inline ::idl::content_basic_info_t* game_update_download_info::mutable_basic_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_basic_info){
_m_basic_info=::idl::content_basic_info_t::create(_pool);
}
return _m_basic_info;
}
inline ::idl::content_basic_info_t* game_update_download_info::m_basic_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_basic_info){
_m_basic_info=::idl::content_basic_info_t::create(_pool);
}
return _m_basic_info;
}
inline void game_update_download_info::clear_basic_info(){
if(_m_basic_info){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_basic_info->clear();
}
}
inline bool game_update_download_info::has_download_info() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::download_detail_t >& game_update_download_info::download_info() const{
 return _m_download_info;
}
inline void game_update_download_info::clear_download_info(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_download_info.clear();
}
inline ::idl::vector< ::idl::download_detail_t >* game_update_download_info::mutable_download_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_download_info);
}
inline ::idl::vector< ::idl::download_detail_t >* game_update_download_info::m_download_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_download_info);
}
inline size_t game_update_download_info::download_info_size() const{
/*  */ return _m_download_info.size();
}
inline const ::idl::download_detail_t& game_update_download_info::download_info(size_t i0) const{
 return _m_download_info.get(i0);
}
inline ::idl::download_detail_t* game_update_download_info::mutable_download_info(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_download_info.mutable_get(i0);
}
inline ::idl::download_detail_t* game_update_download_info::m_download_info(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_download_info.mutable_get(i0);
}
inline bool game_update_download_info::has_update_info() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::game_ext_update_info_t >& game_update_download_info::update_info() const{
 return _m_update_info;
}
inline void game_update_download_info::clear_update_info(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_update_info.clear();
}
inline ::idl::vector< ::idl::game_ext_update_info_t >* game_update_download_info::mutable_update_info(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_update_info);
}
inline ::idl::vector< ::idl::game_ext_update_info_t >* game_update_download_info::m_update_info(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_update_info);
}
inline size_t game_update_download_info::update_info_size() const{
/*  */ return _m_update_info.size();
}
inline const ::idl::game_ext_update_info_t& game_update_download_info::update_info(size_t i0) const{
 return _m_update_info.get(i0);
}
inline ::idl::game_ext_update_info_t* game_update_download_info::mutable_update_info(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_update_info.mutable_get(i0);
}
inline ::idl::game_ext_update_info_t* game_update_download_info::m_update_info(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_update_info.mutable_get(i0);
}
inline ::idl::Unknown* game_update_download_info::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& game_update_download_info::unknown() const{
return _unknown;
}
inline ::idl::Unknown& game_update_download_info::unknown(){
return _unknown;
}
inline size_t game_update_download_info::unknown_size() const{
return _unknown.size();
}
inline game_content_download_info_t* game_content_download_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
game_content_download_info_t* tmp=(game_content_download_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)game_content_download_info_t(pool);
return tmp;
}
inline void game_content_download_info_t::destroy(game_content_download_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~game_content_download_info_t();
pool->free(v,sizeof(*v));
}
}
inline game_content_download_info_t::game_content_download_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_basic_info(0)
,_m_download_info(_pool)
,_unknown(_pool){
_m_basic_info=::idl::content_basic_info_t::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline game_content_download_info_t::game_content_download_info_t(const game_content_download_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_basic_info(0)
,_m_download_info(_pool)
,_unknown(_pool){
_m_basic_info=::idl::content_basic_info_t::create(_pool);
assign(v);
}
inline game_content_download_info_t::~game_content_download_info_t(){
if(_m_basic_info){
::idl::content_basic_info_t::destroy(_m_basic_info);
_m_basic_info=0;
}
}
inline game_content_download_info_t& game_content_download_info_t::operator=(const game_content_download_info_t& v){
assign(v);
return *this;
}
inline void game_content_download_info_t::clear(){
if(_m_basic_info){
_m_basic_info->clear();
}
_m_download_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void game_content_download_info_t::check() const{
// @@content_basic_info_t basic_info;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "basic_info" << "' not found";
}
{
::idl::content_basic_info_t& item=const_cast< ::idl::content_basic_info_t& >(*_m_basic_info);
item.check();

}
// @@download_detail_t download_info=array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "download_info" << "' not found";
}
{
// level 0 begin
typeof(_m_download_info)& lr0=(_m_download_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::download_detail_t& item=const_cast< ::idl::download_detail_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void game_content_download_info_t::detach(){
if(_m_basic_info){
_m_basic_info->detach();
}
_m_download_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline game_content_download_info_t& game_content_download_info_t::assign(const game_content_download_info_t& v){
if(!v._m_basic_info){
if(_m_basic_info){
::idl::content_basic_info_t::destroy(_m_basic_info);
}
_m_basic_info=0;
}else{
if(!_m_basic_info){
_m_basic_info=::idl::content_basic_info_t::create(_pool);
}
*_m_basic_info=*v._m_basic_info;
}
_m_download_info=v._m_download_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool game_content_download_info_t::has_basic_info() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::content_basic_info_t& game_content_download_info_t::basic_info() const{
 return *_m_basic_info;
}
inline ::idl::content_basic_info_t* game_content_download_info_t::mutable_basic_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_basic_info){
_m_basic_info=::idl::content_basic_info_t::create(_pool);
}
return _m_basic_info;
}
inline ::idl::content_basic_info_t* game_content_download_info_t::m_basic_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_basic_info){
_m_basic_info=::idl::content_basic_info_t::create(_pool);
}
return _m_basic_info;
}
inline void game_content_download_info_t::clear_basic_info(){
if(_m_basic_info){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_basic_info->clear();
}
}
inline bool game_content_download_info_t::has_download_info() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::download_detail_t >& game_content_download_info_t::download_info() const{
 return _m_download_info;
}
inline void game_content_download_info_t::clear_download_info(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_download_info.clear();
}
inline ::idl::vector< ::idl::download_detail_t >* game_content_download_info_t::mutable_download_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_download_info);
}
inline ::idl::vector< ::idl::download_detail_t >* game_content_download_info_t::m_download_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_download_info);
}
inline size_t game_content_download_info_t::download_info_size() const{
/*  */ return _m_download_info.size();
}
inline const ::idl::download_detail_t& game_content_download_info_t::download_info(size_t i0) const{
 return _m_download_info.get(i0);
}
inline ::idl::download_detail_t* game_content_download_info_t::mutable_download_info(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_download_info.mutable_get(i0);
}
inline ::idl::download_detail_t* game_content_download_info_t::m_download_info(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_download_info.mutable_get(i0);
}
inline ::idl::Unknown* game_content_download_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& game_content_download_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& game_content_download_info_t::unknown(){
return _unknown;
}
inline size_t game_content_download_info_t::unknown_size() const{
return _unknown.size();
}
inline game_dev_vir_currency_info* game_dev_vir_currency_info::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
game_dev_vir_currency_info* tmp=(game_dev_vir_currency_info*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)game_dev_vir_currency_info(pool);
return tmp;
}
inline void game_dev_vir_currency_info::destroy(game_dev_vir_currency_info* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~game_dev_vir_currency_info();
pool->free(v,sizeof(*v));
}
}
inline game_dev_vir_currency_info::game_dev_vir_currency_info(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_game_id(_pool)
,_m_exchage_rate(_pool)
,_m_icon(_pool)
,_m_desc(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline game_dev_vir_currency_info::game_dev_vir_currency_info(const game_dev_vir_currency_info& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_game_id(_pool)
,_m_exchage_rate(_pool)
,_m_icon(_pool)
,_m_desc(_pool)
,_unknown(_pool){
assign(v);
}
inline game_dev_vir_currency_info::~game_dev_vir_currency_info(){
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::operator=(const game_dev_vir_currency_info& v){
assign(v);
return *this;
}
inline void game_dev_vir_currency_info::clear(){
_m_id.clear();
_m_name.clear();
_m_game_id.clear();
_m_exchage_rate.clear();
_m_icon.clear();
_m_desc.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void game_dev_vir_currency_info::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string game_id;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}
// @@string exchage_rate;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "exchage_rate" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_exchage_rate.get();

}
// @@string icon;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "icon" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_icon.get();

}
// @@string desc;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "desc" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_desc.get();

}

::idl::McpackBean::check();
}
inline void game_dev_vir_currency_info::detach(){
_m_id.detach();
_m_name.detach();
_m_game_id.detach();
_m_exchage_rate.detach();
_m_icon.detach();
_m_desc.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::assign(const game_dev_vir_currency_info& v){
_m_id=v._m_id;
_m_name=v._m_name;
_m_game_id=v._m_game_id;
_m_exchage_rate=v._m_exchage_rate;
_m_icon=v._m_icon;
_m_desc=v._m_desc;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool game_dev_vir_currency_info::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* game_dev_vir_currency_info::id(unsigned int* size) const{
return _m_id.get(size);
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_dev_vir_currency_info::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool game_dev_vir_currency_info::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* game_dev_vir_currency_info::name(unsigned int* size) const{
return _m_name.get(size);
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_dev_vir_currency_info::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool game_dev_vir_currency_info::has_game_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* game_dev_vir_currency_info::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::set_game_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::set_ptr_game_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_dev_vir_currency_info::clear_game_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_game_id.clear();
}
inline bool game_dev_vir_currency_info::has_exchage_rate() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* game_dev_vir_currency_info::exchage_rate(unsigned int* size) const{
return _m_exchage_rate.get(size);
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::set_exchage_rate(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_exchage_rate.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::set_ptr_exchage_rate(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_exchage_rate.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_dev_vir_currency_info::clear_exchage_rate(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_exchage_rate.clear();
}
inline bool game_dev_vir_currency_info::has_icon() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* game_dev_vir_currency_info::icon(unsigned int* size) const{
return _m_icon.get(size);
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::set_icon(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_icon.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::set_ptr_icon(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_icon.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_dev_vir_currency_info::clear_icon(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_icon.clear();
}
inline bool game_dev_vir_currency_info::has_desc() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* game_dev_vir_currency_info::desc(unsigned int* size) const{
return _m_desc.get(size);
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::set_desc(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_desc.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline game_dev_vir_currency_info& game_dev_vir_currency_info::set_ptr_desc(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_desc.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void game_dev_vir_currency_info::clear_desc(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_desc.clear();
}
inline ::idl::Unknown* game_dev_vir_currency_info::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& game_dev_vir_currency_info::unknown() const{
return _unknown;
}
inline ::idl::Unknown& game_dev_vir_currency_info::unknown(){
return _unknown;
}
inline size_t game_dev_vir_currency_info::unknown_size() const{
return _unknown.size();
}
inline question_type_name_t* question_type_name_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
question_type_name_t* tmp=(question_type_name_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)question_type_name_t(pool);
return tmp;
}
inline void question_type_name_t::destroy(question_type_name_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~question_type_name_t();
pool->free(v,sizeof(*v));
}
}
inline question_type_name_t::question_type_name_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_name(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline question_type_name_t::question_type_name_t(const question_type_name_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_name(_pool)
,_unknown(_pool){
assign(v);
}
inline question_type_name_t::~question_type_name_t(){
}
inline question_type_name_t& question_type_name_t::operator=(const question_type_name_t& v){
assign(v);
return *this;
}
inline void question_type_name_t::clear(){
_m_id.clear();
_m_name.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void question_type_name_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}

::idl::McpackBean::check();
}
inline void question_type_name_t::detach(){
_m_id.detach();
_m_name.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline question_type_name_t& question_type_name_t::assign(const question_type_name_t& v){
_m_id=v._m_id;
_m_name=v._m_name;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool question_type_name_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* question_type_name_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline question_type_name_t& question_type_name_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline question_type_name_t& question_type_name_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void question_type_name_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool question_type_name_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* question_type_name_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline question_type_name_t& question_type_name_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline question_type_name_t& question_type_name_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void question_type_name_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline ::idl::Unknown* question_type_name_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& question_type_name_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& question_type_name_t::unknown(){
return _unknown;
}
inline size_t question_type_name_t::unknown_size() const{
return _unknown.size();
}
inline user_question_answer_t* user_question_answer_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
user_question_answer_t* tmp=(user_question_answer_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)user_question_answer_t(pool);
return tmp;
}
inline void user_question_answer_t::destroy(user_question_answer_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~user_question_answer_t();
pool->free(v,sizeof(*v));
}
}
inline user_question_answer_t::user_question_answer_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_app_id(_pool)
,_m_question(_pool)
,_m_answer(_pool)
,_m_status(_pool)
,_m_date_q(_pool)
,_m_date_a(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline user_question_answer_t::user_question_answer_t(const user_question_answer_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_app_id(_pool)
,_m_question(_pool)
,_m_answer(_pool)
,_m_status(_pool)
,_m_date_q(_pool)
,_m_date_a(_pool)
,_unknown(_pool){
assign(v);
}
inline user_question_answer_t::~user_question_answer_t(){
}
inline user_question_answer_t& user_question_answer_t::operator=(const user_question_answer_t& v){
assign(v);
return *this;
}
inline void user_question_answer_t::clear(){
_m_id.clear();
_m_app_id.clear();
_m_question.clear();
_m_answer.clear();
_m_status.clear();
_m_date_q.clear();
_m_date_a.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void user_question_answer_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string app_id;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "app_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_app_id.get();

}
// @@string question;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "question" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_question.get();

}
// @@string answer;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "answer" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_answer.get();

}
// @@string status;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "status" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_status.get();

}
// @@string date_q;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "date_q" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_date_q.get();

}
// @@string date_a;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "date_a" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_date_a.get();

}

::idl::McpackBean::check();
}
inline void user_question_answer_t::detach(){
_m_id.detach();
_m_app_id.detach();
_m_question.detach();
_m_answer.detach();
_m_status.detach();
_m_date_q.detach();
_m_date_a.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline user_question_answer_t& user_question_answer_t::assign(const user_question_answer_t& v){
_m_id=v._m_id;
_m_app_id=v._m_app_id;
_m_question=v._m_question;
_m_answer=v._m_answer;
_m_status=v._m_status;
_m_date_q=v._m_date_q;
_m_date_a=v._m_date_a;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool user_question_answer_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* user_question_answer_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline user_question_answer_t& user_question_answer_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_question_answer_t& user_question_answer_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_question_answer_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool user_question_answer_t::has_app_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* user_question_answer_t::app_id(unsigned int* size) const{
return _m_app_id.get(size);
}
inline user_question_answer_t& user_question_answer_t::set_app_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_app_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_question_answer_t& user_question_answer_t::set_ptr_app_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_app_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_question_answer_t::clear_app_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_app_id.clear();
}
inline bool user_question_answer_t::has_question() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* user_question_answer_t::question(unsigned int* size) const{
return _m_question.get(size);
}
inline user_question_answer_t& user_question_answer_t::set_question(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_question.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_question_answer_t& user_question_answer_t::set_ptr_question(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_question.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_question_answer_t::clear_question(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_question.clear();
}
inline bool user_question_answer_t::has_answer() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* user_question_answer_t::answer(unsigned int* size) const{
return _m_answer.get(size);
}
inline user_question_answer_t& user_question_answer_t::set_answer(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_answer.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_question_answer_t& user_question_answer_t::set_ptr_answer(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_answer.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_question_answer_t::clear_answer(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_answer.clear();
}
inline bool user_question_answer_t::has_status() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* user_question_answer_t::status(unsigned int* size) const{
return _m_status.get(size);
}
inline user_question_answer_t& user_question_answer_t::set_status(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_status.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_question_answer_t& user_question_answer_t::set_ptr_status(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_status.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_question_answer_t::clear_status(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_status.clear();
}
inline bool user_question_answer_t::has_date_q() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* user_question_answer_t::date_q(unsigned int* size) const{
return _m_date_q.get(size);
}
inline user_question_answer_t& user_question_answer_t::set_date_q(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_date_q.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_question_answer_t& user_question_answer_t::set_ptr_date_q(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_date_q.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_question_answer_t::clear_date_q(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_date_q.clear();
}
inline bool user_question_answer_t::has_date_a() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* user_question_answer_t::date_a(unsigned int* size) const{
return _m_date_a.get(size);
}
inline user_question_answer_t& user_question_answer_t::set_date_a(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_date_a.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline user_question_answer_t& user_question_answer_t::set_ptr_date_a(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_date_a.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void user_question_answer_t::clear_date_a(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_date_a.clear();
}
inline ::idl::Unknown* user_question_answer_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& user_question_answer_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& user_question_answer_t::unknown(){
return _unknown;
}
inline size_t user_question_answer_t::unknown_size() const{
return _unknown.size();
}
inline qp_activity_award_t* qp_activity_award_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
qp_activity_award_t* tmp=(qp_activity_award_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)qp_activity_award_t(pool);
return tmp;
}
inline void qp_activity_award_t::destroy(qp_activity_award_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~qp_activity_award_t();
pool->free(v,sizeof(*v));
}
}
inline qp_activity_award_t::qp_activity_award_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_pic_url(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline qp_activity_award_t::qp_activity_award_t(const qp_activity_award_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_name(_pool)
,_m_pic_url(_pool)
,_unknown(_pool){
assign(v);
}
inline qp_activity_award_t::~qp_activity_award_t(){
}
inline qp_activity_award_t& qp_activity_award_t::operator=(const qp_activity_award_t& v){
assign(v);
return *this;
}
inline void qp_activity_award_t::clear(){
_m_id.clear();
_m_name.clear();
_m_pic_url.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void qp_activity_award_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string name;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string pic_url;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "pic_url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_pic_url.get();

}

::idl::McpackBean::check();
}
inline void qp_activity_award_t::detach(){
_m_id.detach();
_m_name.detach();
_m_pic_url.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline qp_activity_award_t& qp_activity_award_t::assign(const qp_activity_award_t& v){
_m_id=v._m_id;
_m_name=v._m_name;
_m_pic_url=v._m_pic_url;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool qp_activity_award_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* qp_activity_award_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline qp_activity_award_t& qp_activity_award_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline qp_activity_award_t& qp_activity_award_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void qp_activity_award_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool qp_activity_award_t::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* qp_activity_award_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline qp_activity_award_t& qp_activity_award_t::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline qp_activity_award_t& qp_activity_award_t::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void qp_activity_award_t::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool qp_activity_award_t::has_pic_url() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* qp_activity_award_t::pic_url(unsigned int* size) const{
return _m_pic_url.get(size);
}
inline qp_activity_award_t& qp_activity_award_t::set_pic_url(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_pic_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline qp_activity_award_t& qp_activity_award_t::set_ptr_pic_url(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_pic_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void qp_activity_award_t::clear_pic_url(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_pic_url.clear();
}
inline ::idl::Unknown* qp_activity_award_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& qp_activity_award_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& qp_activity_award_t::unknown(){
return _unknown;
}
inline size_t qp_activity_award_t::unknown_size() const{
return _unknown.size();
}
inline qp_activity_t* qp_activity_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
qp_activity_t* tmp=(qp_activity_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)qp_activity_t(pool);
return tmp;
}
inline void qp_activity_t::destroy(qp_activity_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~qp_activity_t();
pool->free(v,sizeof(*v));
}
}
inline qp_activity_t::qp_activity_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_c_id(_pool)
,_m_title(_pool)
,_m_info(_pool)
,_m_rules(_pool)
,_m_start_time(0)
,_m_end_time(0)
,_m_icon_url(_pool)
,_m_status(_pool)
,_m_act_info(_pool)
,_m_qp_activity_award_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline qp_activity_t::qp_activity_t(const qp_activity_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_c_id(_pool)
,_m_title(_pool)
,_m_info(_pool)
,_m_rules(_pool)
,_m_start_time(0)
,_m_end_time(0)
,_m_icon_url(_pool)
,_m_status(_pool)
,_m_act_info(_pool)
,_m_qp_activity_award_list(_pool)
,_unknown(_pool){
assign(v);
}
inline qp_activity_t::~qp_activity_t(){
}
inline qp_activity_t& qp_activity_t::operator=(const qp_activity_t& v){
assign(v);
return *this;
}
inline void qp_activity_t::clear(){
_m_id.clear();
_m_c_id.clear();
_m_title.clear();
_m_info.clear();
_m_rules.clear();
// _m_start_time=0;
// _m_end_time=0;
_m_icon_url.clear();
_m_status.clear();
_m_act_info.clear();
_m_qp_activity_award_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void qp_activity_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string c_id;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string title;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "title" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_title.get();

}
// @@string info;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info.get();

}
// @@string rules;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "rules" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_rules.get();

}
// @@int64_t start_time;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "start_time" << "' not found";
}
{
__attribute__((unused)) int64_t item=_m_start_time;

}
// @@int64_t end_time;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "end_time" << "' not found";
}
{
__attribute__((unused)) int64_t item=_m_end_time;

}
// @@string icon_url;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "icon_url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_icon_url.get();

}
// @@string status;
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "status" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_status.get();

}
// @@string act_info;
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "act_info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_act_info.get();

}
// @@qp_activity_award_t qp_activity_award_list=array(0);
if(!(_flag[10 >> 3] & (1 << (10 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "qp_activity_award_list" << "' not found";
}
{
// level 0 begin
typeof(_m_qp_activity_award_list)& lr0=(_m_qp_activity_award_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::qp_activity_award_t& item=const_cast< ::idl::qp_activity_award_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void qp_activity_t::detach(){
_m_id.detach();
_m_c_id.detach();
_m_title.detach();
_m_info.detach();
_m_rules.detach();
_m_icon_url.detach();
_m_status.detach();
_m_act_info.detach();
_m_qp_activity_award_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline qp_activity_t& qp_activity_t::assign(const qp_activity_t& v){
_m_id=v._m_id;
_m_c_id=v._m_c_id;
_m_title=v._m_title;
_m_info=v._m_info;
_m_rules=v._m_rules;
_m_start_time=v._m_start_time;
_m_end_time=v._m_end_time;
_m_icon_url=v._m_icon_url;
_m_status=v._m_status;
_m_act_info=v._m_act_info;
_m_qp_activity_award_list=v._m_qp_activity_award_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool qp_activity_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* qp_activity_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline qp_activity_t& qp_activity_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline qp_activity_t& qp_activity_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void qp_activity_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool qp_activity_t::has_c_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* qp_activity_t::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline qp_activity_t& qp_activity_t::set_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline qp_activity_t& qp_activity_t::set_ptr_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void qp_activity_t::clear_c_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_c_id.clear();
}
inline bool qp_activity_t::has_title() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* qp_activity_t::title(unsigned int* size) const{
return _m_title.get(size);
}
inline qp_activity_t& qp_activity_t::set_title(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_title.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline qp_activity_t& qp_activity_t::set_ptr_title(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_title.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void qp_activity_t::clear_title(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_title.clear();
}
inline bool qp_activity_t::has_info() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* qp_activity_t::info(unsigned int* size) const{
return _m_info.get(size);
}
inline qp_activity_t& qp_activity_t::set_info(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline qp_activity_t& qp_activity_t::set_ptr_info(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void qp_activity_t::clear_info(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_info.clear();
}
inline bool qp_activity_t::has_rules() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* qp_activity_t::rules(unsigned int* size) const{
return _m_rules.get(size);
}
inline qp_activity_t& qp_activity_t::set_rules(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_rules.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline qp_activity_t& qp_activity_t::set_ptr_rules(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_rules.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void qp_activity_t::clear_rules(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_rules.clear();
}
inline bool qp_activity_t::has_start_time() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline int64_t qp_activity_t::start_time() const{
return _m_start_time;
}
inline qp_activity_t& qp_activity_t::set_start_time(int64_t v){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_start_time=v;
return *this;
}
inline void qp_activity_t::clear_start_time(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_start_time=0;
}
inline bool qp_activity_t::has_end_time() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline int64_t qp_activity_t::end_time() const{
return _m_end_time;
}
inline qp_activity_t& qp_activity_t::set_end_time(int64_t v){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_end_time=v;
return *this;
}
inline void qp_activity_t::clear_end_time(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_end_time=0;
}
inline bool qp_activity_t::has_icon_url() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* qp_activity_t::icon_url(unsigned int* size) const{
return _m_icon_url.get(size);
}
inline qp_activity_t& qp_activity_t::set_icon_url(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_icon_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline qp_activity_t& qp_activity_t::set_ptr_icon_url(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_icon_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void qp_activity_t::clear_icon_url(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_icon_url.clear();
}
inline bool qp_activity_t::has_status() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* qp_activity_t::status(unsigned int* size) const{
return _m_status.get(size);
}
inline qp_activity_t& qp_activity_t::set_status(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_status.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline qp_activity_t& qp_activity_t::set_ptr_status(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_status.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void qp_activity_t::clear_status(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_status.clear();
}
inline bool qp_activity_t::has_act_info() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline const char* qp_activity_t::act_info(unsigned int* size) const{
return _m_act_info.get(size);
}
inline qp_activity_t& qp_activity_t::set_act_info(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_act_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline qp_activity_t& qp_activity_t::set_ptr_act_info(const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_act_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void qp_activity_t::clear_act_info(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_act_info.clear();
}
inline bool qp_activity_t::has_qp_activity_award_list() const{
return (_flag[10 >> 3] & (1 << (10 & 0x7)));
}
inline const ::idl::vector< ::idl::qp_activity_award_t >& qp_activity_t::qp_activity_award_list() const{
 return _m_qp_activity_award_list;
}
inline void qp_activity_t::clear_qp_activity_award_list(){
_flag[10 >> 3] &= ~(1 << (10 & 0x7));
 _m_qp_activity_award_list.clear();
}
inline ::idl::vector< ::idl::qp_activity_award_t >* qp_activity_t::mutable_qp_activity_award_list(){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 return &(_m_qp_activity_award_list);
}
inline ::idl::vector< ::idl::qp_activity_award_t >* qp_activity_t::m_qp_activity_award_list(){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 return &(_m_qp_activity_award_list);
}
inline size_t qp_activity_t::qp_activity_award_list_size() const{
/*  */ return _m_qp_activity_award_list.size();
}
inline const ::idl::qp_activity_award_t& qp_activity_t::qp_activity_award_list(size_t i0) const{
 return _m_qp_activity_award_list.get(i0);
}
inline ::idl::qp_activity_award_t* qp_activity_t::mutable_qp_activity_award_list(size_t i0){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 return _m_qp_activity_award_list.mutable_get(i0);
}
inline ::idl::qp_activity_award_t* qp_activity_t::m_qp_activity_award_list(size_t i0){
_flag[10 >> 3] |= (1 << (10 & 0x7));
 return _m_qp_activity_award_list.mutable_get(i0);
}
inline ::idl::Unknown* qp_activity_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& qp_activity_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& qp_activity_t::unknown(){
return _unknown;
}
inline size_t qp_activity_t::unknown_size() const{
return _unknown.size();
}
inline qp_activity_person_t* qp_activity_person_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
qp_activity_person_t* tmp=(qp_activity_person_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)qp_activity_person_t(pool);
return tmp;
}
inline void qp_activity_person_t::destroy(qp_activity_person_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~qp_activity_person_t();
pool->free(v,sizeof(*v));
}
}
inline qp_activity_person_t::qp_activity_person_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_c_id(_pool)
,_m_person_num(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline qp_activity_person_t::qp_activity_person_t(const qp_activity_person_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_c_id(_pool)
,_m_person_num(_pool)
,_unknown(_pool){
assign(v);
}
inline qp_activity_person_t::~qp_activity_person_t(){
}
inline qp_activity_person_t& qp_activity_person_t::operator=(const qp_activity_person_t& v){
assign(v);
return *this;
}
inline void qp_activity_person_t::clear(){
_m_c_id.clear();
_m_person_num.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void qp_activity_person_t::check() const{
// @@string c_id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string person_num;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "person_num" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_person_num.get();

}

::idl::McpackBean::check();
}
inline void qp_activity_person_t::detach(){
_m_c_id.detach();
_m_person_num.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline qp_activity_person_t& qp_activity_person_t::assign(const qp_activity_person_t& v){
_m_c_id=v._m_c_id;
_m_person_num=v._m_person_num;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool qp_activity_person_t::has_c_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* qp_activity_person_t::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline qp_activity_person_t& qp_activity_person_t::set_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline qp_activity_person_t& qp_activity_person_t::set_ptr_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void qp_activity_person_t::clear_c_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_c_id.clear();
}
inline bool qp_activity_person_t::has_person_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* qp_activity_person_t::person_num(unsigned int* size) const{
return _m_person_num.get(size);
}
inline qp_activity_person_t& qp_activity_person_t::set_person_num(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_person_num.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline qp_activity_person_t& qp_activity_person_t::set_ptr_person_num(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_person_num.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void qp_activity_person_t::clear_person_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_person_num.clear();
}
inline ::idl::Unknown* qp_activity_person_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& qp_activity_person_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& qp_activity_person_t::unknown(){
return _unknown;
}
inline size_t qp_activity_person_t::unknown_size() const{
return _unknown.size();
}
inline person_all_award_info_t* person_all_award_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
person_all_award_info_t* tmp=(person_all_award_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)person_all_award_info_t(pool);
return tmp;
}
inline void person_all_award_info_t::destroy(person_all_award_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~person_all_award_info_t();
pool->free(v,sizeof(*v));
}
}
inline person_all_award_info_t::person_all_award_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_icon(_pool)
,_m_name(_pool)
,_m_date(0)
,_m_type(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline person_all_award_info_t::person_all_award_info_t(const person_all_award_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_icon(_pool)
,_m_name(_pool)
,_m_date(0)
,_m_type(_pool)
,_unknown(_pool){
assign(v);
}
inline person_all_award_info_t::~person_all_award_info_t(){
}
inline person_all_award_info_t& person_all_award_info_t::operator=(const person_all_award_info_t& v){
assign(v);
return *this;
}
inline void person_all_award_info_t::clear(){
_m_id.clear();
_m_icon.clear();
_m_name.clear();
// _m_date=0;
_m_type.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void person_all_award_info_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string icon;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "icon" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_icon.get();

}
// @@string name;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@int64_t date;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "date" << "' not found";
}
{
__attribute__((unused)) int64_t item=_m_date;

}
// @@string type;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type.get();

}

::idl::McpackBean::check();
}
inline void person_all_award_info_t::detach(){
_m_id.detach();
_m_icon.detach();
_m_name.detach();
_m_type.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline person_all_award_info_t& person_all_award_info_t::assign(const person_all_award_info_t& v){
_m_id=v._m_id;
_m_icon=v._m_icon;
_m_name=v._m_name;
_m_date=v._m_date;
_m_type=v._m_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool person_all_award_info_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* person_all_award_info_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline person_all_award_info_t& person_all_award_info_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline person_all_award_info_t& person_all_award_info_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void person_all_award_info_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool person_all_award_info_t::has_icon() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* person_all_award_info_t::icon(unsigned int* size) const{
return _m_icon.get(size);
}
inline person_all_award_info_t& person_all_award_info_t::set_icon(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_icon.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline person_all_award_info_t& person_all_award_info_t::set_ptr_icon(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_icon.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void person_all_award_info_t::clear_icon(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_icon.clear();
}
inline bool person_all_award_info_t::has_name() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* person_all_award_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline person_all_award_info_t& person_all_award_info_t::set_name(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline person_all_award_info_t& person_all_award_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void person_all_award_info_t::clear_name(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_name.clear();
}
inline bool person_all_award_info_t::has_date() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline int64_t person_all_award_info_t::date() const{
return _m_date;
}
inline person_all_award_info_t& person_all_award_info_t::set_date(int64_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_date=v;
return *this;
}
inline void person_all_award_info_t::clear_date(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_date=0;
}
inline bool person_all_award_info_t::has_type() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* person_all_award_info_t::type(unsigned int* size) const{
return _m_type.get(size);
}
inline person_all_award_info_t& person_all_award_info_t::set_type(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline person_all_award_info_t& person_all_award_info_t::set_ptr_type(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void person_all_award_info_t::clear_type(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_type.clear();
}
inline ::idl::Unknown* person_all_award_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& person_all_award_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& person_all_award_info_t::unknown(){
return _unknown;
}
inline size_t person_all_award_info_t::unknown_size() const{
return _unknown.size();
}
inline person_award_info_t* person_award_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
person_award_info_t* tmp=(person_award_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)person_award_info_t(pool);
return tmp;
}
inline void person_award_info_t::destroy(person_award_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~person_award_info_t();
pool->free(v,sizeof(*v));
}
}
inline person_award_info_t::person_award_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_user_id(_pool)
,_m_commodity_id(_pool)
,_m_name(_pool)
,_m_kudou(_pool)
,_m_priority(_pool)
,_m_icon(_pool)
,_m_rank(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline person_award_info_t::person_award_info_t(const person_award_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_user_id(_pool)
,_m_commodity_id(_pool)
,_m_name(_pool)
,_m_kudou(_pool)
,_m_priority(_pool)
,_m_icon(_pool)
,_m_rank(0)
,_unknown(_pool){
assign(v);
}
inline person_award_info_t::~person_award_info_t(){
}
inline person_award_info_t& person_award_info_t::operator=(const person_award_info_t& v){
assign(v);
return *this;
}
inline void person_award_info_t::clear(){
_m_id.clear();
_m_user_id.clear();
_m_commodity_id.clear();
_m_name.clear();
_m_kudou.clear();
_m_priority.clear();
_m_icon.clear();
// _m_rank=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void person_award_info_t::check() const{
// @@string id;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string user_id;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}
// @@string commodity_id;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "commodity_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_commodity_id.get();

}
// @@string name;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string kudou;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "kudou" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_kudou.get();

}
// @@string priority;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "priority" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_priority.get();

}
// @@string icon;
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "icon" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_icon.get();

}
// @@int32_t rank;
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "rank" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_rank;

}

::idl::McpackBean::check();
}
inline void person_award_info_t::detach(){
_m_id.detach();
_m_user_id.detach();
_m_commodity_id.detach();
_m_name.detach();
_m_kudou.detach();
_m_priority.detach();
_m_icon.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline person_award_info_t& person_award_info_t::assign(const person_award_info_t& v){
_m_id=v._m_id;
_m_user_id=v._m_user_id;
_m_commodity_id=v._m_commodity_id;
_m_name=v._m_name;
_m_kudou=v._m_kudou;
_m_priority=v._m_priority;
_m_icon=v._m_icon;
_m_rank=v._m_rank;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool person_award_info_t::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* person_award_info_t::id(unsigned int* size) const{
return _m_id.get(size);
}
inline person_award_info_t& person_award_info_t::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline person_award_info_t& person_award_info_t::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void person_award_info_t::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool person_award_info_t::has_user_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* person_award_info_t::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline person_award_info_t& person_award_info_t::set_user_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline person_award_info_t& person_award_info_t::set_ptr_user_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void person_award_info_t::clear_user_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_user_id.clear();
}
inline bool person_award_info_t::has_commodity_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* person_award_info_t::commodity_id(unsigned int* size) const{
return _m_commodity_id.get(size);
}
inline person_award_info_t& person_award_info_t::set_commodity_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_commodity_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline person_award_info_t& person_award_info_t::set_ptr_commodity_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_commodity_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void person_award_info_t::clear_commodity_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_commodity_id.clear();
}
inline bool person_award_info_t::has_name() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* person_award_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline person_award_info_t& person_award_info_t::set_name(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline person_award_info_t& person_award_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void person_award_info_t::clear_name(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_name.clear();
}
inline bool person_award_info_t::has_kudou() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* person_award_info_t::kudou(unsigned int* size) const{
return _m_kudou.get(size);
}
inline person_award_info_t& person_award_info_t::set_kudou(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_kudou.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline person_award_info_t& person_award_info_t::set_ptr_kudou(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_kudou.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void person_award_info_t::clear_kudou(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_kudou.clear();
}
inline bool person_award_info_t::has_priority() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* person_award_info_t::priority(unsigned int* size) const{
return _m_priority.get(size);
}
inline person_award_info_t& person_award_info_t::set_priority(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_priority.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline person_award_info_t& person_award_info_t::set_ptr_priority(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_priority.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void person_award_info_t::clear_priority(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_priority.clear();
}
inline bool person_award_info_t::has_icon() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* person_award_info_t::icon(unsigned int* size) const{
return _m_icon.get(size);
}
inline person_award_info_t& person_award_info_t::set_icon(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_icon.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline person_award_info_t& person_award_info_t::set_ptr_icon(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_icon.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void person_award_info_t::clear_icon(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_icon.clear();
}
inline bool person_award_info_t::has_rank() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline int32_t person_award_info_t::rank() const{
return _m_rank;
}
inline person_award_info_t& person_award_info_t::set_rank(int32_t v){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_rank=v;
return *this;
}
inline void person_award_info_t::clear_rank(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_rank=0;
}
inline ::idl::Unknown* person_award_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& person_award_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& person_award_info_t::unknown(){
return _unknown;
}
inline size_t person_award_info_t::unknown_size() const{
return _unknown.size();
}
inline award_info_t* award_info_t::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
award_info_t* tmp=(award_info_t*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)award_info_t(pool);
return tmp;
}
inline void award_info_t::destroy(award_info_t* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~award_info_t();
pool->free(v,sizeof(*v));
}
}
inline award_info_t::award_info_t(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_type(_pool)
,_m_award_id(_pool)
,_m_name(_pool)
,_m_prize_name(_pool)
,_m_icon(_pool)
,_m_prize_url(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline award_info_t::award_info_t(const award_info_t& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_type(_pool)
,_m_award_id(_pool)
,_m_name(_pool)
,_m_prize_name(_pool)
,_m_icon(_pool)
,_m_prize_url(_pool)
,_unknown(_pool){
assign(v);
}
inline award_info_t::~award_info_t(){
}
inline award_info_t& award_info_t::operator=(const award_info_t& v){
assign(v);
return *this;
}
inline void award_info_t::clear(){
_m_type.clear();
_m_award_id.clear();
_m_name.clear();
_m_prize_name.clear();
_m_icon.clear();
_m_prize_url.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void award_info_t::check() const{
// @@string type;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type.get();

}
// @@string award_id;
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "award_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_award_id.get();

}
// @@string name;
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string prize_name;
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "prize_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_prize_name.get();

}
// @@string icon;
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "icon" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_icon.get();

}
// @@string prize_url;
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "prize_url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_prize_url.get();

}

::idl::McpackBean::check();
}
inline void award_info_t::detach(){
_m_type.detach();
_m_award_id.detach();
_m_name.detach();
_m_prize_name.detach();
_m_icon.detach();
_m_prize_url.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline award_info_t& award_info_t::assign(const award_info_t& v){
_m_type=v._m_type;
_m_award_id=v._m_award_id;
_m_name=v._m_name;
_m_prize_name=v._m_prize_name;
_m_icon=v._m_icon;
_m_prize_url=v._m_prize_url;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool award_info_t::has_type() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* award_info_t::type(unsigned int* size) const{
return _m_type.get(size);
}
inline award_info_t& award_info_t::set_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline award_info_t& award_info_t::set_ptr_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void award_info_t::clear_type(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_type.clear();
}
inline bool award_info_t::has_award_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* award_info_t::award_id(unsigned int* size) const{
return _m_award_id.get(size);
}
inline award_info_t& award_info_t::set_award_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_award_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline award_info_t& award_info_t::set_ptr_award_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_award_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void award_info_t::clear_award_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_award_id.clear();
}
inline bool award_info_t::has_name() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* award_info_t::name(unsigned int* size) const{
return _m_name.get(size);
}
inline award_info_t& award_info_t::set_name(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline award_info_t& award_info_t::set_ptr_name(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void award_info_t::clear_name(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_name.clear();
}
inline bool award_info_t::has_prize_name() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* award_info_t::prize_name(unsigned int* size) const{
return _m_prize_name.get(size);
}
inline award_info_t& award_info_t::set_prize_name(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_prize_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline award_info_t& award_info_t::set_ptr_prize_name(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_prize_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void award_info_t::clear_prize_name(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_prize_name.clear();
}
inline bool award_info_t::has_icon() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* award_info_t::icon(unsigned int* size) const{
return _m_icon.get(size);
}
inline award_info_t& award_info_t::set_icon(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_icon.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline award_info_t& award_info_t::set_ptr_icon(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_icon.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void award_info_t::clear_icon(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_icon.clear();
}
inline bool award_info_t::has_prize_url() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* award_info_t::prize_url(unsigned int* size) const{
return _m_prize_url.get(size);
}
inline award_info_t& award_info_t::set_prize_url(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_prize_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline award_info_t& award_info_t::set_ptr_prize_url(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_prize_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void award_info_t::clear_prize_url(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_prize_url.clear();
}
inline ::idl::Unknown* award_info_t::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& award_info_t::unknown() const{
return _unknown;
}
inline ::idl::Unknown& award_info_t::unknown(){
return _unknown;
}
inline size_t award_info_t::unknown_size() const{
return _unknown.size();
}
inline mcp_get_test_params* mcp_get_test_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_test_params* tmp=(mcp_get_test_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_test_params(pool);
return tmp;
}
inline void mcp_get_test_params::destroy(mcp_get_test_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_test_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_test_params::mcp_get_test_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_type(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_test_params::mcp_get_test_params(const mcp_get_test_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_type(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_test_params::~mcp_get_test_params(){
}
inline mcp_get_test_params& mcp_get_test_params::operator=(const mcp_get_test_params& v){
assign(v);
return *this;
}
inline void mcp_get_test_params::clear(){
// _m_info_type=0;
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_test_params::check() const{
// @@uint32_t info_type=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_type;

}
// @@uint32_t unit_num=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_test_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_test_params& mcp_get_test_params::assign(const mcp_get_test_params& v){
_m_info_type=v._m_info_type;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_test_params::has_info_type() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_test_params::info_type() const{
return _m_info_type;
}
inline mcp_get_test_params& mcp_get_test_params::set_info_type(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_type=v;
return *this;
}
inline void mcp_get_test_params::clear_info_type(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_type=0;
}
inline bool mcp_get_test_params::has_unit_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_test_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_test_params& mcp_get_test_params::set_unit_num(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_test_params::clear_unit_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_test_params::has_unit_times() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_test_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_test_params& mcp_get_test_params::set_unit_times(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_test_params::clear_unit_times(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_test_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_test_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_test_params::unknown(){
return _unknown;
}
inline size_t mcp_get_test_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_test_result_params* mcp_get_test_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_test_result_params* tmp=(mcp_get_test_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_test_result_params(pool);
return tmp;
}
inline void mcp_get_test_result_params::destroy(mcp_get_test_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_test_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_test_result_params::mcp_get_test_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_count(0)
,_m_info_id(_pool)
,_m_info_name(_pool)
,_m_phone_count(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_test_result_params::mcp_get_test_result_params(const mcp_get_test_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_count(0)
,_m_info_id(_pool)
,_m_info_name(_pool)
,_m_phone_count(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_test_result_params::~mcp_get_test_result_params(){
}
inline mcp_get_test_result_params& mcp_get_test_result_params::operator=(const mcp_get_test_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_test_result_params::clear(){
// _m_info_count=0;
_m_info_id.clear();
_m_info_name.clear();
_m_phone_count.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_test_result_params::check() const{
// @@uint32_t info_count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_count;

}
// @@string info_id=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
// level 0 begin
typeof(_m_info_id)& lr0=(_m_info_id);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@string info_name=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_name" << "' not found";
}
{
// level 0 begin
typeof(_m_info_name)& lr0=(_m_info_name);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@uint32_t phone_count=out(),array(0);
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_count" << "' not found";
}
{
// level 0 begin
typeof(_m_phone_count)& lr0=(_m_phone_count);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) uint32_t item=lr0.GetWithoutCheck(i0);

}

}

::idl::McpackBean::check();
}
inline void mcp_get_test_result_params::detach(){
_m_info_id.detach();
_m_info_name.detach();
_m_phone_count.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_test_result_params& mcp_get_test_result_params::assign(const mcp_get_test_result_params& v){
_m_info_count=v._m_info_count;
_m_info_id=v._m_info_id;
_m_info_name=v._m_info_name;
_m_phone_count=v._m_phone_count;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_test_result_params::has_info_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_test_result_params::info_count() const{
return _m_info_count;
}
inline mcp_get_test_result_params& mcp_get_test_result_params::set_info_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_count=v;
return *this;
}
inline void mcp_get_test_result_params::clear_info_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_count=0;
}
inline bool mcp_get_test_result_params::has_info_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_test_result_params::info_id() const{
 return _m_info_id;
}
inline void mcp_get_test_result_params::clear_info_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_id.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_test_result_params::mutable_info_id(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_id);
}
inline ::idl::vector< ::idl::string >* mcp_get_test_result_params::m_info_id(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_id);
}
inline size_t mcp_get_test_result_params::info_id_size() const{
/*  */ return _m_info_id.size();
}
inline const char* mcp_get_test_result_params::info_id(size_t i0,unsigned int* size) const{
 return _m_info_id.get(i0).get(size);
}
inline mcp_get_test_result_params& mcp_get_test_result_params::set_info_id(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_test_result_params& mcp_get_test_result_params::set_ptr_info_id(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool mcp_get_test_result_params::has_info_name() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_test_result_params::info_name() const{
 return _m_info_name;
}
inline void mcp_get_test_result_params::clear_info_name(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_name.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_test_result_params::mutable_info_name(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_info_name);
}
inline ::idl::vector< ::idl::string >* mcp_get_test_result_params::m_info_name(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_info_name);
}
inline size_t mcp_get_test_result_params::info_name_size() const{
/*  */ return _m_info_name.size();
}
inline const char* mcp_get_test_result_params::info_name(size_t i0,unsigned int* size) const{
 return _m_info_name.get(i0).get(size);
}
inline mcp_get_test_result_params& mcp_get_test_result_params::set_info_name(size_t i0,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_name.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_test_result_params& mcp_get_test_result_params::set_ptr_info_name(size_t i0,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_name.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool mcp_get_test_result_params::has_phone_count() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const ::idl::vector< uint32_t >& mcp_get_test_result_params::phone_count() const{
 return _m_phone_count;
}
inline void mcp_get_test_result_params::clear_phone_count(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_phone_count.clear();
}
inline ::idl::vector< uint32_t >* mcp_get_test_result_params::mutable_phone_count(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_phone_count);
}
inline ::idl::vector< uint32_t >* mcp_get_test_result_params::m_phone_count(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_phone_count);
}
inline size_t mcp_get_test_result_params::phone_count_size() const{
/*  */ return _m_phone_count.size();
}
inline uint32_t mcp_get_test_result_params::phone_count(size_t i0) const{
 return _m_phone_count.get(i0);
}
inline mcp_get_test_result_params& mcp_get_test_result_params::set_phone_count(size_t i0,uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 *(_m_phone_count.mutable_get(i0))=v;
return *this;
}
inline ::idl::Unknown* mcp_get_test_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_test_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_test_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_test_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_test_response* mcp_get_test_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_test_response* tmp=(mcp_get_test_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_test_response(pool);
return tmp;
}
inline void mcp_get_test_response::destroy(mcp_get_test_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_test_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_test_response::mcp_get_test_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_test_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_test_response::mcp_get_test_response(const mcp_get_test_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_test_result_params::create(_pool);
assign(v);
}
inline mcp_get_test_response::~mcp_get_test_response(){
if(_m_result_params){
::idl::mcp_get_test_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_test_response& mcp_get_test_response::operator=(const mcp_get_test_response& v){
assign(v);
return *this;
}
inline void mcp_get_test_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_test_response::check() const{
// @@mcp_get_test_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_test_result_params& item=const_cast< ::idl::mcp_get_test_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_test_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_test_response& mcp_get_test_response::assign(const mcp_get_test_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_test_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_test_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_test_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_test_result_params& mcp_get_test_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_test_result_params* mcp_get_test_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_test_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_test_result_params* mcp_get_test_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_test_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_test_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_test_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_test_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_test_response::unknown(){
return _unknown;
}
inline size_t mcp_get_test_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_maker_plat_params* mcp_get_phone_maker_plat_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_maker_plat_params* tmp=(mcp_get_phone_maker_plat_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_maker_plat_params(pool);
return tmp;
}
inline void mcp_get_phone_maker_plat_params::destroy(mcp_get_phone_maker_plat_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_maker_plat_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_maker_plat_params::mcp_get_phone_maker_plat_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_type(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_maker_plat_params::mcp_get_phone_maker_plat_params(const mcp_get_phone_maker_plat_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_type(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_maker_plat_params::~mcp_get_phone_maker_plat_params(){
}
inline mcp_get_phone_maker_plat_params& mcp_get_phone_maker_plat_params::operator=(const mcp_get_phone_maker_plat_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_maker_plat_params::clear(){
// _m_info_type=0;
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_maker_plat_params::check() const{
// @@uint32_t info_type=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_type;

}
// @@uint32_t unit_num=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_maker_plat_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_maker_plat_params& mcp_get_phone_maker_plat_params::assign(const mcp_get_phone_maker_plat_params& v){
_m_info_type=v._m_info_type;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_maker_plat_params::has_info_type() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_phone_maker_plat_params::info_type() const{
return _m_info_type;
}
inline mcp_get_phone_maker_plat_params& mcp_get_phone_maker_plat_params::set_info_type(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_type=v;
return *this;
}
inline void mcp_get_phone_maker_plat_params::clear_info_type(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_type=0;
}
inline bool mcp_get_phone_maker_plat_params::has_unit_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_phone_maker_plat_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_phone_maker_plat_params& mcp_get_phone_maker_plat_params::set_unit_num(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_phone_maker_plat_params::clear_unit_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_phone_maker_plat_params::has_unit_times() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_phone_maker_plat_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_phone_maker_plat_params& mcp_get_phone_maker_plat_params::set_unit_times(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_phone_maker_plat_params::clear_unit_times(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_phone_maker_plat_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_maker_plat_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_maker_plat_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_maker_plat_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_maker_plat_result_params* mcp_get_phone_maker_plat_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_maker_plat_result_params* tmp=(mcp_get_phone_maker_plat_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_maker_plat_result_params(pool);
return tmp;
}
inline void mcp_get_phone_maker_plat_result_params::destroy(mcp_get_phone_maker_plat_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_maker_plat_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_maker_plat_result_params::mcp_get_phone_maker_plat_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_count(0)
,_m_info_id(_pool)
,_m_info_name(_pool)
,_m_phone_count(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_maker_plat_result_params::mcp_get_phone_maker_plat_result_params(const mcp_get_phone_maker_plat_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_count(0)
,_m_info_id(_pool)
,_m_info_name(_pool)
,_m_phone_count(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_maker_plat_result_params::~mcp_get_phone_maker_plat_result_params(){
}
inline mcp_get_phone_maker_plat_result_params& mcp_get_phone_maker_plat_result_params::operator=(const mcp_get_phone_maker_plat_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_maker_plat_result_params::clear(){
// _m_info_count=0;
_m_info_id.clear();
_m_info_name.clear();
_m_phone_count.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_maker_plat_result_params::check() const{
// @@uint32_t info_count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_count;

}
// @@string info_id=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
// level 0 begin
typeof(_m_info_id)& lr0=(_m_info_id);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@string info_name=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_name" << "' not found";
}
{
// level 0 begin
typeof(_m_info_name)& lr0=(_m_info_name);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@uint32_t phone_count=out(),array(0);
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_count" << "' not found";
}
{
// level 0 begin
typeof(_m_phone_count)& lr0=(_m_phone_count);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) uint32_t item=lr0.GetWithoutCheck(i0);

}

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_maker_plat_result_params::detach(){
_m_info_id.detach();
_m_info_name.detach();
_m_phone_count.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_maker_plat_result_params& mcp_get_phone_maker_plat_result_params::assign(const mcp_get_phone_maker_plat_result_params& v){
_m_info_count=v._m_info_count;
_m_info_id=v._m_info_id;
_m_info_name=v._m_info_name;
_m_phone_count=v._m_phone_count;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_maker_plat_result_params::has_info_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_phone_maker_plat_result_params::info_count() const{
return _m_info_count;
}
inline mcp_get_phone_maker_plat_result_params& mcp_get_phone_maker_plat_result_params::set_info_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_count=v;
return *this;
}
inline void mcp_get_phone_maker_plat_result_params::clear_info_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_count=0;
}
inline bool mcp_get_phone_maker_plat_result_params::has_info_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_phone_maker_plat_result_params::info_id() const{
 return _m_info_id;
}
inline void mcp_get_phone_maker_plat_result_params::clear_info_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_id.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_maker_plat_result_params::mutable_info_id(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_id);
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_maker_plat_result_params::m_info_id(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_id);
}
inline size_t mcp_get_phone_maker_plat_result_params::info_id_size() const{
/*  */ return _m_info_id.size();
}
inline const char* mcp_get_phone_maker_plat_result_params::info_id(size_t i0,unsigned int* size) const{
 return _m_info_id.get(i0).get(size);
}
inline mcp_get_phone_maker_plat_result_params& mcp_get_phone_maker_plat_result_params::set_info_id(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_phone_maker_plat_result_params& mcp_get_phone_maker_plat_result_params::set_ptr_info_id(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool mcp_get_phone_maker_plat_result_params::has_info_name() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_phone_maker_plat_result_params::info_name() const{
 return _m_info_name;
}
inline void mcp_get_phone_maker_plat_result_params::clear_info_name(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_name.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_maker_plat_result_params::mutable_info_name(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_info_name);
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_maker_plat_result_params::m_info_name(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_info_name);
}
inline size_t mcp_get_phone_maker_plat_result_params::info_name_size() const{
/*  */ return _m_info_name.size();
}
inline const char* mcp_get_phone_maker_plat_result_params::info_name(size_t i0,unsigned int* size) const{
 return _m_info_name.get(i0).get(size);
}
inline mcp_get_phone_maker_plat_result_params& mcp_get_phone_maker_plat_result_params::set_info_name(size_t i0,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_name.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_phone_maker_plat_result_params& mcp_get_phone_maker_plat_result_params::set_ptr_info_name(size_t i0,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_name.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool mcp_get_phone_maker_plat_result_params::has_phone_count() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const ::idl::vector< uint32_t >& mcp_get_phone_maker_plat_result_params::phone_count() const{
 return _m_phone_count;
}
inline void mcp_get_phone_maker_plat_result_params::clear_phone_count(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_phone_count.clear();
}
inline ::idl::vector< uint32_t >* mcp_get_phone_maker_plat_result_params::mutable_phone_count(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_phone_count);
}
inline ::idl::vector< uint32_t >* mcp_get_phone_maker_plat_result_params::m_phone_count(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_phone_count);
}
inline size_t mcp_get_phone_maker_plat_result_params::phone_count_size() const{
/*  */ return _m_phone_count.size();
}
inline uint32_t mcp_get_phone_maker_plat_result_params::phone_count(size_t i0) const{
 return _m_phone_count.get(i0);
}
inline mcp_get_phone_maker_plat_result_params& mcp_get_phone_maker_plat_result_params::set_phone_count(size_t i0,uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 *(_m_phone_count.mutable_get(i0))=v;
return *this;
}
inline ::idl::Unknown* mcp_get_phone_maker_plat_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_maker_plat_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_maker_plat_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_maker_plat_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_maker_plat_response* mcp_get_phone_maker_plat_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_maker_plat_response* tmp=(mcp_get_phone_maker_plat_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_maker_plat_response(pool);
return tmp;
}
inline void mcp_get_phone_maker_plat_response::destroy(mcp_get_phone_maker_plat_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_maker_plat_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_maker_plat_response::mcp_get_phone_maker_plat_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_maker_plat_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_maker_plat_response::mcp_get_phone_maker_plat_response(const mcp_get_phone_maker_plat_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_maker_plat_result_params::create(_pool);
assign(v);
}
inline mcp_get_phone_maker_plat_response::~mcp_get_phone_maker_plat_response(){
if(_m_result_params){
::idl::mcp_get_phone_maker_plat_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_phone_maker_plat_response& mcp_get_phone_maker_plat_response::operator=(const mcp_get_phone_maker_plat_response& v){
assign(v);
return *this;
}
inline void mcp_get_phone_maker_plat_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_maker_plat_response::check() const{
// @@mcp_get_phone_maker_plat_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_phone_maker_plat_result_params& item=const_cast< ::idl::mcp_get_phone_maker_plat_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_maker_plat_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_maker_plat_response& mcp_get_phone_maker_plat_response::assign(const mcp_get_phone_maker_plat_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_phone_maker_plat_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_maker_plat_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_maker_plat_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_phone_maker_plat_result_params& mcp_get_phone_maker_plat_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_phone_maker_plat_result_params* mcp_get_phone_maker_plat_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_maker_plat_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_phone_maker_plat_result_params* mcp_get_phone_maker_plat_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_maker_plat_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_phone_maker_plat_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_phone_maker_plat_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_maker_plat_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_maker_plat_response::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_maker_plat_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_classID_params* mcp_get_content_list_from_classID_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_classID_params* tmp=(mcp_get_content_list_from_classID_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_classID_params(pool);
return tmp;
}
inline void mcp_get_content_list_from_classID_params::destroy(mcp_get_content_list_from_classID_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_classID_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_classID_params::mcp_get_content_list_from_classID_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_class_id(_pool)
,_m_content_type_id(_pool)
,_m_priority(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_img_size(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_for_adapt(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_classID_params::mcp_get_content_list_from_classID_params(const mcp_get_content_list_from_classID_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_class_id(_pool)
,_m_content_type_id(_pool)
,_m_priority(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_img_size(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_for_adapt(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_from_classID_params::~mcp_get_content_list_from_classID_params(){
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::operator=(const mcp_get_content_list_from_classID_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_classID_params::clear(){
_m_class_id.clear();
_m_content_type_id.clear();
// _m_priority=0;
_m_info_id.clear();
// _m_info_type=0;
_m_img_size.clear();
// _m_unit_num=0;
// _m_unit_times=0;
// _m_for_adapt=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_classID_params::check() const{
// @@string class_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}
// @@string content_type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_type_id.get();

}
// @@uint32_t priority=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "priority" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_priority;

}
// @@string info_id=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@uint32_t info_type=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_type;

}
// @@string img_size=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "img_size" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_img_size.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}
// @@uint32_t for_adapt=in();
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "for_adapt" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_for_adapt;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_classID_params::detach(){
_m_class_id.detach();
_m_content_type_id.detach();
_m_info_id.detach();
_m_img_size.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::assign(const mcp_get_content_list_from_classID_params& v){
_m_class_id=v._m_class_id;
_m_content_type_id=v._m_content_type_id;
_m_priority=v._m_priority;
_m_info_id=v._m_info_id;
_m_info_type=v._m_info_type;
_m_img_size=v._m_img_size;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_m_for_adapt=v._m_for_adapt;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_classID_params::has_class_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_list_from_classID_params::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::set_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::set_ptr_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_classID_params::clear_class_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_class_id.clear();
}
inline bool mcp_get_content_list_from_classID_params::has_content_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_content_list_from_classID_params::content_type_id(unsigned int* size) const{
return _m_content_type_id.get(size);
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::set_content_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::set_ptr_content_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_classID_params::clear_content_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_type_id.clear();
}
inline bool mcp_get_content_list_from_classID_params::has_priority() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_classID_params::priority() const{
return _m_priority;
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::set_priority(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_priority=v;
return *this;
}
inline void mcp_get_content_list_from_classID_params::clear_priority(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_priority=0;
}
inline bool mcp_get_content_list_from_classID_params::has_info_id() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_content_list_from_classID_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::set_info_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_classID_params::clear_info_id(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_content_list_from_classID_params::has_info_type() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_classID_params::info_type() const{
return _m_info_type;
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::set_info_type(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_info_type=v;
return *this;
}
inline void mcp_get_content_list_from_classID_params::clear_info_type(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_info_type=0;
}
inline bool mcp_get_content_list_from_classID_params::has_img_size() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* mcp_get_content_list_from_classID_params::img_size(unsigned int* size) const{
return _m_img_size.get(size);
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::set_img_size(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_img_size.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::set_ptr_img_size(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_img_size.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_classID_params::clear_img_size(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_img_size.clear();
}
inline bool mcp_get_content_list_from_classID_params::has_unit_num() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_classID_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::set_unit_num(uint32_t v){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_content_list_from_classID_params::clear_unit_num(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_content_list_from_classID_params::has_unit_times() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_classID_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::set_unit_times(uint32_t v){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_content_list_from_classID_params::clear_unit_times(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_unit_times=0;
}
inline bool mcp_get_content_list_from_classID_params::has_for_adapt() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_classID_params::for_adapt() const{
return _m_for_adapt;
}
inline mcp_get_content_list_from_classID_params& mcp_get_content_list_from_classID_params::set_for_adapt(uint32_t v){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_for_adapt=v;
return *this;
}
inline void mcp_get_content_list_from_classID_params::clear_for_adapt(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_for_adapt=0;
}
inline ::idl::Unknown* mcp_get_content_list_from_classID_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_classID_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_classID_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_classID_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_classID_result_params* mcp_get_content_list_from_classID_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_classID_result_params* tmp=(mcp_get_content_list_from_classID_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_classID_result_params(pool);
return tmp;
}
inline void mcp_get_content_list_from_classID_result_params::destroy(mcp_get_content_list_from_classID_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_classID_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_classID_result_params::mcp_get_content_list_from_classID_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_classID_result_params::mcp_get_content_list_from_classID_result_params(const mcp_get_content_list_from_classID_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_from_classID_result_params::~mcp_get_content_list_from_classID_result_params(){
}
inline mcp_get_content_list_from_classID_result_params& mcp_get_content_list_from_classID_result_params::operator=(const mcp_get_content_list_from_classID_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_classID_result_params::clear(){
// _m_count=0;
_m_content_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_classID_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string content_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_list" << "' not found";
}
{
// level 0 begin
typeof(_m_content_list)& lr0=(_m_content_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_classID_result_params::detach(){
_m_content_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_classID_result_params& mcp_get_content_list_from_classID_result_params::assign(const mcp_get_content_list_from_classID_result_params& v){
_m_count=v._m_count;
_m_content_list=v._m_content_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_classID_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_classID_result_params::count() const{
return _m_count;
}
inline mcp_get_content_list_from_classID_result_params& mcp_get_content_list_from_classID_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_content_list_from_classID_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_content_list_from_classID_result_params::has_content_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_content_list_from_classID_result_params::content_list() const{
 return _m_content_list;
}
inline void mcp_get_content_list_from_classID_result_params::clear_content_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_from_classID_result_params::mutable_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_from_classID_result_params::m_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline size_t mcp_get_content_list_from_classID_result_params::content_list_size() const{
/*  */ return _m_content_list.size();
}
inline const char* mcp_get_content_list_from_classID_result_params::content_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_content_list.get(i0).get(i1).get(size);
}
inline mcp_get_content_list_from_classID_result_params& mcp_get_content_list_from_classID_result_params::set_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_list_from_classID_result_params& mcp_get_content_list_from_classID_result_params::set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_list_from_classID_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_classID_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_classID_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_classID_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_classID_response* mcp_get_content_list_from_classID_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_classID_response* tmp=(mcp_get_content_list_from_classID_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_classID_response(pool);
return tmp;
}
inline void mcp_get_content_list_from_classID_response::destroy(mcp_get_content_list_from_classID_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_classID_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_classID_response::mcp_get_content_list_from_classID_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_from_classID_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_classID_response::mcp_get_content_list_from_classID_response(const mcp_get_content_list_from_classID_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_from_classID_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_list_from_classID_response::~mcp_get_content_list_from_classID_response(){
if(_m_result_params){
::idl::mcp_get_content_list_from_classID_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_list_from_classID_response& mcp_get_content_list_from_classID_response::operator=(const mcp_get_content_list_from_classID_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_classID_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_classID_response::check() const{
// @@mcp_get_content_list_from_classID_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_list_from_classID_result_params& item=const_cast< ::idl::mcp_get_content_list_from_classID_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_classID_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_classID_response& mcp_get_content_list_from_classID_response::assign(const mcp_get_content_list_from_classID_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_list_from_classID_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_classID_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_classID_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_list_from_classID_result_params& mcp_get_content_list_from_classID_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_list_from_classID_result_params* mcp_get_content_list_from_classID_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_classID_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_list_from_classID_result_params* mcp_get_content_list_from_classID_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_classID_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_list_from_classID_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_list_from_classID_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_classID_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_classID_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_classID_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_typeID_params* mcp_get_content_list_from_typeID_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_typeID_params* tmp=(mcp_get_content_list_from_typeID_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_typeID_params(pool);
return tmp;
}
inline void mcp_get_content_list_from_typeID_params::destroy(mcp_get_content_list_from_typeID_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_typeID_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_typeID_params::mcp_get_content_list_from_typeID_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_content_type_id(_pool)
,_m_priority(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_img_size(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_typeID_params::mcp_get_content_list_from_typeID_params(const mcp_get_content_list_from_typeID_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_content_type_id(_pool)
,_m_priority(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_img_size(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_from_typeID_params::~mcp_get_content_list_from_typeID_params(){
}
inline mcp_get_content_list_from_typeID_params& mcp_get_content_list_from_typeID_params::operator=(const mcp_get_content_list_from_typeID_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_typeID_params::clear(){
_m_content_type_id.clear();
// _m_priority=0;
_m_info_id.clear();
// _m_info_type=0;
_m_img_size.clear();
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_typeID_params::check() const{
// @@string content_type_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_type_id.get();

}
// @@uint32_t priority=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "priority" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_priority;

}
// @@string info_id=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@uint32_t info_type=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_type;

}
// @@string img_size=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "img_size" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_img_size.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_typeID_params::detach(){
_m_content_type_id.detach();
_m_info_id.detach();
_m_img_size.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_typeID_params& mcp_get_content_list_from_typeID_params::assign(const mcp_get_content_list_from_typeID_params& v){
_m_content_type_id=v._m_content_type_id;
_m_priority=v._m_priority;
_m_info_id=v._m_info_id;
_m_info_type=v._m_info_type;
_m_img_size=v._m_img_size;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_typeID_params::has_content_type_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_list_from_typeID_params::content_type_id(unsigned int* size) const{
return _m_content_type_id.get(size);
}
inline mcp_get_content_list_from_typeID_params& mcp_get_content_list_from_typeID_params::set_content_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_typeID_params& mcp_get_content_list_from_typeID_params::set_ptr_content_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_typeID_params::clear_content_type_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_content_type_id.clear();
}
inline bool mcp_get_content_list_from_typeID_params::has_priority() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_typeID_params::priority() const{
return _m_priority;
}
inline mcp_get_content_list_from_typeID_params& mcp_get_content_list_from_typeID_params::set_priority(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_priority=v;
return *this;
}
inline void mcp_get_content_list_from_typeID_params::clear_priority(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_priority=0;
}
inline bool mcp_get_content_list_from_typeID_params::has_info_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_content_list_from_typeID_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_content_list_from_typeID_params& mcp_get_content_list_from_typeID_params::set_info_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_typeID_params& mcp_get_content_list_from_typeID_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_typeID_params::clear_info_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_content_list_from_typeID_params::has_info_type() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_typeID_params::info_type() const{
return _m_info_type;
}
inline mcp_get_content_list_from_typeID_params& mcp_get_content_list_from_typeID_params::set_info_type(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_type=v;
return *this;
}
inline void mcp_get_content_list_from_typeID_params::clear_info_type(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_info_type=0;
}
inline bool mcp_get_content_list_from_typeID_params::has_img_size() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_get_content_list_from_typeID_params::img_size(unsigned int* size) const{
return _m_img_size.get(size);
}
inline mcp_get_content_list_from_typeID_params& mcp_get_content_list_from_typeID_params::set_img_size(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_img_size.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_typeID_params& mcp_get_content_list_from_typeID_params::set_ptr_img_size(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_img_size.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_typeID_params::clear_img_size(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_img_size.clear();
}
inline bool mcp_get_content_list_from_typeID_params::has_unit_num() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_typeID_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_content_list_from_typeID_params& mcp_get_content_list_from_typeID_params::set_unit_num(uint32_t v){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_content_list_from_typeID_params::clear_unit_num(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_content_list_from_typeID_params::has_unit_times() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_typeID_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_content_list_from_typeID_params& mcp_get_content_list_from_typeID_params::set_unit_times(uint32_t v){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_content_list_from_typeID_params::clear_unit_times(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_content_list_from_typeID_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_typeID_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_typeID_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_typeID_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_typeID_result_params* mcp_get_content_list_from_typeID_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_typeID_result_params* tmp=(mcp_get_content_list_from_typeID_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_typeID_result_params(pool);
return tmp;
}
inline void mcp_get_content_list_from_typeID_result_params::destroy(mcp_get_content_list_from_typeID_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_typeID_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_typeID_result_params::mcp_get_content_list_from_typeID_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_typeID_result_params::mcp_get_content_list_from_typeID_result_params(const mcp_get_content_list_from_typeID_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_from_typeID_result_params::~mcp_get_content_list_from_typeID_result_params(){
}
inline mcp_get_content_list_from_typeID_result_params& mcp_get_content_list_from_typeID_result_params::operator=(const mcp_get_content_list_from_typeID_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_typeID_result_params::clear(){
// _m_count=0;
_m_content_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_typeID_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string content_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_list" << "' not found";
}
{
// level 0 begin
typeof(_m_content_list)& lr0=(_m_content_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_typeID_result_params::detach(){
_m_content_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_typeID_result_params& mcp_get_content_list_from_typeID_result_params::assign(const mcp_get_content_list_from_typeID_result_params& v){
_m_count=v._m_count;
_m_content_list=v._m_content_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_typeID_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_typeID_result_params::count() const{
return _m_count;
}
inline mcp_get_content_list_from_typeID_result_params& mcp_get_content_list_from_typeID_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_content_list_from_typeID_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_content_list_from_typeID_result_params::has_content_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_content_list_from_typeID_result_params::content_list() const{
 return _m_content_list;
}
inline void mcp_get_content_list_from_typeID_result_params::clear_content_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_from_typeID_result_params::mutable_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_from_typeID_result_params::m_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline size_t mcp_get_content_list_from_typeID_result_params::content_list_size() const{
/*  */ return _m_content_list.size();
}
inline const char* mcp_get_content_list_from_typeID_result_params::content_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_content_list.get(i0).get(i1).get(size);
}
inline mcp_get_content_list_from_typeID_result_params& mcp_get_content_list_from_typeID_result_params::set_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_list_from_typeID_result_params& mcp_get_content_list_from_typeID_result_params::set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_list_from_typeID_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_typeID_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_typeID_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_typeID_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_typeID_response* mcp_get_content_list_from_typeID_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_typeID_response* tmp=(mcp_get_content_list_from_typeID_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_typeID_response(pool);
return tmp;
}
inline void mcp_get_content_list_from_typeID_response::destroy(mcp_get_content_list_from_typeID_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_typeID_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_typeID_response::mcp_get_content_list_from_typeID_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_from_typeID_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_typeID_response::mcp_get_content_list_from_typeID_response(const mcp_get_content_list_from_typeID_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_from_typeID_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_list_from_typeID_response::~mcp_get_content_list_from_typeID_response(){
if(_m_result_params){
::idl::mcp_get_content_list_from_typeID_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_list_from_typeID_response& mcp_get_content_list_from_typeID_response::operator=(const mcp_get_content_list_from_typeID_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_typeID_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_typeID_response::check() const{
// @@mcp_get_content_list_from_typeID_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_list_from_typeID_result_params& item=const_cast< ::idl::mcp_get_content_list_from_typeID_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_typeID_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_typeID_response& mcp_get_content_list_from_typeID_response::assign(const mcp_get_content_list_from_typeID_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_list_from_typeID_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_typeID_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_typeID_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_list_from_typeID_result_params& mcp_get_content_list_from_typeID_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_list_from_typeID_result_params* mcp_get_content_list_from_typeID_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_typeID_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_list_from_typeID_result_params* mcp_get_content_list_from_typeID_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_typeID_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_list_from_typeID_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_list_from_typeID_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_typeID_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_typeID_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_typeID_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_class_params* mcp_get_content_class_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_class_params* tmp=(mcp_get_content_class_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_class_params(pool);
return tmp;
}
inline void mcp_get_content_class_params::destroy(mcp_get_content_class_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_class_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_class_params::mcp_get_content_class_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_content_type_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_class_params::mcp_get_content_class_params(const mcp_get_content_class_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_content_type_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_class_params::~mcp_get_content_class_params(){
}
inline mcp_get_content_class_params& mcp_get_content_class_params::operator=(const mcp_get_content_class_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_class_params::clear(){
_m_content_type_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_class_params::check() const{
// @@string content_type_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_type_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_class_params::detach(){
_m_content_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_class_params& mcp_get_content_class_params::assign(const mcp_get_content_class_params& v){
_m_content_type_id=v._m_content_type_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_class_params::has_content_type_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_class_params::content_type_id(unsigned int* size) const{
return _m_content_type_id.get(size);
}
inline mcp_get_content_class_params& mcp_get_content_class_params::set_content_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_class_params& mcp_get_content_class_params::set_ptr_content_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_class_params::clear_content_type_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_content_type_id.clear();
}
inline ::idl::Unknown* mcp_get_content_class_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_class_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_class_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_class_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_class_result_params* mcp_get_content_class_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_class_result_params* tmp=(mcp_get_content_class_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_class_result_params(pool);
return tmp;
}
inline void mcp_get_content_class_result_params::destroy(mcp_get_content_class_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_class_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_class_result_params::mcp_get_content_class_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_content_class_id(_pool)
,_m_content_class_name(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_class_result_params::mcp_get_content_class_result_params(const mcp_get_content_class_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_content_class_id(_pool)
,_m_content_class_name(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_class_result_params::~mcp_get_content_class_result_params(){
}
inline mcp_get_content_class_result_params& mcp_get_content_class_result_params::operator=(const mcp_get_content_class_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_class_result_params::clear(){
_m_content_class_id.clear();
_m_content_class_name.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_class_result_params::check() const{
// @@string content_class_id=out(),array(0);
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_class_id" << "' not found";
}
{
// level 0 begin
typeof(_m_content_class_id)& lr0=(_m_content_class_id);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@string content_class_name=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_class_name" << "' not found";
}
{
// level 0 begin
typeof(_m_content_class_name)& lr0=(_m_content_class_name);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_class_result_params::detach(){
_m_content_class_id.detach();
_m_content_class_name.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_class_result_params& mcp_get_content_class_result_params::assign(const mcp_get_content_class_result_params& v){
_m_content_class_id=v._m_content_class_id;
_m_content_class_name=v._m_content_class_name;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_class_result_params::has_content_class_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_content_class_result_params::content_class_id() const{
 return _m_content_class_id;
}
inline void mcp_get_content_class_result_params::clear_content_class_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_content_class_id.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_content_class_result_params::mutable_content_class_id(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_content_class_id);
}
inline ::idl::vector< ::idl::string >* mcp_get_content_class_result_params::m_content_class_id(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_content_class_id);
}
inline size_t mcp_get_content_class_result_params::content_class_id_size() const{
/*  */ return _m_content_class_id.size();
}
inline const char* mcp_get_content_class_result_params::content_class_id(size_t i0,unsigned int* size) const{
 return _m_content_class_id.get(i0).get(size);
}
inline mcp_get_content_class_result_params& mcp_get_content_class_result_params::set_content_class_id(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_class_id.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_class_result_params& mcp_get_content_class_result_params::set_ptr_content_class_id(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_class_id.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool mcp_get_content_class_result_params::has_content_class_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_content_class_result_params::content_class_name() const{
 return _m_content_class_name;
}
inline void mcp_get_content_class_result_params::clear_content_class_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_class_name.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_content_class_result_params::mutable_content_class_name(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_class_name);
}
inline ::idl::vector< ::idl::string >* mcp_get_content_class_result_params::m_content_class_name(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_class_name);
}
inline size_t mcp_get_content_class_result_params::content_class_name_size() const{
/*  */ return _m_content_class_name.size();
}
inline const char* mcp_get_content_class_result_params::content_class_name(size_t i0,unsigned int* size) const{
 return _m_content_class_name.get(i0).get(size);
}
inline mcp_get_content_class_result_params& mcp_get_content_class_result_params::set_content_class_name(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_class_name.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_class_result_params& mcp_get_content_class_result_params::set_ptr_content_class_name(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_class_name.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_class_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_class_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_class_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_class_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_class_response* mcp_get_content_class_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_class_response* tmp=(mcp_get_content_class_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_class_response(pool);
return tmp;
}
inline void mcp_get_content_class_response::destroy(mcp_get_content_class_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_class_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_class_response::mcp_get_content_class_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_class_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_class_response::mcp_get_content_class_response(const mcp_get_content_class_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_class_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_class_response::~mcp_get_content_class_response(){
if(_m_result_params){
::idl::mcp_get_content_class_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_class_response& mcp_get_content_class_response::operator=(const mcp_get_content_class_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_class_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_class_response::check() const{
// @@mcp_get_content_class_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_class_result_params& item=const_cast< ::idl::mcp_get_content_class_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_class_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_class_response& mcp_get_content_class_response::assign(const mcp_get_content_class_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_class_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_class_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_class_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_class_result_params& mcp_get_content_class_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_class_result_params* mcp_get_content_class_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_class_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_class_result_params* mcp_get_content_class_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_class_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_class_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_class_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_class_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_class_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_class_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_class_name_params* mcp_get_content_class_name_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_class_name_params* tmp=(mcp_get_content_class_name_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_class_name_params(pool);
return tmp;
}
inline void mcp_get_content_class_name_params::destroy(mcp_get_content_class_name_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_class_name_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_class_name_params::mcp_get_content_class_name_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_class_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_class_name_params::mcp_get_content_class_name_params(const mcp_get_content_class_name_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_class_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_class_name_params::~mcp_get_content_class_name_params(){
}
inline mcp_get_content_class_name_params& mcp_get_content_class_name_params::operator=(const mcp_get_content_class_name_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_class_name_params::clear(){
_m_class_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_class_name_params::check() const{
// @@string class_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_class_name_params::detach(){
_m_class_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_class_name_params& mcp_get_content_class_name_params::assign(const mcp_get_content_class_name_params& v){
_m_class_id=v._m_class_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_class_name_params::has_class_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_class_name_params::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_get_content_class_name_params& mcp_get_content_class_name_params::set_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_class_name_params& mcp_get_content_class_name_params::set_ptr_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_class_name_params::clear_class_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_class_id.clear();
}
inline ::idl::Unknown* mcp_get_content_class_name_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_class_name_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_class_name_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_class_name_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_class_name_result_params* mcp_get_content_class_name_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_class_name_result_params* tmp=(mcp_get_content_class_name_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_class_name_result_params(pool);
return tmp;
}
inline void mcp_get_content_class_name_result_params::destroy(mcp_get_content_class_name_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_class_name_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_class_name_result_params::mcp_get_content_class_name_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_class_name(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_class_name_result_params::mcp_get_content_class_name_result_params(const mcp_get_content_class_name_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_class_name(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_class_name_result_params::~mcp_get_content_class_name_result_params(){
}
inline mcp_get_content_class_name_result_params& mcp_get_content_class_name_result_params::operator=(const mcp_get_content_class_name_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_class_name_result_params::clear(){
_m_class_name.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_class_name_result_params::check() const{
// @@string class_name=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_name.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_class_name_result_params::detach(){
_m_class_name.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_class_name_result_params& mcp_get_content_class_name_result_params::assign(const mcp_get_content_class_name_result_params& v){
_m_class_name=v._m_class_name;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_class_name_result_params::has_class_name() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_class_name_result_params::class_name(unsigned int* size) const{
return _m_class_name.get(size);
}
inline mcp_get_content_class_name_result_params& mcp_get_content_class_name_result_params::set_class_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_class_name_result_params& mcp_get_content_class_name_result_params::set_ptr_class_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_class_name_result_params::clear_class_name(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_class_name.clear();
}
inline ::idl::Unknown* mcp_get_content_class_name_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_class_name_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_class_name_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_class_name_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_class_name_response* mcp_get_content_class_name_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_class_name_response* tmp=(mcp_get_content_class_name_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_class_name_response(pool);
return tmp;
}
inline void mcp_get_content_class_name_response::destroy(mcp_get_content_class_name_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_class_name_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_class_name_response::mcp_get_content_class_name_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_class_name_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_class_name_response::mcp_get_content_class_name_response(const mcp_get_content_class_name_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_class_name_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_class_name_response::~mcp_get_content_class_name_response(){
if(_m_result_params){
::idl::mcp_get_content_class_name_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_class_name_response& mcp_get_content_class_name_response::operator=(const mcp_get_content_class_name_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_class_name_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_class_name_response::check() const{
// @@mcp_get_content_class_name_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_class_name_result_params& item=const_cast< ::idl::mcp_get_content_class_name_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_class_name_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_class_name_response& mcp_get_content_class_name_response::assign(const mcp_get_content_class_name_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_class_name_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_class_name_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_class_name_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_class_name_result_params& mcp_get_content_class_name_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_class_name_result_params* mcp_get_content_class_name_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_class_name_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_class_name_result_params* mcp_get_content_class_name_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_class_name_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_class_name_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_class_name_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_class_name_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_class_name_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_class_name_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_diy_col_name_params* mcp_get_content_diy_col_name_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_diy_col_name_params* tmp=(mcp_get_content_diy_col_name_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_diy_col_name_params(pool);
return tmp;
}
inline void mcp_get_content_diy_col_name_params::destroy(mcp_get_content_diy_col_name_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_diy_col_name_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_diy_col_name_params::mcp_get_content_diy_col_name_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_diycol_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_diy_col_name_params::mcp_get_content_diy_col_name_params(const mcp_get_content_diy_col_name_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_diycol_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_diy_col_name_params::~mcp_get_content_diy_col_name_params(){
}
inline mcp_get_content_diy_col_name_params& mcp_get_content_diy_col_name_params::operator=(const mcp_get_content_diy_col_name_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_diy_col_name_params::clear(){
_m_diycol_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_diy_col_name_params::check() const{
// @@string diycol_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "diycol_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_diycol_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_diy_col_name_params::detach(){
_m_diycol_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_diy_col_name_params& mcp_get_content_diy_col_name_params::assign(const mcp_get_content_diy_col_name_params& v){
_m_diycol_id=v._m_diycol_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_diy_col_name_params::has_diycol_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_diy_col_name_params::diycol_id(unsigned int* size) const{
return _m_diycol_id.get(size);
}
inline mcp_get_content_diy_col_name_params& mcp_get_content_diy_col_name_params::set_diycol_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_diycol_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_diy_col_name_params& mcp_get_content_diy_col_name_params::set_ptr_diycol_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_diycol_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_diy_col_name_params::clear_diycol_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_diycol_id.clear();
}
inline ::idl::Unknown* mcp_get_content_diy_col_name_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_diy_col_name_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_diy_col_name_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_diy_col_name_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_diy_col_name_result_params* mcp_get_content_diy_col_name_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_diy_col_name_result_params* tmp=(mcp_get_content_diy_col_name_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_diy_col_name_result_params(pool);
return tmp;
}
inline void mcp_get_content_diy_col_name_result_params::destroy(mcp_get_content_diy_col_name_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_diy_col_name_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_diy_col_name_result_params::mcp_get_content_diy_col_name_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_diycol_name(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_diy_col_name_result_params::mcp_get_content_diy_col_name_result_params(const mcp_get_content_diy_col_name_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_diycol_name(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_diy_col_name_result_params::~mcp_get_content_diy_col_name_result_params(){
}
inline mcp_get_content_diy_col_name_result_params& mcp_get_content_diy_col_name_result_params::operator=(const mcp_get_content_diy_col_name_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_diy_col_name_result_params::clear(){
_m_diycol_name.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_diy_col_name_result_params::check() const{
// @@string diycol_name=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "diycol_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_diycol_name.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_diy_col_name_result_params::detach(){
_m_diycol_name.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_diy_col_name_result_params& mcp_get_content_diy_col_name_result_params::assign(const mcp_get_content_diy_col_name_result_params& v){
_m_diycol_name=v._m_diycol_name;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_diy_col_name_result_params::has_diycol_name() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_diy_col_name_result_params::diycol_name(unsigned int* size) const{
return _m_diycol_name.get(size);
}
inline mcp_get_content_diy_col_name_result_params& mcp_get_content_diy_col_name_result_params::set_diycol_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_diycol_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_diy_col_name_result_params& mcp_get_content_diy_col_name_result_params::set_ptr_diycol_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_diycol_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_diy_col_name_result_params::clear_diycol_name(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_diycol_name.clear();
}
inline ::idl::Unknown* mcp_get_content_diy_col_name_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_diy_col_name_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_diy_col_name_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_diy_col_name_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_diy_col_name_response* mcp_get_content_diy_col_name_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_diy_col_name_response* tmp=(mcp_get_content_diy_col_name_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_diy_col_name_response(pool);
return tmp;
}
inline void mcp_get_content_diy_col_name_response::destroy(mcp_get_content_diy_col_name_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_diy_col_name_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_diy_col_name_response::mcp_get_content_diy_col_name_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_diy_col_name_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_diy_col_name_response::mcp_get_content_diy_col_name_response(const mcp_get_content_diy_col_name_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_diy_col_name_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_diy_col_name_response::~mcp_get_content_diy_col_name_response(){
if(_m_result_params){
::idl::mcp_get_content_diy_col_name_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_diy_col_name_response& mcp_get_content_diy_col_name_response::operator=(const mcp_get_content_diy_col_name_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_diy_col_name_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_diy_col_name_response::check() const{
// @@mcp_get_content_diy_col_name_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_diy_col_name_result_params& item=const_cast< ::idl::mcp_get_content_diy_col_name_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_diy_col_name_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_diy_col_name_response& mcp_get_content_diy_col_name_response::assign(const mcp_get_content_diy_col_name_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_diy_col_name_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_diy_col_name_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_diy_col_name_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_diy_col_name_result_params& mcp_get_content_diy_col_name_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_diy_col_name_result_params* mcp_get_content_diy_col_name_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_diy_col_name_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_diy_col_name_result_params* mcp_get_content_diy_col_name_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_diy_col_name_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_diy_col_name_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_diy_col_name_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_diy_col_name_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_diy_col_name_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_diy_col_name_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_info_params* mcp_get_content_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_info_params* tmp=(mcp_get_content_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_info_params(pool);
return tmp;
}
inline void mcp_get_content_info_params::destroy(mcp_get_content_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_info_params::mcp_get_content_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_content_id(_pool)
,_m_content_ext(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_info_params::mcp_get_content_info_params(const mcp_get_content_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_content_id(_pool)
,_m_content_ext(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_info_params::~mcp_get_content_info_params(){
}
inline mcp_get_content_info_params& mcp_get_content_info_params::operator=(const mcp_get_content_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_info_params::clear(){
_m_content_id.clear();
// _m_content_ext=0;
_m_info_id.clear();
// _m_info_type=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_info_params::check() const{
// @@string content_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_id.get();

}
// @@uint32_t content_ext=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_ext" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_content_ext;

}
// @@string info_id=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@uint32_t info_type=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_type;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_info_params::detach(){
_m_content_id.detach();
_m_info_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_info_params& mcp_get_content_info_params::assign(const mcp_get_content_info_params& v){
_m_content_id=v._m_content_id;
_m_content_ext=v._m_content_ext;
_m_info_id=v._m_info_id;
_m_info_type=v._m_info_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_info_params::has_content_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_info_params::content_id(unsigned int* size) const{
return _m_content_id.get(size);
}
inline mcp_get_content_info_params& mcp_get_content_info_params::set_content_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_info_params& mcp_get_content_info_params::set_ptr_content_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_info_params::clear_content_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_content_id.clear();
}
inline bool mcp_get_content_info_params::has_content_ext() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_content_info_params::content_ext() const{
return _m_content_ext;
}
inline mcp_get_content_info_params& mcp_get_content_info_params::set_content_ext(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_ext=v;
return *this;
}
inline void mcp_get_content_info_params::clear_content_ext(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_ext=0;
}
inline bool mcp_get_content_info_params::has_info_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_content_info_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_content_info_params& mcp_get_content_info_params::set_info_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_info_params& mcp_get_content_info_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_info_params::clear_info_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_content_info_params::has_info_type() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_content_info_params::info_type() const{
return _m_info_type;
}
inline mcp_get_content_info_params& mcp_get_content_info_params::set_info_type(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_type=v;
return *this;
}
inline void mcp_get_content_info_params::clear_info_type(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_info_type=0;
}
inline ::idl::Unknown* mcp_get_content_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_info_result_params* mcp_get_content_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_info_result_params* tmp=(mcp_get_content_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_info_result_params(pool);
return tmp;
}
inline void mcp_get_content_info_result_params::destroy(mcp_get_content_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_info_result_params::mcp_get_content_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_info_result_params::mcp_get_content_info_result_params(const mcp_get_content_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_info_result_params::~mcp_get_content_info_result_params(){
}
inline mcp_get_content_info_result_params& mcp_get_content_info_result_params::operator=(const mcp_get_content_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_info_result_params::clear(){
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_info_result_params::check() const{
// @@string info_list=out(),array(0);
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_info_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_info_result_params& mcp_get_content_info_result_params::assign(const mcp_get_content_info_result_params& v){
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_info_result_params::has_info_list() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_content_info_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_content_info_result_params::clear_info_list(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_content_info_result_params::mutable_info_list(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::string >* mcp_get_content_info_result_params::m_info_list(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_content_info_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const char* mcp_get_content_info_result_params::info_list(size_t i0,unsigned int* size) const{
 return _m_info_list.get(i0).get(size);
}
inline mcp_get_content_info_result_params& mcp_get_content_info_result_params::set_info_list(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_list.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_info_result_params& mcp_get_content_info_result_params::set_ptr_info_list(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_list.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_info_response* mcp_get_content_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_info_response* tmp=(mcp_get_content_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_info_response(pool);
return tmp;
}
inline void mcp_get_content_info_response::destroy(mcp_get_content_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_info_response::mcp_get_content_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_info_response::mcp_get_content_info_response(const mcp_get_content_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_info_response::~mcp_get_content_info_response(){
if(_m_result_params){
::idl::mcp_get_content_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_info_response& mcp_get_content_info_response::operator=(const mcp_get_content_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_info_response::check() const{
// @@mcp_get_content_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_info_result_params& item=const_cast< ::idl::mcp_get_content_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_info_response& mcp_get_content_info_response::assign(const mcp_get_content_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_info_result_params& mcp_get_content_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_info_result_params* mcp_get_content_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_info_result_params* mcp_get_content_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_download_info_params* mcp_get_download_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_download_info_params* tmp=(mcp_get_download_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_download_info_params(pool);
return tmp;
}
inline void mcp_get_download_info_params::destroy(mcp_get_download_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_download_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_download_info_params::mcp_get_download_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_content_id(_pool)
,_m_info_id(_pool)
,_m_info_type(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_download_info_params::mcp_get_download_info_params(const mcp_get_download_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_content_id(_pool)
,_m_info_id(_pool)
,_m_info_type(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_download_info_params::~mcp_get_download_info_params(){
}
inline mcp_get_download_info_params& mcp_get_download_info_params::operator=(const mcp_get_download_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_download_info_params::clear(){
_m_content_id.clear();
_m_info_id.clear();
// _m_info_type=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_download_info_params::check() const{
// @@string content_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_id.get();

}
// @@string info_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@uint32_t info_type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_type;

}

::idl::McpackBean::check();
}
inline void mcp_get_download_info_params::detach(){
_m_content_id.detach();
_m_info_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_download_info_params& mcp_get_download_info_params::assign(const mcp_get_download_info_params& v){
_m_content_id=v._m_content_id;
_m_info_id=v._m_info_id;
_m_info_type=v._m_info_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_download_info_params::has_content_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_download_info_params::content_id(unsigned int* size) const{
return _m_content_id.get(size);
}
inline mcp_get_download_info_params& mcp_get_download_info_params::set_content_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_download_info_params& mcp_get_download_info_params::set_ptr_content_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_download_info_params::clear_content_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_content_id.clear();
}
inline bool mcp_get_download_info_params::has_info_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_download_info_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_download_info_params& mcp_get_download_info_params::set_info_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_download_info_params& mcp_get_download_info_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_download_info_params::clear_info_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_download_info_params::has_info_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_download_info_params::info_type() const{
return _m_info_type;
}
inline mcp_get_download_info_params& mcp_get_download_info_params::set_info_type(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_type=v;
return *this;
}
inline void mcp_get_download_info_params::clear_info_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_type=0;
}
inline ::idl::Unknown* mcp_get_download_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_download_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_download_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_download_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_download_info_result_params* mcp_get_download_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_download_info_result_params* tmp=(mcp_get_download_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_download_info_result_params(pool);
return tmp;
}
inline void mcp_get_download_info_result_params::destroy(mcp_get_download_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_download_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_download_info_result_params::mcp_get_download_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_download_info(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_download_info_result_params::mcp_get_download_info_result_params(const mcp_get_download_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_download_info(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_download_info_result_params::~mcp_get_download_info_result_params(){
}
inline mcp_get_download_info_result_params& mcp_get_download_info_result_params::operator=(const mcp_get_download_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_download_info_result_params::clear(){
_m_download_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_download_info_result_params::check() const{
// @@string download_info=out(),array(0,0);
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "download_info" << "' not found";
}
{
// level 0 begin
typeof(_m_download_info)& lr0=(_m_download_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_download_info_result_params::detach(){
_m_download_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_download_info_result_params& mcp_get_download_info_result_params::assign(const mcp_get_download_info_result_params& v){
_m_download_info=v._m_download_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_download_info_result_params::has_download_info() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_download_info_result_params::download_info() const{
 return _m_download_info;
}
inline void mcp_get_download_info_result_params::clear_download_info(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_download_info.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_download_info_result_params::mutable_download_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_download_info);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_download_info_result_params::m_download_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_download_info);
}
inline size_t mcp_get_download_info_result_params::download_info_size() const{
/*  */ return _m_download_info.size();
}
inline const char* mcp_get_download_info_result_params::download_info(size_t i0,size_t i1,unsigned int* size) const{
 return _m_download_info.get(i0).get(i1).get(size);
}
inline mcp_get_download_info_result_params& mcp_get_download_info_result_params::set_download_info(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_download_info.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_download_info_result_params& mcp_get_download_info_result_params::set_ptr_download_info(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_download_info.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_download_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_download_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_download_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_download_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_download_info_response* mcp_get_download_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_download_info_response* tmp=(mcp_get_download_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_download_info_response(pool);
return tmp;
}
inline void mcp_get_download_info_response::destroy(mcp_get_download_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_download_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_download_info_response::mcp_get_download_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_download_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_download_info_response::mcp_get_download_info_response(const mcp_get_download_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_download_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_download_info_response::~mcp_get_download_info_response(){
if(_m_result_params){
::idl::mcp_get_download_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_download_info_response& mcp_get_download_info_response::operator=(const mcp_get_download_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_download_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_download_info_response::check() const{
// @@mcp_get_download_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_download_info_result_params& item=const_cast< ::idl::mcp_get_download_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_download_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_download_info_response& mcp_get_download_info_response::assign(const mcp_get_download_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_download_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_download_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_download_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_download_info_result_params& mcp_get_download_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_download_info_result_params* mcp_get_download_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_download_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_download_info_result_params* mcp_get_download_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_download_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_download_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_download_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_download_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_download_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_download_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_params* mcp_get_content_list_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_params* tmp=(mcp_get_content_list_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_params(pool);
return tmp;
}
inline void mcp_get_content_list_params::destroy(mcp_get_content_list_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_params::mcp_get_content_list_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_priority(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_params::mcp_get_content_list_params(const mcp_get_content_list_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_priority(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_params::~mcp_get_content_list_params(){
}
inline mcp_get_content_list_params& mcp_get_content_list_params::operator=(const mcp_get_content_list_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_params::clear(){
// _m_priority=0;
_m_info_id.clear();
// _m_info_type=0;
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_params::check() const{
// @@uint32_t priority=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "priority" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_priority;

}
// @@string info_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@uint32_t info_type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_type;

}
// @@uint32_t unit_num=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_params::detach(){
_m_info_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_params& mcp_get_content_list_params::assign(const mcp_get_content_list_params& v){
_m_priority=v._m_priority;
_m_info_id=v._m_info_id;
_m_info_type=v._m_info_type;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_params::has_priority() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_content_list_params::priority() const{
return _m_priority;
}
inline mcp_get_content_list_params& mcp_get_content_list_params::set_priority(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_priority=v;
return *this;
}
inline void mcp_get_content_list_params::clear_priority(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_priority=0;
}
inline bool mcp_get_content_list_params::has_info_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_content_list_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_content_list_params& mcp_get_content_list_params::set_info_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_params& mcp_get_content_list_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_params::clear_info_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_content_list_params::has_info_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_content_list_params::info_type() const{
return _m_info_type;
}
inline mcp_get_content_list_params& mcp_get_content_list_params::set_info_type(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_type=v;
return *this;
}
inline void mcp_get_content_list_params::clear_info_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_type=0;
}
inline bool mcp_get_content_list_params::has_unit_num() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_content_list_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_content_list_params& mcp_get_content_list_params::set_unit_num(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_content_list_params::clear_unit_num(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_content_list_params::has_unit_times() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_content_list_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_content_list_params& mcp_get_content_list_params::set_unit_times(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_content_list_params::clear_unit_times(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_content_list_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_result_params* mcp_get_content_list_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_result_params* tmp=(mcp_get_content_list_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_result_params(pool);
return tmp;
}
inline void mcp_get_content_list_result_params::destroy(mcp_get_content_list_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_result_params::mcp_get_content_list_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_result_params::mcp_get_content_list_result_params(const mcp_get_content_list_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_result_params::~mcp_get_content_list_result_params(){
}
inline mcp_get_content_list_result_params& mcp_get_content_list_result_params::operator=(const mcp_get_content_list_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_result_params::clear(){
// _m_count=0;
_m_content_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string content_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_list" << "' not found";
}
{
// level 0 begin
typeof(_m_content_list)& lr0=(_m_content_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_result_params::detach(){
_m_content_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_result_params& mcp_get_content_list_result_params::assign(const mcp_get_content_list_result_params& v){
_m_count=v._m_count;
_m_content_list=v._m_content_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_content_list_result_params::count() const{
return _m_count;
}
inline mcp_get_content_list_result_params& mcp_get_content_list_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_content_list_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_content_list_result_params::has_content_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_content_list_result_params::content_list() const{
 return _m_content_list;
}
inline void mcp_get_content_list_result_params::clear_content_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_result_params::mutable_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_result_params::m_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline size_t mcp_get_content_list_result_params::content_list_size() const{
/*  */ return _m_content_list.size();
}
inline const char* mcp_get_content_list_result_params::content_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_content_list.get(i0).get(i1).get(size);
}
inline mcp_get_content_list_result_params& mcp_get_content_list_result_params::set_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_list_result_params& mcp_get_content_list_result_params::set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_list_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_response* mcp_get_content_list_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_response* tmp=(mcp_get_content_list_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_response(pool);
return tmp;
}
inline void mcp_get_content_list_response::destroy(mcp_get_content_list_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_response::mcp_get_content_list_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_response::mcp_get_content_list_response(const mcp_get_content_list_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_list_response::~mcp_get_content_list_response(){
if(_m_result_params){
::idl::mcp_get_content_list_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_list_response& mcp_get_content_list_response::operator=(const mcp_get_content_list_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_response::check() const{
// @@mcp_get_content_list_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_list_result_params& item=const_cast< ::idl::mcp_get_content_list_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_response& mcp_get_content_list_response::assign(const mcp_get_content_list_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_list_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_list_result_params& mcp_get_content_list_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_list_result_params* mcp_get_content_list_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_list_result_params* mcp_get_content_list_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_list_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_list_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_part_params* mcp_get_content_list_from_part_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_part_params* tmp=(mcp_get_content_list_from_part_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_part_params(pool);
return tmp;
}
inline void mcp_get_content_list_from_part_params::destroy(mcp_get_content_list_from_part_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_part_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_part_params::mcp_get_content_list_from_part_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_part_id(_pool)
,_m_content_type_id(_pool)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_part_params::mcp_get_content_list_from_part_params(const mcp_get_content_list_from_part_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_part_id(_pool)
,_m_content_type_id(_pool)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_from_part_params::~mcp_get_content_list_from_part_params(){
}
inline mcp_get_content_list_from_part_params& mcp_get_content_list_from_part_params::operator=(const mcp_get_content_list_from_part_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_part_params::clear(){
_m_part_id.clear();
_m_content_type_id.clear();
_m_info_id.clear();
// _m_info_type=0;
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_part_params::check() const{
// @@string part_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "part_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_part_id.get();

}
// @@string content_type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_type_id.get();

}
// @@string info_id=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@uint32_t info_type=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_type;

}
// @@uint32_t unit_num=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_part_params::detach(){
_m_part_id.detach();
_m_content_type_id.detach();
_m_info_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_part_params& mcp_get_content_list_from_part_params::assign(const mcp_get_content_list_from_part_params& v){
_m_part_id=v._m_part_id;
_m_content_type_id=v._m_content_type_id;
_m_info_id=v._m_info_id;
_m_info_type=v._m_info_type;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_part_params::has_part_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_list_from_part_params::part_id(unsigned int* size) const{
return _m_part_id.get(size);
}
inline mcp_get_content_list_from_part_params& mcp_get_content_list_from_part_params::set_part_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_part_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_part_params& mcp_get_content_list_from_part_params::set_ptr_part_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_part_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_part_params::clear_part_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_part_id.clear();
}
inline bool mcp_get_content_list_from_part_params::has_content_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_content_list_from_part_params::content_type_id(unsigned int* size) const{
return _m_content_type_id.get(size);
}
inline mcp_get_content_list_from_part_params& mcp_get_content_list_from_part_params::set_content_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_part_params& mcp_get_content_list_from_part_params::set_ptr_content_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_part_params::clear_content_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_type_id.clear();
}
inline bool mcp_get_content_list_from_part_params::has_info_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_content_list_from_part_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_content_list_from_part_params& mcp_get_content_list_from_part_params::set_info_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_part_params& mcp_get_content_list_from_part_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_part_params::clear_info_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_content_list_from_part_params::has_info_type() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_part_params::info_type() const{
return _m_info_type;
}
inline mcp_get_content_list_from_part_params& mcp_get_content_list_from_part_params::set_info_type(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_type=v;
return *this;
}
inline void mcp_get_content_list_from_part_params::clear_info_type(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_info_type=0;
}
inline bool mcp_get_content_list_from_part_params::has_unit_num() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_part_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_content_list_from_part_params& mcp_get_content_list_from_part_params::set_unit_num(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_content_list_from_part_params::clear_unit_num(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_content_list_from_part_params::has_unit_times() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_part_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_content_list_from_part_params& mcp_get_content_list_from_part_params::set_unit_times(uint32_t v){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_content_list_from_part_params::clear_unit_times(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_content_list_from_part_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_part_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_part_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_part_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_part_result_params* mcp_get_content_list_from_part_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_part_result_params* tmp=(mcp_get_content_list_from_part_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_part_result_params(pool);
return tmp;
}
inline void mcp_get_content_list_from_part_result_params::destroy(mcp_get_content_list_from_part_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_part_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_part_result_params::mcp_get_content_list_from_part_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_part_result_params::mcp_get_content_list_from_part_result_params(const mcp_get_content_list_from_part_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_from_part_result_params::~mcp_get_content_list_from_part_result_params(){
}
inline mcp_get_content_list_from_part_result_params& mcp_get_content_list_from_part_result_params::operator=(const mcp_get_content_list_from_part_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_part_result_params::clear(){
// _m_count=0;
_m_content_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_part_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string content_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_list" << "' not found";
}
{
// level 0 begin
typeof(_m_content_list)& lr0=(_m_content_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_part_result_params::detach(){
_m_content_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_part_result_params& mcp_get_content_list_from_part_result_params::assign(const mcp_get_content_list_from_part_result_params& v){
_m_count=v._m_count;
_m_content_list=v._m_content_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_part_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_part_result_params::count() const{
return _m_count;
}
inline mcp_get_content_list_from_part_result_params& mcp_get_content_list_from_part_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_content_list_from_part_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_content_list_from_part_result_params::has_content_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_content_list_from_part_result_params::content_list() const{
 return _m_content_list;
}
inline void mcp_get_content_list_from_part_result_params::clear_content_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_from_part_result_params::mutable_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_from_part_result_params::m_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline size_t mcp_get_content_list_from_part_result_params::content_list_size() const{
/*  */ return _m_content_list.size();
}
inline const char* mcp_get_content_list_from_part_result_params::content_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_content_list.get(i0).get(i1).get(size);
}
inline mcp_get_content_list_from_part_result_params& mcp_get_content_list_from_part_result_params::set_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_list_from_part_result_params& mcp_get_content_list_from_part_result_params::set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_list_from_part_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_part_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_part_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_part_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_part_response* mcp_get_content_list_from_part_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_part_response* tmp=(mcp_get_content_list_from_part_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_part_response(pool);
return tmp;
}
inline void mcp_get_content_list_from_part_response::destroy(mcp_get_content_list_from_part_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_part_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_part_response::mcp_get_content_list_from_part_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_from_part_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_part_response::mcp_get_content_list_from_part_response(const mcp_get_content_list_from_part_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_from_part_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_list_from_part_response::~mcp_get_content_list_from_part_response(){
if(_m_result_params){
::idl::mcp_get_content_list_from_part_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_list_from_part_response& mcp_get_content_list_from_part_response::operator=(const mcp_get_content_list_from_part_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_part_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_part_response::check() const{
// @@mcp_get_content_list_from_part_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_list_from_part_result_params& item=const_cast< ::idl::mcp_get_content_list_from_part_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_part_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_part_response& mcp_get_content_list_from_part_response::assign(const mcp_get_content_list_from_part_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_list_from_part_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_part_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_part_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_list_from_part_result_params& mcp_get_content_list_from_part_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_list_from_part_result_params* mcp_get_content_list_from_part_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_part_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_list_from_part_result_params* mcp_get_content_list_from_part_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_part_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_list_from_part_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_list_from_part_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_part_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_part_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_part_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_count_from_class_params* mcp_get_content_count_from_class_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_count_from_class_params* tmp=(mcp_get_content_count_from_class_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_count_from_class_params(pool);
return tmp;
}
inline void mcp_get_content_count_from_class_params::destroy(mcp_get_content_count_from_class_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_count_from_class_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_count_from_class_params::mcp_get_content_count_from_class_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_class_id(_pool)
,_m_class_type(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_count_from_class_params::mcp_get_content_count_from_class_params(const mcp_get_content_count_from_class_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_class_id(_pool)
,_m_class_type(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_count_from_class_params::~mcp_get_content_count_from_class_params(){
}
inline mcp_get_content_count_from_class_params& mcp_get_content_count_from_class_params::operator=(const mcp_get_content_count_from_class_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_count_from_class_params::clear(){
_m_class_id.clear();
// _m_class_type=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_count_from_class_params::check() const{
// @@string class_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}
// @@uint32_t class_type=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_class_type;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_count_from_class_params::detach(){
_m_class_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_count_from_class_params& mcp_get_content_count_from_class_params::assign(const mcp_get_content_count_from_class_params& v){
_m_class_id=v._m_class_id;
_m_class_type=v._m_class_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_count_from_class_params::has_class_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_count_from_class_params::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_get_content_count_from_class_params& mcp_get_content_count_from_class_params::set_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_count_from_class_params& mcp_get_content_count_from_class_params::set_ptr_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_count_from_class_params::clear_class_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_class_id.clear();
}
inline bool mcp_get_content_count_from_class_params::has_class_type() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_content_count_from_class_params::class_type() const{
return _m_class_type;
}
inline mcp_get_content_count_from_class_params& mcp_get_content_count_from_class_params::set_class_type(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_class_type=v;
return *this;
}
inline void mcp_get_content_count_from_class_params::clear_class_type(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_class_type=0;
}
inline ::idl::Unknown* mcp_get_content_count_from_class_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_count_from_class_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_count_from_class_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_count_from_class_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_count_from_class_result_params* mcp_get_content_count_from_class_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_count_from_class_result_params* tmp=(mcp_get_content_count_from_class_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_count_from_class_result_params(pool);
return tmp;
}
inline void mcp_get_content_count_from_class_result_params::destroy(mcp_get_content_count_from_class_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_count_from_class_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_count_from_class_result_params::mcp_get_content_count_from_class_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_class_name(_pool)
,_m_count(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_count_from_class_result_params::mcp_get_content_count_from_class_result_params(const mcp_get_content_count_from_class_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_class_name(_pool)
,_m_count(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_count_from_class_result_params::~mcp_get_content_count_from_class_result_params(){
}
inline mcp_get_content_count_from_class_result_params& mcp_get_content_count_from_class_result_params::operator=(const mcp_get_content_count_from_class_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_count_from_class_result_params::clear(){
_m_class_name.clear();
// _m_count=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_count_from_class_result_params::check() const{
// @@string class_name=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_name.get();

}
// @@uint32_t count=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_count_from_class_result_params::detach(){
_m_class_name.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_count_from_class_result_params& mcp_get_content_count_from_class_result_params::assign(const mcp_get_content_count_from_class_result_params& v){
_m_class_name=v._m_class_name;
_m_count=v._m_count;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_count_from_class_result_params::has_class_name() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_count_from_class_result_params::class_name(unsigned int* size) const{
return _m_class_name.get(size);
}
inline mcp_get_content_count_from_class_result_params& mcp_get_content_count_from_class_result_params::set_class_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_count_from_class_result_params& mcp_get_content_count_from_class_result_params::set_ptr_class_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_count_from_class_result_params::clear_class_name(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_class_name.clear();
}
inline bool mcp_get_content_count_from_class_result_params::has_count() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_content_count_from_class_result_params::count() const{
return _m_count;
}
inline mcp_get_content_count_from_class_result_params& mcp_get_content_count_from_class_result_params::set_count(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_content_count_from_class_result_params::clear_count(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_count=0;
}
inline ::idl::Unknown* mcp_get_content_count_from_class_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_count_from_class_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_count_from_class_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_count_from_class_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_count_from_class_response* mcp_get_content_count_from_class_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_count_from_class_response* tmp=(mcp_get_content_count_from_class_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_count_from_class_response(pool);
return tmp;
}
inline void mcp_get_content_count_from_class_response::destroy(mcp_get_content_count_from_class_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_count_from_class_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_count_from_class_response::mcp_get_content_count_from_class_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_count_from_class_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_count_from_class_response::mcp_get_content_count_from_class_response(const mcp_get_content_count_from_class_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_count_from_class_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_count_from_class_response::~mcp_get_content_count_from_class_response(){
if(_m_result_params){
::idl::mcp_get_content_count_from_class_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_count_from_class_response& mcp_get_content_count_from_class_response::operator=(const mcp_get_content_count_from_class_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_count_from_class_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_count_from_class_response::check() const{
// @@mcp_get_content_count_from_class_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_count_from_class_result_params& item=const_cast< ::idl::mcp_get_content_count_from_class_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_count_from_class_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_count_from_class_response& mcp_get_content_count_from_class_response::assign(const mcp_get_content_count_from_class_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_count_from_class_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_count_from_class_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_count_from_class_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_count_from_class_result_params& mcp_get_content_count_from_class_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_count_from_class_result_params* mcp_get_content_count_from_class_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_count_from_class_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_count_from_class_result_params* mcp_get_content_count_from_class_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_count_from_class_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_count_from_class_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_count_from_class_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_count_from_class_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_count_from_class_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_count_from_class_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_info_params* mcp_get_phone_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_info_params* tmp=(mcp_get_phone_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_info_params(pool);
return tmp;
}
inline void mcp_get_phone_info_params::destroy(mcp_get_phone_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_info_params::mcp_get_phone_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_user_info(_pool)
,_m_user_type(0)
,_m_phone_info_type(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_info_params::mcp_get_phone_info_params(const mcp_get_phone_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_user_info(_pool)
,_m_user_type(0)
,_m_phone_info_type(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_info_params::~mcp_get_phone_info_params(){
}
inline mcp_get_phone_info_params& mcp_get_phone_info_params::operator=(const mcp_get_phone_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_info_params::clear(){
_m_user_info.clear();
// _m_user_type=0;
// _m_phone_info_type=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_info_params::check() const{
// @@string user_info=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_info.get();

}
// @@uint32_t user_type=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_user_type;

}
// @@uint32_t phone_info_type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_phone_info_type;

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_info_params::detach(){
_m_user_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_info_params& mcp_get_phone_info_params::assign(const mcp_get_phone_info_params& v){
_m_user_info=v._m_user_info;
_m_user_type=v._m_user_type;
_m_phone_info_type=v._m_phone_info_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_info_params::has_user_info() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_phone_info_params::user_info(unsigned int* size) const{
return _m_user_info.get(size);
}
inline mcp_get_phone_info_params& mcp_get_phone_info_params::set_user_info(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_info_params& mcp_get_phone_info_params::set_ptr_user_info(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_info_params::clear_user_info(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_user_info.clear();
}
inline bool mcp_get_phone_info_params::has_user_type() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_phone_info_params::user_type() const{
return _m_user_type;
}
inline mcp_get_phone_info_params& mcp_get_phone_info_params::set_user_type(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_user_type=v;
return *this;
}
inline void mcp_get_phone_info_params::clear_user_type(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_user_type=0;
}
inline bool mcp_get_phone_info_params::has_phone_info_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_phone_info_params::phone_info_type() const{
return _m_phone_info_type;
}
inline mcp_get_phone_info_params& mcp_get_phone_info_params::set_phone_info_type(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_phone_info_type=v;
return *this;
}
inline void mcp_get_phone_info_params::clear_phone_info_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_phone_info_type=0;
}
inline ::idl::Unknown* mcp_get_phone_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_info_result_params* mcp_get_phone_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_info_result_params* tmp=(mcp_get_phone_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_info_result_params(pool);
return tmp;
}
inline void mcp_get_phone_info_result_params::destroy(mcp_get_phone_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_info_result_params::mcp_get_phone_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_phone_info(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_info_result_params::mcp_get_phone_info_result_params(const mcp_get_phone_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_phone_info(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_info_result_params::~mcp_get_phone_info_result_params(){
}
inline mcp_get_phone_info_result_params& mcp_get_phone_info_result_params::operator=(const mcp_get_phone_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_info_result_params::clear(){
_m_phone_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_info_result_params::check() const{
// @@string phone_info=out(),array(0,0);
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_info" << "' not found";
}
{
// level 0 begin
typeof(_m_phone_info)& lr0=(_m_phone_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_info_result_params::detach(){
_m_phone_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_info_result_params& mcp_get_phone_info_result_params::assign(const mcp_get_phone_info_result_params& v){
_m_phone_info=v._m_phone_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_info_result_params::has_phone_info() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_phone_info_result_params::phone_info() const{
 return _m_phone_info;
}
inline void mcp_get_phone_info_result_params::clear_phone_info(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_phone_info.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_phone_info_result_params::mutable_phone_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_phone_info);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_phone_info_result_params::m_phone_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_phone_info);
}
inline size_t mcp_get_phone_info_result_params::phone_info_size() const{
/*  */ return _m_phone_info.size();
}
inline const char* mcp_get_phone_info_result_params::phone_info(size_t i0,size_t i1,unsigned int* size) const{
 return _m_phone_info.get(i0).get(i1).get(size);
}
inline mcp_get_phone_info_result_params& mcp_get_phone_info_result_params::set_phone_info(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_phone_info.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_phone_info_result_params& mcp_get_phone_info_result_params::set_ptr_phone_info(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_phone_info.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_phone_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_info_response* mcp_get_phone_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_info_response* tmp=(mcp_get_phone_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_info_response(pool);
return tmp;
}
inline void mcp_get_phone_info_response::destroy(mcp_get_phone_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_info_response::mcp_get_phone_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_info_response::mcp_get_phone_info_response(const mcp_get_phone_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_phone_info_response::~mcp_get_phone_info_response(){
if(_m_result_params){
::idl::mcp_get_phone_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_phone_info_response& mcp_get_phone_info_response::operator=(const mcp_get_phone_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_phone_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_info_response::check() const{
// @@mcp_get_phone_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_phone_info_result_params& item=const_cast< ::idl::mcp_get_phone_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_info_response& mcp_get_phone_info_response::assign(const mcp_get_phone_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_phone_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_phone_info_result_params& mcp_get_phone_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_phone_info_result_params* mcp_get_phone_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_phone_info_result_params* mcp_get_phone_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_phone_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_phone_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_uaJson_params* mcp_get_phone_uaJson_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_uaJson_params* tmp=(mcp_get_phone_uaJson_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_uaJson_params(pool);
return tmp;
}
inline void mcp_get_phone_uaJson_params::destroy(mcp_get_phone_uaJson_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_uaJson_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_uaJson_params::mcp_get_phone_uaJson_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ua(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_uaJson_params::mcp_get_phone_uaJson_params(const mcp_get_phone_uaJson_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ua(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_uaJson_params::~mcp_get_phone_uaJson_params(){
}
inline mcp_get_phone_uaJson_params& mcp_get_phone_uaJson_params::operator=(const mcp_get_phone_uaJson_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_uaJson_params::clear(){
_m_ua.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_uaJson_params::check() const{
// @@string ua=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ua" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ua.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_uaJson_params::detach(){
_m_ua.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_uaJson_params& mcp_get_phone_uaJson_params::assign(const mcp_get_phone_uaJson_params& v){
_m_ua=v._m_ua;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_uaJson_params::has_ua() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_phone_uaJson_params::ua(unsigned int* size) const{
return _m_ua.get(size);
}
inline mcp_get_phone_uaJson_params& mcp_get_phone_uaJson_params::set_ua(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ua.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_uaJson_params& mcp_get_phone_uaJson_params::set_ptr_ua(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ua.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_uaJson_params::clear_ua(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ua.clear();
}
inline ::idl::Unknown* mcp_get_phone_uaJson_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_uaJson_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_uaJson_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_uaJson_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_uaJson_result_params* mcp_get_phone_uaJson_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_uaJson_result_params* tmp=(mcp_get_phone_uaJson_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_uaJson_result_params(pool);
return tmp;
}
inline void mcp_get_phone_uaJson_result_params::destroy(mcp_get_phone_uaJson_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_uaJson_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_uaJson_result_params::mcp_get_phone_uaJson_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ua_Json(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_uaJson_result_params::mcp_get_phone_uaJson_result_params(const mcp_get_phone_uaJson_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ua_Json(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_uaJson_result_params::~mcp_get_phone_uaJson_result_params(){
}
inline mcp_get_phone_uaJson_result_params& mcp_get_phone_uaJson_result_params::operator=(const mcp_get_phone_uaJson_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_uaJson_result_params::clear(){
_m_ua_Json.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_uaJson_result_params::check() const{
// @@string ua_Json=out(),array(0);
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ua_Json" << "' not found";
}
{
// level 0 begin
typeof(_m_ua_Json)& lr0=(_m_ua_Json);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_uaJson_result_params::detach(){
_m_ua_Json.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_uaJson_result_params& mcp_get_phone_uaJson_result_params::assign(const mcp_get_phone_uaJson_result_params& v){
_m_ua_Json=v._m_ua_Json;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_uaJson_result_params::has_ua_Json() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_phone_uaJson_result_params::ua_Json() const{
 return _m_ua_Json;
}
inline void mcp_get_phone_uaJson_result_params::clear_ua_Json(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ua_Json.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_uaJson_result_params::mutable_ua_Json(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_ua_Json);
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_uaJson_result_params::m_ua_Json(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_ua_Json);
}
inline size_t mcp_get_phone_uaJson_result_params::ua_Json_size() const{
/*  */ return _m_ua_Json.size();
}
inline const char* mcp_get_phone_uaJson_result_params::ua_Json(size_t i0,unsigned int* size) const{
 return _m_ua_Json.get(i0).get(size);
}
inline mcp_get_phone_uaJson_result_params& mcp_get_phone_uaJson_result_params::set_ua_Json(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ua_Json.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_phone_uaJson_result_params& mcp_get_phone_uaJson_result_params::set_ptr_ua_Json(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ua_Json.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_phone_uaJson_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_uaJson_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_uaJson_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_uaJson_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_uaJson_response* mcp_get_phone_uaJson_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_uaJson_response* tmp=(mcp_get_phone_uaJson_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_uaJson_response(pool);
return tmp;
}
inline void mcp_get_phone_uaJson_response::destroy(mcp_get_phone_uaJson_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_uaJson_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_uaJson_response::mcp_get_phone_uaJson_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_uaJson_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_uaJson_response::mcp_get_phone_uaJson_response(const mcp_get_phone_uaJson_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_uaJson_result_params::create(_pool);
assign(v);
}
inline mcp_get_phone_uaJson_response::~mcp_get_phone_uaJson_response(){
if(_m_result_params){
::idl::mcp_get_phone_uaJson_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_phone_uaJson_response& mcp_get_phone_uaJson_response::operator=(const mcp_get_phone_uaJson_response& v){
assign(v);
return *this;
}
inline void mcp_get_phone_uaJson_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_uaJson_response::check() const{
// @@mcp_get_phone_uaJson_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_phone_uaJson_result_params& item=const_cast< ::idl::mcp_get_phone_uaJson_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_uaJson_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_uaJson_response& mcp_get_phone_uaJson_response::assign(const mcp_get_phone_uaJson_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_phone_uaJson_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_uaJson_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_uaJson_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_phone_uaJson_result_params& mcp_get_phone_uaJson_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_phone_uaJson_result_params* mcp_get_phone_uaJson_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_uaJson_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_phone_uaJson_result_params* mcp_get_phone_uaJson_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_uaJson_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_phone_uaJson_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_phone_uaJson_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_uaJson_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_uaJson_response::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_uaJson_response::unknown_size() const{
return _unknown.size();
}
inline mcp_init_phone_uaJson_map_params* mcp_init_phone_uaJson_map_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_init_phone_uaJson_map_params* tmp=(mcp_init_phone_uaJson_map_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_init_phone_uaJson_map_params(pool);
return tmp;
}
inline void mcp_init_phone_uaJson_map_params::destroy(mcp_init_phone_uaJson_map_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_init_phone_uaJson_map_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_init_phone_uaJson_map_params::mcp_init_phone_uaJson_map_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_input(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_init_phone_uaJson_map_params::mcp_init_phone_uaJson_map_params(const mcp_init_phone_uaJson_map_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_input(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_init_phone_uaJson_map_params::~mcp_init_phone_uaJson_map_params(){
}
inline mcp_init_phone_uaJson_map_params& mcp_init_phone_uaJson_map_params::operator=(const mcp_init_phone_uaJson_map_params& v){
assign(v);
return *this;
}
inline void mcp_init_phone_uaJson_map_params::clear(){
_m_input.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_init_phone_uaJson_map_params::check() const{
// @@string input=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "input" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_input.get();

}

::idl::McpackBean::check();
}
inline void mcp_init_phone_uaJson_map_params::detach(){
_m_input.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_init_phone_uaJson_map_params& mcp_init_phone_uaJson_map_params::assign(const mcp_init_phone_uaJson_map_params& v){
_m_input=v._m_input;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_init_phone_uaJson_map_params::has_input() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_init_phone_uaJson_map_params::input(unsigned int* size) const{
return _m_input.get(size);
}
inline mcp_init_phone_uaJson_map_params& mcp_init_phone_uaJson_map_params::set_input(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_input.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_init_phone_uaJson_map_params& mcp_init_phone_uaJson_map_params::set_ptr_input(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_input.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_init_phone_uaJson_map_params::clear_input(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_input.clear();
}
inline ::idl::Unknown* mcp_init_phone_uaJson_map_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_init_phone_uaJson_map_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_init_phone_uaJson_map_params::unknown(){
return _unknown;
}
inline size_t mcp_init_phone_uaJson_map_params::unknown_size() const{
return _unknown.size();
}
inline mcp_init_phone_uaJson_map_result_params* mcp_init_phone_uaJson_map_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_init_phone_uaJson_map_result_params* tmp=(mcp_init_phone_uaJson_map_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_init_phone_uaJson_map_result_params(pool);
return tmp;
}
inline void mcp_init_phone_uaJson_map_result_params::destroy(mcp_init_phone_uaJson_map_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_init_phone_uaJson_map_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_init_phone_uaJson_map_result_params::mcp_init_phone_uaJson_map_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_output(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_init_phone_uaJson_map_result_params::mcp_init_phone_uaJson_map_result_params(const mcp_init_phone_uaJson_map_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_output(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_init_phone_uaJson_map_result_params::~mcp_init_phone_uaJson_map_result_params(){
}
inline mcp_init_phone_uaJson_map_result_params& mcp_init_phone_uaJson_map_result_params::operator=(const mcp_init_phone_uaJson_map_result_params& v){
assign(v);
return *this;
}
inline void mcp_init_phone_uaJson_map_result_params::clear(){
_m_output.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_init_phone_uaJson_map_result_params::check() const{
// @@string output=out(),array(0);
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "output" << "' not found";
}
{
// level 0 begin
typeof(_m_output)& lr0=(_m_output);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_init_phone_uaJson_map_result_params::detach(){
_m_output.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_init_phone_uaJson_map_result_params& mcp_init_phone_uaJson_map_result_params::assign(const mcp_init_phone_uaJson_map_result_params& v){
_m_output=v._m_output;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_init_phone_uaJson_map_result_params::has_output() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_init_phone_uaJson_map_result_params::output() const{
 return _m_output;
}
inline void mcp_init_phone_uaJson_map_result_params::clear_output(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_output.clear();
}
inline ::idl::vector< ::idl::string >* mcp_init_phone_uaJson_map_result_params::mutable_output(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_output);
}
inline ::idl::vector< ::idl::string >* mcp_init_phone_uaJson_map_result_params::m_output(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_output);
}
inline size_t mcp_init_phone_uaJson_map_result_params::output_size() const{
/*  */ return _m_output.size();
}
inline const char* mcp_init_phone_uaJson_map_result_params::output(size_t i0,unsigned int* size) const{
 return _m_output.get(i0).get(size);
}
inline mcp_init_phone_uaJson_map_result_params& mcp_init_phone_uaJson_map_result_params::set_output(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_output.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_init_phone_uaJson_map_result_params& mcp_init_phone_uaJson_map_result_params::set_ptr_output(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_output.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_init_phone_uaJson_map_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_init_phone_uaJson_map_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_init_phone_uaJson_map_result_params::unknown(){
return _unknown;
}
inline size_t mcp_init_phone_uaJson_map_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_init_phone_uaJson_map_response* mcp_init_phone_uaJson_map_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_init_phone_uaJson_map_response* tmp=(mcp_init_phone_uaJson_map_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_init_phone_uaJson_map_response(pool);
return tmp;
}
inline void mcp_init_phone_uaJson_map_response::destroy(mcp_init_phone_uaJson_map_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_init_phone_uaJson_map_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_init_phone_uaJson_map_response::mcp_init_phone_uaJson_map_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_init_phone_uaJson_map_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_init_phone_uaJson_map_response::mcp_init_phone_uaJson_map_response(const mcp_init_phone_uaJson_map_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_init_phone_uaJson_map_result_params::create(_pool);
assign(v);
}
inline mcp_init_phone_uaJson_map_response::~mcp_init_phone_uaJson_map_response(){
if(_m_result_params){
::idl::mcp_init_phone_uaJson_map_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_init_phone_uaJson_map_response& mcp_init_phone_uaJson_map_response::operator=(const mcp_init_phone_uaJson_map_response& v){
assign(v);
return *this;
}
inline void mcp_init_phone_uaJson_map_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_init_phone_uaJson_map_response::check() const{
// @@mcp_init_phone_uaJson_map_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_init_phone_uaJson_map_result_params& item=const_cast< ::idl::mcp_init_phone_uaJson_map_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_init_phone_uaJson_map_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_init_phone_uaJson_map_response& mcp_init_phone_uaJson_map_response::assign(const mcp_init_phone_uaJson_map_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_init_phone_uaJson_map_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_init_phone_uaJson_map_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_init_phone_uaJson_map_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_init_phone_uaJson_map_result_params& mcp_init_phone_uaJson_map_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_init_phone_uaJson_map_result_params* mcp_init_phone_uaJson_map_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_init_phone_uaJson_map_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_init_phone_uaJson_map_result_params* mcp_init_phone_uaJson_map_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_init_phone_uaJson_map_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_init_phone_uaJson_map_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_init_phone_uaJson_map_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_init_phone_uaJson_map_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_init_phone_uaJson_map_response::unknown(){
return _unknown;
}
inline size_t mcp_init_phone_uaJson_map_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_type_from_ID_params* mcp_get_phone_type_from_ID_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_type_from_ID_params* tmp=(mcp_get_phone_type_from_ID_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_type_from_ID_params(pool);
return tmp;
}
inline void mcp_get_phone_type_from_ID_params::destroy(mcp_get_phone_type_from_ID_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_type_from_ID_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_type_from_ID_params::mcp_get_phone_type_from_ID_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_id(_pool)
,_m_id_type(0)
,_m_head_word(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_type_from_ID_params::mcp_get_phone_type_from_ID_params(const mcp_get_phone_type_from_ID_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_id(_pool)
,_m_id_type(0)
,_m_head_word(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_type_from_ID_params::~mcp_get_phone_type_from_ID_params(){
}
inline mcp_get_phone_type_from_ID_params& mcp_get_phone_type_from_ID_params::operator=(const mcp_get_phone_type_from_ID_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_type_from_ID_params::clear(){
_m_info_id.clear();
// _m_id_type=0;
_m_head_word.clear();
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_type_from_ID_params::check() const{
// @@string info_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@uint32_t id_type=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_id_type;

}
// @@string head_word=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "head_word" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_head_word.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_type_from_ID_params::detach(){
_m_info_id.detach();
_m_head_word.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_type_from_ID_params& mcp_get_phone_type_from_ID_params::assign(const mcp_get_phone_type_from_ID_params& v){
_m_info_id=v._m_info_id;
_m_id_type=v._m_id_type;
_m_head_word=v._m_head_word;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_type_from_ID_params::has_info_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_phone_type_from_ID_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_phone_type_from_ID_params& mcp_get_phone_type_from_ID_params::set_info_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_type_from_ID_params& mcp_get_phone_type_from_ID_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_type_from_ID_params::clear_info_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_phone_type_from_ID_params::has_id_type() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_phone_type_from_ID_params::id_type() const{
return _m_id_type;
}
inline mcp_get_phone_type_from_ID_params& mcp_get_phone_type_from_ID_params::set_id_type(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_id_type=v;
return *this;
}
inline void mcp_get_phone_type_from_ID_params::clear_id_type(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_id_type=0;
}
inline bool mcp_get_phone_type_from_ID_params::has_head_word() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_phone_type_from_ID_params::head_word(unsigned int* size) const{
return _m_head_word.get(size);
}
inline mcp_get_phone_type_from_ID_params& mcp_get_phone_type_from_ID_params::set_head_word(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_head_word.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_type_from_ID_params& mcp_get_phone_type_from_ID_params::set_ptr_head_word(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_head_word.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_type_from_ID_params::clear_head_word(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_head_word.clear();
}
inline bool mcp_get_phone_type_from_ID_params::has_unit_num() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_phone_type_from_ID_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_phone_type_from_ID_params& mcp_get_phone_type_from_ID_params::set_unit_num(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_phone_type_from_ID_params::clear_unit_num(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_phone_type_from_ID_params::has_unit_times() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_phone_type_from_ID_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_phone_type_from_ID_params& mcp_get_phone_type_from_ID_params::set_unit_times(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_phone_type_from_ID_params::clear_unit_times(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_phone_type_from_ID_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_type_from_ID_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_type_from_ID_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_type_from_ID_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_type_from_ID_result_params* mcp_get_phone_type_from_ID_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_type_from_ID_result_params* tmp=(mcp_get_phone_type_from_ID_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_type_from_ID_result_params(pool);
return tmp;
}
inline void mcp_get_phone_type_from_ID_result_params::destroy(mcp_get_phone_type_from_ID_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_type_from_ID_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_type_from_ID_result_params::mcp_get_phone_type_from_ID_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_phone_count(0)
,_m_phone_id(_pool)
,_m_phone_name(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_type_from_ID_result_params::mcp_get_phone_type_from_ID_result_params(const mcp_get_phone_type_from_ID_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_phone_count(0)
,_m_phone_id(_pool)
,_m_phone_name(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_type_from_ID_result_params::~mcp_get_phone_type_from_ID_result_params(){
}
inline mcp_get_phone_type_from_ID_result_params& mcp_get_phone_type_from_ID_result_params::operator=(const mcp_get_phone_type_from_ID_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_type_from_ID_result_params::clear(){
// _m_phone_count=0;
_m_phone_id.clear();
_m_phone_name.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_type_from_ID_result_params::check() const{
// @@uint32_t phone_count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_phone_count;

}
// @@string phone_id=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_id" << "' not found";
}
{
// level 0 begin
typeof(_m_phone_id)& lr0=(_m_phone_id);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@string phone_name=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_name" << "' not found";
}
{
// level 0 begin
typeof(_m_phone_name)& lr0=(_m_phone_name);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_type_from_ID_result_params::detach(){
_m_phone_id.detach();
_m_phone_name.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_type_from_ID_result_params& mcp_get_phone_type_from_ID_result_params::assign(const mcp_get_phone_type_from_ID_result_params& v){
_m_phone_count=v._m_phone_count;
_m_phone_id=v._m_phone_id;
_m_phone_name=v._m_phone_name;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_type_from_ID_result_params::has_phone_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_phone_type_from_ID_result_params::phone_count() const{
return _m_phone_count;
}
inline mcp_get_phone_type_from_ID_result_params& mcp_get_phone_type_from_ID_result_params::set_phone_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_phone_count=v;
return *this;
}
inline void mcp_get_phone_type_from_ID_result_params::clear_phone_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_phone_count=0;
}
inline bool mcp_get_phone_type_from_ID_result_params::has_phone_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_phone_type_from_ID_result_params::phone_id() const{
 return _m_phone_id;
}
inline void mcp_get_phone_type_from_ID_result_params::clear_phone_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_phone_id.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_type_from_ID_result_params::mutable_phone_id(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_phone_id);
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_type_from_ID_result_params::m_phone_id(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_phone_id);
}
inline size_t mcp_get_phone_type_from_ID_result_params::phone_id_size() const{
/*  */ return _m_phone_id.size();
}
inline const char* mcp_get_phone_type_from_ID_result_params::phone_id(size_t i0,unsigned int* size) const{
 return _m_phone_id.get(i0).get(size);
}
inline mcp_get_phone_type_from_ID_result_params& mcp_get_phone_type_from_ID_result_params::set_phone_id(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_phone_id.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_phone_type_from_ID_result_params& mcp_get_phone_type_from_ID_result_params::set_ptr_phone_id(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_phone_id.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool mcp_get_phone_type_from_ID_result_params::has_phone_name() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_phone_type_from_ID_result_params::phone_name() const{
 return _m_phone_name;
}
inline void mcp_get_phone_type_from_ID_result_params::clear_phone_name(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_phone_name.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_type_from_ID_result_params::mutable_phone_name(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_phone_name);
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_type_from_ID_result_params::m_phone_name(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_phone_name);
}
inline size_t mcp_get_phone_type_from_ID_result_params::phone_name_size() const{
/*  */ return _m_phone_name.size();
}
inline const char* mcp_get_phone_type_from_ID_result_params::phone_name(size_t i0,unsigned int* size) const{
 return _m_phone_name.get(i0).get(size);
}
inline mcp_get_phone_type_from_ID_result_params& mcp_get_phone_type_from_ID_result_params::set_phone_name(size_t i0,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_phone_name.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_phone_type_from_ID_result_params& mcp_get_phone_type_from_ID_result_params::set_ptr_phone_name(size_t i0,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_phone_name.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_phone_type_from_ID_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_type_from_ID_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_type_from_ID_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_type_from_ID_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_type_from_ID_response* mcp_get_phone_type_from_ID_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_type_from_ID_response* tmp=(mcp_get_phone_type_from_ID_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_type_from_ID_response(pool);
return tmp;
}
inline void mcp_get_phone_type_from_ID_response::destroy(mcp_get_phone_type_from_ID_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_type_from_ID_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_type_from_ID_response::mcp_get_phone_type_from_ID_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_type_from_ID_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_type_from_ID_response::mcp_get_phone_type_from_ID_response(const mcp_get_phone_type_from_ID_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_type_from_ID_result_params::create(_pool);
assign(v);
}
inline mcp_get_phone_type_from_ID_response::~mcp_get_phone_type_from_ID_response(){
if(_m_result_params){
::idl::mcp_get_phone_type_from_ID_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_phone_type_from_ID_response& mcp_get_phone_type_from_ID_response::operator=(const mcp_get_phone_type_from_ID_response& v){
assign(v);
return *this;
}
inline void mcp_get_phone_type_from_ID_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_type_from_ID_response::check() const{
// @@mcp_get_phone_type_from_ID_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_phone_type_from_ID_result_params& item=const_cast< ::idl::mcp_get_phone_type_from_ID_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_type_from_ID_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_type_from_ID_response& mcp_get_phone_type_from_ID_response::assign(const mcp_get_phone_type_from_ID_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_phone_type_from_ID_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_type_from_ID_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_type_from_ID_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_phone_type_from_ID_result_params& mcp_get_phone_type_from_ID_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_phone_type_from_ID_result_params* mcp_get_phone_type_from_ID_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_type_from_ID_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_phone_type_from_ID_result_params* mcp_get_phone_type_from_ID_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_type_from_ID_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_phone_type_from_ID_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_phone_type_from_ID_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_type_from_ID_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_type_from_ID_response::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_type_from_ID_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_headword_from_maker_params* mcp_get_phone_headword_from_maker_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_headword_from_maker_params* tmp=(mcp_get_phone_headword_from_maker_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_headword_from_maker_params(pool);
return tmp;
}
inline void mcp_get_phone_headword_from_maker_params::destroy(mcp_get_phone_headword_from_maker_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_headword_from_maker_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_headword_from_maker_params::mcp_get_phone_headword_from_maker_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_maker_id(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_headword_from_maker_params::mcp_get_phone_headword_from_maker_params(const mcp_get_phone_headword_from_maker_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_maker_id(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_headword_from_maker_params::~mcp_get_phone_headword_from_maker_params(){
}
inline mcp_get_phone_headword_from_maker_params& mcp_get_phone_headword_from_maker_params::operator=(const mcp_get_phone_headword_from_maker_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_headword_from_maker_params::clear(){
_m_maker_id.clear();
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_headword_from_maker_params::check() const{
// @@string maker_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "maker_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_maker_id.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_headword_from_maker_params::detach(){
_m_maker_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_headword_from_maker_params& mcp_get_phone_headword_from_maker_params::assign(const mcp_get_phone_headword_from_maker_params& v){
_m_maker_id=v._m_maker_id;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_headword_from_maker_params::has_maker_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_phone_headword_from_maker_params::maker_id(unsigned int* size) const{
return _m_maker_id.get(size);
}
inline mcp_get_phone_headword_from_maker_params& mcp_get_phone_headword_from_maker_params::set_maker_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_maker_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_headword_from_maker_params& mcp_get_phone_headword_from_maker_params::set_ptr_maker_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_maker_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_headword_from_maker_params::clear_maker_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_maker_id.clear();
}
inline bool mcp_get_phone_headword_from_maker_params::has_unit_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_phone_headword_from_maker_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_phone_headword_from_maker_params& mcp_get_phone_headword_from_maker_params::set_unit_num(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_phone_headword_from_maker_params::clear_unit_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_phone_headword_from_maker_params::has_unit_times() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_phone_headword_from_maker_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_phone_headword_from_maker_params& mcp_get_phone_headword_from_maker_params::set_unit_times(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_phone_headword_from_maker_params::clear_unit_times(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_phone_headword_from_maker_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_headword_from_maker_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_headword_from_maker_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_headword_from_maker_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_headword_from_maker_result_params* mcp_get_phone_headword_from_maker_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_headword_from_maker_result_params* tmp=(mcp_get_phone_headword_from_maker_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_headword_from_maker_result_params(pool);
return tmp;
}
inline void mcp_get_phone_headword_from_maker_result_params::destroy(mcp_get_phone_headword_from_maker_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_headword_from_maker_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_headword_from_maker_result_params::mcp_get_phone_headword_from_maker_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_headword_count(0)
,_m_head_word(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_headword_from_maker_result_params::mcp_get_phone_headword_from_maker_result_params(const mcp_get_phone_headword_from_maker_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_headword_count(0)
,_m_head_word(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_headword_from_maker_result_params::~mcp_get_phone_headword_from_maker_result_params(){
}
inline mcp_get_phone_headword_from_maker_result_params& mcp_get_phone_headword_from_maker_result_params::operator=(const mcp_get_phone_headword_from_maker_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_headword_from_maker_result_params::clear(){
// _m_headword_count=0;
_m_head_word.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_headword_from_maker_result_params::check() const{
// @@uint32_t headword_count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "headword_count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_headword_count;

}
// @@string head_word=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "head_word" << "' not found";
}
{
// level 0 begin
typeof(_m_head_word)& lr0=(_m_head_word);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_headword_from_maker_result_params::detach(){
_m_head_word.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_headword_from_maker_result_params& mcp_get_phone_headword_from_maker_result_params::assign(const mcp_get_phone_headword_from_maker_result_params& v){
_m_headword_count=v._m_headword_count;
_m_head_word=v._m_head_word;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_headword_from_maker_result_params::has_headword_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_phone_headword_from_maker_result_params::headword_count() const{
return _m_headword_count;
}
inline mcp_get_phone_headword_from_maker_result_params& mcp_get_phone_headword_from_maker_result_params::set_headword_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_headword_count=v;
return *this;
}
inline void mcp_get_phone_headword_from_maker_result_params::clear_headword_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_headword_count=0;
}
inline bool mcp_get_phone_headword_from_maker_result_params::has_head_word() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_phone_headword_from_maker_result_params::head_word() const{
 return _m_head_word;
}
inline void mcp_get_phone_headword_from_maker_result_params::clear_head_word(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_head_word.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_headword_from_maker_result_params::mutable_head_word(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_head_word);
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_headword_from_maker_result_params::m_head_word(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_head_word);
}
inline size_t mcp_get_phone_headword_from_maker_result_params::head_word_size() const{
/*  */ return _m_head_word.size();
}
inline const char* mcp_get_phone_headword_from_maker_result_params::head_word(size_t i0,unsigned int* size) const{
 return _m_head_word.get(i0).get(size);
}
inline mcp_get_phone_headword_from_maker_result_params& mcp_get_phone_headword_from_maker_result_params::set_head_word(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_head_word.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_phone_headword_from_maker_result_params& mcp_get_phone_headword_from_maker_result_params::set_ptr_head_word(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_head_word.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_phone_headword_from_maker_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_headword_from_maker_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_headword_from_maker_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_headword_from_maker_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_headword_from_maker_response* mcp_get_phone_headword_from_maker_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_headword_from_maker_response* tmp=(mcp_get_phone_headword_from_maker_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_headword_from_maker_response(pool);
return tmp;
}
inline void mcp_get_phone_headword_from_maker_response::destroy(mcp_get_phone_headword_from_maker_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_headword_from_maker_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_headword_from_maker_response::mcp_get_phone_headword_from_maker_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_headword_from_maker_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_headword_from_maker_response::mcp_get_phone_headword_from_maker_response(const mcp_get_phone_headword_from_maker_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_headword_from_maker_result_params::create(_pool);
assign(v);
}
inline mcp_get_phone_headword_from_maker_response::~mcp_get_phone_headword_from_maker_response(){
if(_m_result_params){
::idl::mcp_get_phone_headword_from_maker_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_phone_headword_from_maker_response& mcp_get_phone_headword_from_maker_response::operator=(const mcp_get_phone_headword_from_maker_response& v){
assign(v);
return *this;
}
inline void mcp_get_phone_headword_from_maker_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_headword_from_maker_response::check() const{
// @@mcp_get_phone_headword_from_maker_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_phone_headword_from_maker_result_params& item=const_cast< ::idl::mcp_get_phone_headword_from_maker_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_headword_from_maker_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_headword_from_maker_response& mcp_get_phone_headword_from_maker_response::assign(const mcp_get_phone_headword_from_maker_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_phone_headword_from_maker_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_headword_from_maker_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_headword_from_maker_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_phone_headword_from_maker_result_params& mcp_get_phone_headword_from_maker_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_phone_headword_from_maker_result_params* mcp_get_phone_headword_from_maker_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_headword_from_maker_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_phone_headword_from_maker_result_params* mcp_get_phone_headword_from_maker_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_headword_from_maker_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_phone_headword_from_maker_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_phone_headword_from_maker_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_headword_from_maker_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_headword_from_maker_response::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_headword_from_maker_response::unknown_size() const{
return _unknown.size();
}
inline mcp_search_phone_info_params* mcp_search_phone_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_search_phone_info_params* tmp=(mcp_search_phone_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_search_phone_info_params(pool);
return tmp;
}
inline void mcp_search_phone_info_params::destroy(mcp_search_phone_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_search_phone_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_search_phone_info_params::mcp_search_phone_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_key(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_search_phone_info_params::mcp_search_phone_info_params(const mcp_search_phone_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_key(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_search_phone_info_params::~mcp_search_phone_info_params(){
}
inline mcp_search_phone_info_params& mcp_search_phone_info_params::operator=(const mcp_search_phone_info_params& v){
assign(v);
return *this;
}
inline void mcp_search_phone_info_params::clear(){
_m_key.clear();
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_search_phone_info_params::check() const{
// @@string key=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "key" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_key.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_search_phone_info_params::detach(){
_m_key.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_search_phone_info_params& mcp_search_phone_info_params::assign(const mcp_search_phone_info_params& v){
_m_key=v._m_key;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_search_phone_info_params::has_key() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_search_phone_info_params::key(unsigned int* size) const{
return _m_key.get(size);
}
inline mcp_search_phone_info_params& mcp_search_phone_info_params::set_key(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_key.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_search_phone_info_params& mcp_search_phone_info_params::set_ptr_key(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_key.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_search_phone_info_params::clear_key(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_key.clear();
}
inline bool mcp_search_phone_info_params::has_unit_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_search_phone_info_params::unit_num() const{
return _m_unit_num;
}
inline mcp_search_phone_info_params& mcp_search_phone_info_params::set_unit_num(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_search_phone_info_params::clear_unit_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_search_phone_info_params::has_unit_times() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_search_phone_info_params::unit_times() const{
return _m_unit_times;
}
inline mcp_search_phone_info_params& mcp_search_phone_info_params::set_unit_times(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_search_phone_info_params::clear_unit_times(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_search_phone_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_search_phone_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_search_phone_info_params::unknown(){
return _unknown;
}
inline size_t mcp_search_phone_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_search_phone_info_result_params* mcp_search_phone_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_search_phone_info_result_params* tmp=(mcp_search_phone_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_search_phone_info_result_params(pool);
return tmp;
}
inline void mcp_search_phone_info_result_params::destroy(mcp_search_phone_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_search_phone_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_search_phone_info_result_params::mcp_search_phone_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_phone_count(0)
,_m_phone_id(_pool)
,_m_phone_name(_pool)
,_m_brand_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_search_phone_info_result_params::mcp_search_phone_info_result_params(const mcp_search_phone_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_phone_count(0)
,_m_phone_id(_pool)
,_m_phone_name(_pool)
,_m_brand_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_search_phone_info_result_params::~mcp_search_phone_info_result_params(){
}
inline mcp_search_phone_info_result_params& mcp_search_phone_info_result_params::operator=(const mcp_search_phone_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_search_phone_info_result_params::clear(){
// _m_phone_count=0;
_m_phone_id.clear();
_m_phone_name.clear();
_m_brand_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_search_phone_info_result_params::check() const{
// @@uint32_t phone_count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_phone_count;

}
// @@string phone_id=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_id" << "' not found";
}
{
// level 0 begin
typeof(_m_phone_id)& lr0=(_m_phone_id);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@string phone_name=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_name" << "' not found";
}
{
// level 0 begin
typeof(_m_phone_name)& lr0=(_m_phone_name);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@string brand_id=out(),array(0);
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "brand_id" << "' not found";
}
{
// level 0 begin
typeof(_m_brand_id)& lr0=(_m_brand_id);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_search_phone_info_result_params::detach(){
_m_phone_id.detach();
_m_phone_name.detach();
_m_brand_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_search_phone_info_result_params& mcp_search_phone_info_result_params::assign(const mcp_search_phone_info_result_params& v){
_m_phone_count=v._m_phone_count;
_m_phone_id=v._m_phone_id;
_m_phone_name=v._m_phone_name;
_m_brand_id=v._m_brand_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_search_phone_info_result_params::has_phone_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_search_phone_info_result_params::phone_count() const{
return _m_phone_count;
}
inline mcp_search_phone_info_result_params& mcp_search_phone_info_result_params::set_phone_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_phone_count=v;
return *this;
}
inline void mcp_search_phone_info_result_params::clear_phone_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_phone_count=0;
}
inline bool mcp_search_phone_info_result_params::has_phone_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_search_phone_info_result_params::phone_id() const{
 return _m_phone_id;
}
inline void mcp_search_phone_info_result_params::clear_phone_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_phone_id.clear();
}
inline ::idl::vector< ::idl::string >* mcp_search_phone_info_result_params::mutable_phone_id(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_phone_id);
}
inline ::idl::vector< ::idl::string >* mcp_search_phone_info_result_params::m_phone_id(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_phone_id);
}
inline size_t mcp_search_phone_info_result_params::phone_id_size() const{
/*  */ return _m_phone_id.size();
}
inline const char* mcp_search_phone_info_result_params::phone_id(size_t i0,unsigned int* size) const{
 return _m_phone_id.get(i0).get(size);
}
inline mcp_search_phone_info_result_params& mcp_search_phone_info_result_params::set_phone_id(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_phone_id.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_search_phone_info_result_params& mcp_search_phone_info_result_params::set_ptr_phone_id(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_phone_id.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool mcp_search_phone_info_result_params::has_phone_name() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_search_phone_info_result_params::phone_name() const{
 return _m_phone_name;
}
inline void mcp_search_phone_info_result_params::clear_phone_name(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_phone_name.clear();
}
inline ::idl::vector< ::idl::string >* mcp_search_phone_info_result_params::mutable_phone_name(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_phone_name);
}
inline ::idl::vector< ::idl::string >* mcp_search_phone_info_result_params::m_phone_name(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_phone_name);
}
inline size_t mcp_search_phone_info_result_params::phone_name_size() const{
/*  */ return _m_phone_name.size();
}
inline const char* mcp_search_phone_info_result_params::phone_name(size_t i0,unsigned int* size) const{
 return _m_phone_name.get(i0).get(size);
}
inline mcp_search_phone_info_result_params& mcp_search_phone_info_result_params::set_phone_name(size_t i0,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_phone_name.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_search_phone_info_result_params& mcp_search_phone_info_result_params::set_ptr_phone_name(size_t i0,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_phone_name.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool mcp_search_phone_info_result_params::has_brand_id() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_search_phone_info_result_params::brand_id() const{
 return _m_brand_id;
}
inline void mcp_search_phone_info_result_params::clear_brand_id(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_brand_id.clear();
}
inline ::idl::vector< ::idl::string >* mcp_search_phone_info_result_params::mutable_brand_id(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_brand_id);
}
inline ::idl::vector< ::idl::string >* mcp_search_phone_info_result_params::m_brand_id(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_brand_id);
}
inline size_t mcp_search_phone_info_result_params::brand_id_size() const{
/*  */ return _m_brand_id.size();
}
inline const char* mcp_search_phone_info_result_params::brand_id(size_t i0,unsigned int* size) const{
 return _m_brand_id.get(i0).get(size);
}
inline mcp_search_phone_info_result_params& mcp_search_phone_info_result_params::set_brand_id(size_t i0,const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_brand_id.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_search_phone_info_result_params& mcp_search_phone_info_result_params::set_ptr_brand_id(size_t i0,const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_brand_id.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_search_phone_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_search_phone_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_search_phone_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_search_phone_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_search_phone_info_response* mcp_search_phone_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_search_phone_info_response* tmp=(mcp_search_phone_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_search_phone_info_response(pool);
return tmp;
}
inline void mcp_search_phone_info_response::destroy(mcp_search_phone_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_search_phone_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_search_phone_info_response::mcp_search_phone_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_search_phone_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_search_phone_info_response::mcp_search_phone_info_response(const mcp_search_phone_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_search_phone_info_result_params::create(_pool);
assign(v);
}
inline mcp_search_phone_info_response::~mcp_search_phone_info_response(){
if(_m_result_params){
::idl::mcp_search_phone_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_search_phone_info_response& mcp_search_phone_info_response::operator=(const mcp_search_phone_info_response& v){
assign(v);
return *this;
}
inline void mcp_search_phone_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_search_phone_info_response::check() const{
// @@mcp_search_phone_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_search_phone_info_result_params& item=const_cast< ::idl::mcp_search_phone_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_search_phone_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_search_phone_info_response& mcp_search_phone_info_response::assign(const mcp_search_phone_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_search_phone_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_search_phone_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_search_phone_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_search_phone_info_result_params& mcp_search_phone_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_search_phone_info_result_params* mcp_search_phone_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_search_phone_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_search_phone_info_result_params* mcp_search_phone_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_search_phone_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_search_phone_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_search_phone_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_search_phone_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_search_phone_info_response::unknown(){
return _unknown;
}
inline size_t mcp_search_phone_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_carriers_info_from_ip_params* mcp_get_carriers_info_from_ip_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_carriers_info_from_ip_params* tmp=(mcp_get_carriers_info_from_ip_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_carriers_info_from_ip_params(pool);
return tmp;
}
inline void mcp_get_carriers_info_from_ip_params::destroy(mcp_get_carriers_info_from_ip_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_carriers_info_from_ip_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_carriers_info_from_ip_params::mcp_get_carriers_info_from_ip_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ip_addres(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_carriers_info_from_ip_params::mcp_get_carriers_info_from_ip_params(const mcp_get_carriers_info_from_ip_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ip_addres(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_carriers_info_from_ip_params::~mcp_get_carriers_info_from_ip_params(){
}
inline mcp_get_carriers_info_from_ip_params& mcp_get_carriers_info_from_ip_params::operator=(const mcp_get_carriers_info_from_ip_params& v){
assign(v);
return *this;
}
inline void mcp_get_carriers_info_from_ip_params::clear(){
_m_ip_addres.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_carriers_info_from_ip_params::check() const{
// @@string ip_addres=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ip_addres" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ip_addres.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_carriers_info_from_ip_params::detach(){
_m_ip_addres.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_carriers_info_from_ip_params& mcp_get_carriers_info_from_ip_params::assign(const mcp_get_carriers_info_from_ip_params& v){
_m_ip_addres=v._m_ip_addres;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_carriers_info_from_ip_params::has_ip_addres() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_carriers_info_from_ip_params::ip_addres(unsigned int* size) const{
return _m_ip_addres.get(size);
}
inline mcp_get_carriers_info_from_ip_params& mcp_get_carriers_info_from_ip_params::set_ip_addres(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ip_addres.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_carriers_info_from_ip_params& mcp_get_carriers_info_from_ip_params::set_ptr_ip_addres(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ip_addres.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_carriers_info_from_ip_params::clear_ip_addres(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ip_addres.clear();
}
inline ::idl::Unknown* mcp_get_carriers_info_from_ip_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_carriers_info_from_ip_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_carriers_info_from_ip_params::unknown(){
return _unknown;
}
inline size_t mcp_get_carriers_info_from_ip_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_carriers_info_from_ip_result_params* mcp_get_carriers_info_from_ip_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_carriers_info_from_ip_result_params* tmp=(mcp_get_carriers_info_from_ip_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_carriers_info_from_ip_result_params(pool);
return tmp;
}
inline void mcp_get_carriers_info_from_ip_result_params::destroy(mcp_get_carriers_info_from_ip_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_carriers_info_from_ip_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_carriers_info_from_ip_result_params::mcp_get_carriers_info_from_ip_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_carriers_name(0)
,_m_owner_place(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_carriers_info_from_ip_result_params::mcp_get_carriers_info_from_ip_result_params(const mcp_get_carriers_info_from_ip_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_carriers_name(0)
,_m_owner_place(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_carriers_info_from_ip_result_params::~mcp_get_carriers_info_from_ip_result_params(){
}
inline mcp_get_carriers_info_from_ip_result_params& mcp_get_carriers_info_from_ip_result_params::operator=(const mcp_get_carriers_info_from_ip_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_carriers_info_from_ip_result_params::clear(){
// _m_carriers_name=0;
// _m_owner_place=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_carriers_info_from_ip_result_params::check() const{
// @@uint32_t carriers_name=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "carriers_name" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_carriers_name;

}
// @@uint32_t owner_place=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "owner_place" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_owner_place;

}

::idl::McpackBean::check();
}
inline void mcp_get_carriers_info_from_ip_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_carriers_info_from_ip_result_params& mcp_get_carriers_info_from_ip_result_params::assign(const mcp_get_carriers_info_from_ip_result_params& v){
_m_carriers_name=v._m_carriers_name;
_m_owner_place=v._m_owner_place;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_carriers_info_from_ip_result_params::has_carriers_name() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_carriers_info_from_ip_result_params::carriers_name() const{
return _m_carriers_name;
}
inline mcp_get_carriers_info_from_ip_result_params& mcp_get_carriers_info_from_ip_result_params::set_carriers_name(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_carriers_name=v;
return *this;
}
inline void mcp_get_carriers_info_from_ip_result_params::clear_carriers_name(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_carriers_name=0;
}
inline bool mcp_get_carriers_info_from_ip_result_params::has_owner_place() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_carriers_info_from_ip_result_params::owner_place() const{
return _m_owner_place;
}
inline mcp_get_carriers_info_from_ip_result_params& mcp_get_carriers_info_from_ip_result_params::set_owner_place(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_owner_place=v;
return *this;
}
inline void mcp_get_carriers_info_from_ip_result_params::clear_owner_place(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_owner_place=0;
}
inline ::idl::Unknown* mcp_get_carriers_info_from_ip_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_carriers_info_from_ip_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_carriers_info_from_ip_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_carriers_info_from_ip_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_carriers_info_from_ip_response* mcp_get_carriers_info_from_ip_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_carriers_info_from_ip_response* tmp=(mcp_get_carriers_info_from_ip_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_carriers_info_from_ip_response(pool);
return tmp;
}
inline void mcp_get_carriers_info_from_ip_response::destroy(mcp_get_carriers_info_from_ip_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_carriers_info_from_ip_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_carriers_info_from_ip_response::mcp_get_carriers_info_from_ip_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_carriers_info_from_ip_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_carriers_info_from_ip_response::mcp_get_carriers_info_from_ip_response(const mcp_get_carriers_info_from_ip_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_carriers_info_from_ip_result_params::create(_pool);
assign(v);
}
inline mcp_get_carriers_info_from_ip_response::~mcp_get_carriers_info_from_ip_response(){
if(_m_result_params){
::idl::mcp_get_carriers_info_from_ip_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_carriers_info_from_ip_response& mcp_get_carriers_info_from_ip_response::operator=(const mcp_get_carriers_info_from_ip_response& v){
assign(v);
return *this;
}
inline void mcp_get_carriers_info_from_ip_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_carriers_info_from_ip_response::check() const{
// @@mcp_get_carriers_info_from_ip_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_carriers_info_from_ip_result_params& item=const_cast< ::idl::mcp_get_carriers_info_from_ip_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_carriers_info_from_ip_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_carriers_info_from_ip_response& mcp_get_carriers_info_from_ip_response::assign(const mcp_get_carriers_info_from_ip_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_carriers_info_from_ip_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_carriers_info_from_ip_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_carriers_info_from_ip_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_carriers_info_from_ip_result_params& mcp_get_carriers_info_from_ip_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_carriers_info_from_ip_result_params* mcp_get_carriers_info_from_ip_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_carriers_info_from_ip_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_carriers_info_from_ip_result_params* mcp_get_carriers_info_from_ip_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_carriers_info_from_ip_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_carriers_info_from_ip_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_carriers_info_from_ip_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_carriers_info_from_ip_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_carriers_info_from_ip_response::unknown(){
return _unknown;
}
inline size_t mcp_get_carriers_info_from_ip_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_info_from_maker_plat_params* mcp_get_phone_info_from_maker_plat_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_info_from_maker_plat_params* tmp=(mcp_get_phone_info_from_maker_plat_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_info_from_maker_plat_params(pool);
return tmp;
}
inline void mcp_get_phone_info_from_maker_plat_params::destroy(mcp_get_phone_info_from_maker_plat_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_info_from_maker_plat_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_info_from_maker_plat_params::mcp_get_phone_info_from_maker_plat_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_maker_id(_pool)
,_m_plat_id(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_info_from_maker_plat_params::mcp_get_phone_info_from_maker_plat_params(const mcp_get_phone_info_from_maker_plat_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_maker_id(_pool)
,_m_plat_id(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_info_from_maker_plat_params::~mcp_get_phone_info_from_maker_plat_params(){
}
inline mcp_get_phone_info_from_maker_plat_params& mcp_get_phone_info_from_maker_plat_params::operator=(const mcp_get_phone_info_from_maker_plat_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_info_from_maker_plat_params::clear(){
_m_maker_id.clear();
_m_plat_id.clear();
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_info_from_maker_plat_params::check() const{
// @@string maker_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "maker_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_maker_id.get();

}
// @@string plat_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "plat_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_plat_id.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_info_from_maker_plat_params::detach(){
_m_maker_id.detach();
_m_plat_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_info_from_maker_plat_params& mcp_get_phone_info_from_maker_plat_params::assign(const mcp_get_phone_info_from_maker_plat_params& v){
_m_maker_id=v._m_maker_id;
_m_plat_id=v._m_plat_id;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_info_from_maker_plat_params::has_maker_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_phone_info_from_maker_plat_params::maker_id(unsigned int* size) const{
return _m_maker_id.get(size);
}
inline mcp_get_phone_info_from_maker_plat_params& mcp_get_phone_info_from_maker_plat_params::set_maker_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_maker_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_info_from_maker_plat_params& mcp_get_phone_info_from_maker_plat_params::set_ptr_maker_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_maker_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_info_from_maker_plat_params::clear_maker_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_maker_id.clear();
}
inline bool mcp_get_phone_info_from_maker_plat_params::has_plat_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_phone_info_from_maker_plat_params::plat_id(unsigned int* size) const{
return _m_plat_id.get(size);
}
inline mcp_get_phone_info_from_maker_plat_params& mcp_get_phone_info_from_maker_plat_params::set_plat_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_plat_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_info_from_maker_plat_params& mcp_get_phone_info_from_maker_plat_params::set_ptr_plat_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_plat_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_info_from_maker_plat_params::clear_plat_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_plat_id.clear();
}
inline bool mcp_get_phone_info_from_maker_plat_params::has_unit_num() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_phone_info_from_maker_plat_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_phone_info_from_maker_plat_params& mcp_get_phone_info_from_maker_plat_params::set_unit_num(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_phone_info_from_maker_plat_params::clear_unit_num(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_phone_info_from_maker_plat_params::has_unit_times() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_phone_info_from_maker_plat_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_phone_info_from_maker_plat_params& mcp_get_phone_info_from_maker_plat_params::set_unit_times(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_phone_info_from_maker_plat_params::clear_unit_times(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_phone_info_from_maker_plat_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_info_from_maker_plat_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_info_from_maker_plat_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_info_from_maker_plat_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_info_from_maker_plat_result_params* mcp_get_phone_info_from_maker_plat_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_info_from_maker_plat_result_params* tmp=(mcp_get_phone_info_from_maker_plat_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_info_from_maker_plat_result_params(pool);
return tmp;
}
inline void mcp_get_phone_info_from_maker_plat_result_params::destroy(mcp_get_phone_info_from_maker_plat_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_info_from_maker_plat_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_info_from_maker_plat_result_params::mcp_get_phone_info_from_maker_plat_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_phone_count(0)
,_m_phone_id(_pool)
,_m_phone_name(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_info_from_maker_plat_result_params::mcp_get_phone_info_from_maker_plat_result_params(const mcp_get_phone_info_from_maker_plat_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_phone_count(0)
,_m_phone_id(_pool)
,_m_phone_name(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_info_from_maker_plat_result_params::~mcp_get_phone_info_from_maker_plat_result_params(){
}
inline mcp_get_phone_info_from_maker_plat_result_params& mcp_get_phone_info_from_maker_plat_result_params::operator=(const mcp_get_phone_info_from_maker_plat_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_info_from_maker_plat_result_params::clear(){
// _m_phone_count=0;
_m_phone_id.clear();
_m_phone_name.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_info_from_maker_plat_result_params::check() const{
// @@uint32_t phone_count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_phone_count;

}
// @@string phone_id=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_id" << "' not found";
}
{
// level 0 begin
typeof(_m_phone_id)& lr0=(_m_phone_id);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@string phone_name=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_name" << "' not found";
}
{
// level 0 begin
typeof(_m_phone_name)& lr0=(_m_phone_name);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_info_from_maker_plat_result_params::detach(){
_m_phone_id.detach();
_m_phone_name.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_info_from_maker_plat_result_params& mcp_get_phone_info_from_maker_plat_result_params::assign(const mcp_get_phone_info_from_maker_plat_result_params& v){
_m_phone_count=v._m_phone_count;
_m_phone_id=v._m_phone_id;
_m_phone_name=v._m_phone_name;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_info_from_maker_plat_result_params::has_phone_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_phone_info_from_maker_plat_result_params::phone_count() const{
return _m_phone_count;
}
inline mcp_get_phone_info_from_maker_plat_result_params& mcp_get_phone_info_from_maker_plat_result_params::set_phone_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_phone_count=v;
return *this;
}
inline void mcp_get_phone_info_from_maker_plat_result_params::clear_phone_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_phone_count=0;
}
inline bool mcp_get_phone_info_from_maker_plat_result_params::has_phone_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_phone_info_from_maker_plat_result_params::phone_id() const{
 return _m_phone_id;
}
inline void mcp_get_phone_info_from_maker_plat_result_params::clear_phone_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_phone_id.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_info_from_maker_plat_result_params::mutable_phone_id(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_phone_id);
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_info_from_maker_plat_result_params::m_phone_id(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_phone_id);
}
inline size_t mcp_get_phone_info_from_maker_plat_result_params::phone_id_size() const{
/*  */ return _m_phone_id.size();
}
inline const char* mcp_get_phone_info_from_maker_plat_result_params::phone_id(size_t i0,unsigned int* size) const{
 return _m_phone_id.get(i0).get(size);
}
inline mcp_get_phone_info_from_maker_plat_result_params& mcp_get_phone_info_from_maker_plat_result_params::set_phone_id(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_phone_id.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_phone_info_from_maker_plat_result_params& mcp_get_phone_info_from_maker_plat_result_params::set_ptr_phone_id(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_phone_id.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool mcp_get_phone_info_from_maker_plat_result_params::has_phone_name() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_phone_info_from_maker_plat_result_params::phone_name() const{
 return _m_phone_name;
}
inline void mcp_get_phone_info_from_maker_plat_result_params::clear_phone_name(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_phone_name.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_info_from_maker_plat_result_params::mutable_phone_name(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_phone_name);
}
inline ::idl::vector< ::idl::string >* mcp_get_phone_info_from_maker_plat_result_params::m_phone_name(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_phone_name);
}
inline size_t mcp_get_phone_info_from_maker_plat_result_params::phone_name_size() const{
/*  */ return _m_phone_name.size();
}
inline const char* mcp_get_phone_info_from_maker_plat_result_params::phone_name(size_t i0,unsigned int* size) const{
 return _m_phone_name.get(i0).get(size);
}
inline mcp_get_phone_info_from_maker_plat_result_params& mcp_get_phone_info_from_maker_plat_result_params::set_phone_name(size_t i0,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_phone_name.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_phone_info_from_maker_plat_result_params& mcp_get_phone_info_from_maker_plat_result_params::set_ptr_phone_name(size_t i0,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_phone_name.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_phone_info_from_maker_plat_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_info_from_maker_plat_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_info_from_maker_plat_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_info_from_maker_plat_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_info_from_maker_plat_response* mcp_get_phone_info_from_maker_plat_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_info_from_maker_plat_response* tmp=(mcp_get_phone_info_from_maker_plat_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_info_from_maker_plat_response(pool);
return tmp;
}
inline void mcp_get_phone_info_from_maker_plat_response::destroy(mcp_get_phone_info_from_maker_plat_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_info_from_maker_plat_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_info_from_maker_plat_response::mcp_get_phone_info_from_maker_plat_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_info_from_maker_plat_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_info_from_maker_plat_response::mcp_get_phone_info_from_maker_plat_response(const mcp_get_phone_info_from_maker_plat_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_info_from_maker_plat_result_params::create(_pool);
assign(v);
}
inline mcp_get_phone_info_from_maker_plat_response::~mcp_get_phone_info_from_maker_plat_response(){
if(_m_result_params){
::idl::mcp_get_phone_info_from_maker_plat_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_phone_info_from_maker_plat_response& mcp_get_phone_info_from_maker_plat_response::operator=(const mcp_get_phone_info_from_maker_plat_response& v){
assign(v);
return *this;
}
inline void mcp_get_phone_info_from_maker_plat_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_info_from_maker_plat_response::check() const{
// @@mcp_get_phone_info_from_maker_plat_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_phone_info_from_maker_plat_result_params& item=const_cast< ::idl::mcp_get_phone_info_from_maker_plat_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_info_from_maker_plat_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_info_from_maker_plat_response& mcp_get_phone_info_from_maker_plat_response::assign(const mcp_get_phone_info_from_maker_plat_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_phone_info_from_maker_plat_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_info_from_maker_plat_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_info_from_maker_plat_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_phone_info_from_maker_plat_result_params& mcp_get_phone_info_from_maker_plat_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_phone_info_from_maker_plat_result_params* mcp_get_phone_info_from_maker_plat_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_info_from_maker_plat_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_phone_info_from_maker_plat_result_params* mcp_get_phone_info_from_maker_plat_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_info_from_maker_plat_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_phone_info_from_maker_plat_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_phone_info_from_maker_plat_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_info_from_maker_plat_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_info_from_maker_plat_response::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_info_from_maker_plat_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_url_info_by_id_params* mcp_get_url_info_by_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_url_info_by_id_params* tmp=(mcp_get_url_info_by_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_url_info_by_id_params(pool);
return tmp;
}
inline void mcp_get_url_info_by_id_params::destroy(mcp_get_url_info_by_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_url_info_by_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_url_info_by_id_params::mcp_get_url_info_by_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_url_info_by_id_params::mcp_get_url_info_by_id_params(const mcp_get_url_info_by_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_url_info_by_id_params::~mcp_get_url_info_by_id_params(){
}
inline mcp_get_url_info_by_id_params& mcp_get_url_info_by_id_params::operator=(const mcp_get_url_info_by_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_url_info_by_id_params::clear(){
_m_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_url_info_by_id_params::check() const{
// @@string id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_url_info_by_id_params::detach(){
_m_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_url_info_by_id_params& mcp_get_url_info_by_id_params::assign(const mcp_get_url_info_by_id_params& v){
_m_id=v._m_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_url_info_by_id_params::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_url_info_by_id_params::id(unsigned int* size) const{
return _m_id.get(size);
}
inline mcp_get_url_info_by_id_params& mcp_get_url_info_by_id_params::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_url_info_by_id_params& mcp_get_url_info_by_id_params::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_url_info_by_id_params::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline ::idl::Unknown* mcp_get_url_info_by_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_url_info_by_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_url_info_by_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_url_info_by_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_url_info_by_id_result_params* mcp_get_url_info_by_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_url_info_by_id_result_params* tmp=(mcp_get_url_info_by_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_url_info_by_id_result_params(pool);
return tmp;
}
inline void mcp_get_url_info_by_id_result_params::destroy(mcp_get_url_info_by_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_url_info_by_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_url_info_by_id_result_params::mcp_get_url_info_by_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_url_info(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_url_info_by_id_result_params::mcp_get_url_info_by_id_result_params(const mcp_get_url_info_by_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_url_info(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_url_info_by_id_result_params::~mcp_get_url_info_by_id_result_params(){
}
inline mcp_get_url_info_by_id_result_params& mcp_get_url_info_by_id_result_params::operator=(const mcp_get_url_info_by_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_url_info_by_id_result_params::clear(){
_m_url_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_url_info_by_id_result_params::check() const{
// @@string url_info=out(),array(0);
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "url_info" << "' not found";
}
{
// level 0 begin
typeof(_m_url_info)& lr0=(_m_url_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_url_info_by_id_result_params::detach(){
_m_url_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_url_info_by_id_result_params& mcp_get_url_info_by_id_result_params::assign(const mcp_get_url_info_by_id_result_params& v){
_m_url_info=v._m_url_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_url_info_by_id_result_params::has_url_info() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_url_info_by_id_result_params::url_info() const{
 return _m_url_info;
}
inline void mcp_get_url_info_by_id_result_params::clear_url_info(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_url_info.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_url_info_by_id_result_params::mutable_url_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_url_info);
}
inline ::idl::vector< ::idl::string >* mcp_get_url_info_by_id_result_params::m_url_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_url_info);
}
inline size_t mcp_get_url_info_by_id_result_params::url_info_size() const{
/*  */ return _m_url_info.size();
}
inline const char* mcp_get_url_info_by_id_result_params::url_info(size_t i0,unsigned int* size) const{
 return _m_url_info.get(i0).get(size);
}
inline mcp_get_url_info_by_id_result_params& mcp_get_url_info_by_id_result_params::set_url_info(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_url_info.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_url_info_by_id_result_params& mcp_get_url_info_by_id_result_params::set_ptr_url_info(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_url_info.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_url_info_by_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_url_info_by_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_url_info_by_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_url_info_by_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_url_info_by_id_response* mcp_get_url_info_by_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_url_info_by_id_response* tmp=(mcp_get_url_info_by_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_url_info_by_id_response(pool);
return tmp;
}
inline void mcp_get_url_info_by_id_response::destroy(mcp_get_url_info_by_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_url_info_by_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_url_info_by_id_response::mcp_get_url_info_by_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_url_info_by_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_url_info_by_id_response::mcp_get_url_info_by_id_response(const mcp_get_url_info_by_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_url_info_by_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_url_info_by_id_response::~mcp_get_url_info_by_id_response(){
if(_m_result_params){
::idl::mcp_get_url_info_by_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_url_info_by_id_response& mcp_get_url_info_by_id_response::operator=(const mcp_get_url_info_by_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_url_info_by_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_url_info_by_id_response::check() const{
// @@mcp_get_url_info_by_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_url_info_by_id_result_params& item=const_cast< ::idl::mcp_get_url_info_by_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_url_info_by_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_url_info_by_id_response& mcp_get_url_info_by_id_response::assign(const mcp_get_url_info_by_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_url_info_by_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_url_info_by_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_url_info_by_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_url_info_by_id_result_params& mcp_get_url_info_by_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_url_info_by_id_result_params* mcp_get_url_info_by_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_url_info_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_url_info_by_id_result_params* mcp_get_url_info_by_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_url_info_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_url_info_by_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_url_info_by_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_url_info_by_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_url_info_by_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_url_info_by_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_url_info_by_class_id_params* mcp_get_url_info_by_class_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_url_info_by_class_id_params* tmp=(mcp_get_url_info_by_class_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_url_info_by_class_id_params(pool);
return tmp;
}
inline void mcp_get_url_info_by_class_id_params::destroy(mcp_get_url_info_by_class_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_url_info_by_class_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_url_info_by_class_id_params::mcp_get_url_info_by_class_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_class_id(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_url_info_by_class_id_params::mcp_get_url_info_by_class_id_params(const mcp_get_url_info_by_class_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_class_id(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_url_info_by_class_id_params::~mcp_get_url_info_by_class_id_params(){
}
inline mcp_get_url_info_by_class_id_params& mcp_get_url_info_by_class_id_params::operator=(const mcp_get_url_info_by_class_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_url_info_by_class_id_params::clear(){
_m_class_id.clear();
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_url_info_by_class_id_params::check() const{
// @@string class_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_url_info_by_class_id_params::detach(){
_m_class_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_url_info_by_class_id_params& mcp_get_url_info_by_class_id_params::assign(const mcp_get_url_info_by_class_id_params& v){
_m_class_id=v._m_class_id;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_url_info_by_class_id_params::has_class_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_url_info_by_class_id_params::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_get_url_info_by_class_id_params& mcp_get_url_info_by_class_id_params::set_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_url_info_by_class_id_params& mcp_get_url_info_by_class_id_params::set_ptr_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_url_info_by_class_id_params::clear_class_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_class_id.clear();
}
inline bool mcp_get_url_info_by_class_id_params::has_unit_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_url_info_by_class_id_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_url_info_by_class_id_params& mcp_get_url_info_by_class_id_params::set_unit_num(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_url_info_by_class_id_params::clear_unit_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_url_info_by_class_id_params::has_unit_times() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_url_info_by_class_id_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_url_info_by_class_id_params& mcp_get_url_info_by_class_id_params::set_unit_times(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_url_info_by_class_id_params::clear_unit_times(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_url_info_by_class_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_url_info_by_class_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_url_info_by_class_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_url_info_by_class_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_url_info_by_class_id_result_params* mcp_get_url_info_by_class_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_url_info_by_class_id_result_params* tmp=(mcp_get_url_info_by_class_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_url_info_by_class_id_result_params(pool);
return tmp;
}
inline void mcp_get_url_info_by_class_id_result_params::destroy(mcp_get_url_info_by_class_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_url_info_by_class_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_url_info_by_class_id_result_params::mcp_get_url_info_by_class_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_url_info(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_url_info_by_class_id_result_params::mcp_get_url_info_by_class_id_result_params(const mcp_get_url_info_by_class_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_url_info(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_url_info_by_class_id_result_params::~mcp_get_url_info_by_class_id_result_params(){
}
inline mcp_get_url_info_by_class_id_result_params& mcp_get_url_info_by_class_id_result_params::operator=(const mcp_get_url_info_by_class_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_url_info_by_class_id_result_params::clear(){
// _m_count=0;
_m_url_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_url_info_by_class_id_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string url_info=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "url_info" << "' not found";
}
{
// level 0 begin
typeof(_m_url_info)& lr0=(_m_url_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_url_info_by_class_id_result_params::detach(){
_m_url_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_url_info_by_class_id_result_params& mcp_get_url_info_by_class_id_result_params::assign(const mcp_get_url_info_by_class_id_result_params& v){
_m_count=v._m_count;
_m_url_info=v._m_url_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_url_info_by_class_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_url_info_by_class_id_result_params::count() const{
return _m_count;
}
inline mcp_get_url_info_by_class_id_result_params& mcp_get_url_info_by_class_id_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_url_info_by_class_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_url_info_by_class_id_result_params::has_url_info() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_url_info_by_class_id_result_params::url_info() const{
 return _m_url_info;
}
inline void mcp_get_url_info_by_class_id_result_params::clear_url_info(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_url_info.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_url_info_by_class_id_result_params::mutable_url_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_url_info);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_url_info_by_class_id_result_params::m_url_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_url_info);
}
inline size_t mcp_get_url_info_by_class_id_result_params::url_info_size() const{
/*  */ return _m_url_info.size();
}
inline const char* mcp_get_url_info_by_class_id_result_params::url_info(size_t i0,size_t i1,unsigned int* size) const{
 return _m_url_info.get(i0).get(i1).get(size);
}
inline mcp_get_url_info_by_class_id_result_params& mcp_get_url_info_by_class_id_result_params::set_url_info(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_url_info.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_url_info_by_class_id_result_params& mcp_get_url_info_by_class_id_result_params::set_ptr_url_info(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_url_info.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_url_info_by_class_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_url_info_by_class_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_url_info_by_class_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_url_info_by_class_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_url_info_by_class_id_response* mcp_get_url_info_by_class_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_url_info_by_class_id_response* tmp=(mcp_get_url_info_by_class_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_url_info_by_class_id_response(pool);
return tmp;
}
inline void mcp_get_url_info_by_class_id_response::destroy(mcp_get_url_info_by_class_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_url_info_by_class_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_url_info_by_class_id_response::mcp_get_url_info_by_class_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_url_info_by_class_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_url_info_by_class_id_response::mcp_get_url_info_by_class_id_response(const mcp_get_url_info_by_class_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_url_info_by_class_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_url_info_by_class_id_response::~mcp_get_url_info_by_class_id_response(){
if(_m_result_params){
::idl::mcp_get_url_info_by_class_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_url_info_by_class_id_response& mcp_get_url_info_by_class_id_response::operator=(const mcp_get_url_info_by_class_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_url_info_by_class_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_url_info_by_class_id_response::check() const{
// @@mcp_get_url_info_by_class_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_url_info_by_class_id_result_params& item=const_cast< ::idl::mcp_get_url_info_by_class_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_url_info_by_class_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_url_info_by_class_id_response& mcp_get_url_info_by_class_id_response::assign(const mcp_get_url_info_by_class_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_url_info_by_class_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_url_info_by_class_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_url_info_by_class_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_url_info_by_class_id_result_params& mcp_get_url_info_by_class_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_url_info_by_class_id_result_params* mcp_get_url_info_by_class_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_url_info_by_class_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_url_info_by_class_id_result_params* mcp_get_url_info_by_class_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_url_info_by_class_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_url_info_by_class_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_url_info_by_class_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_url_info_by_class_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_url_info_by_class_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_url_info_by_class_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_url_info_by_column_id_params* mcp_get_url_info_by_column_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_url_info_by_column_id_params* tmp=(mcp_get_url_info_by_column_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_url_info_by_column_id_params(pool);
return tmp;
}
inline void mcp_get_url_info_by_column_id_params::destroy(mcp_get_url_info_by_column_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_url_info_by_column_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_url_info_by_column_id_params::mcp_get_url_info_by_column_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_column_id(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_url_info_by_column_id_params::mcp_get_url_info_by_column_id_params(const mcp_get_url_info_by_column_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_column_id(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_url_info_by_column_id_params::~mcp_get_url_info_by_column_id_params(){
}
inline mcp_get_url_info_by_column_id_params& mcp_get_url_info_by_column_id_params::operator=(const mcp_get_url_info_by_column_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_url_info_by_column_id_params::clear(){
_m_column_id.clear();
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_url_info_by_column_id_params::check() const{
// @@string column_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "column_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_column_id.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_url_info_by_column_id_params::detach(){
_m_column_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_url_info_by_column_id_params& mcp_get_url_info_by_column_id_params::assign(const mcp_get_url_info_by_column_id_params& v){
_m_column_id=v._m_column_id;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_url_info_by_column_id_params::has_column_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_url_info_by_column_id_params::column_id(unsigned int* size) const{
return _m_column_id.get(size);
}
inline mcp_get_url_info_by_column_id_params& mcp_get_url_info_by_column_id_params::set_column_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_column_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_url_info_by_column_id_params& mcp_get_url_info_by_column_id_params::set_ptr_column_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_column_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_url_info_by_column_id_params::clear_column_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_column_id.clear();
}
inline bool mcp_get_url_info_by_column_id_params::has_unit_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_url_info_by_column_id_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_url_info_by_column_id_params& mcp_get_url_info_by_column_id_params::set_unit_num(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_url_info_by_column_id_params::clear_unit_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_url_info_by_column_id_params::has_unit_times() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_url_info_by_column_id_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_url_info_by_column_id_params& mcp_get_url_info_by_column_id_params::set_unit_times(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_url_info_by_column_id_params::clear_unit_times(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_url_info_by_column_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_url_info_by_column_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_url_info_by_column_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_url_info_by_column_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_url_info_by_column_id_result_params* mcp_get_url_info_by_column_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_url_info_by_column_id_result_params* tmp=(mcp_get_url_info_by_column_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_url_info_by_column_id_result_params(pool);
return tmp;
}
inline void mcp_get_url_info_by_column_id_result_params::destroy(mcp_get_url_info_by_column_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_url_info_by_column_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_url_info_by_column_id_result_params::mcp_get_url_info_by_column_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_url_info(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_url_info_by_column_id_result_params::mcp_get_url_info_by_column_id_result_params(const mcp_get_url_info_by_column_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_url_info(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_url_info_by_column_id_result_params::~mcp_get_url_info_by_column_id_result_params(){
}
inline mcp_get_url_info_by_column_id_result_params& mcp_get_url_info_by_column_id_result_params::operator=(const mcp_get_url_info_by_column_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_url_info_by_column_id_result_params::clear(){
// _m_count=0;
_m_url_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_url_info_by_column_id_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string url_info=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "url_info" << "' not found";
}
{
// level 0 begin
typeof(_m_url_info)& lr0=(_m_url_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_url_info_by_column_id_result_params::detach(){
_m_url_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_url_info_by_column_id_result_params& mcp_get_url_info_by_column_id_result_params::assign(const mcp_get_url_info_by_column_id_result_params& v){
_m_count=v._m_count;
_m_url_info=v._m_url_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_url_info_by_column_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_url_info_by_column_id_result_params::count() const{
return _m_count;
}
inline mcp_get_url_info_by_column_id_result_params& mcp_get_url_info_by_column_id_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_url_info_by_column_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_url_info_by_column_id_result_params::has_url_info() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_url_info_by_column_id_result_params::url_info() const{
 return _m_url_info;
}
inline void mcp_get_url_info_by_column_id_result_params::clear_url_info(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_url_info.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_url_info_by_column_id_result_params::mutable_url_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_url_info);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_url_info_by_column_id_result_params::m_url_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_url_info);
}
inline size_t mcp_get_url_info_by_column_id_result_params::url_info_size() const{
/*  */ return _m_url_info.size();
}
inline const char* mcp_get_url_info_by_column_id_result_params::url_info(size_t i0,size_t i1,unsigned int* size) const{
 return _m_url_info.get(i0).get(i1).get(size);
}
inline mcp_get_url_info_by_column_id_result_params& mcp_get_url_info_by_column_id_result_params::set_url_info(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_url_info.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_url_info_by_column_id_result_params& mcp_get_url_info_by_column_id_result_params::set_ptr_url_info(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_url_info.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_url_info_by_column_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_url_info_by_column_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_url_info_by_column_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_url_info_by_column_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_url_info_by_column_id_response* mcp_get_url_info_by_column_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_url_info_by_column_id_response* tmp=(mcp_get_url_info_by_column_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_url_info_by_column_id_response(pool);
return tmp;
}
inline void mcp_get_url_info_by_column_id_response::destroy(mcp_get_url_info_by_column_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_url_info_by_column_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_url_info_by_column_id_response::mcp_get_url_info_by_column_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_url_info_by_column_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_url_info_by_column_id_response::mcp_get_url_info_by_column_id_response(const mcp_get_url_info_by_column_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_url_info_by_column_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_url_info_by_column_id_response::~mcp_get_url_info_by_column_id_response(){
if(_m_result_params){
::idl::mcp_get_url_info_by_column_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_url_info_by_column_id_response& mcp_get_url_info_by_column_id_response::operator=(const mcp_get_url_info_by_column_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_url_info_by_column_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_url_info_by_column_id_response::check() const{
// @@mcp_get_url_info_by_column_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_url_info_by_column_id_result_params& item=const_cast< ::idl::mcp_get_url_info_by_column_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_url_info_by_column_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_url_info_by_column_id_response& mcp_get_url_info_by_column_id_response::assign(const mcp_get_url_info_by_column_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_url_info_by_column_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_url_info_by_column_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_url_info_by_column_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_url_info_by_column_id_result_params& mcp_get_url_info_by_column_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_url_info_by_column_id_result_params* mcp_get_url_info_by_column_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_url_info_by_column_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_url_info_by_column_id_result_params* mcp_get_url_info_by_column_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_url_info_by_column_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_url_info_by_column_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_url_info_by_column_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_url_info_by_column_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_url_info_by_column_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_url_info_by_column_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_phone_params* mcp_get_content_list_from_phone_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_phone_params* tmp=(mcp_get_content_list_from_phone_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_phone_params(pool);
return tmp;
}
inline void mcp_get_content_list_from_phone_params::destroy(mcp_get_content_list_from_phone_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_phone_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_phone_params::mcp_get_content_list_from_phone_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_p_id(_pool)
,_m_priority(0)
,_m_type(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_phone_params::mcp_get_content_list_from_phone_params(const mcp_get_content_list_from_phone_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_p_id(_pool)
,_m_priority(0)
,_m_type(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_from_phone_params::~mcp_get_content_list_from_phone_params(){
}
inline mcp_get_content_list_from_phone_params& mcp_get_content_list_from_phone_params::operator=(const mcp_get_content_list_from_phone_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_phone_params::clear(){
_m_p_id.clear();
// _m_priority=0;
// _m_type=0;
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_phone_params::check() const{
// @@string p_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "p_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_p_id.get();

}
// @@uint32_t priority=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "priority" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_priority;

}
// @@uint32_t type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_type;

}
// @@uint32_t unit_num=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_phone_params::detach(){
_m_p_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_phone_params& mcp_get_content_list_from_phone_params::assign(const mcp_get_content_list_from_phone_params& v){
_m_p_id=v._m_p_id;
_m_priority=v._m_priority;
_m_type=v._m_type;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_phone_params::has_p_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_list_from_phone_params::p_id(unsigned int* size) const{
return _m_p_id.get(size);
}
inline mcp_get_content_list_from_phone_params& mcp_get_content_list_from_phone_params::set_p_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_p_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_phone_params& mcp_get_content_list_from_phone_params::set_ptr_p_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_p_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_phone_params::clear_p_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_p_id.clear();
}
inline bool mcp_get_content_list_from_phone_params::has_priority() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_phone_params::priority() const{
return _m_priority;
}
inline mcp_get_content_list_from_phone_params& mcp_get_content_list_from_phone_params::set_priority(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_priority=v;
return *this;
}
inline void mcp_get_content_list_from_phone_params::clear_priority(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_priority=0;
}
inline bool mcp_get_content_list_from_phone_params::has_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_phone_params::type() const{
return _m_type;
}
inline mcp_get_content_list_from_phone_params& mcp_get_content_list_from_phone_params::set_type(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_type=v;
return *this;
}
inline void mcp_get_content_list_from_phone_params::clear_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_type=0;
}
inline bool mcp_get_content_list_from_phone_params::has_unit_num() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_phone_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_content_list_from_phone_params& mcp_get_content_list_from_phone_params::set_unit_num(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_content_list_from_phone_params::clear_unit_num(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_content_list_from_phone_params::has_unit_times() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_phone_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_content_list_from_phone_params& mcp_get_content_list_from_phone_params::set_unit_times(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_content_list_from_phone_params::clear_unit_times(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_content_list_from_phone_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_phone_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_phone_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_phone_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_phone_result_params* mcp_get_content_list_from_phone_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_phone_result_params* tmp=(mcp_get_content_list_from_phone_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_phone_result_params(pool);
return tmp;
}
inline void mcp_get_content_list_from_phone_result_params::destroy(mcp_get_content_list_from_phone_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_phone_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_phone_result_params::mcp_get_content_list_from_phone_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_phone_result_params::mcp_get_content_list_from_phone_result_params(const mcp_get_content_list_from_phone_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_from_phone_result_params::~mcp_get_content_list_from_phone_result_params(){
}
inline mcp_get_content_list_from_phone_result_params& mcp_get_content_list_from_phone_result_params::operator=(const mcp_get_content_list_from_phone_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_phone_result_params::clear(){
// _m_count=0;
_m_content_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_phone_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string content_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_list" << "' not found";
}
{
// level 0 begin
typeof(_m_content_list)& lr0=(_m_content_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_phone_result_params::detach(){
_m_content_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_phone_result_params& mcp_get_content_list_from_phone_result_params::assign(const mcp_get_content_list_from_phone_result_params& v){
_m_count=v._m_count;
_m_content_list=v._m_content_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_phone_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_phone_result_params::count() const{
return _m_count;
}
inline mcp_get_content_list_from_phone_result_params& mcp_get_content_list_from_phone_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_content_list_from_phone_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_content_list_from_phone_result_params::has_content_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_content_list_from_phone_result_params::content_list() const{
 return _m_content_list;
}
inline void mcp_get_content_list_from_phone_result_params::clear_content_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_from_phone_result_params::mutable_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_from_phone_result_params::m_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline size_t mcp_get_content_list_from_phone_result_params::content_list_size() const{
/*  */ return _m_content_list.size();
}
inline const char* mcp_get_content_list_from_phone_result_params::content_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_content_list.get(i0).get(i1).get(size);
}
inline mcp_get_content_list_from_phone_result_params& mcp_get_content_list_from_phone_result_params::set_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_list_from_phone_result_params& mcp_get_content_list_from_phone_result_params::set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_list_from_phone_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_phone_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_phone_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_phone_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_phone_response* mcp_get_content_list_from_phone_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_phone_response* tmp=(mcp_get_content_list_from_phone_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_phone_response(pool);
return tmp;
}
inline void mcp_get_content_list_from_phone_response::destroy(mcp_get_content_list_from_phone_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_phone_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_phone_response::mcp_get_content_list_from_phone_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_from_phone_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_phone_response::mcp_get_content_list_from_phone_response(const mcp_get_content_list_from_phone_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_from_phone_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_list_from_phone_response::~mcp_get_content_list_from_phone_response(){
if(_m_result_params){
::idl::mcp_get_content_list_from_phone_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_list_from_phone_response& mcp_get_content_list_from_phone_response::operator=(const mcp_get_content_list_from_phone_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_phone_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_phone_response::check() const{
// @@mcp_get_content_list_from_phone_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_list_from_phone_result_params& item=const_cast< ::idl::mcp_get_content_list_from_phone_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_phone_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_phone_response& mcp_get_content_list_from_phone_response::assign(const mcp_get_content_list_from_phone_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_list_from_phone_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_phone_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_phone_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_list_from_phone_result_params& mcp_get_content_list_from_phone_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_list_from_phone_result_params* mcp_get_content_list_from_phone_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_phone_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_list_from_phone_result_params* mcp_get_content_list_from_phone_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_phone_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_list_from_phone_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_list_from_phone_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_phone_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_phone_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_phone_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_rank_params* mcp_get_content_list_by_rank_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_rank_params* tmp=(mcp_get_content_list_by_rank_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_rank_params(pool);
return tmp;
}
inline void mcp_get_content_list_by_rank_params::destroy(mcp_get_content_list_by_rank_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_rank_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_rank_params::mcp_get_content_list_by_rank_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_content_type(_pool)
,_m_class_id(_pool)
,_m_p_type(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_for_adapt(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_rank_params::mcp_get_content_list_by_rank_params(const mcp_get_content_list_by_rank_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_content_type(_pool)
,_m_class_id(_pool)
,_m_p_type(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_for_adapt(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_by_rank_params::~mcp_get_content_list_by_rank_params(){
}
inline mcp_get_content_list_by_rank_params& mcp_get_content_list_by_rank_params::operator=(const mcp_get_content_list_by_rank_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_rank_params::clear(){
_m_content_type.clear();
_m_class_id.clear();
// _m_p_type=0;
// _m_unit_num=0;
// _m_unit_times=0;
_m_info_id.clear();
// _m_info_type=0;
// _m_for_adapt=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_rank_params::check() const{
// @@string content_type=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_type.get();

}
// @@string class_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}
// @@uint32_t p_type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "p_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_p_type;

}
// @@uint32_t unit_num=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}
// @@string info_id=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@uint32_t info_type=in();
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_type;

}
// @@uint32_t for_adapt=in();
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "for_adapt" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_for_adapt;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_rank_params::detach(){
_m_content_type.detach();
_m_class_id.detach();
_m_info_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_rank_params& mcp_get_content_list_by_rank_params::assign(const mcp_get_content_list_by_rank_params& v){
_m_content_type=v._m_content_type;
_m_class_id=v._m_class_id;
_m_p_type=v._m_p_type;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_m_info_id=v._m_info_id;
_m_info_type=v._m_info_type;
_m_for_adapt=v._m_for_adapt;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_rank_params::has_content_type() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_list_by_rank_params::content_type(unsigned int* size) const{
return _m_content_type.get(size);
}
inline mcp_get_content_list_by_rank_params& mcp_get_content_list_by_rank_params::set_content_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_by_rank_params& mcp_get_content_list_by_rank_params::set_ptr_content_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_by_rank_params::clear_content_type(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_content_type.clear();
}
inline bool mcp_get_content_list_by_rank_params::has_class_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_content_list_by_rank_params::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_get_content_list_by_rank_params& mcp_get_content_list_by_rank_params::set_class_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_by_rank_params& mcp_get_content_list_by_rank_params::set_ptr_class_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_by_rank_params::clear_class_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_class_id.clear();
}
inline bool mcp_get_content_list_by_rank_params::has_p_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_rank_params::p_type() const{
return _m_p_type;
}
inline mcp_get_content_list_by_rank_params& mcp_get_content_list_by_rank_params::set_p_type(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_p_type=v;
return *this;
}
inline void mcp_get_content_list_by_rank_params::clear_p_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_p_type=0;
}
inline bool mcp_get_content_list_by_rank_params::has_unit_num() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_rank_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_content_list_by_rank_params& mcp_get_content_list_by_rank_params::set_unit_num(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_content_list_by_rank_params::clear_unit_num(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_content_list_by_rank_params::has_unit_times() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_rank_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_content_list_by_rank_params& mcp_get_content_list_by_rank_params::set_unit_times(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_content_list_by_rank_params::clear_unit_times(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_unit_times=0;
}
inline bool mcp_get_content_list_by_rank_params::has_info_id() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* mcp_get_content_list_by_rank_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_content_list_by_rank_params& mcp_get_content_list_by_rank_params::set_info_id(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_by_rank_params& mcp_get_content_list_by_rank_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_by_rank_params::clear_info_id(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_content_list_by_rank_params::has_info_type() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_rank_params::info_type() const{
return _m_info_type;
}
inline mcp_get_content_list_by_rank_params& mcp_get_content_list_by_rank_params::set_info_type(uint32_t v){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_info_type=v;
return *this;
}
inline void mcp_get_content_list_by_rank_params::clear_info_type(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_info_type=0;
}
inline bool mcp_get_content_list_by_rank_params::has_for_adapt() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_rank_params::for_adapt() const{
return _m_for_adapt;
}
inline mcp_get_content_list_by_rank_params& mcp_get_content_list_by_rank_params::set_for_adapt(uint32_t v){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_for_adapt=v;
return *this;
}
inline void mcp_get_content_list_by_rank_params::clear_for_adapt(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_for_adapt=0;
}
inline ::idl::Unknown* mcp_get_content_list_by_rank_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_rank_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_rank_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_rank_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_rank_result_params* mcp_get_content_list_by_rank_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_rank_result_params* tmp=(mcp_get_content_list_by_rank_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_rank_result_params(pool);
return tmp;
}
inline void mcp_get_content_list_by_rank_result_params::destroy(mcp_get_content_list_by_rank_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_rank_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_rank_result_params::mcp_get_content_list_by_rank_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_rank_result_params::mcp_get_content_list_by_rank_result_params(const mcp_get_content_list_by_rank_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_by_rank_result_params::~mcp_get_content_list_by_rank_result_params(){
}
inline mcp_get_content_list_by_rank_result_params& mcp_get_content_list_by_rank_result_params::operator=(const mcp_get_content_list_by_rank_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_rank_result_params::clear(){
// _m_count=0;
_m_content_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_rank_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string content_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_list" << "' not found";
}
{
// level 0 begin
typeof(_m_content_list)& lr0=(_m_content_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_rank_result_params::detach(){
_m_content_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_rank_result_params& mcp_get_content_list_by_rank_result_params::assign(const mcp_get_content_list_by_rank_result_params& v){
_m_count=v._m_count;
_m_content_list=v._m_content_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_rank_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_content_list_by_rank_result_params::count() const{
return _m_count;
}
inline mcp_get_content_list_by_rank_result_params& mcp_get_content_list_by_rank_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_content_list_by_rank_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_content_list_by_rank_result_params::has_content_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_content_list_by_rank_result_params::content_list() const{
 return _m_content_list;
}
inline void mcp_get_content_list_by_rank_result_params::clear_content_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_by_rank_result_params::mutable_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_by_rank_result_params::m_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline size_t mcp_get_content_list_by_rank_result_params::content_list_size() const{
/*  */ return _m_content_list.size();
}
inline const char* mcp_get_content_list_by_rank_result_params::content_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_content_list.get(i0).get(i1).get(size);
}
inline mcp_get_content_list_by_rank_result_params& mcp_get_content_list_by_rank_result_params::set_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_list_by_rank_result_params& mcp_get_content_list_by_rank_result_params::set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_list_by_rank_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_rank_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_rank_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_rank_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_rank_response* mcp_get_content_list_by_rank_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_rank_response* tmp=(mcp_get_content_list_by_rank_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_rank_response(pool);
return tmp;
}
inline void mcp_get_content_list_by_rank_response::destroy(mcp_get_content_list_by_rank_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_rank_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_rank_response::mcp_get_content_list_by_rank_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_by_rank_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_rank_response::mcp_get_content_list_by_rank_response(const mcp_get_content_list_by_rank_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_by_rank_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_list_by_rank_response::~mcp_get_content_list_by_rank_response(){
if(_m_result_params){
::idl::mcp_get_content_list_by_rank_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_list_by_rank_response& mcp_get_content_list_by_rank_response::operator=(const mcp_get_content_list_by_rank_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_rank_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_rank_response::check() const{
// @@mcp_get_content_list_by_rank_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_list_by_rank_result_params& item=const_cast< ::idl::mcp_get_content_list_by_rank_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_rank_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_rank_response& mcp_get_content_list_by_rank_response::assign(const mcp_get_content_list_by_rank_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_list_by_rank_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_rank_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_rank_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_list_by_rank_result_params& mcp_get_content_list_by_rank_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_list_by_rank_result_params* mcp_get_content_list_by_rank_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_rank_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_list_by_rank_result_params* mcp_get_content_list_by_rank_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_rank_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_list_by_rank_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_list_by_rank_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_rank_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_rank_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_rank_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_label_by_content_id_params* mcp_get_label_by_content_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_label_by_content_id_params* tmp=(mcp_get_label_by_content_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_label_by_content_id_params(pool);
return tmp;
}
inline void mcp_get_label_by_content_id_params::destroy(mcp_get_label_by_content_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_label_by_content_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_label_by_content_id_params::mcp_get_label_by_content_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_content_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_label_by_content_id_params::mcp_get_label_by_content_id_params(const mcp_get_label_by_content_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_content_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_label_by_content_id_params::~mcp_get_label_by_content_id_params(){
}
inline mcp_get_label_by_content_id_params& mcp_get_label_by_content_id_params::operator=(const mcp_get_label_by_content_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_label_by_content_id_params::clear(){
_m_content_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_label_by_content_id_params::check() const{
// @@string content_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_label_by_content_id_params::detach(){
_m_content_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_label_by_content_id_params& mcp_get_label_by_content_id_params::assign(const mcp_get_label_by_content_id_params& v){
_m_content_id=v._m_content_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_label_by_content_id_params::has_content_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_label_by_content_id_params::content_id(unsigned int* size) const{
return _m_content_id.get(size);
}
inline mcp_get_label_by_content_id_params& mcp_get_label_by_content_id_params::set_content_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_label_by_content_id_params& mcp_get_label_by_content_id_params::set_ptr_content_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_label_by_content_id_params::clear_content_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_content_id.clear();
}
inline ::idl::Unknown* mcp_get_label_by_content_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_label_by_content_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_label_by_content_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_label_by_content_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_label_by_content_id_result_params* mcp_get_label_by_content_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_label_by_content_id_result_params* tmp=(mcp_get_label_by_content_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_label_by_content_id_result_params(pool);
return tmp;
}
inline void mcp_get_label_by_content_id_result_params::destroy(mcp_get_label_by_content_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_label_by_content_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_label_by_content_id_result_params::mcp_get_label_by_content_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_label_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_label_by_content_id_result_params::mcp_get_label_by_content_id_result_params(const mcp_get_label_by_content_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_label_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_label_by_content_id_result_params::~mcp_get_label_by_content_id_result_params(){
}
inline mcp_get_label_by_content_id_result_params& mcp_get_label_by_content_id_result_params::operator=(const mcp_get_label_by_content_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_label_by_content_id_result_params::clear(){
// _m_result=0;
_m_label_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_label_by_content_id_result_params::check() const{
// @@uint32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_result;

}
// @@string label_list=out(),array(0,2);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "label_list" << "' not found";
}
{
// level 0 begin
typeof(_m_label_list)& lr0=(_m_label_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
if(size1>2){
throw ::idl::BreakConstraintException() << BSL_EARG << "array length '" << size1 << "' larger than idl constraint '2'";
}
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_label_by_content_id_result_params::detach(){
_m_label_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_label_by_content_id_result_params& mcp_get_label_by_content_id_result_params::assign(const mcp_get_label_by_content_id_result_params& v){
_m_result=v._m_result;
_m_label_list=v._m_label_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_label_by_content_id_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_label_by_content_id_result_params::result() const{
return _m_result;
}
inline mcp_get_label_by_content_id_result_params& mcp_get_label_by_content_id_result_params::set_result(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_get_label_by_content_id_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_get_label_by_content_id_result_params::has_label_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_label_by_content_id_result_params::label_list() const{
 return _m_label_list;
}
inline void mcp_get_label_by_content_id_result_params::clear_label_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_label_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_label_by_content_id_result_params::mutable_label_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_label_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_label_by_content_id_result_params::m_label_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_label_list);
}
inline size_t mcp_get_label_by_content_id_result_params::label_list_size() const{
/*  */ return _m_label_list.size();
}
inline const char* mcp_get_label_by_content_id_result_params::label_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_label_list.get(i0).get(i1).get(size);
}
inline mcp_get_label_by_content_id_result_params& mcp_get_label_by_content_id_result_params::set_label_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_label_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_label_by_content_id_result_params& mcp_get_label_by_content_id_result_params::set_ptr_label_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_label_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_label_by_content_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_label_by_content_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_label_by_content_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_label_by_content_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_label_by_content_id_response* mcp_get_label_by_content_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_label_by_content_id_response* tmp=(mcp_get_label_by_content_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_label_by_content_id_response(pool);
return tmp;
}
inline void mcp_get_label_by_content_id_response::destroy(mcp_get_label_by_content_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_label_by_content_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_label_by_content_id_response::mcp_get_label_by_content_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_label_by_content_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_label_by_content_id_response::mcp_get_label_by_content_id_response(const mcp_get_label_by_content_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_label_by_content_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_label_by_content_id_response::~mcp_get_label_by_content_id_response(){
if(_m_result_params){
::idl::mcp_get_label_by_content_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_label_by_content_id_response& mcp_get_label_by_content_id_response::operator=(const mcp_get_label_by_content_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_label_by_content_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_label_by_content_id_response::check() const{
// @@mcp_get_label_by_content_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_label_by_content_id_result_params& item=const_cast< ::idl::mcp_get_label_by_content_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_label_by_content_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_label_by_content_id_response& mcp_get_label_by_content_id_response::assign(const mcp_get_label_by_content_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_label_by_content_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_label_by_content_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_label_by_content_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_label_by_content_id_result_params& mcp_get_label_by_content_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_label_by_content_id_result_params* mcp_get_label_by_content_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_label_by_content_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_label_by_content_id_result_params* mcp_get_label_by_content_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_label_by_content_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_label_by_content_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_label_by_content_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_label_by_content_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_label_by_content_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_label_by_content_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_label_params* mcp_get_content_list_by_label_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_label_params* tmp=(mcp_get_content_list_by_label_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_label_params(pool);
return tmp;
}
inline void mcp_get_content_list_by_label_params::destroy(mcp_get_content_list_by_label_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_label_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_label_params::mcp_get_content_list_by_label_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_label_id(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_for_adapt(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_label_params::mcp_get_content_list_by_label_params(const mcp_get_content_list_by_label_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_label_id(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_for_adapt(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_by_label_params::~mcp_get_content_list_by_label_params(){
}
inline mcp_get_content_list_by_label_params& mcp_get_content_list_by_label_params::operator=(const mcp_get_content_list_by_label_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_label_params::clear(){
_m_label_id.clear();
// _m_unit_num=0;
// _m_unit_times=0;
_m_info_id.clear();
// _m_info_type=0;
// _m_for_adapt=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_label_params::check() const{
// @@string label_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "label_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_label_id.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}
// @@string info_id=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@uint32_t info_type=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_type;

}
// @@uint32_t for_adapt=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "for_adapt" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_for_adapt;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_label_params::detach(){
_m_label_id.detach();
_m_info_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_label_params& mcp_get_content_list_by_label_params::assign(const mcp_get_content_list_by_label_params& v){
_m_label_id=v._m_label_id;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_m_info_id=v._m_info_id;
_m_info_type=v._m_info_type;
_m_for_adapt=v._m_for_adapt;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_label_params::has_label_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_list_by_label_params::label_id(unsigned int* size) const{
return _m_label_id.get(size);
}
inline mcp_get_content_list_by_label_params& mcp_get_content_list_by_label_params::set_label_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_label_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_by_label_params& mcp_get_content_list_by_label_params::set_ptr_label_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_label_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_by_label_params::clear_label_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_label_id.clear();
}
inline bool mcp_get_content_list_by_label_params::has_unit_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_label_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_content_list_by_label_params& mcp_get_content_list_by_label_params::set_unit_num(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_content_list_by_label_params::clear_unit_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_content_list_by_label_params::has_unit_times() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_label_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_content_list_by_label_params& mcp_get_content_list_by_label_params::set_unit_times(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_content_list_by_label_params::clear_unit_times(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_unit_times=0;
}
inline bool mcp_get_content_list_by_label_params::has_info_id() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_content_list_by_label_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_content_list_by_label_params& mcp_get_content_list_by_label_params::set_info_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_by_label_params& mcp_get_content_list_by_label_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_by_label_params::clear_info_id(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_content_list_by_label_params::has_info_type() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_label_params::info_type() const{
return _m_info_type;
}
inline mcp_get_content_list_by_label_params& mcp_get_content_list_by_label_params::set_info_type(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_info_type=v;
return *this;
}
inline void mcp_get_content_list_by_label_params::clear_info_type(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_info_type=0;
}
inline bool mcp_get_content_list_by_label_params::has_for_adapt() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_label_params::for_adapt() const{
return _m_for_adapt;
}
inline mcp_get_content_list_by_label_params& mcp_get_content_list_by_label_params::set_for_adapt(uint32_t v){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_for_adapt=v;
return *this;
}
inline void mcp_get_content_list_by_label_params::clear_for_adapt(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_for_adapt=0;
}
inline ::idl::Unknown* mcp_get_content_list_by_label_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_label_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_label_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_label_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_label_result_params* mcp_get_content_list_by_label_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_label_result_params* tmp=(mcp_get_content_list_by_label_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_label_result_params(pool);
return tmp;
}
inline void mcp_get_content_list_by_label_result_params::destroy(mcp_get_content_list_by_label_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_label_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_label_result_params::mcp_get_content_list_by_label_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_label_result_params::mcp_get_content_list_by_label_result_params(const mcp_get_content_list_by_label_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_by_label_result_params::~mcp_get_content_list_by_label_result_params(){
}
inline mcp_get_content_list_by_label_result_params& mcp_get_content_list_by_label_result_params::operator=(const mcp_get_content_list_by_label_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_label_result_params::clear(){
// _m_count=0;
_m_content_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_label_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string content_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_list" << "' not found";
}
{
// level 0 begin
typeof(_m_content_list)& lr0=(_m_content_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_label_result_params::detach(){
_m_content_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_label_result_params& mcp_get_content_list_by_label_result_params::assign(const mcp_get_content_list_by_label_result_params& v){
_m_count=v._m_count;
_m_content_list=v._m_content_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_label_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_label_result_params::count() const{
return _m_count;
}
inline mcp_get_content_list_by_label_result_params& mcp_get_content_list_by_label_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_content_list_by_label_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_content_list_by_label_result_params::has_content_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_content_list_by_label_result_params::content_list() const{
 return _m_content_list;
}
inline void mcp_get_content_list_by_label_result_params::clear_content_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_by_label_result_params::mutable_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_by_label_result_params::m_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline size_t mcp_get_content_list_by_label_result_params::content_list_size() const{
/*  */ return _m_content_list.size();
}
inline const char* mcp_get_content_list_by_label_result_params::content_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_content_list.get(i0).get(i1).get(size);
}
inline mcp_get_content_list_by_label_result_params& mcp_get_content_list_by_label_result_params::set_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_list_by_label_result_params& mcp_get_content_list_by_label_result_params::set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_list_by_label_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_label_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_label_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_label_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_label_response* mcp_get_content_list_by_label_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_label_response* tmp=(mcp_get_content_list_by_label_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_label_response(pool);
return tmp;
}
inline void mcp_get_content_list_by_label_response::destroy(mcp_get_content_list_by_label_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_label_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_label_response::mcp_get_content_list_by_label_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_by_label_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_label_response::mcp_get_content_list_by_label_response(const mcp_get_content_list_by_label_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_by_label_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_list_by_label_response::~mcp_get_content_list_by_label_response(){
if(_m_result_params){
::idl::mcp_get_content_list_by_label_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_list_by_label_response& mcp_get_content_list_by_label_response::operator=(const mcp_get_content_list_by_label_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_label_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_label_response::check() const{
// @@mcp_get_content_list_by_label_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_list_by_label_result_params& item=const_cast< ::idl::mcp_get_content_list_by_label_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_label_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_label_response& mcp_get_content_list_by_label_response::assign(const mcp_get_content_list_by_label_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_list_by_label_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_label_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_label_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_list_by_label_result_params& mcp_get_content_list_by_label_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_list_by_label_result_params* mcp_get_content_list_by_label_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_label_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_list_by_label_result_params* mcp_get_content_list_by_label_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_label_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_list_by_label_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_list_by_label_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_label_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_label_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_label_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_topic_info_params* mcp_get_topic_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_topic_info_params* tmp=(mcp_get_topic_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_topic_info_params(pool);
return tmp;
}
inline void mcp_get_topic_info_params::destroy(mcp_get_topic_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_topic_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_topic_info_params::mcp_get_topic_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_content_type(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_topic_info_params::mcp_get_topic_info_params(const mcp_get_topic_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_content_type(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_topic_info_params::~mcp_get_topic_info_params(){
}
inline mcp_get_topic_info_params& mcp_get_topic_info_params::operator=(const mcp_get_topic_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_topic_info_params::clear(){
_m_content_type.clear();
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_topic_info_params::check() const{
// @@string content_type=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_type.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_topic_info_params::detach(){
_m_content_type.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_topic_info_params& mcp_get_topic_info_params::assign(const mcp_get_topic_info_params& v){
_m_content_type=v._m_content_type;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_topic_info_params::has_content_type() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_topic_info_params::content_type(unsigned int* size) const{
return _m_content_type.get(size);
}
inline mcp_get_topic_info_params& mcp_get_topic_info_params::set_content_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_topic_info_params& mcp_get_topic_info_params::set_ptr_content_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_topic_info_params::clear_content_type(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_content_type.clear();
}
inline bool mcp_get_topic_info_params::has_unit_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_topic_info_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_topic_info_params& mcp_get_topic_info_params::set_unit_num(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_topic_info_params::clear_unit_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_topic_info_params::has_unit_times() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_topic_info_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_topic_info_params& mcp_get_topic_info_params::set_unit_times(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_topic_info_params::clear_unit_times(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_topic_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_topic_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_topic_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_topic_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_topic_info_result_params* mcp_get_topic_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_topic_info_result_params* tmp=(mcp_get_topic_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_topic_info_result_params(pool);
return tmp;
}
inline void mcp_get_topic_info_result_params::destroy(mcp_get_topic_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_topic_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_topic_info_result_params::mcp_get_topic_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_topic_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_topic_info_result_params::mcp_get_topic_info_result_params(const mcp_get_topic_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_topic_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_topic_info_result_params::~mcp_get_topic_info_result_params(){
}
inline mcp_get_topic_info_result_params& mcp_get_topic_info_result_params::operator=(const mcp_get_topic_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_topic_info_result_params::clear(){
// _m_count=0;
_m_topic_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_topic_info_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string topic_list=out(),array(0,2);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "topic_list" << "' not found";
}
{
// level 0 begin
typeof(_m_topic_list)& lr0=(_m_topic_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
if(size1>2){
throw ::idl::BreakConstraintException() << BSL_EARG << "array length '" << size1 << "' larger than idl constraint '2'";
}
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_topic_info_result_params::detach(){
_m_topic_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_topic_info_result_params& mcp_get_topic_info_result_params::assign(const mcp_get_topic_info_result_params& v){
_m_count=v._m_count;
_m_topic_list=v._m_topic_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_topic_info_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_topic_info_result_params::count() const{
return _m_count;
}
inline mcp_get_topic_info_result_params& mcp_get_topic_info_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_topic_info_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_topic_info_result_params::has_topic_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_topic_info_result_params::topic_list() const{
 return _m_topic_list;
}
inline void mcp_get_topic_info_result_params::clear_topic_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_topic_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_topic_info_result_params::mutable_topic_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_topic_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_topic_info_result_params::m_topic_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_topic_list);
}
inline size_t mcp_get_topic_info_result_params::topic_list_size() const{
/*  */ return _m_topic_list.size();
}
inline const char* mcp_get_topic_info_result_params::topic_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_topic_list.get(i0).get(i1).get(size);
}
inline mcp_get_topic_info_result_params& mcp_get_topic_info_result_params::set_topic_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_topic_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_topic_info_result_params& mcp_get_topic_info_result_params::set_ptr_topic_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_topic_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_topic_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_topic_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_topic_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_topic_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_topic_info_response* mcp_get_topic_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_topic_info_response* tmp=(mcp_get_topic_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_topic_info_response(pool);
return tmp;
}
inline void mcp_get_topic_info_response::destroy(mcp_get_topic_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_topic_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_topic_info_response::mcp_get_topic_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_topic_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_topic_info_response::mcp_get_topic_info_response(const mcp_get_topic_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_topic_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_topic_info_response::~mcp_get_topic_info_response(){
if(_m_result_params){
::idl::mcp_get_topic_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_topic_info_response& mcp_get_topic_info_response::operator=(const mcp_get_topic_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_topic_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_topic_info_response::check() const{
// @@mcp_get_topic_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_topic_info_result_params& item=const_cast< ::idl::mcp_get_topic_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_topic_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_topic_info_response& mcp_get_topic_info_response::assign(const mcp_get_topic_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_topic_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_topic_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_topic_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_topic_info_result_params& mcp_get_topic_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_topic_info_result_params* mcp_get_topic_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_topic_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_topic_info_result_params* mcp_get_topic_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_topic_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_topic_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_topic_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_topic_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_topic_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_topic_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_count_by_class_params* mcp_get_content_count_by_class_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_count_by_class_params* tmp=(mcp_get_content_count_by_class_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_count_by_class_params(pool);
return tmp;
}
inline void mcp_get_content_count_by_class_params::destroy(mcp_get_content_count_by_class_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_count_by_class_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_count_by_class_params::mcp_get_content_count_by_class_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_class_id(_pool)
,_m_info_id(_pool)
,_m_info_type(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_count_by_class_params::mcp_get_content_count_by_class_params(const mcp_get_content_count_by_class_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_class_id(_pool)
,_m_info_id(_pool)
,_m_info_type(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_count_by_class_params::~mcp_get_content_count_by_class_params(){
}
inline mcp_get_content_count_by_class_params& mcp_get_content_count_by_class_params::operator=(const mcp_get_content_count_by_class_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_count_by_class_params::clear(){
_m_class_id.clear();
_m_info_id.clear();
// _m_info_type=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_count_by_class_params::check() const{
// @@string class_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}
// @@string info_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@uint32_t info_type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_type;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_count_by_class_params::detach(){
_m_class_id.detach();
_m_info_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_count_by_class_params& mcp_get_content_count_by_class_params::assign(const mcp_get_content_count_by_class_params& v){
_m_class_id=v._m_class_id;
_m_info_id=v._m_info_id;
_m_info_type=v._m_info_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_count_by_class_params::has_class_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_count_by_class_params::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_get_content_count_by_class_params& mcp_get_content_count_by_class_params::set_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_count_by_class_params& mcp_get_content_count_by_class_params::set_ptr_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_count_by_class_params::clear_class_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_class_id.clear();
}
inline bool mcp_get_content_count_by_class_params::has_info_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_content_count_by_class_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_content_count_by_class_params& mcp_get_content_count_by_class_params::set_info_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_count_by_class_params& mcp_get_content_count_by_class_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_count_by_class_params::clear_info_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_content_count_by_class_params::has_info_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_content_count_by_class_params::info_type() const{
return _m_info_type;
}
inline mcp_get_content_count_by_class_params& mcp_get_content_count_by_class_params::set_info_type(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_type=v;
return *this;
}
inline void mcp_get_content_count_by_class_params::clear_info_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_type=0;
}
inline ::idl::Unknown* mcp_get_content_count_by_class_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_count_by_class_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_count_by_class_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_count_by_class_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_count_by_class_result_params* mcp_get_content_count_by_class_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_count_by_class_result_params* tmp=(mcp_get_content_count_by_class_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_count_by_class_result_params(pool);
return tmp;
}
inline void mcp_get_content_count_by_class_result_params::destroy(mcp_get_content_count_by_class_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_count_by_class_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_count_by_class_result_params::mcp_get_content_count_by_class_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_count_by_class_result_params::mcp_get_content_count_by_class_result_params(const mcp_get_content_count_by_class_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_count_by_class_result_params::~mcp_get_content_count_by_class_result_params(){
}
inline mcp_get_content_count_by_class_result_params& mcp_get_content_count_by_class_result_params::operator=(const mcp_get_content_count_by_class_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_count_by_class_result_params::clear(){
_m_count.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_count_by_class_result_params::check() const{
// @@int32_t count=out(),array(0);
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
// level 0 begin
typeof(_m_count)& lr0=(_m_count);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) int32_t item=lr0.GetWithoutCheck(i0);

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_count_by_class_result_params::detach(){
_m_count.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_count_by_class_result_params& mcp_get_content_count_by_class_result_params::assign(const mcp_get_content_count_by_class_result_params& v){
_m_count=v._m_count;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_count_by_class_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::vector< int32_t >& mcp_get_content_count_by_class_result_params::count() const{
 return _m_count;
}
inline void mcp_get_content_count_by_class_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count.clear();
}
inline ::idl::vector< int32_t >* mcp_get_content_count_by_class_result_params::mutable_count(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_count);
}
inline ::idl::vector< int32_t >* mcp_get_content_count_by_class_result_params::m_count(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_count);
}
inline size_t mcp_get_content_count_by_class_result_params::count_size() const{
/*  */ return _m_count.size();
}
inline int32_t mcp_get_content_count_by_class_result_params::count(size_t i0) const{
 return _m_count.get(i0);
}
inline mcp_get_content_count_by_class_result_params& mcp_get_content_count_by_class_result_params::set_count(size_t i0,int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 *(_m_count.mutable_get(i0))=v;
return *this;
}
inline ::idl::Unknown* mcp_get_content_count_by_class_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_count_by_class_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_count_by_class_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_count_by_class_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_count_by_class_response* mcp_get_content_count_by_class_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_count_by_class_response* tmp=(mcp_get_content_count_by_class_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_count_by_class_response(pool);
return tmp;
}
inline void mcp_get_content_count_by_class_response::destroy(mcp_get_content_count_by_class_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_count_by_class_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_count_by_class_response::mcp_get_content_count_by_class_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_count_by_class_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_count_by_class_response::mcp_get_content_count_by_class_response(const mcp_get_content_count_by_class_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_count_by_class_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_count_by_class_response::~mcp_get_content_count_by_class_response(){
if(_m_result_params){
::idl::mcp_get_content_count_by_class_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_count_by_class_response& mcp_get_content_count_by_class_response::operator=(const mcp_get_content_count_by_class_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_count_by_class_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_count_by_class_response::check() const{
// @@mcp_get_content_count_by_class_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_count_by_class_result_params& item=const_cast< ::idl::mcp_get_content_count_by_class_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_count_by_class_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_count_by_class_response& mcp_get_content_count_by_class_response::assign(const mcp_get_content_count_by_class_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_count_by_class_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_count_by_class_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_count_by_class_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_count_by_class_result_params& mcp_get_content_count_by_class_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_count_by_class_result_params* mcp_get_content_count_by_class_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_count_by_class_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_count_by_class_result_params* mcp_get_content_count_by_class_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_count_by_class_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_count_by_class_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_count_by_class_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_count_by_class_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_count_by_class_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_count_by_class_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_img_params* mcp_get_content_img_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_img_params* tmp=(mcp_get_content_img_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_img_params(pool);
return tmp;
}
inline void mcp_get_content_img_params::destroy(mcp_get_content_img_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_img_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_img_params::mcp_get_content_img_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_content_id(_pool)
,_m_img_type(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_img_params::mcp_get_content_img_params(const mcp_get_content_img_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_content_id(_pool)
,_m_img_type(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_img_params::~mcp_get_content_img_params(){
}
inline mcp_get_content_img_params& mcp_get_content_img_params::operator=(const mcp_get_content_img_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_img_params::clear(){
_m_content_id.clear();
// _m_img_type=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_img_params::check() const{
// @@string content_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_id.get();

}
// @@uint32_t img_type=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "img_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_img_type;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_img_params::detach(){
_m_content_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_img_params& mcp_get_content_img_params::assign(const mcp_get_content_img_params& v){
_m_content_id=v._m_content_id;
_m_img_type=v._m_img_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_img_params::has_content_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_img_params::content_id(unsigned int* size) const{
return _m_content_id.get(size);
}
inline mcp_get_content_img_params& mcp_get_content_img_params::set_content_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_img_params& mcp_get_content_img_params::set_ptr_content_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_img_params::clear_content_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_content_id.clear();
}
inline bool mcp_get_content_img_params::has_img_type() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_content_img_params::img_type() const{
return _m_img_type;
}
inline mcp_get_content_img_params& mcp_get_content_img_params::set_img_type(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_img_type=v;
return *this;
}
inline void mcp_get_content_img_params::clear_img_type(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_img_type=0;
}
inline ::idl::Unknown* mcp_get_content_img_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_img_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_img_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_img_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_img_result_params* mcp_get_content_img_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_img_result_params* tmp=(mcp_get_content_img_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_img_result_params(pool);
return tmp;
}
inline void mcp_get_content_img_result_params::destroy(mcp_get_content_img_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_img_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_img_result_params::mcp_get_content_img_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_img_url(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_img_result_params::mcp_get_content_img_result_params(const mcp_get_content_img_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_img_url(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_img_result_params::~mcp_get_content_img_result_params(){
}
inline mcp_get_content_img_result_params& mcp_get_content_img_result_params::operator=(const mcp_get_content_img_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_img_result_params::clear(){
// _m_count=0;
_m_img_url.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_img_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string img_url=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "img_url" << "' not found";
}
{
// level 0 begin
typeof(_m_img_url)& lr0=(_m_img_url);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_img_result_params::detach(){
_m_img_url.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_img_result_params& mcp_get_content_img_result_params::assign(const mcp_get_content_img_result_params& v){
_m_count=v._m_count;
_m_img_url=v._m_img_url;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_img_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_content_img_result_params::count() const{
return _m_count;
}
inline mcp_get_content_img_result_params& mcp_get_content_img_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_content_img_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_content_img_result_params::has_img_url() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_content_img_result_params::img_url() const{
 return _m_img_url;
}
inline void mcp_get_content_img_result_params::clear_img_url(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_img_url.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_content_img_result_params::mutable_img_url(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_img_url);
}
inline ::idl::vector< ::idl::string >* mcp_get_content_img_result_params::m_img_url(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_img_url);
}
inline size_t mcp_get_content_img_result_params::img_url_size() const{
/*  */ return _m_img_url.size();
}
inline const char* mcp_get_content_img_result_params::img_url(size_t i0,unsigned int* size) const{
 return _m_img_url.get(i0).get(size);
}
inline mcp_get_content_img_result_params& mcp_get_content_img_result_params::set_img_url(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_img_url.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_img_result_params& mcp_get_content_img_result_params::set_ptr_img_url(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_img_url.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_img_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_img_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_img_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_img_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_img_response* mcp_get_content_img_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_img_response* tmp=(mcp_get_content_img_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_img_response(pool);
return tmp;
}
inline void mcp_get_content_img_response::destroy(mcp_get_content_img_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_img_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_img_response::mcp_get_content_img_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_img_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_img_response::mcp_get_content_img_response(const mcp_get_content_img_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_img_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_img_response::~mcp_get_content_img_response(){
if(_m_result_params){
::idl::mcp_get_content_img_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_img_response& mcp_get_content_img_response::operator=(const mcp_get_content_img_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_img_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_img_response::check() const{
// @@mcp_get_content_img_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_img_result_params& item=const_cast< ::idl::mcp_get_content_img_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_img_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_img_response& mcp_get_content_img_response::assign(const mcp_get_content_img_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_img_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_img_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_img_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_img_result_params& mcp_get_content_img_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_img_result_params* mcp_get_content_img_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_img_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_img_result_params* mcp_get_content_img_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_img_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_img_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_img_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_img_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_img_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_img_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_label_name_by_id_params* mcp_get_label_name_by_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_label_name_by_id_params* tmp=(mcp_get_label_name_by_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_label_name_by_id_params(pool);
return tmp;
}
inline void mcp_get_label_name_by_id_params::destroy(mcp_get_label_name_by_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_label_name_by_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_label_name_by_id_params::mcp_get_label_name_by_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_label_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_label_name_by_id_params::mcp_get_label_name_by_id_params(const mcp_get_label_name_by_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_label_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_label_name_by_id_params::~mcp_get_label_name_by_id_params(){
}
inline mcp_get_label_name_by_id_params& mcp_get_label_name_by_id_params::operator=(const mcp_get_label_name_by_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_label_name_by_id_params::clear(){
_m_label_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_label_name_by_id_params::check() const{
// @@string label_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "label_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_label_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_label_name_by_id_params::detach(){
_m_label_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_label_name_by_id_params& mcp_get_label_name_by_id_params::assign(const mcp_get_label_name_by_id_params& v){
_m_label_id=v._m_label_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_label_name_by_id_params::has_label_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_label_name_by_id_params::label_id(unsigned int* size) const{
return _m_label_id.get(size);
}
inline mcp_get_label_name_by_id_params& mcp_get_label_name_by_id_params::set_label_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_label_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_label_name_by_id_params& mcp_get_label_name_by_id_params::set_ptr_label_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_label_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_label_name_by_id_params::clear_label_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_label_id.clear();
}
inline ::idl::Unknown* mcp_get_label_name_by_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_label_name_by_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_label_name_by_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_label_name_by_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_label_name_by_id_result_params* mcp_get_label_name_by_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_label_name_by_id_result_params* tmp=(mcp_get_label_name_by_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_label_name_by_id_result_params(pool);
return tmp;
}
inline void mcp_get_label_name_by_id_result_params::destroy(mcp_get_label_name_by_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_label_name_by_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_label_name_by_id_result_params::mcp_get_label_name_by_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_label_name(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_label_name_by_id_result_params::mcp_get_label_name_by_id_result_params(const mcp_get_label_name_by_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_label_name(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_label_name_by_id_result_params::~mcp_get_label_name_by_id_result_params(){
}
inline mcp_get_label_name_by_id_result_params& mcp_get_label_name_by_id_result_params::operator=(const mcp_get_label_name_by_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_label_name_by_id_result_params::clear(){
_m_label_name.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_label_name_by_id_result_params::check() const{
// @@string label_name=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "label_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_label_name.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_label_name_by_id_result_params::detach(){
_m_label_name.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_label_name_by_id_result_params& mcp_get_label_name_by_id_result_params::assign(const mcp_get_label_name_by_id_result_params& v){
_m_label_name=v._m_label_name;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_label_name_by_id_result_params::has_label_name() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_label_name_by_id_result_params::label_name(unsigned int* size) const{
return _m_label_name.get(size);
}
inline mcp_get_label_name_by_id_result_params& mcp_get_label_name_by_id_result_params::set_label_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_label_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_label_name_by_id_result_params& mcp_get_label_name_by_id_result_params::set_ptr_label_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_label_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_label_name_by_id_result_params::clear_label_name(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_label_name.clear();
}
inline ::idl::Unknown* mcp_get_label_name_by_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_label_name_by_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_label_name_by_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_label_name_by_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_label_name_by_id_response* mcp_get_label_name_by_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_label_name_by_id_response* tmp=(mcp_get_label_name_by_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_label_name_by_id_response(pool);
return tmp;
}
inline void mcp_get_label_name_by_id_response::destroy(mcp_get_label_name_by_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_label_name_by_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_label_name_by_id_response::mcp_get_label_name_by_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_label_name_by_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_label_name_by_id_response::mcp_get_label_name_by_id_response(const mcp_get_label_name_by_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_label_name_by_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_label_name_by_id_response::~mcp_get_label_name_by_id_response(){
if(_m_result_params){
::idl::mcp_get_label_name_by_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_label_name_by_id_response& mcp_get_label_name_by_id_response::operator=(const mcp_get_label_name_by_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_label_name_by_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_label_name_by_id_response::check() const{
// @@mcp_get_label_name_by_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_label_name_by_id_result_params& item=const_cast< ::idl::mcp_get_label_name_by_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_label_name_by_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_label_name_by_id_response& mcp_get_label_name_by_id_response::assign(const mcp_get_label_name_by_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_label_name_by_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_label_name_by_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_label_name_by_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_label_name_by_id_result_params& mcp_get_label_name_by_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_label_name_by_id_result_params* mcp_get_label_name_by_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_label_name_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_label_name_by_id_result_params* mcp_get_label_name_by_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_label_name_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_label_name_by_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_label_name_by_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_label_name_by_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_label_name_by_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_label_name_by_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_date_params* mcp_get_content_list_by_date_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_date_params* tmp=(mcp_get_content_list_by_date_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_date_params(pool);
return tmp;
}
inline void mcp_get_content_list_by_date_params::destroy(mcp_get_content_list_by_date_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_date_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_date_params::mcp_get_content_list_by_date_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_content_type(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_for_adapt(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_date_params::mcp_get_content_list_by_date_params(const mcp_get_content_list_by_date_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_content_type(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_for_adapt(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_by_date_params::~mcp_get_content_list_by_date_params(){
}
inline mcp_get_content_list_by_date_params& mcp_get_content_list_by_date_params::operator=(const mcp_get_content_list_by_date_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_date_params::clear(){
_m_content_type.clear();
// _m_unit_num=0;
// _m_unit_times=0;
_m_info_id.clear();
// _m_info_type=0;
// _m_for_adapt=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_date_params::check() const{
// @@string content_type=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_type.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}
// @@string info_id=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@uint32_t info_type=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_type;

}
// @@uint32_t for_adapt=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "for_adapt" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_for_adapt;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_date_params::detach(){
_m_content_type.detach();
_m_info_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_date_params& mcp_get_content_list_by_date_params::assign(const mcp_get_content_list_by_date_params& v){
_m_content_type=v._m_content_type;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_m_info_id=v._m_info_id;
_m_info_type=v._m_info_type;
_m_for_adapt=v._m_for_adapt;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_date_params::has_content_type() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_list_by_date_params::content_type(unsigned int* size) const{
return _m_content_type.get(size);
}
inline mcp_get_content_list_by_date_params& mcp_get_content_list_by_date_params::set_content_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_by_date_params& mcp_get_content_list_by_date_params::set_ptr_content_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_content_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_by_date_params::clear_content_type(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_content_type.clear();
}
inline bool mcp_get_content_list_by_date_params::has_unit_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_date_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_content_list_by_date_params& mcp_get_content_list_by_date_params::set_unit_num(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_content_list_by_date_params::clear_unit_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_content_list_by_date_params::has_unit_times() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_date_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_content_list_by_date_params& mcp_get_content_list_by_date_params::set_unit_times(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_content_list_by_date_params::clear_unit_times(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_unit_times=0;
}
inline bool mcp_get_content_list_by_date_params::has_info_id() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_content_list_by_date_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_content_list_by_date_params& mcp_get_content_list_by_date_params::set_info_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_by_date_params& mcp_get_content_list_by_date_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_by_date_params::clear_info_id(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_content_list_by_date_params::has_info_type() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_date_params::info_type() const{
return _m_info_type;
}
inline mcp_get_content_list_by_date_params& mcp_get_content_list_by_date_params::set_info_type(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_info_type=v;
return *this;
}
inline void mcp_get_content_list_by_date_params::clear_info_type(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_info_type=0;
}
inline bool mcp_get_content_list_by_date_params::has_for_adapt() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_date_params::for_adapt() const{
return _m_for_adapt;
}
inline mcp_get_content_list_by_date_params& mcp_get_content_list_by_date_params::set_for_adapt(uint32_t v){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_for_adapt=v;
return *this;
}
inline void mcp_get_content_list_by_date_params::clear_for_adapt(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_for_adapt=0;
}
inline ::idl::Unknown* mcp_get_content_list_by_date_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_date_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_date_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_date_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_date_result_params* mcp_get_content_list_by_date_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_date_result_params* tmp=(mcp_get_content_list_by_date_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_date_result_params(pool);
return tmp;
}
inline void mcp_get_content_list_by_date_result_params::destroy(mcp_get_content_list_by_date_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_date_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_date_result_params::mcp_get_content_list_by_date_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_content_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_date_result_params::mcp_get_content_list_by_date_result_params(const mcp_get_content_list_by_date_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_content_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_by_date_result_params::~mcp_get_content_list_by_date_result_params(){
}
inline mcp_get_content_list_by_date_result_params& mcp_get_content_list_by_date_result_params::operator=(const mcp_get_content_list_by_date_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_date_result_params::clear(){
// _m_result=0;
_m_content_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_date_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}
// @@string content_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_list" << "' not found";
}
{
// level 0 begin
typeof(_m_content_list)& lr0=(_m_content_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_date_result_params::detach(){
_m_content_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_date_result_params& mcp_get_content_list_by_date_result_params::assign(const mcp_get_content_list_by_date_result_params& v){
_m_result=v._m_result;
_m_content_list=v._m_content_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_date_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_content_list_by_date_result_params::result() const{
return _m_result;
}
inline mcp_get_content_list_by_date_result_params& mcp_get_content_list_by_date_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_get_content_list_by_date_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_get_content_list_by_date_result_params::has_content_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_content_list_by_date_result_params::content_list() const{
 return _m_content_list;
}
inline void mcp_get_content_list_by_date_result_params::clear_content_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_by_date_result_params::mutable_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_by_date_result_params::m_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline size_t mcp_get_content_list_by_date_result_params::content_list_size() const{
/*  */ return _m_content_list.size();
}
inline const char* mcp_get_content_list_by_date_result_params::content_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_content_list.get(i0).get(i1).get(size);
}
inline mcp_get_content_list_by_date_result_params& mcp_get_content_list_by_date_result_params::set_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_list_by_date_result_params& mcp_get_content_list_by_date_result_params::set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_list_by_date_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_date_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_date_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_date_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_date_response* mcp_get_content_list_by_date_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_date_response* tmp=(mcp_get_content_list_by_date_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_date_response(pool);
return tmp;
}
inline void mcp_get_content_list_by_date_response::destroy(mcp_get_content_list_by_date_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_date_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_date_response::mcp_get_content_list_by_date_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_by_date_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_date_response::mcp_get_content_list_by_date_response(const mcp_get_content_list_by_date_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_by_date_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_list_by_date_response::~mcp_get_content_list_by_date_response(){
if(_m_result_params){
::idl::mcp_get_content_list_by_date_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_list_by_date_response& mcp_get_content_list_by_date_response::operator=(const mcp_get_content_list_by_date_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_date_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_date_response::check() const{
// @@mcp_get_content_list_by_date_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_list_by_date_result_params& item=const_cast< ::idl::mcp_get_content_list_by_date_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_date_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_date_response& mcp_get_content_list_by_date_response::assign(const mcp_get_content_list_by_date_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_list_by_date_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_date_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_date_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_list_by_date_result_params& mcp_get_content_list_by_date_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_list_by_date_result_params* mcp_get_content_list_by_date_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_date_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_list_by_date_result_params* mcp_get_content_list_by_date_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_date_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_list_by_date_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_list_by_date_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_date_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_date_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_date_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_soft_info_by_id_params* mcp_get_soft_info_by_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_soft_info_by_id_params* tmp=(mcp_get_soft_info_by_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_soft_info_by_id_params(pool);
return tmp;
}
inline void mcp_get_soft_info_by_id_params::destroy(mcp_get_soft_info_by_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_soft_info_by_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_soft_info_by_id_params::mcp_get_soft_info_by_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_soft_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_soft_info_by_id_params::mcp_get_soft_info_by_id_params(const mcp_get_soft_info_by_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_soft_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_soft_info_by_id_params::~mcp_get_soft_info_by_id_params(){
}
inline mcp_get_soft_info_by_id_params& mcp_get_soft_info_by_id_params::operator=(const mcp_get_soft_info_by_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_soft_info_by_id_params::clear(){
_m_soft_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_soft_info_by_id_params::check() const{
// @@string soft_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "soft_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_soft_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_soft_info_by_id_params::detach(){
_m_soft_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_soft_info_by_id_params& mcp_get_soft_info_by_id_params::assign(const mcp_get_soft_info_by_id_params& v){
_m_soft_id=v._m_soft_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_soft_info_by_id_params::has_soft_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_soft_info_by_id_params::soft_id(unsigned int* size) const{
return _m_soft_id.get(size);
}
inline mcp_get_soft_info_by_id_params& mcp_get_soft_info_by_id_params::set_soft_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_soft_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_soft_info_by_id_params& mcp_get_soft_info_by_id_params::set_ptr_soft_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_soft_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_soft_info_by_id_params::clear_soft_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_soft_id.clear();
}
inline ::idl::Unknown* mcp_get_soft_info_by_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_soft_info_by_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_soft_info_by_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_soft_info_by_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_soft_info_by_id_result_params* mcp_get_soft_info_by_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_soft_info_by_id_result_params* tmp=(mcp_get_soft_info_by_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_soft_info_by_id_result_params(pool);
return tmp;
}
inline void mcp_get_soft_info_by_id_result_params::destroy(mcp_get_soft_info_by_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_soft_info_by_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_soft_info_by_id_result_params::mcp_get_soft_info_by_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_soft_info(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_soft_info_by_id_result_params::mcp_get_soft_info_by_id_result_params(const mcp_get_soft_info_by_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_soft_info(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_soft_info_by_id_result_params::~mcp_get_soft_info_by_id_result_params(){
}
inline mcp_get_soft_info_by_id_result_params& mcp_get_soft_info_by_id_result_params::operator=(const mcp_get_soft_info_by_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_soft_info_by_id_result_params::clear(){
// _m_result=0;
_m_soft_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_soft_info_by_id_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}
// @@string soft_info=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "soft_info" << "' not found";
}
{
// level 0 begin
typeof(_m_soft_info)& lr0=(_m_soft_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_soft_info_by_id_result_params::detach(){
_m_soft_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_soft_info_by_id_result_params& mcp_get_soft_info_by_id_result_params::assign(const mcp_get_soft_info_by_id_result_params& v){
_m_result=v._m_result;
_m_soft_info=v._m_soft_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_soft_info_by_id_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_soft_info_by_id_result_params::result() const{
return _m_result;
}
inline mcp_get_soft_info_by_id_result_params& mcp_get_soft_info_by_id_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_get_soft_info_by_id_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_get_soft_info_by_id_result_params::has_soft_info() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_soft_info_by_id_result_params::soft_info() const{
 return _m_soft_info;
}
inline void mcp_get_soft_info_by_id_result_params::clear_soft_info(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_soft_info.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_soft_info_by_id_result_params::mutable_soft_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_soft_info);
}
inline ::idl::vector< ::idl::string >* mcp_get_soft_info_by_id_result_params::m_soft_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_soft_info);
}
inline size_t mcp_get_soft_info_by_id_result_params::soft_info_size() const{
/*  */ return _m_soft_info.size();
}
inline const char* mcp_get_soft_info_by_id_result_params::soft_info(size_t i0,unsigned int* size) const{
 return _m_soft_info.get(i0).get(size);
}
inline mcp_get_soft_info_by_id_result_params& mcp_get_soft_info_by_id_result_params::set_soft_info(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_soft_info.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_soft_info_by_id_result_params& mcp_get_soft_info_by_id_result_params::set_ptr_soft_info(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_soft_info.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_soft_info_by_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_soft_info_by_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_soft_info_by_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_soft_info_by_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_soft_info_by_id_response* mcp_get_soft_info_by_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_soft_info_by_id_response* tmp=(mcp_get_soft_info_by_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_soft_info_by_id_response(pool);
return tmp;
}
inline void mcp_get_soft_info_by_id_response::destroy(mcp_get_soft_info_by_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_soft_info_by_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_soft_info_by_id_response::mcp_get_soft_info_by_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_soft_info_by_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_soft_info_by_id_response::mcp_get_soft_info_by_id_response(const mcp_get_soft_info_by_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_soft_info_by_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_soft_info_by_id_response::~mcp_get_soft_info_by_id_response(){
if(_m_result_params){
::idl::mcp_get_soft_info_by_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_soft_info_by_id_response& mcp_get_soft_info_by_id_response::operator=(const mcp_get_soft_info_by_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_soft_info_by_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_soft_info_by_id_response::check() const{
// @@mcp_get_soft_info_by_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_soft_info_by_id_result_params& item=const_cast< ::idl::mcp_get_soft_info_by_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_soft_info_by_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_soft_info_by_id_response& mcp_get_soft_info_by_id_response::assign(const mcp_get_soft_info_by_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_soft_info_by_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_soft_info_by_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_soft_info_by_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_soft_info_by_id_result_params& mcp_get_soft_info_by_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_soft_info_by_id_result_params* mcp_get_soft_info_by_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_soft_info_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_soft_info_by_id_result_params* mcp_get_soft_info_by_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_soft_info_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_soft_info_by_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_soft_info_by_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_soft_info_by_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_soft_info_by_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_soft_info_by_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_android_theme_by_id_params* mcp_get_android_theme_by_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_android_theme_by_id_params* tmp=(mcp_get_android_theme_by_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_android_theme_by_id_params(pool);
return tmp;
}
inline void mcp_get_android_theme_by_id_params::destroy(mcp_get_android_theme_by_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_android_theme_by_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_android_theme_by_id_params::mcp_get_android_theme_by_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_android_theme_by_id_params::mcp_get_android_theme_by_id_params(const mcp_get_android_theme_by_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_android_theme_by_id_params::~mcp_get_android_theme_by_id_params(){
}
inline mcp_get_android_theme_by_id_params& mcp_get_android_theme_by_id_params::operator=(const mcp_get_android_theme_by_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_android_theme_by_id_params::clear(){
_m_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_android_theme_by_id_params::check() const{
// @@string id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_android_theme_by_id_params::detach(){
_m_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_android_theme_by_id_params& mcp_get_android_theme_by_id_params::assign(const mcp_get_android_theme_by_id_params& v){
_m_id=v._m_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_android_theme_by_id_params::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_android_theme_by_id_params::id(unsigned int* size) const{
return _m_id.get(size);
}
inline mcp_get_android_theme_by_id_params& mcp_get_android_theme_by_id_params::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_android_theme_by_id_params& mcp_get_android_theme_by_id_params::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_android_theme_by_id_params::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline ::idl::Unknown* mcp_get_android_theme_by_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_android_theme_by_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_android_theme_by_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_android_theme_by_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_android_theme_by_id_result_params* mcp_get_android_theme_by_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_android_theme_by_id_result_params* tmp=(mcp_get_android_theme_by_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_android_theme_by_id_result_params(pool);
return tmp;
}
inline void mcp_get_android_theme_by_id_result_params::destroy(mcp_get_android_theme_by_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_android_theme_by_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_android_theme_by_id_result_params::mcp_get_android_theme_by_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_info(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_android_theme_by_id_result_params::mcp_get_android_theme_by_id_result_params(const mcp_get_android_theme_by_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_info(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_android_theme_by_id_result_params::~mcp_get_android_theme_by_id_result_params(){
}
inline mcp_get_android_theme_by_id_result_params& mcp_get_android_theme_by_id_result_params::operator=(const mcp_get_android_theme_by_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_android_theme_by_id_result_params::clear(){
// _m_result=0;
_m_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_android_theme_by_id_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}
// @@string info=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info" << "' not found";
}
{
// level 0 begin
typeof(_m_info)& lr0=(_m_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_android_theme_by_id_result_params::detach(){
_m_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_android_theme_by_id_result_params& mcp_get_android_theme_by_id_result_params::assign(const mcp_get_android_theme_by_id_result_params& v){
_m_result=v._m_result;
_m_info=v._m_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_android_theme_by_id_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_android_theme_by_id_result_params::result() const{
return _m_result;
}
inline mcp_get_android_theme_by_id_result_params& mcp_get_android_theme_by_id_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_get_android_theme_by_id_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_get_android_theme_by_id_result_params::has_info() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_android_theme_by_id_result_params::info() const{
 return _m_info;
}
inline void mcp_get_android_theme_by_id_result_params::clear_info(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_android_theme_by_id_result_params::mutable_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info);
}
inline ::idl::vector< ::idl::string >* mcp_get_android_theme_by_id_result_params::m_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info);
}
inline size_t mcp_get_android_theme_by_id_result_params::info_size() const{
/*  */ return _m_info.size();
}
inline const char* mcp_get_android_theme_by_id_result_params::info(size_t i0,unsigned int* size) const{
 return _m_info.get(i0).get(size);
}
inline mcp_get_android_theme_by_id_result_params& mcp_get_android_theme_by_id_result_params::set_info(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_android_theme_by_id_result_params& mcp_get_android_theme_by_id_result_params::set_ptr_info(size_t i0,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_android_theme_by_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_android_theme_by_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_android_theme_by_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_android_theme_by_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_android_theme_by_id_response* mcp_get_android_theme_by_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_android_theme_by_id_response* tmp=(mcp_get_android_theme_by_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_android_theme_by_id_response(pool);
return tmp;
}
inline void mcp_get_android_theme_by_id_response::destroy(mcp_get_android_theme_by_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_android_theme_by_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_android_theme_by_id_response::mcp_get_android_theme_by_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_android_theme_by_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_android_theme_by_id_response::mcp_get_android_theme_by_id_response(const mcp_get_android_theme_by_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_android_theme_by_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_android_theme_by_id_response::~mcp_get_android_theme_by_id_response(){
if(_m_result_params){
::idl::mcp_get_android_theme_by_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_android_theme_by_id_response& mcp_get_android_theme_by_id_response::operator=(const mcp_get_android_theme_by_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_android_theme_by_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_android_theme_by_id_response::check() const{
// @@mcp_get_android_theme_by_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_android_theme_by_id_result_params& item=const_cast< ::idl::mcp_get_android_theme_by_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_android_theme_by_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_android_theme_by_id_response& mcp_get_android_theme_by_id_response::assign(const mcp_get_android_theme_by_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_android_theme_by_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_android_theme_by_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_android_theme_by_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_android_theme_by_id_result_params& mcp_get_android_theme_by_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_android_theme_by_id_result_params* mcp_get_android_theme_by_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_android_theme_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_android_theme_by_id_result_params* mcp_get_android_theme_by_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_android_theme_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_android_theme_by_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_android_theme_by_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_android_theme_by_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_android_theme_by_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_android_theme_by_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_mcp_stat_params* mcp_get_mcp_stat_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_mcp_stat_params* tmp=(mcp_get_mcp_stat_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_mcp_stat_params(pool);
return tmp;
}
inline void mcp_get_mcp_stat_params::destroy(mcp_get_mcp_stat_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_mcp_stat_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_mcp_stat_params::mcp_get_mcp_stat_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_mcp_stat_params::mcp_get_mcp_stat_params(const mcp_get_mcp_stat_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_mcp_stat_params::~mcp_get_mcp_stat_params(){
}
inline mcp_get_mcp_stat_params& mcp_get_mcp_stat_params::operator=(const mcp_get_mcp_stat_params& v){
assign(v);
return *this;
}
inline void mcp_get_mcp_stat_params::clear(){
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_mcp_stat_params::check() const{

::idl::McpackBean::check();
}
inline void mcp_get_mcp_stat_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_mcp_stat_params& mcp_get_mcp_stat_params::assign(const mcp_get_mcp_stat_params& v){
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline ::idl::Unknown* mcp_get_mcp_stat_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_mcp_stat_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_mcp_stat_params::unknown(){
return _unknown;
}
inline size_t mcp_get_mcp_stat_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_mcp_stat_result_params* mcp_get_mcp_stat_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_mcp_stat_result_params* tmp=(mcp_get_mcp_stat_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_mcp_stat_result_params(pool);
return tmp;
}
inline void mcp_get_mcp_stat_result_params::destroy(mcp_get_mcp_stat_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_mcp_stat_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_mcp_stat_result_params::mcp_get_mcp_stat_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_stat(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_mcp_stat_result_params::mcp_get_mcp_stat_result_params(const mcp_get_mcp_stat_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_stat(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_mcp_stat_result_params::~mcp_get_mcp_stat_result_params(){
}
inline mcp_get_mcp_stat_result_params& mcp_get_mcp_stat_result_params::operator=(const mcp_get_mcp_stat_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_mcp_stat_result_params::clear(){
_m_stat.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_mcp_stat_result_params::check() const{
// @@int32_t stat=out(),array(0);
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "stat" << "' not found";
}
{
// level 0 begin
typeof(_m_stat)& lr0=(_m_stat);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) int32_t item=lr0.GetWithoutCheck(i0);

}

}

::idl::McpackBean::check();
}
inline void mcp_get_mcp_stat_result_params::detach(){
_m_stat.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_mcp_stat_result_params& mcp_get_mcp_stat_result_params::assign(const mcp_get_mcp_stat_result_params& v){
_m_stat=v._m_stat;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_mcp_stat_result_params::has_stat() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::vector< int32_t >& mcp_get_mcp_stat_result_params::stat() const{
 return _m_stat;
}
inline void mcp_get_mcp_stat_result_params::clear_stat(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_stat.clear();
}
inline ::idl::vector< int32_t >* mcp_get_mcp_stat_result_params::mutable_stat(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_stat);
}
inline ::idl::vector< int32_t >* mcp_get_mcp_stat_result_params::m_stat(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_stat);
}
inline size_t mcp_get_mcp_stat_result_params::stat_size() const{
/*  */ return _m_stat.size();
}
inline int32_t mcp_get_mcp_stat_result_params::stat(size_t i0) const{
 return _m_stat.get(i0);
}
inline mcp_get_mcp_stat_result_params& mcp_get_mcp_stat_result_params::set_stat(size_t i0,int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 *(_m_stat.mutable_get(i0))=v;
return *this;
}
inline ::idl::Unknown* mcp_get_mcp_stat_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_mcp_stat_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_mcp_stat_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_mcp_stat_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_mcp_stat_response* mcp_get_mcp_stat_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_mcp_stat_response* tmp=(mcp_get_mcp_stat_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_mcp_stat_response(pool);
return tmp;
}
inline void mcp_get_mcp_stat_response::destroy(mcp_get_mcp_stat_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_mcp_stat_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_mcp_stat_response::mcp_get_mcp_stat_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_mcp_stat_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_mcp_stat_response::mcp_get_mcp_stat_response(const mcp_get_mcp_stat_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_mcp_stat_result_params::create(_pool);
assign(v);
}
inline mcp_get_mcp_stat_response::~mcp_get_mcp_stat_response(){
if(_m_result_params){
::idl::mcp_get_mcp_stat_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_mcp_stat_response& mcp_get_mcp_stat_response::operator=(const mcp_get_mcp_stat_response& v){
assign(v);
return *this;
}
inline void mcp_get_mcp_stat_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_mcp_stat_response::check() const{
// @@mcp_get_mcp_stat_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_mcp_stat_result_params& item=const_cast< ::idl::mcp_get_mcp_stat_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_mcp_stat_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_mcp_stat_response& mcp_get_mcp_stat_response::assign(const mcp_get_mcp_stat_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_mcp_stat_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_mcp_stat_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_mcp_stat_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_mcp_stat_result_params& mcp_get_mcp_stat_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_mcp_stat_result_params* mcp_get_mcp_stat_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_mcp_stat_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_mcp_stat_result_params* mcp_get_mcp_stat_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_mcp_stat_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_mcp_stat_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_mcp_stat_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_mcp_stat_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_mcp_stat_response::unknown(){
return _unknown;
}
inline size_t mcp_get_mcp_stat_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_col_list_by_topic_params* mcp_get_col_list_by_topic_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_col_list_by_topic_params* tmp=(mcp_get_col_list_by_topic_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_col_list_by_topic_params(pool);
return tmp;
}
inline void mcp_get_col_list_by_topic_params::destroy(mcp_get_col_list_by_topic_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_col_list_by_topic_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_col_list_by_topic_params::mcp_get_col_list_by_topic_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_topic_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_col_list_by_topic_params::mcp_get_col_list_by_topic_params(const mcp_get_col_list_by_topic_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_topic_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_col_list_by_topic_params::~mcp_get_col_list_by_topic_params(){
}
inline mcp_get_col_list_by_topic_params& mcp_get_col_list_by_topic_params::operator=(const mcp_get_col_list_by_topic_params& v){
assign(v);
return *this;
}
inline void mcp_get_col_list_by_topic_params::clear(){
_m_topic_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_col_list_by_topic_params::check() const{
// @@string topic_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "topic_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_topic_id.get();

}
// @@uint32_t page=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_col_list_by_topic_params::detach(){
_m_topic_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_col_list_by_topic_params& mcp_get_col_list_by_topic_params::assign(const mcp_get_col_list_by_topic_params& v){
_m_topic_id=v._m_topic_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_col_list_by_topic_params::has_topic_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_col_list_by_topic_params::topic_id(unsigned int* size) const{
return _m_topic_id.get(size);
}
inline mcp_get_col_list_by_topic_params& mcp_get_col_list_by_topic_params::set_topic_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_topic_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_col_list_by_topic_params& mcp_get_col_list_by_topic_params::set_ptr_topic_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_topic_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_col_list_by_topic_params::clear_topic_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_topic_id.clear();
}
inline bool mcp_get_col_list_by_topic_params::has_page() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_col_list_by_topic_params::page() const{
return _m_page;
}
inline mcp_get_col_list_by_topic_params& mcp_get_col_list_by_topic_params::set_page(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_col_list_by_topic_params::clear_page(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page=0;
}
inline bool mcp_get_col_list_by_topic_params::has_page_size() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_col_list_by_topic_params::page_size() const{
return _m_page_size;
}
inline mcp_get_col_list_by_topic_params& mcp_get_col_list_by_topic_params::set_page_size(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_col_list_by_topic_params::clear_page_size(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_col_list_by_topic_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_col_list_by_topic_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_col_list_by_topic_params::unknown(){
return _unknown;
}
inline size_t mcp_get_col_list_by_topic_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_col_list_by_topic_result_params* mcp_get_col_list_by_topic_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_col_list_by_topic_result_params* tmp=(mcp_get_col_list_by_topic_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_col_list_by_topic_result_params(pool);
return tmp;
}
inline void mcp_get_col_list_by_topic_result_params::destroy(mcp_get_col_list_by_topic_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_col_list_by_topic_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_col_list_by_topic_result_params::mcp_get_col_list_by_topic_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_topic_name(_pool)
,_m_topic_img(_pool)
,_m_topic_intro(_pool)
,_m_log_date(_pool)
,_m_before_topic(_pool)
,_m_before_name(_pool)
,_m_next_topic(_pool)
,_m_next_name(_pool)
,_m_col_id_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_col_list_by_topic_result_params::mcp_get_col_list_by_topic_result_params(const mcp_get_col_list_by_topic_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_topic_name(_pool)
,_m_topic_img(_pool)
,_m_topic_intro(_pool)
,_m_log_date(_pool)
,_m_before_topic(_pool)
,_m_before_name(_pool)
,_m_next_topic(_pool)
,_m_next_name(_pool)
,_m_col_id_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_col_list_by_topic_result_params::~mcp_get_col_list_by_topic_result_params(){
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::operator=(const mcp_get_col_list_by_topic_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_col_list_by_topic_result_params::clear(){
// _m_count=0;
_m_topic_name.clear();
_m_topic_img.clear();
_m_topic_intro.clear();
_m_log_date.clear();
_m_before_topic.clear();
_m_before_name.clear();
_m_next_topic.clear();
_m_next_name.clear();
_m_col_id_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_col_list_by_topic_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string topic_name=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "topic_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_topic_name.get();

}
// @@string topic_img=out();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "topic_img" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_topic_img.get();

}
// @@string topic_intro=out();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "topic_intro" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_topic_intro.get();

}
// @@string log_date=out();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "log_date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_log_date.get();

}
// @@string before_topic=out();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "before_topic" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_before_topic.get();

}
// @@string before_name=out();
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "before_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_before_name.get();

}
// @@string next_topic=out();
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "next_topic" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_next_topic.get();

}
// @@string next_name=out();
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "next_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_next_name.get();

}
// @@string col_id_list=out(),array(0);
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_id_list" << "' not found";
}
{
// level 0 begin
typeof(_m_col_id_list)& lr0=(_m_col_id_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_col_list_by_topic_result_params::detach(){
_m_topic_name.detach();
_m_topic_img.detach();
_m_topic_intro.detach();
_m_log_date.detach();
_m_before_topic.detach();
_m_before_name.detach();
_m_next_topic.detach();
_m_next_name.detach();
_m_col_id_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::assign(const mcp_get_col_list_by_topic_result_params& v){
_m_count=v._m_count;
_m_topic_name=v._m_topic_name;
_m_topic_img=v._m_topic_img;
_m_topic_intro=v._m_topic_intro;
_m_log_date=v._m_log_date;
_m_before_topic=v._m_before_topic;
_m_before_name=v._m_before_name;
_m_next_topic=v._m_next_topic;
_m_next_name=v._m_next_name;
_m_col_id_list=v._m_col_id_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_col_list_by_topic_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_col_list_by_topic_result_params::count() const{
return _m_count;
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_col_list_by_topic_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_col_list_by_topic_result_params::has_topic_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_col_list_by_topic_result_params::topic_name(unsigned int* size) const{
return _m_topic_name.get(size);
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_topic_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_topic_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_ptr_topic_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_topic_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_col_list_by_topic_result_params::clear_topic_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_topic_name.clear();
}
inline bool mcp_get_col_list_by_topic_result_params::has_topic_img() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_col_list_by_topic_result_params::topic_img(unsigned int* size) const{
return _m_topic_img.get(size);
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_topic_img(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_topic_img.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_ptr_topic_img(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_topic_img.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_col_list_by_topic_result_params::clear_topic_img(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_topic_img.clear();
}
inline bool mcp_get_col_list_by_topic_result_params::has_topic_intro() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_col_list_by_topic_result_params::topic_intro(unsigned int* size) const{
return _m_topic_intro.get(size);
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_topic_intro(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_topic_intro.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_ptr_topic_intro(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_topic_intro.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_col_list_by_topic_result_params::clear_topic_intro(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_topic_intro.clear();
}
inline bool mcp_get_col_list_by_topic_result_params::has_log_date() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_get_col_list_by_topic_result_params::log_date(unsigned int* size) const{
return _m_log_date.get(size);
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_log_date(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_log_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_ptr_log_date(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_log_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_col_list_by_topic_result_params::clear_log_date(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_log_date.clear();
}
inline bool mcp_get_col_list_by_topic_result_params::has_before_topic() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* mcp_get_col_list_by_topic_result_params::before_topic(unsigned int* size) const{
return _m_before_topic.get(size);
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_before_topic(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_before_topic.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_ptr_before_topic(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_before_topic.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_col_list_by_topic_result_params::clear_before_topic(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_before_topic.clear();
}
inline bool mcp_get_col_list_by_topic_result_params::has_before_name() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* mcp_get_col_list_by_topic_result_params::before_name(unsigned int* size) const{
return _m_before_name.get(size);
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_before_name(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_before_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_ptr_before_name(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_before_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_col_list_by_topic_result_params::clear_before_name(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_before_name.clear();
}
inline bool mcp_get_col_list_by_topic_result_params::has_next_topic() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* mcp_get_col_list_by_topic_result_params::next_topic(unsigned int* size) const{
return _m_next_topic.get(size);
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_next_topic(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_next_topic.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_ptr_next_topic(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_next_topic.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_col_list_by_topic_result_params::clear_next_topic(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_next_topic.clear();
}
inline bool mcp_get_col_list_by_topic_result_params::has_next_name() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline const char* mcp_get_col_list_by_topic_result_params::next_name(unsigned int* size) const{
return _m_next_name.get(size);
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_next_name(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_next_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_ptr_next_name(const char* s,ssize_t size){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_next_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_col_list_by_topic_result_params::clear_next_name(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_next_name.clear();
}
inline bool mcp_get_col_list_by_topic_result_params::has_col_id_list() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_col_list_by_topic_result_params::col_id_list() const{
 return _m_col_id_list;
}
inline void mcp_get_col_list_by_topic_result_params::clear_col_id_list(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_col_id_list.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_col_list_by_topic_result_params::mutable_col_id_list(){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 return &(_m_col_id_list);
}
inline ::idl::vector< ::idl::string >* mcp_get_col_list_by_topic_result_params::m_col_id_list(){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 return &(_m_col_id_list);
}
inline size_t mcp_get_col_list_by_topic_result_params::col_id_list_size() const{
/*  */ return _m_col_id_list.size();
}
inline const char* mcp_get_col_list_by_topic_result_params::col_id_list(size_t i0,unsigned int* size) const{
 return _m_col_id_list.get(i0).get(size);
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_col_id_list(size_t i0,const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_col_id_list.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_result_params::set_ptr_col_id_list(size_t i0,const char* s,ssize_t size){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_col_id_list.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_col_list_by_topic_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_col_list_by_topic_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_col_list_by_topic_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_col_list_by_topic_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_col_list_by_topic_response* mcp_get_col_list_by_topic_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_col_list_by_topic_response* tmp=(mcp_get_col_list_by_topic_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_col_list_by_topic_response(pool);
return tmp;
}
inline void mcp_get_col_list_by_topic_response::destroy(mcp_get_col_list_by_topic_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_col_list_by_topic_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_col_list_by_topic_response::mcp_get_col_list_by_topic_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_col_list_by_topic_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_col_list_by_topic_response::mcp_get_col_list_by_topic_response(const mcp_get_col_list_by_topic_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_col_list_by_topic_result_params::create(_pool);
assign(v);
}
inline mcp_get_col_list_by_topic_response::~mcp_get_col_list_by_topic_response(){
if(_m_result_params){
::idl::mcp_get_col_list_by_topic_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_col_list_by_topic_response& mcp_get_col_list_by_topic_response::operator=(const mcp_get_col_list_by_topic_response& v){
assign(v);
return *this;
}
inline void mcp_get_col_list_by_topic_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_col_list_by_topic_response::check() const{
// @@mcp_get_col_list_by_topic_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_col_list_by_topic_result_params& item=const_cast< ::idl::mcp_get_col_list_by_topic_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_col_list_by_topic_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_col_list_by_topic_response& mcp_get_col_list_by_topic_response::assign(const mcp_get_col_list_by_topic_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_col_list_by_topic_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_col_list_by_topic_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_col_list_by_topic_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_col_list_by_topic_result_params& mcp_get_col_list_by_topic_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_col_list_by_topic_result_params* mcp_get_col_list_by_topic_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_col_list_by_topic_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_col_list_by_topic_result_params* mcp_get_col_list_by_topic_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_col_list_by_topic_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_col_list_by_topic_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_col_list_by_topic_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_col_list_by_topic_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_col_list_by_topic_response::unknown(){
return _unknown;
}
inline size_t mcp_get_col_list_by_topic_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_soft_list_by_col_id_params* mcp_get_soft_list_by_col_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_soft_list_by_col_id_params* tmp=(mcp_get_soft_list_by_col_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_soft_list_by_col_id_params(pool);
return tmp;
}
inline void mcp_get_soft_list_by_col_id_params::destroy(mcp_get_soft_list_by_col_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_soft_list_by_col_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_soft_list_by_col_id_params::mcp_get_soft_list_by_col_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_col_id(_pool)
,_m_type_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_soft_list_by_col_id_params::mcp_get_soft_list_by_col_id_params(const mcp_get_soft_list_by_col_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_col_id(_pool)
,_m_type_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_soft_list_by_col_id_params::~mcp_get_soft_list_by_col_id_params(){
}
inline mcp_get_soft_list_by_col_id_params& mcp_get_soft_list_by_col_id_params::operator=(const mcp_get_soft_list_by_col_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_soft_list_by_col_id_params::clear(){
_m_col_id.clear();
_m_type_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_soft_list_by_col_id_params::check() const{
// @@string col_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_col_id.get();

}
// @@string type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t page=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_soft_list_by_col_id_params::detach(){
_m_col_id.detach();
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_soft_list_by_col_id_params& mcp_get_soft_list_by_col_id_params::assign(const mcp_get_soft_list_by_col_id_params& v){
_m_col_id=v._m_col_id;
_m_type_id=v._m_type_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_soft_list_by_col_id_params::has_col_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_soft_list_by_col_id_params::col_id(unsigned int* size) const{
return _m_col_id.get(size);
}
inline mcp_get_soft_list_by_col_id_params& mcp_get_soft_list_by_col_id_params::set_col_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_col_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_soft_list_by_col_id_params& mcp_get_soft_list_by_col_id_params::set_ptr_col_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_col_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_soft_list_by_col_id_params::clear_col_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_col_id.clear();
}
inline bool mcp_get_soft_list_by_col_id_params::has_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_soft_list_by_col_id_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_soft_list_by_col_id_params& mcp_get_soft_list_by_col_id_params::set_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_soft_list_by_col_id_params& mcp_get_soft_list_by_col_id_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_soft_list_by_col_id_params::clear_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_soft_list_by_col_id_params::has_page() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_soft_list_by_col_id_params::page() const{
return _m_page;
}
inline mcp_get_soft_list_by_col_id_params& mcp_get_soft_list_by_col_id_params::set_page(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_soft_list_by_col_id_params::clear_page(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page=0;
}
inline bool mcp_get_soft_list_by_col_id_params::has_page_size() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_soft_list_by_col_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_soft_list_by_col_id_params& mcp_get_soft_list_by_col_id_params::set_page_size(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_soft_list_by_col_id_params::clear_page_size(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_soft_list_by_col_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_soft_list_by_col_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_soft_list_by_col_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_soft_list_by_col_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_soft_list_by_col_id_result_params* mcp_get_soft_list_by_col_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_soft_list_by_col_id_result_params* tmp=(mcp_get_soft_list_by_col_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_soft_list_by_col_id_result_params(pool);
return tmp;
}
inline void mcp_get_soft_list_by_col_id_result_params::destroy(mcp_get_soft_list_by_col_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_soft_list_by_col_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_soft_list_by_col_id_result_params::mcp_get_soft_list_by_col_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_col_name(_pool)
,_m_soft_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_soft_list_by_col_id_result_params::mcp_get_soft_list_by_col_id_result_params(const mcp_get_soft_list_by_col_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_col_name(_pool)
,_m_soft_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_soft_list_by_col_id_result_params::~mcp_get_soft_list_by_col_id_result_params(){
}
inline mcp_get_soft_list_by_col_id_result_params& mcp_get_soft_list_by_col_id_result_params::operator=(const mcp_get_soft_list_by_col_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_soft_list_by_col_id_result_params::clear(){
// _m_count=0;
_m_col_name.clear();
_m_soft_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_soft_list_by_col_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string col_name=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_col_name.get();

}
// @@string soft_list=out(),array(0,0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "soft_list" << "' not found";
}
{
// level 0 begin
typeof(_m_soft_list)& lr0=(_m_soft_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_soft_list_by_col_id_result_params::detach(){
_m_col_name.detach();
_m_soft_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_soft_list_by_col_id_result_params& mcp_get_soft_list_by_col_id_result_params::assign(const mcp_get_soft_list_by_col_id_result_params& v){
_m_count=v._m_count;
_m_col_name=v._m_col_name;
_m_soft_list=v._m_soft_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_soft_list_by_col_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_soft_list_by_col_id_result_params::count() const{
return _m_count;
}
inline mcp_get_soft_list_by_col_id_result_params& mcp_get_soft_list_by_col_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_soft_list_by_col_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_soft_list_by_col_id_result_params::has_col_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_soft_list_by_col_id_result_params::col_name(unsigned int* size) const{
return _m_col_name.get(size);
}
inline mcp_get_soft_list_by_col_id_result_params& mcp_get_soft_list_by_col_id_result_params::set_col_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_col_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_soft_list_by_col_id_result_params& mcp_get_soft_list_by_col_id_result_params::set_ptr_col_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_col_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_soft_list_by_col_id_result_params::clear_col_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_col_name.clear();
}
inline bool mcp_get_soft_list_by_col_id_result_params::has_soft_list() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_soft_list_by_col_id_result_params::soft_list() const{
 return _m_soft_list;
}
inline void mcp_get_soft_list_by_col_id_result_params::clear_soft_list(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_soft_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_soft_list_by_col_id_result_params::mutable_soft_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_soft_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_soft_list_by_col_id_result_params::m_soft_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_soft_list);
}
inline size_t mcp_get_soft_list_by_col_id_result_params::soft_list_size() const{
/*  */ return _m_soft_list.size();
}
inline const char* mcp_get_soft_list_by_col_id_result_params::soft_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_soft_list.get(i0).get(i1).get(size);
}
inline mcp_get_soft_list_by_col_id_result_params& mcp_get_soft_list_by_col_id_result_params::set_soft_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_soft_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_soft_list_by_col_id_result_params& mcp_get_soft_list_by_col_id_result_params::set_ptr_soft_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_soft_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_soft_list_by_col_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_soft_list_by_col_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_soft_list_by_col_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_soft_list_by_col_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_soft_list_by_col_id_response* mcp_get_soft_list_by_col_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_soft_list_by_col_id_response* tmp=(mcp_get_soft_list_by_col_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_soft_list_by_col_id_response(pool);
return tmp;
}
inline void mcp_get_soft_list_by_col_id_response::destroy(mcp_get_soft_list_by_col_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_soft_list_by_col_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_soft_list_by_col_id_response::mcp_get_soft_list_by_col_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_soft_list_by_col_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_soft_list_by_col_id_response::mcp_get_soft_list_by_col_id_response(const mcp_get_soft_list_by_col_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_soft_list_by_col_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_soft_list_by_col_id_response::~mcp_get_soft_list_by_col_id_response(){
if(_m_result_params){
::idl::mcp_get_soft_list_by_col_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_soft_list_by_col_id_response& mcp_get_soft_list_by_col_id_response::operator=(const mcp_get_soft_list_by_col_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_soft_list_by_col_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_soft_list_by_col_id_response::check() const{
// @@mcp_get_soft_list_by_col_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_soft_list_by_col_id_result_params& item=const_cast< ::idl::mcp_get_soft_list_by_col_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_soft_list_by_col_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_soft_list_by_col_id_response& mcp_get_soft_list_by_col_id_response::assign(const mcp_get_soft_list_by_col_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_soft_list_by_col_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_soft_list_by_col_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_soft_list_by_col_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_soft_list_by_col_id_result_params& mcp_get_soft_list_by_col_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_soft_list_by_col_id_result_params* mcp_get_soft_list_by_col_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_soft_list_by_col_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_soft_list_by_col_id_result_params* mcp_get_soft_list_by_col_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_soft_list_by_col_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_soft_list_by_col_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_soft_list_by_col_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_soft_list_by_col_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_soft_list_by_col_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_soft_list_by_col_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_soft_list_by_class_id_params* mcp_get_soft_list_by_class_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_soft_list_by_class_id_params* tmp=(mcp_get_soft_list_by_class_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_soft_list_by_class_id_params(pool);
return tmp;
}
inline void mcp_get_soft_list_by_class_id_params::destroy(mcp_get_soft_list_by_class_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_soft_list_by_class_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_soft_list_by_class_id_params::mcp_get_soft_list_by_class_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_class_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_soft_list_by_class_id_params::mcp_get_soft_list_by_class_id_params(const mcp_get_soft_list_by_class_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_class_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_soft_list_by_class_id_params::~mcp_get_soft_list_by_class_id_params(){
}
inline mcp_get_soft_list_by_class_id_params& mcp_get_soft_list_by_class_id_params::operator=(const mcp_get_soft_list_by_class_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_soft_list_by_class_id_params::clear(){
_m_class_id.clear();
_m_type_id.clear();
// _m_orderby=0;
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_soft_list_by_class_id_params::check() const{
// @@string class_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}
// @@string type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t orderby=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "orderby" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_orderby;

}
// @@uint32_t page=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_soft_list_by_class_id_params::detach(){
_m_class_id.detach();
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_soft_list_by_class_id_params& mcp_get_soft_list_by_class_id_params::assign(const mcp_get_soft_list_by_class_id_params& v){
_m_class_id=v._m_class_id;
_m_type_id=v._m_type_id;
_m_orderby=v._m_orderby;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_soft_list_by_class_id_params::has_class_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_soft_list_by_class_id_params::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_get_soft_list_by_class_id_params& mcp_get_soft_list_by_class_id_params::set_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_soft_list_by_class_id_params& mcp_get_soft_list_by_class_id_params::set_ptr_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_soft_list_by_class_id_params::clear_class_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_class_id.clear();
}
inline bool mcp_get_soft_list_by_class_id_params::has_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_soft_list_by_class_id_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_soft_list_by_class_id_params& mcp_get_soft_list_by_class_id_params::set_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_soft_list_by_class_id_params& mcp_get_soft_list_by_class_id_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_soft_list_by_class_id_params::clear_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_soft_list_by_class_id_params::has_orderby() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_soft_list_by_class_id_params::orderby() const{
return _m_orderby;
}
inline mcp_get_soft_list_by_class_id_params& mcp_get_soft_list_by_class_id_params::set_orderby(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_orderby=v;
return *this;
}
inline void mcp_get_soft_list_by_class_id_params::clear_orderby(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_orderby=0;
}
inline bool mcp_get_soft_list_by_class_id_params::has_page() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_soft_list_by_class_id_params::page() const{
return _m_page;
}
inline mcp_get_soft_list_by_class_id_params& mcp_get_soft_list_by_class_id_params::set_page(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_soft_list_by_class_id_params::clear_page(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page=0;
}
inline bool mcp_get_soft_list_by_class_id_params::has_page_size() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_soft_list_by_class_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_soft_list_by_class_id_params& mcp_get_soft_list_by_class_id_params::set_page_size(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_soft_list_by_class_id_params::clear_page_size(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_soft_list_by_class_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_soft_list_by_class_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_soft_list_by_class_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_soft_list_by_class_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_soft_list_by_class_id_result_params* mcp_get_soft_list_by_class_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_soft_list_by_class_id_result_params* tmp=(mcp_get_soft_list_by_class_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_soft_list_by_class_id_result_params(pool);
return tmp;
}
inline void mcp_get_soft_list_by_class_id_result_params::destroy(mcp_get_soft_list_by_class_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_soft_list_by_class_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_soft_list_by_class_id_result_params::mcp_get_soft_list_by_class_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_class_name(_pool)
,_m_class_icon(_pool)
,_m_soft_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_soft_list_by_class_id_result_params::mcp_get_soft_list_by_class_id_result_params(const mcp_get_soft_list_by_class_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_class_name(_pool)
,_m_class_icon(_pool)
,_m_soft_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_soft_list_by_class_id_result_params::~mcp_get_soft_list_by_class_id_result_params(){
}
inline mcp_get_soft_list_by_class_id_result_params& mcp_get_soft_list_by_class_id_result_params::operator=(const mcp_get_soft_list_by_class_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_soft_list_by_class_id_result_params::clear(){
// _m_count=0;
_m_class_name.clear();
_m_class_icon.clear();
_m_soft_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_soft_list_by_class_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string class_name=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_name.get();

}
// @@string class_icon=out();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_icon" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_icon.get();

}
// @@string soft_list=out(),array(0,0);
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "soft_list" << "' not found";
}
{
// level 0 begin
typeof(_m_soft_list)& lr0=(_m_soft_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_soft_list_by_class_id_result_params::detach(){
_m_class_name.detach();
_m_class_icon.detach();
_m_soft_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_soft_list_by_class_id_result_params& mcp_get_soft_list_by_class_id_result_params::assign(const mcp_get_soft_list_by_class_id_result_params& v){
_m_count=v._m_count;
_m_class_name=v._m_class_name;
_m_class_icon=v._m_class_icon;
_m_soft_list=v._m_soft_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_soft_list_by_class_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_soft_list_by_class_id_result_params::count() const{
return _m_count;
}
inline mcp_get_soft_list_by_class_id_result_params& mcp_get_soft_list_by_class_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_soft_list_by_class_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_soft_list_by_class_id_result_params::has_class_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_soft_list_by_class_id_result_params::class_name(unsigned int* size) const{
return _m_class_name.get(size);
}
inline mcp_get_soft_list_by_class_id_result_params& mcp_get_soft_list_by_class_id_result_params::set_class_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_class_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_soft_list_by_class_id_result_params& mcp_get_soft_list_by_class_id_result_params::set_ptr_class_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_class_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_soft_list_by_class_id_result_params::clear_class_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_class_name.clear();
}
inline bool mcp_get_soft_list_by_class_id_result_params::has_class_icon() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_soft_list_by_class_id_result_params::class_icon(unsigned int* size) const{
return _m_class_icon.get(size);
}
inline mcp_get_soft_list_by_class_id_result_params& mcp_get_soft_list_by_class_id_result_params::set_class_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_class_icon.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_soft_list_by_class_id_result_params& mcp_get_soft_list_by_class_id_result_params::set_ptr_class_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_class_icon.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_soft_list_by_class_id_result_params::clear_class_icon(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_class_icon.clear();
}
inline bool mcp_get_soft_list_by_class_id_result_params::has_soft_list() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_soft_list_by_class_id_result_params::soft_list() const{
 return _m_soft_list;
}
inline void mcp_get_soft_list_by_class_id_result_params::clear_soft_list(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_soft_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_soft_list_by_class_id_result_params::mutable_soft_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_soft_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_soft_list_by_class_id_result_params::m_soft_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_soft_list);
}
inline size_t mcp_get_soft_list_by_class_id_result_params::soft_list_size() const{
/*  */ return _m_soft_list.size();
}
inline const char* mcp_get_soft_list_by_class_id_result_params::soft_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_soft_list.get(i0).get(i1).get(size);
}
inline mcp_get_soft_list_by_class_id_result_params& mcp_get_soft_list_by_class_id_result_params::set_soft_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_soft_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_soft_list_by_class_id_result_params& mcp_get_soft_list_by_class_id_result_params::set_ptr_soft_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_soft_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_soft_list_by_class_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_soft_list_by_class_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_soft_list_by_class_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_soft_list_by_class_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_soft_list_by_class_id_response* mcp_get_soft_list_by_class_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_soft_list_by_class_id_response* tmp=(mcp_get_soft_list_by_class_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_soft_list_by_class_id_response(pool);
return tmp;
}
inline void mcp_get_soft_list_by_class_id_response::destroy(mcp_get_soft_list_by_class_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_soft_list_by_class_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_soft_list_by_class_id_response::mcp_get_soft_list_by_class_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_soft_list_by_class_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_soft_list_by_class_id_response::mcp_get_soft_list_by_class_id_response(const mcp_get_soft_list_by_class_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_soft_list_by_class_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_soft_list_by_class_id_response::~mcp_get_soft_list_by_class_id_response(){
if(_m_result_params){
::idl::mcp_get_soft_list_by_class_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_soft_list_by_class_id_response& mcp_get_soft_list_by_class_id_response::operator=(const mcp_get_soft_list_by_class_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_soft_list_by_class_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_soft_list_by_class_id_response::check() const{
// @@mcp_get_soft_list_by_class_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_soft_list_by_class_id_result_params& item=const_cast< ::idl::mcp_get_soft_list_by_class_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_soft_list_by_class_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_soft_list_by_class_id_response& mcp_get_soft_list_by_class_id_response::assign(const mcp_get_soft_list_by_class_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_soft_list_by_class_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_soft_list_by_class_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_soft_list_by_class_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_soft_list_by_class_id_result_params& mcp_get_soft_list_by_class_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_soft_list_by_class_id_result_params* mcp_get_soft_list_by_class_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_soft_list_by_class_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_soft_list_by_class_id_result_params* mcp_get_soft_list_by_class_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_soft_list_by_class_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_soft_list_by_class_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_soft_list_by_class_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_soft_list_by_class_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_soft_list_by_class_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_soft_list_by_class_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_android_theme_by_col_id_params* mcp_get_android_theme_by_col_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_android_theme_by_col_id_params* tmp=(mcp_get_android_theme_by_col_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_android_theme_by_col_id_params(pool);
return tmp;
}
inline void mcp_get_android_theme_by_col_id_params::destroy(mcp_get_android_theme_by_col_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_android_theme_by_col_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_android_theme_by_col_id_params::mcp_get_android_theme_by_col_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_col_id(_pool)
,_m_type_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_android_theme_by_col_id_params::mcp_get_android_theme_by_col_id_params(const mcp_get_android_theme_by_col_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_col_id(_pool)
,_m_type_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_android_theme_by_col_id_params::~mcp_get_android_theme_by_col_id_params(){
}
inline mcp_get_android_theme_by_col_id_params& mcp_get_android_theme_by_col_id_params::operator=(const mcp_get_android_theme_by_col_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_android_theme_by_col_id_params::clear(){
_m_col_id.clear();
_m_type_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_android_theme_by_col_id_params::check() const{
// @@string col_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_col_id.get();

}
// @@string type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t page=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_android_theme_by_col_id_params::detach(){
_m_col_id.detach();
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_android_theme_by_col_id_params& mcp_get_android_theme_by_col_id_params::assign(const mcp_get_android_theme_by_col_id_params& v){
_m_col_id=v._m_col_id;
_m_type_id=v._m_type_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_android_theme_by_col_id_params::has_col_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_android_theme_by_col_id_params::col_id(unsigned int* size) const{
return _m_col_id.get(size);
}
inline mcp_get_android_theme_by_col_id_params& mcp_get_android_theme_by_col_id_params::set_col_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_col_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_android_theme_by_col_id_params& mcp_get_android_theme_by_col_id_params::set_ptr_col_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_col_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_android_theme_by_col_id_params::clear_col_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_col_id.clear();
}
inline bool mcp_get_android_theme_by_col_id_params::has_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_android_theme_by_col_id_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_android_theme_by_col_id_params& mcp_get_android_theme_by_col_id_params::set_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_android_theme_by_col_id_params& mcp_get_android_theme_by_col_id_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_android_theme_by_col_id_params::clear_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_android_theme_by_col_id_params::has_page() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_android_theme_by_col_id_params::page() const{
return _m_page;
}
inline mcp_get_android_theme_by_col_id_params& mcp_get_android_theme_by_col_id_params::set_page(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_android_theme_by_col_id_params::clear_page(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page=0;
}
inline bool mcp_get_android_theme_by_col_id_params::has_page_size() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_android_theme_by_col_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_android_theme_by_col_id_params& mcp_get_android_theme_by_col_id_params::set_page_size(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_android_theme_by_col_id_params::clear_page_size(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_android_theme_by_col_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_android_theme_by_col_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_android_theme_by_col_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_android_theme_by_col_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_android_theme_by_col_id_result_params* mcp_get_android_theme_by_col_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_android_theme_by_col_id_result_params* tmp=(mcp_get_android_theme_by_col_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_android_theme_by_col_id_result_params(pool);
return tmp;
}
inline void mcp_get_android_theme_by_col_id_result_params::destroy(mcp_get_android_theme_by_col_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_android_theme_by_col_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_android_theme_by_col_id_result_params::mcp_get_android_theme_by_col_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_col_name(_pool)
,_m_theme_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_android_theme_by_col_id_result_params::mcp_get_android_theme_by_col_id_result_params(const mcp_get_android_theme_by_col_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_col_name(_pool)
,_m_theme_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_android_theme_by_col_id_result_params::~mcp_get_android_theme_by_col_id_result_params(){
}
inline mcp_get_android_theme_by_col_id_result_params& mcp_get_android_theme_by_col_id_result_params::operator=(const mcp_get_android_theme_by_col_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_android_theme_by_col_id_result_params::clear(){
// _m_count=0;
_m_col_name.clear();
_m_theme_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_android_theme_by_col_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string col_name=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_col_name.get();

}
// @@string theme_list=out(),array(0,0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "theme_list" << "' not found";
}
{
// level 0 begin
typeof(_m_theme_list)& lr0=(_m_theme_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_android_theme_by_col_id_result_params::detach(){
_m_col_name.detach();
_m_theme_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_android_theme_by_col_id_result_params& mcp_get_android_theme_by_col_id_result_params::assign(const mcp_get_android_theme_by_col_id_result_params& v){
_m_count=v._m_count;
_m_col_name=v._m_col_name;
_m_theme_list=v._m_theme_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_android_theme_by_col_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_android_theme_by_col_id_result_params::count() const{
return _m_count;
}
inline mcp_get_android_theme_by_col_id_result_params& mcp_get_android_theme_by_col_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_android_theme_by_col_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_android_theme_by_col_id_result_params::has_col_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_android_theme_by_col_id_result_params::col_name(unsigned int* size) const{
return _m_col_name.get(size);
}
inline mcp_get_android_theme_by_col_id_result_params& mcp_get_android_theme_by_col_id_result_params::set_col_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_col_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_android_theme_by_col_id_result_params& mcp_get_android_theme_by_col_id_result_params::set_ptr_col_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_col_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_android_theme_by_col_id_result_params::clear_col_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_col_name.clear();
}
inline bool mcp_get_android_theme_by_col_id_result_params::has_theme_list() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_android_theme_by_col_id_result_params::theme_list() const{
 return _m_theme_list;
}
inline void mcp_get_android_theme_by_col_id_result_params::clear_theme_list(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_theme_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_android_theme_by_col_id_result_params::mutable_theme_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_theme_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_android_theme_by_col_id_result_params::m_theme_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_theme_list);
}
inline size_t mcp_get_android_theme_by_col_id_result_params::theme_list_size() const{
/*  */ return _m_theme_list.size();
}
inline const char* mcp_get_android_theme_by_col_id_result_params::theme_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_theme_list.get(i0).get(i1).get(size);
}
inline mcp_get_android_theme_by_col_id_result_params& mcp_get_android_theme_by_col_id_result_params::set_theme_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_theme_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_android_theme_by_col_id_result_params& mcp_get_android_theme_by_col_id_result_params::set_ptr_theme_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_theme_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_android_theme_by_col_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_android_theme_by_col_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_android_theme_by_col_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_android_theme_by_col_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_android_theme_by_col_id_response* mcp_get_android_theme_by_col_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_android_theme_by_col_id_response* tmp=(mcp_get_android_theme_by_col_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_android_theme_by_col_id_response(pool);
return tmp;
}
inline void mcp_get_android_theme_by_col_id_response::destroy(mcp_get_android_theme_by_col_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_android_theme_by_col_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_android_theme_by_col_id_response::mcp_get_android_theme_by_col_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_android_theme_by_col_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_android_theme_by_col_id_response::mcp_get_android_theme_by_col_id_response(const mcp_get_android_theme_by_col_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_android_theme_by_col_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_android_theme_by_col_id_response::~mcp_get_android_theme_by_col_id_response(){
if(_m_result_params){
::idl::mcp_get_android_theme_by_col_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_android_theme_by_col_id_response& mcp_get_android_theme_by_col_id_response::operator=(const mcp_get_android_theme_by_col_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_android_theme_by_col_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_android_theme_by_col_id_response::check() const{
// @@mcp_get_android_theme_by_col_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_android_theme_by_col_id_result_params& item=const_cast< ::idl::mcp_get_android_theme_by_col_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_android_theme_by_col_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_android_theme_by_col_id_response& mcp_get_android_theme_by_col_id_response::assign(const mcp_get_android_theme_by_col_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_android_theme_by_col_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_android_theme_by_col_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_android_theme_by_col_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_android_theme_by_col_id_result_params& mcp_get_android_theme_by_col_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_android_theme_by_col_id_result_params* mcp_get_android_theme_by_col_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_android_theme_by_col_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_android_theme_by_col_id_result_params* mcp_get_android_theme_by_col_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_android_theme_by_col_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_android_theme_by_col_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_android_theme_by_col_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_android_theme_by_col_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_android_theme_by_col_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_android_theme_by_col_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_android_theme_by_class_id_params* mcp_get_android_theme_by_class_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_android_theme_by_class_id_params* tmp=(mcp_get_android_theme_by_class_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_android_theme_by_class_id_params(pool);
return tmp;
}
inline void mcp_get_android_theme_by_class_id_params::destroy(mcp_get_android_theme_by_class_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_android_theme_by_class_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_android_theme_by_class_id_params::mcp_get_android_theme_by_class_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_class_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_android_theme_by_class_id_params::mcp_get_android_theme_by_class_id_params(const mcp_get_android_theme_by_class_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_class_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_android_theme_by_class_id_params::~mcp_get_android_theme_by_class_id_params(){
}
inline mcp_get_android_theme_by_class_id_params& mcp_get_android_theme_by_class_id_params::operator=(const mcp_get_android_theme_by_class_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_android_theme_by_class_id_params::clear(){
_m_class_id.clear();
_m_type_id.clear();
// _m_orderby=0;
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_android_theme_by_class_id_params::check() const{
// @@string class_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}
// @@string type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t orderby=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "orderby" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_orderby;

}
// @@uint32_t page=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_android_theme_by_class_id_params::detach(){
_m_class_id.detach();
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_android_theme_by_class_id_params& mcp_get_android_theme_by_class_id_params::assign(const mcp_get_android_theme_by_class_id_params& v){
_m_class_id=v._m_class_id;
_m_type_id=v._m_type_id;
_m_orderby=v._m_orderby;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_android_theme_by_class_id_params::has_class_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_android_theme_by_class_id_params::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_get_android_theme_by_class_id_params& mcp_get_android_theme_by_class_id_params::set_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_android_theme_by_class_id_params& mcp_get_android_theme_by_class_id_params::set_ptr_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_android_theme_by_class_id_params::clear_class_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_class_id.clear();
}
inline bool mcp_get_android_theme_by_class_id_params::has_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_android_theme_by_class_id_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_android_theme_by_class_id_params& mcp_get_android_theme_by_class_id_params::set_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_android_theme_by_class_id_params& mcp_get_android_theme_by_class_id_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_android_theme_by_class_id_params::clear_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_android_theme_by_class_id_params::has_orderby() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_android_theme_by_class_id_params::orderby() const{
return _m_orderby;
}
inline mcp_get_android_theme_by_class_id_params& mcp_get_android_theme_by_class_id_params::set_orderby(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_orderby=v;
return *this;
}
inline void mcp_get_android_theme_by_class_id_params::clear_orderby(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_orderby=0;
}
inline bool mcp_get_android_theme_by_class_id_params::has_page() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_android_theme_by_class_id_params::page() const{
return _m_page;
}
inline mcp_get_android_theme_by_class_id_params& mcp_get_android_theme_by_class_id_params::set_page(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_android_theme_by_class_id_params::clear_page(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page=0;
}
inline bool mcp_get_android_theme_by_class_id_params::has_page_size() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_android_theme_by_class_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_android_theme_by_class_id_params& mcp_get_android_theme_by_class_id_params::set_page_size(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_android_theme_by_class_id_params::clear_page_size(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_android_theme_by_class_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_android_theme_by_class_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_android_theme_by_class_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_android_theme_by_class_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_android_theme_by_class_id_result_params* mcp_get_android_theme_by_class_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_android_theme_by_class_id_result_params* tmp=(mcp_get_android_theme_by_class_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_android_theme_by_class_id_result_params(pool);
return tmp;
}
inline void mcp_get_android_theme_by_class_id_result_params::destroy(mcp_get_android_theme_by_class_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_android_theme_by_class_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_android_theme_by_class_id_result_params::mcp_get_android_theme_by_class_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_class_name(_pool)
,_m_class_icon(_pool)
,_m_theme_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_android_theme_by_class_id_result_params::mcp_get_android_theme_by_class_id_result_params(const mcp_get_android_theme_by_class_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_class_name(_pool)
,_m_class_icon(_pool)
,_m_theme_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_android_theme_by_class_id_result_params::~mcp_get_android_theme_by_class_id_result_params(){
}
inline mcp_get_android_theme_by_class_id_result_params& mcp_get_android_theme_by_class_id_result_params::operator=(const mcp_get_android_theme_by_class_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_android_theme_by_class_id_result_params::clear(){
// _m_count=0;
_m_class_name.clear();
_m_class_icon.clear();
_m_theme_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_android_theme_by_class_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string class_name=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_name.get();

}
// @@string class_icon=out();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_icon" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_icon.get();

}
// @@string theme_list=out(),array(0,0);
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "theme_list" << "' not found";
}
{
// level 0 begin
typeof(_m_theme_list)& lr0=(_m_theme_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_android_theme_by_class_id_result_params::detach(){
_m_class_name.detach();
_m_class_icon.detach();
_m_theme_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_android_theme_by_class_id_result_params& mcp_get_android_theme_by_class_id_result_params::assign(const mcp_get_android_theme_by_class_id_result_params& v){
_m_count=v._m_count;
_m_class_name=v._m_class_name;
_m_class_icon=v._m_class_icon;
_m_theme_list=v._m_theme_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_android_theme_by_class_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_android_theme_by_class_id_result_params::count() const{
return _m_count;
}
inline mcp_get_android_theme_by_class_id_result_params& mcp_get_android_theme_by_class_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_android_theme_by_class_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_android_theme_by_class_id_result_params::has_class_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_android_theme_by_class_id_result_params::class_name(unsigned int* size) const{
return _m_class_name.get(size);
}
inline mcp_get_android_theme_by_class_id_result_params& mcp_get_android_theme_by_class_id_result_params::set_class_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_class_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_android_theme_by_class_id_result_params& mcp_get_android_theme_by_class_id_result_params::set_ptr_class_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_class_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_android_theme_by_class_id_result_params::clear_class_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_class_name.clear();
}
inline bool mcp_get_android_theme_by_class_id_result_params::has_class_icon() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_android_theme_by_class_id_result_params::class_icon(unsigned int* size) const{
return _m_class_icon.get(size);
}
inline mcp_get_android_theme_by_class_id_result_params& mcp_get_android_theme_by_class_id_result_params::set_class_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_class_icon.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_android_theme_by_class_id_result_params& mcp_get_android_theme_by_class_id_result_params::set_ptr_class_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_class_icon.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_android_theme_by_class_id_result_params::clear_class_icon(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_class_icon.clear();
}
inline bool mcp_get_android_theme_by_class_id_result_params::has_theme_list() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_android_theme_by_class_id_result_params::theme_list() const{
 return _m_theme_list;
}
inline void mcp_get_android_theme_by_class_id_result_params::clear_theme_list(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_theme_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_android_theme_by_class_id_result_params::mutable_theme_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_theme_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_android_theme_by_class_id_result_params::m_theme_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_theme_list);
}
inline size_t mcp_get_android_theme_by_class_id_result_params::theme_list_size() const{
/*  */ return _m_theme_list.size();
}
inline const char* mcp_get_android_theme_by_class_id_result_params::theme_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_theme_list.get(i0).get(i1).get(size);
}
inline mcp_get_android_theme_by_class_id_result_params& mcp_get_android_theme_by_class_id_result_params::set_theme_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_theme_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_android_theme_by_class_id_result_params& mcp_get_android_theme_by_class_id_result_params::set_ptr_theme_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_theme_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_android_theme_by_class_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_android_theme_by_class_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_android_theme_by_class_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_android_theme_by_class_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_android_theme_by_class_id_response* mcp_get_android_theme_by_class_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_android_theme_by_class_id_response* tmp=(mcp_get_android_theme_by_class_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_android_theme_by_class_id_response(pool);
return tmp;
}
inline void mcp_get_android_theme_by_class_id_response::destroy(mcp_get_android_theme_by_class_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_android_theme_by_class_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_android_theme_by_class_id_response::mcp_get_android_theme_by_class_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_android_theme_by_class_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_android_theme_by_class_id_response::mcp_get_android_theme_by_class_id_response(const mcp_get_android_theme_by_class_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_android_theme_by_class_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_android_theme_by_class_id_response::~mcp_get_android_theme_by_class_id_response(){
if(_m_result_params){
::idl::mcp_get_android_theme_by_class_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_android_theme_by_class_id_response& mcp_get_android_theme_by_class_id_response::operator=(const mcp_get_android_theme_by_class_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_android_theme_by_class_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_android_theme_by_class_id_response::check() const{
// @@mcp_get_android_theme_by_class_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_android_theme_by_class_id_result_params& item=const_cast< ::idl::mcp_get_android_theme_by_class_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_android_theme_by_class_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_android_theme_by_class_id_response& mcp_get_android_theme_by_class_id_response::assign(const mcp_get_android_theme_by_class_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_android_theme_by_class_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_android_theme_by_class_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_android_theme_by_class_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_android_theme_by_class_id_result_params& mcp_get_android_theme_by_class_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_android_theme_by_class_id_result_params* mcp_get_android_theme_by_class_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_android_theme_by_class_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_android_theme_by_class_id_result_params* mcp_get_android_theme_by_class_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_android_theme_by_class_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_android_theme_by_class_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_android_theme_by_class_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_android_theme_by_class_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_android_theme_by_class_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_android_theme_by_class_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_topic_list_by_type_params* mcp_get_topic_list_by_type_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_topic_list_by_type_params* tmp=(mcp_get_topic_list_by_type_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_topic_list_by_type_params(pool);
return tmp;
}
inline void mcp_get_topic_list_by_type_params::destroy(mcp_get_topic_list_by_type_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_topic_list_by_type_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_topic_list_by_type_params::mcp_get_topic_list_by_type_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_type_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_topic_list_by_type_params::mcp_get_topic_list_by_type_params(const mcp_get_topic_list_by_type_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_type_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_topic_list_by_type_params::~mcp_get_topic_list_by_type_params(){
}
inline mcp_get_topic_list_by_type_params& mcp_get_topic_list_by_type_params::operator=(const mcp_get_topic_list_by_type_params& v){
assign(v);
return *this;
}
inline void mcp_get_topic_list_by_type_params::clear(){
_m_type_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_topic_list_by_type_params::check() const{
// @@string type_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t page=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_topic_list_by_type_params::detach(){
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_topic_list_by_type_params& mcp_get_topic_list_by_type_params::assign(const mcp_get_topic_list_by_type_params& v){
_m_type_id=v._m_type_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_topic_list_by_type_params::has_type_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_topic_list_by_type_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_topic_list_by_type_params& mcp_get_topic_list_by_type_params::set_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_topic_list_by_type_params& mcp_get_topic_list_by_type_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_topic_list_by_type_params::clear_type_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_topic_list_by_type_params::has_page() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_topic_list_by_type_params::page() const{
return _m_page;
}
inline mcp_get_topic_list_by_type_params& mcp_get_topic_list_by_type_params::set_page(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_topic_list_by_type_params::clear_page(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page=0;
}
inline bool mcp_get_topic_list_by_type_params::has_page_size() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_topic_list_by_type_params::page_size() const{
return _m_page_size;
}
inline mcp_get_topic_list_by_type_params& mcp_get_topic_list_by_type_params::set_page_size(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_topic_list_by_type_params::clear_page_size(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_topic_list_by_type_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_topic_list_by_type_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_topic_list_by_type_params::unknown(){
return _unknown;
}
inline size_t mcp_get_topic_list_by_type_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_topic_list_by_type_result_params* mcp_get_topic_list_by_type_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_topic_list_by_type_result_params* tmp=(mcp_get_topic_list_by_type_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_topic_list_by_type_result_params(pool);
return tmp;
}
inline void mcp_get_topic_list_by_type_result_params::destroy(mcp_get_topic_list_by_type_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_topic_list_by_type_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_topic_list_by_type_result_params::mcp_get_topic_list_by_type_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_topic_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_topic_list_by_type_result_params::mcp_get_topic_list_by_type_result_params(const mcp_get_topic_list_by_type_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_topic_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_topic_list_by_type_result_params::~mcp_get_topic_list_by_type_result_params(){
}
inline mcp_get_topic_list_by_type_result_params& mcp_get_topic_list_by_type_result_params::operator=(const mcp_get_topic_list_by_type_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_topic_list_by_type_result_params::clear(){
// _m_count=0;
_m_topic_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_topic_list_by_type_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string topic_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "topic_list" << "' not found";
}
{
// level 0 begin
typeof(_m_topic_list)& lr0=(_m_topic_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_topic_list_by_type_result_params::detach(){
_m_topic_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_topic_list_by_type_result_params& mcp_get_topic_list_by_type_result_params::assign(const mcp_get_topic_list_by_type_result_params& v){
_m_count=v._m_count;
_m_topic_list=v._m_topic_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_topic_list_by_type_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_topic_list_by_type_result_params::count() const{
return _m_count;
}
inline mcp_get_topic_list_by_type_result_params& mcp_get_topic_list_by_type_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_topic_list_by_type_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_topic_list_by_type_result_params::has_topic_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_topic_list_by_type_result_params::topic_list() const{
 return _m_topic_list;
}
inline void mcp_get_topic_list_by_type_result_params::clear_topic_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_topic_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_topic_list_by_type_result_params::mutable_topic_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_topic_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_topic_list_by_type_result_params::m_topic_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_topic_list);
}
inline size_t mcp_get_topic_list_by_type_result_params::topic_list_size() const{
/*  */ return _m_topic_list.size();
}
inline const char* mcp_get_topic_list_by_type_result_params::topic_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_topic_list.get(i0).get(i1).get(size);
}
inline mcp_get_topic_list_by_type_result_params& mcp_get_topic_list_by_type_result_params::set_topic_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_topic_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_topic_list_by_type_result_params& mcp_get_topic_list_by_type_result_params::set_ptr_topic_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_topic_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_topic_list_by_type_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_topic_list_by_type_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_topic_list_by_type_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_topic_list_by_type_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_topic_list_by_type_response* mcp_get_topic_list_by_type_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_topic_list_by_type_response* tmp=(mcp_get_topic_list_by_type_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_topic_list_by_type_response(pool);
return tmp;
}
inline void mcp_get_topic_list_by_type_response::destroy(mcp_get_topic_list_by_type_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_topic_list_by_type_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_topic_list_by_type_response::mcp_get_topic_list_by_type_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_topic_list_by_type_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_topic_list_by_type_response::mcp_get_topic_list_by_type_response(const mcp_get_topic_list_by_type_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_topic_list_by_type_result_params::create(_pool);
assign(v);
}
inline mcp_get_topic_list_by_type_response::~mcp_get_topic_list_by_type_response(){
if(_m_result_params){
::idl::mcp_get_topic_list_by_type_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_topic_list_by_type_response& mcp_get_topic_list_by_type_response::operator=(const mcp_get_topic_list_by_type_response& v){
assign(v);
return *this;
}
inline void mcp_get_topic_list_by_type_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_topic_list_by_type_response::check() const{
// @@mcp_get_topic_list_by_type_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_topic_list_by_type_result_params& item=const_cast< ::idl::mcp_get_topic_list_by_type_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_topic_list_by_type_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_topic_list_by_type_response& mcp_get_topic_list_by_type_response::assign(const mcp_get_topic_list_by_type_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_topic_list_by_type_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_topic_list_by_type_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_topic_list_by_type_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_topic_list_by_type_result_params& mcp_get_topic_list_by_type_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_topic_list_by_type_result_params* mcp_get_topic_list_by_type_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_topic_list_by_type_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_topic_list_by_type_result_params* mcp_get_topic_list_by_type_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_topic_list_by_type_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_topic_list_by_type_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_topic_list_by_type_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_topic_list_by_type_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_topic_list_by_type_response::unknown(){
return _unknown;
}
inline size_t mcp_get_topic_list_by_type_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_sub_class_by_class_params* mcp_get_sub_class_by_class_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_sub_class_by_class_params* tmp=(mcp_get_sub_class_by_class_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_sub_class_by_class_params(pool);
return tmp;
}
inline void mcp_get_sub_class_by_class_params::destroy(mcp_get_sub_class_by_class_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_sub_class_by_class_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_sub_class_by_class_params::mcp_get_sub_class_by_class_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_class_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_sub_class_by_class_params::mcp_get_sub_class_by_class_params(const mcp_get_sub_class_by_class_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_class_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_sub_class_by_class_params::~mcp_get_sub_class_by_class_params(){
}
inline mcp_get_sub_class_by_class_params& mcp_get_sub_class_by_class_params::operator=(const mcp_get_sub_class_by_class_params& v){
assign(v);
return *this;
}
inline void mcp_get_sub_class_by_class_params::clear(){
_m_class_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_sub_class_by_class_params::check() const{
// @@string class_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}
// @@uint32_t page=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_sub_class_by_class_params::detach(){
_m_class_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_sub_class_by_class_params& mcp_get_sub_class_by_class_params::assign(const mcp_get_sub_class_by_class_params& v){
_m_class_id=v._m_class_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_sub_class_by_class_params::has_class_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_sub_class_by_class_params::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_get_sub_class_by_class_params& mcp_get_sub_class_by_class_params::set_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_sub_class_by_class_params& mcp_get_sub_class_by_class_params::set_ptr_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_sub_class_by_class_params::clear_class_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_class_id.clear();
}
inline bool mcp_get_sub_class_by_class_params::has_page() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_sub_class_by_class_params::page() const{
return _m_page;
}
inline mcp_get_sub_class_by_class_params& mcp_get_sub_class_by_class_params::set_page(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_sub_class_by_class_params::clear_page(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page=0;
}
inline bool mcp_get_sub_class_by_class_params::has_page_size() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_sub_class_by_class_params::page_size() const{
return _m_page_size;
}
inline mcp_get_sub_class_by_class_params& mcp_get_sub_class_by_class_params::set_page_size(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_sub_class_by_class_params::clear_page_size(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_sub_class_by_class_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_sub_class_by_class_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_sub_class_by_class_params::unknown(){
return _unknown;
}
inline size_t mcp_get_sub_class_by_class_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_sub_class_by_class_result_params* mcp_get_sub_class_by_class_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_sub_class_by_class_result_params* tmp=(mcp_get_sub_class_by_class_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_sub_class_by_class_result_params(pool);
return tmp;
}
inline void mcp_get_sub_class_by_class_result_params::destroy(mcp_get_sub_class_by_class_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_sub_class_by_class_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_sub_class_by_class_result_params::mcp_get_sub_class_by_class_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_cooooooount(0)
,_m_sub_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_sub_class_by_class_result_params::mcp_get_sub_class_by_class_result_params(const mcp_get_sub_class_by_class_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_cooooooount(0)
,_m_sub_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_sub_class_by_class_result_params::~mcp_get_sub_class_by_class_result_params(){
}
inline mcp_get_sub_class_by_class_result_params& mcp_get_sub_class_by_class_result_params::operator=(const mcp_get_sub_class_by_class_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_sub_class_by_class_result_params::clear(){
// _m_cooooooount=0;
_m_sub_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_sub_class_by_class_result_params::check() const{
// @@int32_t cooooooount=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cooooooount" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_cooooooount;

}
// @@sub_class_t sub_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "sub_list" << "' not found";
}
{
// level 0 begin
typeof(_m_sub_list)& lr0=(_m_sub_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::sub_class_t& item=const_cast< ::idl::sub_class_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_sub_class_by_class_result_params::detach(){
_m_sub_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_sub_class_by_class_result_params& mcp_get_sub_class_by_class_result_params::assign(const mcp_get_sub_class_by_class_result_params& v){
_m_cooooooount=v._m_cooooooount;
_m_sub_list=v._m_sub_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_sub_class_by_class_result_params::has_cooooooount() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_sub_class_by_class_result_params::cooooooount() const{
return _m_cooooooount;
}
inline mcp_get_sub_class_by_class_result_params& mcp_get_sub_class_by_class_result_params::set_cooooooount(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_cooooooount=v;
return *this;
}
inline void mcp_get_sub_class_by_class_result_params::clear_cooooooount(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_cooooooount=0;
}
inline bool mcp_get_sub_class_by_class_result_params::has_sub_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::sub_class_t >& mcp_get_sub_class_by_class_result_params::sub_list() const{
 return _m_sub_list;
}
inline void mcp_get_sub_class_by_class_result_params::clear_sub_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_sub_list.clear();
}
inline ::idl::vector< ::idl::sub_class_t >* mcp_get_sub_class_by_class_result_params::mutable_sub_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_sub_list);
}
inline ::idl::vector< ::idl::sub_class_t >* mcp_get_sub_class_by_class_result_params::m_sub_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_sub_list);
}
inline size_t mcp_get_sub_class_by_class_result_params::sub_list_size() const{
/*  */ return _m_sub_list.size();
}
inline const ::idl::sub_class_t& mcp_get_sub_class_by_class_result_params::sub_list(size_t i0) const{
 return _m_sub_list.get(i0);
}
inline ::idl::sub_class_t* mcp_get_sub_class_by_class_result_params::mutable_sub_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_sub_list.mutable_get(i0);
}
inline ::idl::sub_class_t* mcp_get_sub_class_by_class_result_params::m_sub_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_sub_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_sub_class_by_class_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_sub_class_by_class_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_sub_class_by_class_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_sub_class_by_class_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_sub_class_by_class_response* mcp_get_sub_class_by_class_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_sub_class_by_class_response* tmp=(mcp_get_sub_class_by_class_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_sub_class_by_class_response(pool);
return tmp;
}
inline void mcp_get_sub_class_by_class_response::destroy(mcp_get_sub_class_by_class_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_sub_class_by_class_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_sub_class_by_class_response::mcp_get_sub_class_by_class_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_sub_class_by_class_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_sub_class_by_class_response::mcp_get_sub_class_by_class_response(const mcp_get_sub_class_by_class_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_sub_class_by_class_result_params::create(_pool);
assign(v);
}
inline mcp_get_sub_class_by_class_response::~mcp_get_sub_class_by_class_response(){
if(_m_result_params){
::idl::mcp_get_sub_class_by_class_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_sub_class_by_class_response& mcp_get_sub_class_by_class_response::operator=(const mcp_get_sub_class_by_class_response& v){
assign(v);
return *this;
}
inline void mcp_get_sub_class_by_class_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_sub_class_by_class_response::check() const{
// @@mcp_get_sub_class_by_class_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_sub_class_by_class_result_params& item=const_cast< ::idl::mcp_get_sub_class_by_class_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_sub_class_by_class_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_sub_class_by_class_response& mcp_get_sub_class_by_class_response::assign(const mcp_get_sub_class_by_class_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_sub_class_by_class_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_sub_class_by_class_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_sub_class_by_class_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_sub_class_by_class_result_params& mcp_get_sub_class_by_class_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_sub_class_by_class_result_params* mcp_get_sub_class_by_class_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_sub_class_by_class_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_sub_class_by_class_result_params* mcp_get_sub_class_by_class_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_sub_class_by_class_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_sub_class_by_class_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_sub_class_by_class_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_sub_class_by_class_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_sub_class_by_class_response::unknown(){
return _unknown;
}
inline size_t mcp_get_sub_class_by_class_response::unknown_size() const{
return _unknown.size();
}
inline mcp_mcp_content_common_init_params* mcp_mcp_content_common_init_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_mcp_content_common_init_params* tmp=(mcp_mcp_content_common_init_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_mcp_content_common_init_params(pool);
return tmp;
}
inline void mcp_mcp_content_common_init_params::destroy(mcp_mcp_content_common_init_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_mcp_content_common_init_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_mcp_content_common_init_params::mcp_mcp_content_common_init_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_mcp_content_common_init_params::mcp_mcp_content_common_init_params(const mcp_mcp_content_common_init_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_unknown(_pool){
assign(v);
}
inline mcp_mcp_content_common_init_params::~mcp_mcp_content_common_init_params(){
}
inline mcp_mcp_content_common_init_params& mcp_mcp_content_common_init_params::operator=(const mcp_mcp_content_common_init_params& v){
assign(v);
return *this;
}
inline void mcp_mcp_content_common_init_params::clear(){
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_mcp_content_common_init_params::check() const{

::idl::McpackBean::check();
}
inline void mcp_mcp_content_common_init_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_mcp_content_common_init_params& mcp_mcp_content_common_init_params::assign(const mcp_mcp_content_common_init_params& v){
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline ::idl::Unknown* mcp_mcp_content_common_init_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_mcp_content_common_init_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_mcp_content_common_init_params::unknown(){
return _unknown;
}
inline size_t mcp_mcp_content_common_init_params::unknown_size() const{
return _unknown.size();
}
inline mcp_mcp_content_common_init_result_params* mcp_mcp_content_common_init_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_mcp_content_common_init_result_params* tmp=(mcp_mcp_content_common_init_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_mcp_content_common_init_result_params(pool);
return tmp;
}
inline void mcp_mcp_content_common_init_result_params::destroy(mcp_mcp_content_common_init_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_mcp_content_common_init_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_mcp_content_common_init_result_params::mcp_mcp_content_common_init_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_mcp_content_common_init_result_params::mcp_mcp_content_common_init_result_params(const mcp_mcp_content_common_init_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_unknown(_pool){
assign(v);
}
inline mcp_mcp_content_common_init_result_params::~mcp_mcp_content_common_init_result_params(){
}
inline mcp_mcp_content_common_init_result_params& mcp_mcp_content_common_init_result_params::operator=(const mcp_mcp_content_common_init_result_params& v){
assign(v);
return *this;
}
inline void mcp_mcp_content_common_init_result_params::clear(){
// _m_result=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_mcp_content_common_init_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}

::idl::McpackBean::check();
}
inline void mcp_mcp_content_common_init_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_mcp_content_common_init_result_params& mcp_mcp_content_common_init_result_params::assign(const mcp_mcp_content_common_init_result_params& v){
_m_result=v._m_result;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_mcp_content_common_init_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_mcp_content_common_init_result_params::result() const{
return _m_result;
}
inline mcp_mcp_content_common_init_result_params& mcp_mcp_content_common_init_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_mcp_content_common_init_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline ::idl::Unknown* mcp_mcp_content_common_init_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_mcp_content_common_init_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_mcp_content_common_init_result_params::unknown(){
return _unknown;
}
inline size_t mcp_mcp_content_common_init_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_mcp_content_common_init_response* mcp_mcp_content_common_init_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_mcp_content_common_init_response* tmp=(mcp_mcp_content_common_init_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_mcp_content_common_init_response(pool);
return tmp;
}
inline void mcp_mcp_content_common_init_response::destroy(mcp_mcp_content_common_init_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_mcp_content_common_init_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_mcp_content_common_init_response::mcp_mcp_content_common_init_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_mcp_content_common_init_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_mcp_content_common_init_response::mcp_mcp_content_common_init_response(const mcp_mcp_content_common_init_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_mcp_content_common_init_result_params::create(_pool);
assign(v);
}
inline mcp_mcp_content_common_init_response::~mcp_mcp_content_common_init_response(){
if(_m_result_params){
::idl::mcp_mcp_content_common_init_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_mcp_content_common_init_response& mcp_mcp_content_common_init_response::operator=(const mcp_mcp_content_common_init_response& v){
assign(v);
return *this;
}
inline void mcp_mcp_content_common_init_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_mcp_content_common_init_response::check() const{
// @@mcp_mcp_content_common_init_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_mcp_content_common_init_result_params& item=const_cast< ::idl::mcp_mcp_content_common_init_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_mcp_content_common_init_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_mcp_content_common_init_response& mcp_mcp_content_common_init_response::assign(const mcp_mcp_content_common_init_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_mcp_content_common_init_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_mcp_content_common_init_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_mcp_content_common_init_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_mcp_content_common_init_result_params& mcp_mcp_content_common_init_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_mcp_content_common_init_result_params* mcp_mcp_content_common_init_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_mcp_content_common_init_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_mcp_content_common_init_result_params* mcp_mcp_content_common_init_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_mcp_content_common_init_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_mcp_content_common_init_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_mcp_content_common_init_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_mcp_content_common_init_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_mcp_content_common_init_response::unknown(){
return _unknown;
}
inline size_t mcp_mcp_content_common_init_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_area_by_phone_num_params* mcp_get_phone_area_by_phone_num_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_area_by_phone_num_params* tmp=(mcp_get_phone_area_by_phone_num_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_area_by_phone_num_params(pool);
return tmp;
}
inline void mcp_get_phone_area_by_phone_num_params::destroy(mcp_get_phone_area_by_phone_num_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_area_by_phone_num_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_area_by_phone_num_params::mcp_get_phone_area_by_phone_num_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_phone_num(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_area_by_phone_num_params::mcp_get_phone_area_by_phone_num_params(const mcp_get_phone_area_by_phone_num_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_phone_num(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_area_by_phone_num_params::~mcp_get_phone_area_by_phone_num_params(){
}
inline mcp_get_phone_area_by_phone_num_params& mcp_get_phone_area_by_phone_num_params::operator=(const mcp_get_phone_area_by_phone_num_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_area_by_phone_num_params::clear(){
_m_phone_num.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_area_by_phone_num_params::check() const{
// @@string phone_num=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone_num" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_phone_num.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_area_by_phone_num_params::detach(){
_m_phone_num.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_area_by_phone_num_params& mcp_get_phone_area_by_phone_num_params::assign(const mcp_get_phone_area_by_phone_num_params& v){
_m_phone_num=v._m_phone_num;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_area_by_phone_num_params::has_phone_num() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_phone_area_by_phone_num_params::phone_num(unsigned int* size) const{
return _m_phone_num.get(size);
}
inline mcp_get_phone_area_by_phone_num_params& mcp_get_phone_area_by_phone_num_params::set_phone_num(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_phone_num.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_area_by_phone_num_params& mcp_get_phone_area_by_phone_num_params::set_ptr_phone_num(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_phone_num.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_area_by_phone_num_params::clear_phone_num(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_phone_num.clear();
}
inline ::idl::Unknown* mcp_get_phone_area_by_phone_num_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_area_by_phone_num_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_area_by_phone_num_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_area_by_phone_num_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_area_by_phone_num_result_params* mcp_get_phone_area_by_phone_num_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_area_by_phone_num_result_params* tmp=(mcp_get_phone_area_by_phone_num_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_area_by_phone_num_result_params(pool);
return tmp;
}
inline void mcp_get_phone_area_by_phone_num_result_params::destroy(mcp_get_phone_area_by_phone_num_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_area_by_phone_num_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_area_by_phone_num_result_params::mcp_get_phone_area_by_phone_num_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_numseg(_pool)
,_m_result(_pool)
,_m_type(_pool)
,_m_oid(_pool)
,_m_provice(_pool)
,_m_city(_pool)
,_m_code(_pool)
,_m_enabled(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_area_by_phone_num_result_params::mcp_get_phone_area_by_phone_num_result_params(const mcp_get_phone_area_by_phone_num_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_numseg(_pool)
,_m_result(_pool)
,_m_type(_pool)
,_m_oid(_pool)
,_m_provice(_pool)
,_m_city(_pool)
,_m_code(_pool)
,_m_enabled(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_phone_area_by_phone_num_result_params::~mcp_get_phone_area_by_phone_num_result_params(){
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::operator=(const mcp_get_phone_area_by_phone_num_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_phone_area_by_phone_num_result_params::clear(){
_m_numseg.clear();
_m_result.clear();
_m_type.clear();
_m_oid.clear();
_m_provice.clear();
_m_city.clear();
_m_code.clear();
_m_enabled.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_area_by_phone_num_result_params::check() const{
// @@string numseg=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "numseg" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_numseg.get();

}
// @@string result=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_result.get();

}
// @@string type=out();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type.get();

}
// @@string oid=out();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "oid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_oid.get();

}
// @@string provice=out();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "provice" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_provice.get();

}
// @@string city=out();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "city" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_city.get();

}
// @@string code=out();
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "code" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_code.get();

}
// @@string enabled=out();
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "enabled" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_enabled.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_area_by_phone_num_result_params::detach(){
_m_numseg.detach();
_m_result.detach();
_m_type.detach();
_m_oid.detach();
_m_provice.detach();
_m_city.detach();
_m_code.detach();
_m_enabled.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::assign(const mcp_get_phone_area_by_phone_num_result_params& v){
_m_numseg=v._m_numseg;
_m_result=v._m_result;
_m_type=v._m_type;
_m_oid=v._m_oid;
_m_provice=v._m_provice;
_m_city=v._m_city;
_m_code=v._m_code;
_m_enabled=v._m_enabled;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_area_by_phone_num_result_params::has_numseg() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_phone_area_by_phone_num_result_params::numseg(unsigned int* size) const{
return _m_numseg.get(size);
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_numseg(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_numseg.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_ptr_numseg(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_numseg.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_area_by_phone_num_result_params::clear_numseg(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_numseg.clear();
}
inline bool mcp_get_phone_area_by_phone_num_result_params::has_result() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_phone_area_by_phone_num_result_params::result(unsigned int* size) const{
return _m_result.get(size);
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_result(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_result.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_ptr_result(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_result.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_area_by_phone_num_result_params::clear_result(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_result.clear();
}
inline bool mcp_get_phone_area_by_phone_num_result_params::has_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_phone_area_by_phone_num_result_params::type(unsigned int* size) const{
return _m_type.get(size);
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_ptr_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_area_by_phone_num_result_params::clear_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_type.clear();
}
inline bool mcp_get_phone_area_by_phone_num_result_params::has_oid() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_phone_area_by_phone_num_result_params::oid(unsigned int* size) const{
return _m_oid.get(size);
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_oid(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_oid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_ptr_oid(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_oid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_area_by_phone_num_result_params::clear_oid(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_oid.clear();
}
inline bool mcp_get_phone_area_by_phone_num_result_params::has_provice() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_get_phone_area_by_phone_num_result_params::provice(unsigned int* size) const{
return _m_provice.get(size);
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_provice(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_provice.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_ptr_provice(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_provice.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_area_by_phone_num_result_params::clear_provice(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_provice.clear();
}
inline bool mcp_get_phone_area_by_phone_num_result_params::has_city() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* mcp_get_phone_area_by_phone_num_result_params::city(unsigned int* size) const{
return _m_city.get(size);
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_city(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_city.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_ptr_city(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_city.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_area_by_phone_num_result_params::clear_city(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_city.clear();
}
inline bool mcp_get_phone_area_by_phone_num_result_params::has_code() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* mcp_get_phone_area_by_phone_num_result_params::code(unsigned int* size) const{
return _m_code.get(size);
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_code(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_code.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_ptr_code(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_code.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_area_by_phone_num_result_params::clear_code(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_code.clear();
}
inline bool mcp_get_phone_area_by_phone_num_result_params::has_enabled() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* mcp_get_phone_area_by_phone_num_result_params::enabled(unsigned int* size) const{
return _m_enabled.get(size);
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_enabled(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_enabled.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_result_params::set_ptr_enabled(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_enabled.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_phone_area_by_phone_num_result_params::clear_enabled(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_enabled.clear();
}
inline ::idl::Unknown* mcp_get_phone_area_by_phone_num_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_area_by_phone_num_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_area_by_phone_num_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_area_by_phone_num_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_phone_area_by_phone_num_response* mcp_get_phone_area_by_phone_num_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_phone_area_by_phone_num_response* tmp=(mcp_get_phone_area_by_phone_num_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_phone_area_by_phone_num_response(pool);
return tmp;
}
inline void mcp_get_phone_area_by_phone_num_response::destroy(mcp_get_phone_area_by_phone_num_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_phone_area_by_phone_num_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_phone_area_by_phone_num_response::mcp_get_phone_area_by_phone_num_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_area_by_phone_num_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_phone_area_by_phone_num_response::mcp_get_phone_area_by_phone_num_response(const mcp_get_phone_area_by_phone_num_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_phone_area_by_phone_num_result_params::create(_pool);
assign(v);
}
inline mcp_get_phone_area_by_phone_num_response::~mcp_get_phone_area_by_phone_num_response(){
if(_m_result_params){
::idl::mcp_get_phone_area_by_phone_num_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_phone_area_by_phone_num_response& mcp_get_phone_area_by_phone_num_response::operator=(const mcp_get_phone_area_by_phone_num_response& v){
assign(v);
return *this;
}
inline void mcp_get_phone_area_by_phone_num_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_phone_area_by_phone_num_response::check() const{
// @@mcp_get_phone_area_by_phone_num_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_phone_area_by_phone_num_result_params& item=const_cast< ::idl::mcp_get_phone_area_by_phone_num_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_phone_area_by_phone_num_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_phone_area_by_phone_num_response& mcp_get_phone_area_by_phone_num_response::assign(const mcp_get_phone_area_by_phone_num_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_phone_area_by_phone_num_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_area_by_phone_num_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_phone_area_by_phone_num_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_phone_area_by_phone_num_result_params& mcp_get_phone_area_by_phone_num_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_phone_area_by_phone_num_result_params* mcp_get_phone_area_by_phone_num_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_area_by_phone_num_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_phone_area_by_phone_num_result_params* mcp_get_phone_area_by_phone_num_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_phone_area_by_phone_num_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_phone_area_by_phone_num_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_phone_area_by_phone_num_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_phone_area_by_phone_num_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_phone_area_by_phone_num_response::unknown(){
return _unknown;
}
inline size_t mcp_get_phone_area_by_phone_num_response::unknown_size() const{
return _unknown.size();
}
inline mcp_reload_config_by_id_params* mcp_reload_config_by_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_reload_config_by_id_params* tmp=(mcp_reload_config_by_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_reload_config_by_id_params(pool);
return tmp;
}
inline void mcp_reload_config_by_id_params::destroy(mcp_reload_config_by_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_reload_config_by_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_reload_config_by_id_params::mcp_reload_config_by_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_reload_id(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_reload_config_by_id_params::mcp_reload_config_by_id_params(const mcp_reload_config_by_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_reload_id(0)
,_unknown(_pool){
assign(v);
}
inline mcp_reload_config_by_id_params::~mcp_reload_config_by_id_params(){
}
inline mcp_reload_config_by_id_params& mcp_reload_config_by_id_params::operator=(const mcp_reload_config_by_id_params& v){
assign(v);
return *this;
}
inline void mcp_reload_config_by_id_params::clear(){
// _m_reload_id=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_reload_config_by_id_params::check() const{
// @@uint32_t reload_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "reload_id" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_reload_id;

}

::idl::McpackBean::check();
}
inline void mcp_reload_config_by_id_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_reload_config_by_id_params& mcp_reload_config_by_id_params::assign(const mcp_reload_config_by_id_params& v){
_m_reload_id=v._m_reload_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_reload_config_by_id_params::has_reload_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_reload_config_by_id_params::reload_id() const{
return _m_reload_id;
}
inline mcp_reload_config_by_id_params& mcp_reload_config_by_id_params::set_reload_id(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_reload_id=v;
return *this;
}
inline void mcp_reload_config_by_id_params::clear_reload_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_reload_id=0;
}
inline ::idl::Unknown* mcp_reload_config_by_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_reload_config_by_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_reload_config_by_id_params::unknown(){
return _unknown;
}
inline size_t mcp_reload_config_by_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_reload_config_by_id_result_params* mcp_reload_config_by_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_reload_config_by_id_result_params* tmp=(mcp_reload_config_by_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_reload_config_by_id_result_params(pool);
return tmp;
}
inline void mcp_reload_config_by_id_result_params::destroy(mcp_reload_config_by_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_reload_config_by_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_reload_config_by_id_result_params::mcp_reload_config_by_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_reload_config_by_id_result_params::mcp_reload_config_by_id_result_params(const mcp_reload_config_by_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_unknown(_pool){
assign(v);
}
inline mcp_reload_config_by_id_result_params::~mcp_reload_config_by_id_result_params(){
}
inline mcp_reload_config_by_id_result_params& mcp_reload_config_by_id_result_params::operator=(const mcp_reload_config_by_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_reload_config_by_id_result_params::clear(){
// _m_result=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_reload_config_by_id_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}

::idl::McpackBean::check();
}
inline void mcp_reload_config_by_id_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_reload_config_by_id_result_params& mcp_reload_config_by_id_result_params::assign(const mcp_reload_config_by_id_result_params& v){
_m_result=v._m_result;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_reload_config_by_id_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_reload_config_by_id_result_params::result() const{
return _m_result;
}
inline mcp_reload_config_by_id_result_params& mcp_reload_config_by_id_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_reload_config_by_id_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline ::idl::Unknown* mcp_reload_config_by_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_reload_config_by_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_reload_config_by_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_reload_config_by_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_reload_config_by_id_response* mcp_reload_config_by_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_reload_config_by_id_response* tmp=(mcp_reload_config_by_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_reload_config_by_id_response(pool);
return tmp;
}
inline void mcp_reload_config_by_id_response::destroy(mcp_reload_config_by_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_reload_config_by_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_reload_config_by_id_response::mcp_reload_config_by_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_reload_config_by_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_reload_config_by_id_response::mcp_reload_config_by_id_response(const mcp_reload_config_by_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_reload_config_by_id_result_params::create(_pool);
assign(v);
}
inline mcp_reload_config_by_id_response::~mcp_reload_config_by_id_response(){
if(_m_result_params){
::idl::mcp_reload_config_by_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_reload_config_by_id_response& mcp_reload_config_by_id_response::operator=(const mcp_reload_config_by_id_response& v){
assign(v);
return *this;
}
inline void mcp_reload_config_by_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_reload_config_by_id_response::check() const{
// @@mcp_reload_config_by_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_reload_config_by_id_result_params& item=const_cast< ::idl::mcp_reload_config_by_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_reload_config_by_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_reload_config_by_id_response& mcp_reload_config_by_id_response::assign(const mcp_reload_config_by_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_reload_config_by_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_reload_config_by_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_reload_config_by_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_reload_config_by_id_result_params& mcp_reload_config_by_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_reload_config_by_id_result_params* mcp_reload_config_by_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_reload_config_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_reload_config_by_id_result_params* mcp_reload_config_by_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_reload_config_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_reload_config_by_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_reload_config_by_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_reload_config_by_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_reload_config_by_id_response::unknown(){
return _unknown;
}
inline size_t mcp_reload_config_by_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_id_params* mcp_get_ios_content_by_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_id_params* tmp=(mcp_get_ios_content_by_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_id_params(pool);
return tmp;
}
inline void mcp_get_ios_content_by_id_params::destroy(mcp_get_ios_content_by_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_id_params::mcp_get_ios_content_by_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_id_params::mcp_get_ios_content_by_id_params(const mcp_get_ios_content_by_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_ios_content_by_id_params::~mcp_get_ios_content_by_id_params(){
}
inline mcp_get_ios_content_by_id_params& mcp_get_ios_content_by_id_params::operator=(const mcp_get_ios_content_by_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_id_params::clear(){
_m_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_id_params::check() const{
// @@string id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_id_params::detach(){
_m_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_id_params& mcp_get_ios_content_by_id_params::assign(const mcp_get_ios_content_by_id_params& v){
_m_id=v._m_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_id_params::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_ios_content_by_id_params::id(unsigned int* size) const{
return _m_id.get(size);
}
inline mcp_get_ios_content_by_id_params& mcp_get_ios_content_by_id_params::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_ios_content_by_id_params& mcp_get_ios_content_by_id_params::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_ios_content_by_id_params::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline ::idl::Unknown* mcp_get_ios_content_by_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_id_result_params* mcp_get_ios_content_by_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_id_result_params* tmp=(mcp_get_ios_content_by_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_id_result_params(pool);
return tmp;
}
inline void mcp_get_ios_content_by_id_result_params::destroy(mcp_get_ios_content_by_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_id_result_params::mcp_get_ios_content_by_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_info(0)
,_unknown(_pool){
_m_info=::idl::ios_content_info_t::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_id_result_params::mcp_get_ios_content_by_id_result_params(const mcp_get_ios_content_by_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_info(0)
,_unknown(_pool){
_m_info=::idl::ios_content_info_t::create(_pool);
assign(v);
}
inline mcp_get_ios_content_by_id_result_params::~mcp_get_ios_content_by_id_result_params(){
if(_m_info){
::idl::ios_content_info_t::destroy(_m_info);
_m_info=0;
}
}
inline mcp_get_ios_content_by_id_result_params& mcp_get_ios_content_by_id_result_params::operator=(const mcp_get_ios_content_by_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_id_result_params::clear(){
// _m_result=0;
if(_m_info){
_m_info->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_id_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}
// @@ios_content_info_t info=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info" << "' not found";
}
{
::idl::ios_content_info_t& item=const_cast< ::idl::ios_content_info_t& >(*_m_info);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_id_result_params::detach(){
if(_m_info){
_m_info->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_id_result_params& mcp_get_ios_content_by_id_result_params::assign(const mcp_get_ios_content_by_id_result_params& v){
_m_result=v._m_result;
if(!v._m_info){
if(_m_info){
::idl::ios_content_info_t::destroy(_m_info);
}
_m_info=0;
}else{
if(!_m_info){
_m_info=::idl::ios_content_info_t::create(_pool);
}
*_m_info=*v._m_info;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_id_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_ios_content_by_id_result_params::result() const{
return _m_result;
}
inline mcp_get_ios_content_by_id_result_params& mcp_get_ios_content_by_id_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_get_ios_content_by_id_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_get_ios_content_by_id_result_params::has_info() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::ios_content_info_t& mcp_get_ios_content_by_id_result_params::info() const{
 return *_m_info;
}
inline ::idl::ios_content_info_t* mcp_get_ios_content_by_id_result_params::mutable_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 if(!_m_info){
_m_info=::idl::ios_content_info_t::create(_pool);
}
return _m_info;
}
inline ::idl::ios_content_info_t* mcp_get_ios_content_by_id_result_params::m_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 if(!_m_info){
_m_info=::idl::ios_content_info_t::create(_pool);
}
return _m_info;
}
inline void mcp_get_ios_content_by_id_result_params::clear_info(){
if(_m_info){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info->clear();
}
}
inline ::idl::Unknown* mcp_get_ios_content_by_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_id_response* mcp_get_ios_content_by_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_id_response* tmp=(mcp_get_ios_content_by_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_id_response(pool);
return tmp;
}
inline void mcp_get_ios_content_by_id_response::destroy(mcp_get_ios_content_by_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_id_response::mcp_get_ios_content_by_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ios_content_by_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_id_response::mcp_get_ios_content_by_id_response(const mcp_get_ios_content_by_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ios_content_by_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_ios_content_by_id_response::~mcp_get_ios_content_by_id_response(){
if(_m_result_params){
::idl::mcp_get_ios_content_by_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_ios_content_by_id_response& mcp_get_ios_content_by_id_response::operator=(const mcp_get_ios_content_by_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_id_response::check() const{
// @@mcp_get_ios_content_by_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_ios_content_by_id_result_params& item=const_cast< ::idl::mcp_get_ios_content_by_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_id_response& mcp_get_ios_content_by_id_response::assign(const mcp_get_ios_content_by_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_ios_content_by_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_ios_content_by_id_result_params& mcp_get_ios_content_by_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_ios_content_by_id_result_params* mcp_get_ios_content_by_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_ios_content_by_id_result_params* mcp_get_ios_content_by_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_ios_content_by_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_ios_content_by_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_class_id_params* mcp_get_ios_content_by_class_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_class_id_params* tmp=(mcp_get_ios_content_by_class_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_class_id_params(pool);
return tmp;
}
inline void mcp_get_ios_content_by_class_id_params::destroy(mcp_get_ios_content_by_class_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_class_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_class_id_params::mcp_get_ios_content_by_class_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_class_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_m_for_free(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_class_id_params::mcp_get_ios_content_by_class_id_params(const mcp_get_ios_content_by_class_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_class_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_m_for_free(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_ios_content_by_class_id_params::~mcp_get_ios_content_by_class_id_params(){
}
inline mcp_get_ios_content_by_class_id_params& mcp_get_ios_content_by_class_id_params::operator=(const mcp_get_ios_content_by_class_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_class_id_params::clear(){
_m_class_id.clear();
_m_type_id.clear();
// _m_orderby=0;
// _m_page=0;
// _m_page_size=0;
// _m_for_free=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_class_id_params::check() const{
// @@string class_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}
// @@string type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t orderby=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "orderby" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_orderby;

}
// @@uint32_t page=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}
// @@uint32_t for_free=in(),default(0);
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "for_free" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_for_free;

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_class_id_params::detach(){
_m_class_id.detach();
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_class_id_params& mcp_get_ios_content_by_class_id_params::assign(const mcp_get_ios_content_by_class_id_params& v){
_m_class_id=v._m_class_id;
_m_type_id=v._m_type_id;
_m_orderby=v._m_orderby;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_m_for_free=v._m_for_free;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_class_id_params::has_class_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_ios_content_by_class_id_params::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_get_ios_content_by_class_id_params& mcp_get_ios_content_by_class_id_params::set_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_ios_content_by_class_id_params& mcp_get_ios_content_by_class_id_params::set_ptr_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_ios_content_by_class_id_params::clear_class_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_class_id.clear();
}
inline bool mcp_get_ios_content_by_class_id_params::has_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_ios_content_by_class_id_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_ios_content_by_class_id_params& mcp_get_ios_content_by_class_id_params::set_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_ios_content_by_class_id_params& mcp_get_ios_content_by_class_id_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_ios_content_by_class_id_params::clear_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_ios_content_by_class_id_params::has_orderby() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_class_id_params::orderby() const{
return _m_orderby;
}
inline mcp_get_ios_content_by_class_id_params& mcp_get_ios_content_by_class_id_params::set_orderby(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_orderby=v;
return *this;
}
inline void mcp_get_ios_content_by_class_id_params::clear_orderby(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_orderby=0;
}
inline bool mcp_get_ios_content_by_class_id_params::has_page() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_class_id_params::page() const{
return _m_page;
}
inline mcp_get_ios_content_by_class_id_params& mcp_get_ios_content_by_class_id_params::set_page(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_ios_content_by_class_id_params::clear_page(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page=0;
}
inline bool mcp_get_ios_content_by_class_id_params::has_page_size() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_class_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_ios_content_by_class_id_params& mcp_get_ios_content_by_class_id_params::set_page_size(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_ios_content_by_class_id_params::clear_page_size(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_page_size=0;
}
inline bool mcp_get_ios_content_by_class_id_params::has_for_free() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_class_id_params::for_free() const{
return _m_for_free;
}
inline mcp_get_ios_content_by_class_id_params& mcp_get_ios_content_by_class_id_params::set_for_free(uint32_t v){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_for_free=v;
return *this;
}
inline void mcp_get_ios_content_by_class_id_params::clear_for_free(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_for_free=0;
}
inline ::idl::Unknown* mcp_get_ios_content_by_class_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_class_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_class_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_class_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_class_id_result_params* mcp_get_ios_content_by_class_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_class_id_result_params* tmp=(mcp_get_ios_content_by_class_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_class_id_result_params(pool);
return tmp;
}
inline void mcp_get_ios_content_by_class_id_result_params::destroy(mcp_get_ios_content_by_class_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_class_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_class_id_result_params::mcp_get_ios_content_by_class_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_class_id_result_params::mcp_get_ios_content_by_class_id_result_params(const mcp_get_ios_content_by_class_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_ios_content_by_class_id_result_params::~mcp_get_ios_content_by_class_id_result_params(){
}
inline mcp_get_ios_content_by_class_id_result_params& mcp_get_ios_content_by_class_id_result_params::operator=(const mcp_get_ios_content_by_class_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_class_id_result_params::clear(){
// _m_count=0;
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_class_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@ios_content_info_t info_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::ios_content_info_t& item=const_cast< ::idl::ios_content_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_class_id_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_class_id_result_params& mcp_get_ios_content_by_class_id_result_params::assign(const mcp_get_ios_content_by_class_id_result_params& v){
_m_count=v._m_count;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_class_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_ios_content_by_class_id_result_params::count() const{
return _m_count;
}
inline mcp_get_ios_content_by_class_id_result_params& mcp_get_ios_content_by_class_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_ios_content_by_class_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_ios_content_by_class_id_result_params::has_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::ios_content_info_t >& mcp_get_ios_content_by_class_id_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_ios_content_by_class_id_result_params::clear_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::ios_content_info_t >* mcp_get_ios_content_by_class_id_result_params::mutable_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::ios_content_info_t >* mcp_get_ios_content_by_class_id_result_params::m_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_ios_content_by_class_id_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const ::idl::ios_content_info_t& mcp_get_ios_content_by_class_id_result_params::info_list(size_t i0) const{
 return _m_info_list.get(i0);
}
inline ::idl::ios_content_info_t* mcp_get_ios_content_by_class_id_result_params::mutable_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::ios_content_info_t* mcp_get_ios_content_by_class_id_result_params::m_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_ios_content_by_class_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_class_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_class_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_class_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_class_id_response* mcp_get_ios_content_by_class_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_class_id_response* tmp=(mcp_get_ios_content_by_class_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_class_id_response(pool);
return tmp;
}
inline void mcp_get_ios_content_by_class_id_response::destroy(mcp_get_ios_content_by_class_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_class_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_class_id_response::mcp_get_ios_content_by_class_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ios_content_by_class_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_class_id_response::mcp_get_ios_content_by_class_id_response(const mcp_get_ios_content_by_class_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ios_content_by_class_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_ios_content_by_class_id_response::~mcp_get_ios_content_by_class_id_response(){
if(_m_result_params){
::idl::mcp_get_ios_content_by_class_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_ios_content_by_class_id_response& mcp_get_ios_content_by_class_id_response::operator=(const mcp_get_ios_content_by_class_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_class_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_class_id_response::check() const{
// @@mcp_get_ios_content_by_class_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_ios_content_by_class_id_result_params& item=const_cast< ::idl::mcp_get_ios_content_by_class_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_class_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_class_id_response& mcp_get_ios_content_by_class_id_response::assign(const mcp_get_ios_content_by_class_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_ios_content_by_class_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_class_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_class_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_ios_content_by_class_id_result_params& mcp_get_ios_content_by_class_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_ios_content_by_class_id_result_params* mcp_get_ios_content_by_class_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_class_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_ios_content_by_class_id_result_params* mcp_get_ios_content_by_class_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_class_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_ios_content_by_class_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_ios_content_by_class_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_class_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_class_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_class_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_cp_id_params* mcp_get_ios_content_by_cp_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_cp_id_params* tmp=(mcp_get_ios_content_by_cp_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_cp_id_params(pool);
return tmp;
}
inline void mcp_get_ios_content_by_cp_id_params::destroy(mcp_get_ios_content_by_cp_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_cp_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_cp_id_params::mcp_get_ios_content_by_cp_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_cp_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_cp_id_params::mcp_get_ios_content_by_cp_id_params(const mcp_get_ios_content_by_cp_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_cp_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_ios_content_by_cp_id_params::~mcp_get_ios_content_by_cp_id_params(){
}
inline mcp_get_ios_content_by_cp_id_params& mcp_get_ios_content_by_cp_id_params::operator=(const mcp_get_ios_content_by_cp_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_cp_id_params::clear(){
_m_cp_id.clear();
_m_type_id.clear();
// _m_orderby=0;
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_cp_id_params::check() const{
// @@string cp_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cp_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_cp_id.get();

}
// @@string type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t orderby=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "orderby" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_orderby;

}
// @@uint32_t page=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_cp_id_params::detach(){
_m_cp_id.detach();
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_cp_id_params& mcp_get_ios_content_by_cp_id_params::assign(const mcp_get_ios_content_by_cp_id_params& v){
_m_cp_id=v._m_cp_id;
_m_type_id=v._m_type_id;
_m_orderby=v._m_orderby;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_cp_id_params::has_cp_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_ios_content_by_cp_id_params::cp_id(unsigned int* size) const{
return _m_cp_id.get(size);
}
inline mcp_get_ios_content_by_cp_id_params& mcp_get_ios_content_by_cp_id_params::set_cp_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_cp_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_ios_content_by_cp_id_params& mcp_get_ios_content_by_cp_id_params::set_ptr_cp_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_cp_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_ios_content_by_cp_id_params::clear_cp_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_cp_id.clear();
}
inline bool mcp_get_ios_content_by_cp_id_params::has_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_ios_content_by_cp_id_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_ios_content_by_cp_id_params& mcp_get_ios_content_by_cp_id_params::set_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_ios_content_by_cp_id_params& mcp_get_ios_content_by_cp_id_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_ios_content_by_cp_id_params::clear_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_ios_content_by_cp_id_params::has_orderby() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_cp_id_params::orderby() const{
return _m_orderby;
}
inline mcp_get_ios_content_by_cp_id_params& mcp_get_ios_content_by_cp_id_params::set_orderby(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_orderby=v;
return *this;
}
inline void mcp_get_ios_content_by_cp_id_params::clear_orderby(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_orderby=0;
}
inline bool mcp_get_ios_content_by_cp_id_params::has_page() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_cp_id_params::page() const{
return _m_page;
}
inline mcp_get_ios_content_by_cp_id_params& mcp_get_ios_content_by_cp_id_params::set_page(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_ios_content_by_cp_id_params::clear_page(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page=0;
}
inline bool mcp_get_ios_content_by_cp_id_params::has_page_size() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_cp_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_ios_content_by_cp_id_params& mcp_get_ios_content_by_cp_id_params::set_page_size(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_ios_content_by_cp_id_params::clear_page_size(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_ios_content_by_cp_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_cp_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_cp_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_cp_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_cp_id_result_params* mcp_get_ios_content_by_cp_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_cp_id_result_params* tmp=(mcp_get_ios_content_by_cp_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_cp_id_result_params(pool);
return tmp;
}
inline void mcp_get_ios_content_by_cp_id_result_params::destroy(mcp_get_ios_content_by_cp_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_cp_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_cp_id_result_params::mcp_get_ios_content_by_cp_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_cp_name(_pool)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_cp_id_result_params::mcp_get_ios_content_by_cp_id_result_params(const mcp_get_ios_content_by_cp_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_cp_name(_pool)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_ios_content_by_cp_id_result_params::~mcp_get_ios_content_by_cp_id_result_params(){
}
inline mcp_get_ios_content_by_cp_id_result_params& mcp_get_ios_content_by_cp_id_result_params::operator=(const mcp_get_ios_content_by_cp_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_cp_id_result_params::clear(){
// _m_count=0;
_m_cp_name.clear();
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_cp_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string cp_name=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cp_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_cp_name.get();

}
// @@ios_content_info_t info_list=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::ios_content_info_t& item=const_cast< ::idl::ios_content_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_cp_id_result_params::detach(){
_m_cp_name.detach();
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_cp_id_result_params& mcp_get_ios_content_by_cp_id_result_params::assign(const mcp_get_ios_content_by_cp_id_result_params& v){
_m_count=v._m_count;
_m_cp_name=v._m_cp_name;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_cp_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_ios_content_by_cp_id_result_params::count() const{
return _m_count;
}
inline mcp_get_ios_content_by_cp_id_result_params& mcp_get_ios_content_by_cp_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_ios_content_by_cp_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_ios_content_by_cp_id_result_params::has_cp_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_ios_content_by_cp_id_result_params::cp_name(unsigned int* size) const{
return _m_cp_name.get(size);
}
inline mcp_get_ios_content_by_cp_id_result_params& mcp_get_ios_content_by_cp_id_result_params::set_cp_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_cp_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_ios_content_by_cp_id_result_params& mcp_get_ios_content_by_cp_id_result_params::set_ptr_cp_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_cp_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_ios_content_by_cp_id_result_params::clear_cp_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_cp_name.clear();
}
inline bool mcp_get_ios_content_by_cp_id_result_params::has_info_list() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::ios_content_info_t >& mcp_get_ios_content_by_cp_id_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_ios_content_by_cp_id_result_params::clear_info_list(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::ios_content_info_t >* mcp_get_ios_content_by_cp_id_result_params::mutable_info_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::ios_content_info_t >* mcp_get_ios_content_by_cp_id_result_params::m_info_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_ios_content_by_cp_id_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const ::idl::ios_content_info_t& mcp_get_ios_content_by_cp_id_result_params::info_list(size_t i0) const{
 return _m_info_list.get(i0);
}
inline ::idl::ios_content_info_t* mcp_get_ios_content_by_cp_id_result_params::mutable_info_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::ios_content_info_t* mcp_get_ios_content_by_cp_id_result_params::m_info_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_ios_content_by_cp_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_cp_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_cp_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_cp_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_cp_id_response* mcp_get_ios_content_by_cp_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_cp_id_response* tmp=(mcp_get_ios_content_by_cp_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_cp_id_response(pool);
return tmp;
}
inline void mcp_get_ios_content_by_cp_id_response::destroy(mcp_get_ios_content_by_cp_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_cp_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_cp_id_response::mcp_get_ios_content_by_cp_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ios_content_by_cp_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_cp_id_response::mcp_get_ios_content_by_cp_id_response(const mcp_get_ios_content_by_cp_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ios_content_by_cp_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_ios_content_by_cp_id_response::~mcp_get_ios_content_by_cp_id_response(){
if(_m_result_params){
::idl::mcp_get_ios_content_by_cp_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_ios_content_by_cp_id_response& mcp_get_ios_content_by_cp_id_response::operator=(const mcp_get_ios_content_by_cp_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_cp_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_cp_id_response::check() const{
// @@mcp_get_ios_content_by_cp_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_ios_content_by_cp_id_result_params& item=const_cast< ::idl::mcp_get_ios_content_by_cp_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_cp_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_cp_id_response& mcp_get_ios_content_by_cp_id_response::assign(const mcp_get_ios_content_by_cp_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_ios_content_by_cp_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_cp_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_cp_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_ios_content_by_cp_id_result_params& mcp_get_ios_content_by_cp_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_ios_content_by_cp_id_result_params* mcp_get_ios_content_by_cp_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_cp_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_ios_content_by_cp_id_result_params* mcp_get_ios_content_by_cp_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_cp_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_ios_content_by_cp_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_ios_content_by_cp_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_cp_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_cp_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_cp_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_col_id_params* mcp_get_ios_content_by_col_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_col_id_params* tmp=(mcp_get_ios_content_by_col_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_col_id_params(pool);
return tmp;
}
inline void mcp_get_ios_content_by_col_id_params::destroy(mcp_get_ios_content_by_col_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_col_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_col_id_params::mcp_get_ios_content_by_col_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_column_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_col_id_params::mcp_get_ios_content_by_col_id_params(const mcp_get_ios_content_by_col_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_column_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_ios_content_by_col_id_params::~mcp_get_ios_content_by_col_id_params(){
}
inline mcp_get_ios_content_by_col_id_params& mcp_get_ios_content_by_col_id_params::operator=(const mcp_get_ios_content_by_col_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_col_id_params::clear(){
_m_column_id.clear();
_m_type_id.clear();
// _m_orderby=0;
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_col_id_params::check() const{
// @@string column_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "column_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_column_id.get();

}
// @@string type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t orderby=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "orderby" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_orderby;

}
// @@uint32_t page=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_col_id_params::detach(){
_m_column_id.detach();
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_col_id_params& mcp_get_ios_content_by_col_id_params::assign(const mcp_get_ios_content_by_col_id_params& v){
_m_column_id=v._m_column_id;
_m_type_id=v._m_type_id;
_m_orderby=v._m_orderby;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_col_id_params::has_column_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_ios_content_by_col_id_params::column_id(unsigned int* size) const{
return _m_column_id.get(size);
}
inline mcp_get_ios_content_by_col_id_params& mcp_get_ios_content_by_col_id_params::set_column_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_column_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_ios_content_by_col_id_params& mcp_get_ios_content_by_col_id_params::set_ptr_column_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_column_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_ios_content_by_col_id_params::clear_column_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_column_id.clear();
}
inline bool mcp_get_ios_content_by_col_id_params::has_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_ios_content_by_col_id_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_ios_content_by_col_id_params& mcp_get_ios_content_by_col_id_params::set_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_ios_content_by_col_id_params& mcp_get_ios_content_by_col_id_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_ios_content_by_col_id_params::clear_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_ios_content_by_col_id_params::has_orderby() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_col_id_params::orderby() const{
return _m_orderby;
}
inline mcp_get_ios_content_by_col_id_params& mcp_get_ios_content_by_col_id_params::set_orderby(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_orderby=v;
return *this;
}
inline void mcp_get_ios_content_by_col_id_params::clear_orderby(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_orderby=0;
}
inline bool mcp_get_ios_content_by_col_id_params::has_page() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_col_id_params::page() const{
return _m_page;
}
inline mcp_get_ios_content_by_col_id_params& mcp_get_ios_content_by_col_id_params::set_page(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_ios_content_by_col_id_params::clear_page(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page=0;
}
inline bool mcp_get_ios_content_by_col_id_params::has_page_size() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_col_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_ios_content_by_col_id_params& mcp_get_ios_content_by_col_id_params::set_page_size(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_ios_content_by_col_id_params::clear_page_size(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_ios_content_by_col_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_col_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_col_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_col_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_col_id_result_params* mcp_get_ios_content_by_col_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_col_id_result_params* tmp=(mcp_get_ios_content_by_col_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_col_id_result_params(pool);
return tmp;
}
inline void mcp_get_ios_content_by_col_id_result_params::destroy(mcp_get_ios_content_by_col_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_col_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_col_id_result_params::mcp_get_ios_content_by_col_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_name(_pool)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_col_id_result_params::mcp_get_ios_content_by_col_id_result_params(const mcp_get_ios_content_by_col_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_name(_pool)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_ios_content_by_col_id_result_params::~mcp_get_ios_content_by_col_id_result_params(){
}
inline mcp_get_ios_content_by_col_id_result_params& mcp_get_ios_content_by_col_id_result_params::operator=(const mcp_get_ios_content_by_col_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_col_id_result_params::clear(){
// _m_count=0;
_m_name.clear();
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_col_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string name=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@ios_content_info_t info_list=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::ios_content_info_t& item=const_cast< ::idl::ios_content_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_col_id_result_params::detach(){
_m_name.detach();
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_col_id_result_params& mcp_get_ios_content_by_col_id_result_params::assign(const mcp_get_ios_content_by_col_id_result_params& v){
_m_count=v._m_count;
_m_name=v._m_name;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_col_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_ios_content_by_col_id_result_params::count() const{
return _m_count;
}
inline mcp_get_ios_content_by_col_id_result_params& mcp_get_ios_content_by_col_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_ios_content_by_col_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_ios_content_by_col_id_result_params::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_ios_content_by_col_id_result_params::name(unsigned int* size) const{
return _m_name.get(size);
}
inline mcp_get_ios_content_by_col_id_result_params& mcp_get_ios_content_by_col_id_result_params::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_ios_content_by_col_id_result_params& mcp_get_ios_content_by_col_id_result_params::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_ios_content_by_col_id_result_params::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool mcp_get_ios_content_by_col_id_result_params::has_info_list() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::ios_content_info_t >& mcp_get_ios_content_by_col_id_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_ios_content_by_col_id_result_params::clear_info_list(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::ios_content_info_t >* mcp_get_ios_content_by_col_id_result_params::mutable_info_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::ios_content_info_t >* mcp_get_ios_content_by_col_id_result_params::m_info_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_ios_content_by_col_id_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const ::idl::ios_content_info_t& mcp_get_ios_content_by_col_id_result_params::info_list(size_t i0) const{
 return _m_info_list.get(i0);
}
inline ::idl::ios_content_info_t* mcp_get_ios_content_by_col_id_result_params::mutable_info_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::ios_content_info_t* mcp_get_ios_content_by_col_id_result_params::m_info_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_ios_content_by_col_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_col_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_col_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_col_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_col_id_response* mcp_get_ios_content_by_col_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_col_id_response* tmp=(mcp_get_ios_content_by_col_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_col_id_response(pool);
return tmp;
}
inline void mcp_get_ios_content_by_col_id_response::destroy(mcp_get_ios_content_by_col_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_col_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_col_id_response::mcp_get_ios_content_by_col_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ios_content_by_col_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_col_id_response::mcp_get_ios_content_by_col_id_response(const mcp_get_ios_content_by_col_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ios_content_by_col_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_ios_content_by_col_id_response::~mcp_get_ios_content_by_col_id_response(){
if(_m_result_params){
::idl::mcp_get_ios_content_by_col_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_ios_content_by_col_id_response& mcp_get_ios_content_by_col_id_response::operator=(const mcp_get_ios_content_by_col_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_col_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_col_id_response::check() const{
// @@mcp_get_ios_content_by_col_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_ios_content_by_col_id_result_params& item=const_cast< ::idl::mcp_get_ios_content_by_col_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_col_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_col_id_response& mcp_get_ios_content_by_col_id_response::assign(const mcp_get_ios_content_by_col_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_ios_content_by_col_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_col_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_col_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_ios_content_by_col_id_result_params& mcp_get_ios_content_by_col_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_ios_content_by_col_id_result_params* mcp_get_ios_content_by_col_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_col_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_ios_content_by_col_id_result_params* mcp_get_ios_content_by_col_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_col_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_ios_content_by_col_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_ios_content_by_col_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_col_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_col_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_col_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_rank_params* mcp_get_ios_content_by_rank_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_rank_params* tmp=(mcp_get_ios_content_by_rank_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_rank_params(pool);
return tmp;
}
inline void mcp_get_ios_content_by_rank_params::destroy(mcp_get_ios_content_by_rank_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_rank_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_rank_params::mcp_get_ios_content_by_rank_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_type_id(_pool)
,_m_p_type(0)
,_m_page(0)
,_m_page_size(0)
,_m_for_free(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_rank_params::mcp_get_ios_content_by_rank_params(const mcp_get_ios_content_by_rank_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_type_id(_pool)
,_m_p_type(0)
,_m_page(0)
,_m_page_size(0)
,_m_for_free(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_ios_content_by_rank_params::~mcp_get_ios_content_by_rank_params(){
}
inline mcp_get_ios_content_by_rank_params& mcp_get_ios_content_by_rank_params::operator=(const mcp_get_ios_content_by_rank_params& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_rank_params::clear(){
_m_type_id.clear();
// _m_p_type=0;
// _m_page=0;
// _m_page_size=0;
// _m_for_free=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_rank_params::check() const{
// @@string type_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t p_type=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "p_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_p_type;

}
// @@uint32_t page=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}
// @@uint32_t for_free=in(),default(0);
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "for_free" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_for_free;

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_rank_params::detach(){
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_rank_params& mcp_get_ios_content_by_rank_params::assign(const mcp_get_ios_content_by_rank_params& v){
_m_type_id=v._m_type_id;
_m_p_type=v._m_p_type;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_m_for_free=v._m_for_free;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_rank_params::has_type_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_ios_content_by_rank_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_ios_content_by_rank_params& mcp_get_ios_content_by_rank_params::set_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_ios_content_by_rank_params& mcp_get_ios_content_by_rank_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_ios_content_by_rank_params::clear_type_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_ios_content_by_rank_params::has_p_type() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_rank_params::p_type() const{
return _m_p_type;
}
inline mcp_get_ios_content_by_rank_params& mcp_get_ios_content_by_rank_params::set_p_type(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_p_type=v;
return *this;
}
inline void mcp_get_ios_content_by_rank_params::clear_p_type(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_p_type=0;
}
inline bool mcp_get_ios_content_by_rank_params::has_page() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_rank_params::page() const{
return _m_page;
}
inline mcp_get_ios_content_by_rank_params& mcp_get_ios_content_by_rank_params::set_page(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_ios_content_by_rank_params::clear_page(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page=0;
}
inline bool mcp_get_ios_content_by_rank_params::has_page_size() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_rank_params::page_size() const{
return _m_page_size;
}
inline mcp_get_ios_content_by_rank_params& mcp_get_ios_content_by_rank_params::set_page_size(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_ios_content_by_rank_params::clear_page_size(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page_size=0;
}
inline bool mcp_get_ios_content_by_rank_params::has_for_free() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_ios_content_by_rank_params::for_free() const{
return _m_for_free;
}
inline mcp_get_ios_content_by_rank_params& mcp_get_ios_content_by_rank_params::set_for_free(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_for_free=v;
return *this;
}
inline void mcp_get_ios_content_by_rank_params::clear_for_free(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_for_free=0;
}
inline ::idl::Unknown* mcp_get_ios_content_by_rank_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_rank_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_rank_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_rank_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_rank_result_params* mcp_get_ios_content_by_rank_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_rank_result_params* tmp=(mcp_get_ios_content_by_rank_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_rank_result_params(pool);
return tmp;
}
inline void mcp_get_ios_content_by_rank_result_params::destroy(mcp_get_ios_content_by_rank_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_rank_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_rank_result_params::mcp_get_ios_content_by_rank_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_rank_result_params::mcp_get_ios_content_by_rank_result_params(const mcp_get_ios_content_by_rank_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_ios_content_by_rank_result_params::~mcp_get_ios_content_by_rank_result_params(){
}
inline mcp_get_ios_content_by_rank_result_params& mcp_get_ios_content_by_rank_result_params::operator=(const mcp_get_ios_content_by_rank_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_rank_result_params::clear(){
// _m_count=0;
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_rank_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@ios_content_info_t info_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::ios_content_info_t& item=const_cast< ::idl::ios_content_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_rank_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_rank_result_params& mcp_get_ios_content_by_rank_result_params::assign(const mcp_get_ios_content_by_rank_result_params& v){
_m_count=v._m_count;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_rank_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_ios_content_by_rank_result_params::count() const{
return _m_count;
}
inline mcp_get_ios_content_by_rank_result_params& mcp_get_ios_content_by_rank_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_ios_content_by_rank_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_ios_content_by_rank_result_params::has_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::ios_content_info_t >& mcp_get_ios_content_by_rank_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_ios_content_by_rank_result_params::clear_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::ios_content_info_t >* mcp_get_ios_content_by_rank_result_params::mutable_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::ios_content_info_t >* mcp_get_ios_content_by_rank_result_params::m_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_ios_content_by_rank_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const ::idl::ios_content_info_t& mcp_get_ios_content_by_rank_result_params::info_list(size_t i0) const{
 return _m_info_list.get(i0);
}
inline ::idl::ios_content_info_t* mcp_get_ios_content_by_rank_result_params::mutable_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::ios_content_info_t* mcp_get_ios_content_by_rank_result_params::m_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_ios_content_by_rank_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_rank_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_rank_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_rank_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_content_by_rank_response* mcp_get_ios_content_by_rank_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_content_by_rank_response* tmp=(mcp_get_ios_content_by_rank_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_content_by_rank_response(pool);
return tmp;
}
inline void mcp_get_ios_content_by_rank_response::destroy(mcp_get_ios_content_by_rank_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_content_by_rank_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_content_by_rank_response::mcp_get_ios_content_by_rank_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ios_content_by_rank_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_content_by_rank_response::mcp_get_ios_content_by_rank_response(const mcp_get_ios_content_by_rank_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ios_content_by_rank_result_params::create(_pool);
assign(v);
}
inline mcp_get_ios_content_by_rank_response::~mcp_get_ios_content_by_rank_response(){
if(_m_result_params){
::idl::mcp_get_ios_content_by_rank_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_ios_content_by_rank_response& mcp_get_ios_content_by_rank_response::operator=(const mcp_get_ios_content_by_rank_response& v){
assign(v);
return *this;
}
inline void mcp_get_ios_content_by_rank_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_content_by_rank_response::check() const{
// @@mcp_get_ios_content_by_rank_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_ios_content_by_rank_result_params& item=const_cast< ::idl::mcp_get_ios_content_by_rank_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_content_by_rank_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_content_by_rank_response& mcp_get_ios_content_by_rank_response::assign(const mcp_get_ios_content_by_rank_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_ios_content_by_rank_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_rank_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_content_by_rank_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_ios_content_by_rank_result_params& mcp_get_ios_content_by_rank_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_ios_content_by_rank_result_params* mcp_get_ios_content_by_rank_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_rank_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_ios_content_by_rank_result_params* mcp_get_ios_content_by_rank_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_content_by_rank_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_ios_content_by_rank_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_ios_content_by_rank_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_content_by_rank_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_content_by_rank_response::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_content_by_rank_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_class_list_by_type_id_params* mcp_get_class_list_by_type_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_class_list_by_type_id_params* tmp=(mcp_get_class_list_by_type_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_class_list_by_type_id_params(pool);
return tmp;
}
inline void mcp_get_class_list_by_type_id_params::destroy(mcp_get_class_list_by_type_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_class_list_by_type_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_class_list_by_type_id_params::mcp_get_class_list_by_type_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_type_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_class_list_by_type_id_params::mcp_get_class_list_by_type_id_params(const mcp_get_class_list_by_type_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_type_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_class_list_by_type_id_params::~mcp_get_class_list_by_type_id_params(){
}
inline mcp_get_class_list_by_type_id_params& mcp_get_class_list_by_type_id_params::operator=(const mcp_get_class_list_by_type_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_class_list_by_type_id_params::clear(){
_m_type_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_class_list_by_type_id_params::check() const{
// @@string type_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_class_list_by_type_id_params::detach(){
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_class_list_by_type_id_params& mcp_get_class_list_by_type_id_params::assign(const mcp_get_class_list_by_type_id_params& v){
_m_type_id=v._m_type_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_class_list_by_type_id_params::has_type_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_class_list_by_type_id_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_class_list_by_type_id_params& mcp_get_class_list_by_type_id_params::set_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_class_list_by_type_id_params& mcp_get_class_list_by_type_id_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_class_list_by_type_id_params::clear_type_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_type_id.clear();
}
inline ::idl::Unknown* mcp_get_class_list_by_type_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_class_list_by_type_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_class_list_by_type_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_class_list_by_type_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_class_list_by_type_id_result_params* mcp_get_class_list_by_type_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_class_list_by_type_id_result_params* tmp=(mcp_get_class_list_by_type_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_class_list_by_type_id_result_params(pool);
return tmp;
}
inline void mcp_get_class_list_by_type_id_result_params::destroy(mcp_get_class_list_by_type_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_class_list_by_type_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_class_list_by_type_id_result_params::mcp_get_class_list_by_type_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_class_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_class_list_by_type_id_result_params::mcp_get_class_list_by_type_id_result_params(const mcp_get_class_list_by_type_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_class_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_class_list_by_type_id_result_params::~mcp_get_class_list_by_type_id_result_params(){
}
inline mcp_get_class_list_by_type_id_result_params& mcp_get_class_list_by_type_id_result_params::operator=(const mcp_get_class_list_by_type_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_class_list_by_type_id_result_params::clear(){
// _m_count=0;
_m_class_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_class_list_by_type_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@class_detail_count_t class_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_list" << "' not found";
}
{
// level 0 begin
typeof(_m_class_list)& lr0=(_m_class_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::class_detail_count_t& item=const_cast< ::idl::class_detail_count_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_class_list_by_type_id_result_params::detach(){
_m_class_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_class_list_by_type_id_result_params& mcp_get_class_list_by_type_id_result_params::assign(const mcp_get_class_list_by_type_id_result_params& v){
_m_count=v._m_count;
_m_class_list=v._m_class_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_class_list_by_type_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_class_list_by_type_id_result_params::count() const{
return _m_count;
}
inline mcp_get_class_list_by_type_id_result_params& mcp_get_class_list_by_type_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_class_list_by_type_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_class_list_by_type_id_result_params::has_class_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::class_detail_count_t >& mcp_get_class_list_by_type_id_result_params::class_list() const{
 return _m_class_list;
}
inline void mcp_get_class_list_by_type_id_result_params::clear_class_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_class_list.clear();
}
inline ::idl::vector< ::idl::class_detail_count_t >* mcp_get_class_list_by_type_id_result_params::mutable_class_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_class_list);
}
inline ::idl::vector< ::idl::class_detail_count_t >* mcp_get_class_list_by_type_id_result_params::m_class_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_class_list);
}
inline size_t mcp_get_class_list_by_type_id_result_params::class_list_size() const{
/*  */ return _m_class_list.size();
}
inline const ::idl::class_detail_count_t& mcp_get_class_list_by_type_id_result_params::class_list(size_t i0) const{
 return _m_class_list.get(i0);
}
inline ::idl::class_detail_count_t* mcp_get_class_list_by_type_id_result_params::mutable_class_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_class_list.mutable_get(i0);
}
inline ::idl::class_detail_count_t* mcp_get_class_list_by_type_id_result_params::m_class_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_class_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_class_list_by_type_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_class_list_by_type_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_class_list_by_type_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_class_list_by_type_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_class_list_by_type_id_response* mcp_get_class_list_by_type_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_class_list_by_type_id_response* tmp=(mcp_get_class_list_by_type_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_class_list_by_type_id_response(pool);
return tmp;
}
inline void mcp_get_class_list_by_type_id_response::destroy(mcp_get_class_list_by_type_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_class_list_by_type_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_class_list_by_type_id_response::mcp_get_class_list_by_type_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_class_list_by_type_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_class_list_by_type_id_response::mcp_get_class_list_by_type_id_response(const mcp_get_class_list_by_type_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_class_list_by_type_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_class_list_by_type_id_response::~mcp_get_class_list_by_type_id_response(){
if(_m_result_params){
::idl::mcp_get_class_list_by_type_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_class_list_by_type_id_response& mcp_get_class_list_by_type_id_response::operator=(const mcp_get_class_list_by_type_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_class_list_by_type_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_class_list_by_type_id_response::check() const{
// @@mcp_get_class_list_by_type_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_class_list_by_type_id_result_params& item=const_cast< ::idl::mcp_get_class_list_by_type_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_class_list_by_type_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_class_list_by_type_id_response& mcp_get_class_list_by_type_id_response::assign(const mcp_get_class_list_by_type_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_class_list_by_type_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_class_list_by_type_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_class_list_by_type_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_class_list_by_type_id_result_params& mcp_get_class_list_by_type_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_class_list_by_type_id_result_params* mcp_get_class_list_by_type_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_class_list_by_type_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_class_list_by_type_id_result_params* mcp_get_class_list_by_type_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_class_list_by_type_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_class_list_by_type_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_class_list_by_type_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_class_list_by_type_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_class_list_by_type_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_class_list_by_type_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_probably_like_list_by_id_params* mcp_get_ios_probably_like_list_by_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_probably_like_list_by_id_params* tmp=(mcp_get_ios_probably_like_list_by_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_probably_like_list_by_id_params(pool);
return tmp;
}
inline void mcp_get_ios_probably_like_list_by_id_params::destroy(mcp_get_ios_probably_like_list_by_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_probably_like_list_by_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_probably_like_list_by_id_params::mcp_get_ios_probably_like_list_by_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_list_cnt(0)
,_m_type(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_probably_like_list_by_id_params::mcp_get_ios_probably_like_list_by_id_params(const mcp_get_ios_probably_like_list_by_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_list_cnt(0)
,_m_type(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_ios_probably_like_list_by_id_params::~mcp_get_ios_probably_like_list_by_id_params(){
}
inline mcp_get_ios_probably_like_list_by_id_params& mcp_get_ios_probably_like_list_by_id_params::operator=(const mcp_get_ios_probably_like_list_by_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_ios_probably_like_list_by_id_params::clear(){
_m_id.clear();
// _m_list_cnt=0;
// _m_type=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_probably_like_list_by_id_params::check() const{
// @@string id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@uint32_t list_cnt=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "list_cnt" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_list_cnt;

}
// @@uint32_t type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_type;

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_probably_like_list_by_id_params::detach(){
_m_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_probably_like_list_by_id_params& mcp_get_ios_probably_like_list_by_id_params::assign(const mcp_get_ios_probably_like_list_by_id_params& v){
_m_id=v._m_id;
_m_list_cnt=v._m_list_cnt;
_m_type=v._m_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_probably_like_list_by_id_params::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_ios_probably_like_list_by_id_params::id(unsigned int* size) const{
return _m_id.get(size);
}
inline mcp_get_ios_probably_like_list_by_id_params& mcp_get_ios_probably_like_list_by_id_params::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_ios_probably_like_list_by_id_params& mcp_get_ios_probably_like_list_by_id_params::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_ios_probably_like_list_by_id_params::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool mcp_get_ios_probably_like_list_by_id_params::has_list_cnt() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_ios_probably_like_list_by_id_params::list_cnt() const{
return _m_list_cnt;
}
inline mcp_get_ios_probably_like_list_by_id_params& mcp_get_ios_probably_like_list_by_id_params::set_list_cnt(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_list_cnt=v;
return *this;
}
inline void mcp_get_ios_probably_like_list_by_id_params::clear_list_cnt(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_list_cnt=0;
}
inline bool mcp_get_ios_probably_like_list_by_id_params::has_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_ios_probably_like_list_by_id_params::type() const{
return _m_type;
}
inline mcp_get_ios_probably_like_list_by_id_params& mcp_get_ios_probably_like_list_by_id_params::set_type(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_type=v;
return *this;
}
inline void mcp_get_ios_probably_like_list_by_id_params::clear_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_type=0;
}
inline ::idl::Unknown* mcp_get_ios_probably_like_list_by_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_probably_like_list_by_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_probably_like_list_by_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_probably_like_list_by_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_probably_like_list_by_id_result_params* mcp_get_ios_probably_like_list_by_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_probably_like_list_by_id_result_params* tmp=(mcp_get_ios_probably_like_list_by_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_probably_like_list_by_id_result_params(pool);
return tmp;
}
inline void mcp_get_ios_probably_like_list_by_id_result_params::destroy(mcp_get_ios_probably_like_list_by_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_probably_like_list_by_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_probably_like_list_by_id_result_params::mcp_get_ios_probably_like_list_by_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_probably_like_list_by_id_result_params::mcp_get_ios_probably_like_list_by_id_result_params(const mcp_get_ios_probably_like_list_by_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_ios_probably_like_list_by_id_result_params::~mcp_get_ios_probably_like_list_by_id_result_params(){
}
inline mcp_get_ios_probably_like_list_by_id_result_params& mcp_get_ios_probably_like_list_by_id_result_params::operator=(const mcp_get_ios_probably_like_list_by_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_ios_probably_like_list_by_id_result_params::clear(){
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_probably_like_list_by_id_result_params::check() const{
// @@ios_content_info_t info_list=out(),array(0);
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::ios_content_info_t& item=const_cast< ::idl::ios_content_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_probably_like_list_by_id_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_probably_like_list_by_id_result_params& mcp_get_ios_probably_like_list_by_id_result_params::assign(const mcp_get_ios_probably_like_list_by_id_result_params& v){
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_probably_like_list_by_id_result_params::has_info_list() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::vector< ::idl::ios_content_info_t >& mcp_get_ios_probably_like_list_by_id_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_ios_probably_like_list_by_id_result_params::clear_info_list(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::ios_content_info_t >* mcp_get_ios_probably_like_list_by_id_result_params::mutable_info_list(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::ios_content_info_t >* mcp_get_ios_probably_like_list_by_id_result_params::m_info_list(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_ios_probably_like_list_by_id_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const ::idl::ios_content_info_t& mcp_get_ios_probably_like_list_by_id_result_params::info_list(size_t i0) const{
 return _m_info_list.get(i0);
}
inline ::idl::ios_content_info_t* mcp_get_ios_probably_like_list_by_id_result_params::mutable_info_list(size_t i0){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::ios_content_info_t* mcp_get_ios_probably_like_list_by_id_result_params::m_info_list(size_t i0){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_ios_probably_like_list_by_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_probably_like_list_by_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_probably_like_list_by_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_probably_like_list_by_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ios_probably_like_list_by_id_response* mcp_get_ios_probably_like_list_by_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ios_probably_like_list_by_id_response* tmp=(mcp_get_ios_probably_like_list_by_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ios_probably_like_list_by_id_response(pool);
return tmp;
}
inline void mcp_get_ios_probably_like_list_by_id_response::destroy(mcp_get_ios_probably_like_list_by_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ios_probably_like_list_by_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ios_probably_like_list_by_id_response::mcp_get_ios_probably_like_list_by_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ios_probably_like_list_by_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ios_probably_like_list_by_id_response::mcp_get_ios_probably_like_list_by_id_response(const mcp_get_ios_probably_like_list_by_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ios_probably_like_list_by_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_ios_probably_like_list_by_id_response::~mcp_get_ios_probably_like_list_by_id_response(){
if(_m_result_params){
::idl::mcp_get_ios_probably_like_list_by_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_ios_probably_like_list_by_id_response& mcp_get_ios_probably_like_list_by_id_response::operator=(const mcp_get_ios_probably_like_list_by_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_ios_probably_like_list_by_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ios_probably_like_list_by_id_response::check() const{
// @@mcp_get_ios_probably_like_list_by_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_ios_probably_like_list_by_id_result_params& item=const_cast< ::idl::mcp_get_ios_probably_like_list_by_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_ios_probably_like_list_by_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ios_probably_like_list_by_id_response& mcp_get_ios_probably_like_list_by_id_response::assign(const mcp_get_ios_probably_like_list_by_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_ios_probably_like_list_by_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_probably_like_list_by_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ios_probably_like_list_by_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_ios_probably_like_list_by_id_result_params& mcp_get_ios_probably_like_list_by_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_ios_probably_like_list_by_id_result_params* mcp_get_ios_probably_like_list_by_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_probably_like_list_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_ios_probably_like_list_by_id_result_params* mcp_get_ios_probably_like_list_by_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ios_probably_like_list_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_ios_probably_like_list_by_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_ios_probably_like_list_by_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ios_probably_like_list_by_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ios_probably_like_list_by_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_ios_probably_like_list_by_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_info_list_params* mcp_get_game_info_list_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_info_list_params* tmp=(mcp_get_game_info_list_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_info_list_params(pool);
return tmp;
}
inline void mcp_get_game_info_list_params::destroy(mcp_get_game_info_list_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_info_list_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_info_list_params::mcp_get_game_info_list_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_type(_pool)
,_m_game_type(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_info_list_params::mcp_get_game_info_list_params(const mcp_get_game_info_list_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_type(_pool)
,_m_game_type(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_info_list_params::~mcp_get_game_info_list_params(){
}
inline mcp_get_game_info_list_params& mcp_get_game_info_list_params::operator=(const mcp_get_game_info_list_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_info_list_params::clear(){
_m_info_type.clear();
_m_game_type.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_info_list_params::check() const{
// @@string info_type=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_type.get();

}
// @@string game_type=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_type.get();

}
// @@uint32_t page=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_game_info_list_params::detach(){
_m_info_type.detach();
_m_game_type.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_info_list_params& mcp_get_game_info_list_params::assign(const mcp_get_game_info_list_params& v){
_m_info_type=v._m_info_type;
_m_game_type=v._m_game_type;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_info_list_params::has_info_type() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_info_list_params::info_type(unsigned int* size) const{
return _m_info_type.get(size);
}
inline mcp_get_game_info_list_params& mcp_get_game_info_list_params::set_info_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_info_list_params& mcp_get_game_info_list_params::set_ptr_info_type(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_info_list_params::clear_info_type(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_type.clear();
}
inline bool mcp_get_game_info_list_params::has_game_type() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_game_info_list_params::game_type(unsigned int* size) const{
return _m_game_type.get(size);
}
inline mcp_get_game_info_list_params& mcp_get_game_info_list_params::set_game_type(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_info_list_params& mcp_get_game_info_list_params::set_ptr_game_type(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_info_list_params::clear_game_type(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_type.clear();
}
inline bool mcp_get_game_info_list_params::has_page() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_game_info_list_params::page() const{
return _m_page;
}
inline mcp_get_game_info_list_params& mcp_get_game_info_list_params::set_page(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_game_info_list_params::clear_page(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page=0;
}
inline bool mcp_get_game_info_list_params::has_page_size() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_game_info_list_params::page_size() const{
return _m_page_size;
}
inline mcp_get_game_info_list_params& mcp_get_game_info_list_params::set_page_size(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_game_info_list_params::clear_page_size(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_game_info_list_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_info_list_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_info_list_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_info_list_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_info_list_result_params* mcp_get_game_info_list_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_info_list_result_params* tmp=(mcp_get_game_info_list_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_info_list_result_params(pool);
return tmp;
}
inline void mcp_get_game_info_list_result_params::destroy(mcp_get_game_info_list_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_info_list_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_info_list_result_params::mcp_get_game_info_list_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_game_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_info_list_result_params::mcp_get_game_info_list_result_params(const mcp_get_game_info_list_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_game_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_info_list_result_params::~mcp_get_game_info_list_result_params(){
}
inline mcp_get_game_info_list_result_params& mcp_get_game_info_list_result_params::operator=(const mcp_get_game_info_list_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_info_list_result_params::clear(){
// _m_count=0;
_m_game_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_info_list_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@game_brief_info_t game_info_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_game_info_list)& lr0=(_m_game_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_brief_info_t& item=const_cast< ::idl::game_brief_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_game_info_list_result_params::detach(){
_m_game_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_info_list_result_params& mcp_get_game_info_list_result_params::assign(const mcp_get_game_info_list_result_params& v){
_m_count=v._m_count;
_m_game_info_list=v._m_game_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_info_list_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_game_info_list_result_params::count() const{
return _m_count;
}
inline mcp_get_game_info_list_result_params& mcp_get_game_info_list_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_game_info_list_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_game_info_list_result_params::has_game_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_brief_info_t >& mcp_get_game_info_list_result_params::game_info_list() const{
 return _m_game_info_list;
}
inline void mcp_get_game_info_list_result_params::clear_game_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_info_list.clear();
}
inline ::idl::vector< ::idl::game_brief_info_t >* mcp_get_game_info_list_result_params::mutable_game_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_info_list);
}
inline ::idl::vector< ::idl::game_brief_info_t >* mcp_get_game_info_list_result_params::m_game_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_info_list);
}
inline size_t mcp_get_game_info_list_result_params::game_info_list_size() const{
/*  */ return _m_game_info_list.size();
}
inline const ::idl::game_brief_info_t& mcp_get_game_info_list_result_params::game_info_list(size_t i0) const{
 return _m_game_info_list.get(i0);
}
inline ::idl::game_brief_info_t* mcp_get_game_info_list_result_params::mutable_game_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_info_list.mutable_get(i0);
}
inline ::idl::game_brief_info_t* mcp_get_game_info_list_result_params::m_game_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_game_info_list_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_info_list_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_info_list_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_info_list_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_info_list_response* mcp_get_game_info_list_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_info_list_response* tmp=(mcp_get_game_info_list_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_info_list_response(pool);
return tmp;
}
inline void mcp_get_game_info_list_response::destroy(mcp_get_game_info_list_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_info_list_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_info_list_response::mcp_get_game_info_list_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_info_list_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_info_list_response::mcp_get_game_info_list_response(const mcp_get_game_info_list_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_info_list_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_info_list_response::~mcp_get_game_info_list_response(){
if(_m_result_params){
::idl::mcp_get_game_info_list_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_info_list_response& mcp_get_game_info_list_response::operator=(const mcp_get_game_info_list_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_info_list_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_info_list_response::check() const{
// @@mcp_get_game_info_list_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_info_list_result_params& item=const_cast< ::idl::mcp_get_game_info_list_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_info_list_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_info_list_response& mcp_get_game_info_list_response::assign(const mcp_get_game_info_list_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_info_list_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_info_list_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_info_list_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_info_list_result_params& mcp_get_game_info_list_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_info_list_result_params* mcp_get_game_info_list_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_info_list_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_info_list_result_params* mcp_get_game_info_list_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_info_list_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_info_list_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_info_list_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_info_list_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_info_list_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_info_list_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_info_params* mcp_get_game_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_info_params* tmp=(mcp_get_game_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_info_params(pool);
return tmp;
}
inline void mcp_get_game_info_params::destroy(mcp_get_game_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_info_params::mcp_get_game_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_info_params::mcp_get_game_info_params(const mcp_get_game_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_info_params::~mcp_get_game_info_params(){
}
inline mcp_get_game_info_params& mcp_get_game_info_params::operator=(const mcp_get_game_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_info_params::clear(){
_m_info_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_info_params::check() const{
// @@string info_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_info_params::detach(){
_m_info_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_info_params& mcp_get_game_info_params::assign(const mcp_get_game_info_params& v){
_m_info_id=v._m_info_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_info_params::has_info_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_info_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_game_info_params& mcp_get_game_info_params::set_info_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_info_params& mcp_get_game_info_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_info_params::clear_info_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_id.clear();
}
inline ::idl::Unknown* mcp_get_game_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_info_result_params* mcp_get_game_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_info_result_params* tmp=(mcp_get_game_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_info_result_params(pool);
return tmp;
}
inline void mcp_get_game_info_result_params::destroy(mcp_get_game_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_info_result_params::mcp_get_game_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_game_info(0)
,_unknown(_pool){
_m_game_info=::idl::game_info_t::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_info_result_params::mcp_get_game_info_result_params(const mcp_get_game_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_game_info(0)
,_unknown(_pool){
_m_game_info=::idl::game_info_t::create(_pool);
assign(v);
}
inline mcp_get_game_info_result_params::~mcp_get_game_info_result_params(){
if(_m_game_info){
::idl::game_info_t::destroy(_m_game_info);
_m_game_info=0;
}
}
inline mcp_get_game_info_result_params& mcp_get_game_info_result_params::operator=(const mcp_get_game_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_info_result_params::clear(){
if(_m_game_info){
_m_game_info->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_info_result_params::check() const{
// @@game_info_t game_info=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_info" << "' not found";
}
{
::idl::game_info_t& item=const_cast< ::idl::game_info_t& >(*_m_game_info);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_info_result_params::detach(){
if(_m_game_info){
_m_game_info->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_info_result_params& mcp_get_game_info_result_params::assign(const mcp_get_game_info_result_params& v){
if(!v._m_game_info){
if(_m_game_info){
::idl::game_info_t::destroy(_m_game_info);
}
_m_game_info=0;
}else{
if(!_m_game_info){
_m_game_info=::idl::game_info_t::create(_pool);
}
*_m_game_info=*v._m_game_info;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_info_result_params::has_game_info() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::game_info_t& mcp_get_game_info_result_params::game_info() const{
 return *_m_game_info;
}
inline ::idl::game_info_t* mcp_get_game_info_result_params::mutable_game_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_game_info){
_m_game_info=::idl::game_info_t::create(_pool);
}
return _m_game_info;
}
inline ::idl::game_info_t* mcp_get_game_info_result_params::m_game_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_game_info){
_m_game_info=::idl::game_info_t::create(_pool);
}
return _m_game_info;
}
inline void mcp_get_game_info_result_params::clear_game_info(){
if(_m_game_info){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_game_info->clear();
}
}
inline ::idl::Unknown* mcp_get_game_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_info_response* mcp_get_game_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_info_response* tmp=(mcp_get_game_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_info_response(pool);
return tmp;
}
inline void mcp_get_game_info_response::destroy(mcp_get_game_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_info_response::mcp_get_game_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_info_response::mcp_get_game_info_response(const mcp_get_game_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_info_response::~mcp_get_game_info_response(){
if(_m_result_params){
::idl::mcp_get_game_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_info_response& mcp_get_game_info_response::operator=(const mcp_get_game_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_info_response::check() const{
// @@mcp_get_game_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_info_result_params& item=const_cast< ::idl::mcp_get_game_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_info_response& mcp_get_game_info_response::assign(const mcp_get_game_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_info_result_params& mcp_get_game_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_info_result_params* mcp_get_game_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_info_result_params* mcp_get_game_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_info_list_by_c_id_params* mcp_get_game_info_list_by_c_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_info_list_by_c_id_params* tmp=(mcp_get_game_info_list_by_c_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_info_list_by_c_id_params(pool);
return tmp;
}
inline void mcp_get_game_info_list_by_c_id_params::destroy(mcp_get_game_info_list_by_c_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_info_list_by_c_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_info_list_by_c_id_params::mcp_get_game_info_list_by_c_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_c_id(_pool)
,_m_info_type(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_info_list_by_c_id_params::mcp_get_game_info_list_by_c_id_params(const mcp_get_game_info_list_by_c_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_c_id(_pool)
,_m_info_type(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_info_list_by_c_id_params::~mcp_get_game_info_list_by_c_id_params(){
}
inline mcp_get_game_info_list_by_c_id_params& mcp_get_game_info_list_by_c_id_params::operator=(const mcp_get_game_info_list_by_c_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_info_list_by_c_id_params::clear(){
_m_c_id.clear();
_m_info_type.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_info_list_by_c_id_params::check() const{
// @@string c_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string info_type=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_type.get();

}
// @@uint32_t page=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_game_info_list_by_c_id_params::detach(){
_m_c_id.detach();
_m_info_type.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_info_list_by_c_id_params& mcp_get_game_info_list_by_c_id_params::assign(const mcp_get_game_info_list_by_c_id_params& v){
_m_c_id=v._m_c_id;
_m_info_type=v._m_info_type;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_info_list_by_c_id_params::has_c_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_info_list_by_c_id_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_get_game_info_list_by_c_id_params& mcp_get_game_info_list_by_c_id_params::set_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_info_list_by_c_id_params& mcp_get_game_info_list_by_c_id_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_info_list_by_c_id_params::clear_c_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_c_id.clear();
}
inline bool mcp_get_game_info_list_by_c_id_params::has_info_type() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_game_info_list_by_c_id_params::info_type(unsigned int* size) const{
return _m_info_type.get(size);
}
inline mcp_get_game_info_list_by_c_id_params& mcp_get_game_info_list_by_c_id_params::set_info_type(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_info_list_by_c_id_params& mcp_get_game_info_list_by_c_id_params::set_ptr_info_type(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_info_list_by_c_id_params::clear_info_type(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_type.clear();
}
inline bool mcp_get_game_info_list_by_c_id_params::has_page() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_game_info_list_by_c_id_params::page() const{
return _m_page;
}
inline mcp_get_game_info_list_by_c_id_params& mcp_get_game_info_list_by_c_id_params::set_page(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_game_info_list_by_c_id_params::clear_page(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page=0;
}
inline bool mcp_get_game_info_list_by_c_id_params::has_page_size() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_game_info_list_by_c_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_game_info_list_by_c_id_params& mcp_get_game_info_list_by_c_id_params::set_page_size(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_game_info_list_by_c_id_params::clear_page_size(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_game_info_list_by_c_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_info_list_by_c_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_info_list_by_c_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_info_list_by_c_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_info_list_by_c_id_result_params* mcp_get_game_info_list_by_c_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_info_list_by_c_id_result_params* tmp=(mcp_get_game_info_list_by_c_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_info_list_by_c_id_result_params(pool);
return tmp;
}
inline void mcp_get_game_info_list_by_c_id_result_params::destroy(mcp_get_game_info_list_by_c_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_info_list_by_c_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_info_list_by_c_id_result_params::mcp_get_game_info_list_by_c_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_game_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_info_list_by_c_id_result_params::mcp_get_game_info_list_by_c_id_result_params(const mcp_get_game_info_list_by_c_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_game_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_info_list_by_c_id_result_params::~mcp_get_game_info_list_by_c_id_result_params(){
}
inline mcp_get_game_info_list_by_c_id_result_params& mcp_get_game_info_list_by_c_id_result_params::operator=(const mcp_get_game_info_list_by_c_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_info_list_by_c_id_result_params::clear(){
// _m_count=0;
_m_game_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_info_list_by_c_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@game_brief_info_t game_info_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_game_info_list)& lr0=(_m_game_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_brief_info_t& item=const_cast< ::idl::game_brief_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_game_info_list_by_c_id_result_params::detach(){
_m_game_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_info_list_by_c_id_result_params& mcp_get_game_info_list_by_c_id_result_params::assign(const mcp_get_game_info_list_by_c_id_result_params& v){
_m_count=v._m_count;
_m_game_info_list=v._m_game_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_info_list_by_c_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_game_info_list_by_c_id_result_params::count() const{
return _m_count;
}
inline mcp_get_game_info_list_by_c_id_result_params& mcp_get_game_info_list_by_c_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_game_info_list_by_c_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_game_info_list_by_c_id_result_params::has_game_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_brief_info_t >& mcp_get_game_info_list_by_c_id_result_params::game_info_list() const{
 return _m_game_info_list;
}
inline void mcp_get_game_info_list_by_c_id_result_params::clear_game_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_info_list.clear();
}
inline ::idl::vector< ::idl::game_brief_info_t >* mcp_get_game_info_list_by_c_id_result_params::mutable_game_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_info_list);
}
inline ::idl::vector< ::idl::game_brief_info_t >* mcp_get_game_info_list_by_c_id_result_params::m_game_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_info_list);
}
inline size_t mcp_get_game_info_list_by_c_id_result_params::game_info_list_size() const{
/*  */ return _m_game_info_list.size();
}
inline const ::idl::game_brief_info_t& mcp_get_game_info_list_by_c_id_result_params::game_info_list(size_t i0) const{
 return _m_game_info_list.get(i0);
}
inline ::idl::game_brief_info_t* mcp_get_game_info_list_by_c_id_result_params::mutable_game_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_info_list.mutable_get(i0);
}
inline ::idl::game_brief_info_t* mcp_get_game_info_list_by_c_id_result_params::m_game_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_game_info_list_by_c_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_info_list_by_c_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_info_list_by_c_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_info_list_by_c_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_info_list_by_c_id_response* mcp_get_game_info_list_by_c_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_info_list_by_c_id_response* tmp=(mcp_get_game_info_list_by_c_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_info_list_by_c_id_response(pool);
return tmp;
}
inline void mcp_get_game_info_list_by_c_id_response::destroy(mcp_get_game_info_list_by_c_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_info_list_by_c_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_info_list_by_c_id_response::mcp_get_game_info_list_by_c_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_info_list_by_c_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_info_list_by_c_id_response::mcp_get_game_info_list_by_c_id_response(const mcp_get_game_info_list_by_c_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_info_list_by_c_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_info_list_by_c_id_response::~mcp_get_game_info_list_by_c_id_response(){
if(_m_result_params){
::idl::mcp_get_game_info_list_by_c_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_info_list_by_c_id_response& mcp_get_game_info_list_by_c_id_response::operator=(const mcp_get_game_info_list_by_c_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_info_list_by_c_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_info_list_by_c_id_response::check() const{
// @@mcp_get_game_info_list_by_c_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_info_list_by_c_id_result_params& item=const_cast< ::idl::mcp_get_game_info_list_by_c_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_info_list_by_c_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_info_list_by_c_id_response& mcp_get_game_info_list_by_c_id_response::assign(const mcp_get_game_info_list_by_c_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_info_list_by_c_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_info_list_by_c_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_info_list_by_c_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_info_list_by_c_id_result_params& mcp_get_game_info_list_by_c_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_info_list_by_c_id_result_params* mcp_get_game_info_list_by_c_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_info_list_by_c_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_info_list_by_c_id_result_params* mcp_get_game_info_list_by_c_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_info_list_by_c_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_info_list_by_c_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_info_list_by_c_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_info_list_by_c_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_info_list_by_c_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_info_list_by_c_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_score_by_imei_or_uid_params* mcp_get_game_score_by_imei_or_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_score_by_imei_or_uid_params* tmp=(mcp_get_game_score_by_imei_or_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_score_by_imei_or_uid_params(pool);
return tmp;
}
inline void mcp_get_game_score_by_imei_or_uid_params::destroy(mcp_get_game_score_by_imei_or_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_score_by_imei_or_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_score_by_imei_or_uid_params::mcp_get_game_score_by_imei_or_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_c_id(_pool)
,_m_type(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_score_by_imei_or_uid_params::mcp_get_game_score_by_imei_or_uid_params(const mcp_get_game_score_by_imei_or_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_c_id(_pool)
,_m_type(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_score_by_imei_or_uid_params::~mcp_get_game_score_by_imei_or_uid_params(){
}
inline mcp_get_game_score_by_imei_or_uid_params& mcp_get_game_score_by_imei_or_uid_params::operator=(const mcp_get_game_score_by_imei_or_uid_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_score_by_imei_or_uid_params::clear(){
_m_id.clear();
_m_c_id.clear();
_m_type.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_score_by_imei_or_uid_params::check() const{
// @@string id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@string c_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_score_by_imei_or_uid_params::detach(){
_m_id.detach();
_m_c_id.detach();
_m_type.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_score_by_imei_or_uid_params& mcp_get_game_score_by_imei_or_uid_params::assign(const mcp_get_game_score_by_imei_or_uid_params& v){
_m_id=v._m_id;
_m_c_id=v._m_c_id;
_m_type=v._m_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_score_by_imei_or_uid_params::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_score_by_imei_or_uid_params::id(unsigned int* size) const{
return _m_id.get(size);
}
inline mcp_get_game_score_by_imei_or_uid_params& mcp_get_game_score_by_imei_or_uid_params::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_score_by_imei_or_uid_params& mcp_get_game_score_by_imei_or_uid_params::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_score_by_imei_or_uid_params::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool mcp_get_game_score_by_imei_or_uid_params::has_c_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_game_score_by_imei_or_uid_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_get_game_score_by_imei_or_uid_params& mcp_get_game_score_by_imei_or_uid_params::set_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_score_by_imei_or_uid_params& mcp_get_game_score_by_imei_or_uid_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_score_by_imei_or_uid_params::clear_c_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_c_id.clear();
}
inline bool mcp_get_game_score_by_imei_or_uid_params::has_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_game_score_by_imei_or_uid_params::type(unsigned int* size) const{
return _m_type.get(size);
}
inline mcp_get_game_score_by_imei_or_uid_params& mcp_get_game_score_by_imei_or_uid_params::set_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_score_by_imei_or_uid_params& mcp_get_game_score_by_imei_or_uid_params::set_ptr_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_score_by_imei_or_uid_params::clear_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_type.clear();
}
inline ::idl::Unknown* mcp_get_game_score_by_imei_or_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_score_by_imei_or_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_score_by_imei_or_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_score_by_imei_or_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_score_by_imei_or_uid_result_params* mcp_get_game_score_by_imei_or_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_score_by_imei_or_uid_result_params* tmp=(mcp_get_game_score_by_imei_or_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_score_by_imei_or_uid_result_params(pool);
return tmp;
}
inline void mcp_get_game_score_by_imei_or_uid_result_params::destroy(mcp_get_game_score_by_imei_or_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_score_by_imei_or_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_score_by_imei_or_uid_result_params::mcp_get_game_score_by_imei_or_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_score(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_score_by_imei_or_uid_result_params::mcp_get_game_score_by_imei_or_uid_result_params(const mcp_get_game_score_by_imei_or_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_score(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_score_by_imei_or_uid_result_params::~mcp_get_game_score_by_imei_or_uid_result_params(){
}
inline mcp_get_game_score_by_imei_or_uid_result_params& mcp_get_game_score_by_imei_or_uid_result_params::operator=(const mcp_get_game_score_by_imei_or_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_score_by_imei_or_uid_result_params::clear(){
_m_score.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_score_by_imei_or_uid_result_params::check() const{
// @@string score=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "score" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_score.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_score_by_imei_or_uid_result_params::detach(){
_m_score.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_score_by_imei_or_uid_result_params& mcp_get_game_score_by_imei_or_uid_result_params::assign(const mcp_get_game_score_by_imei_or_uid_result_params& v){
_m_score=v._m_score;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_score_by_imei_or_uid_result_params::has_score() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_score_by_imei_or_uid_result_params::score(unsigned int* size) const{
return _m_score.get(size);
}
inline mcp_get_game_score_by_imei_or_uid_result_params& mcp_get_game_score_by_imei_or_uid_result_params::set_score(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_score.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_score_by_imei_or_uid_result_params& mcp_get_game_score_by_imei_or_uid_result_params::set_ptr_score(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_score.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_score_by_imei_or_uid_result_params::clear_score(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_score.clear();
}
inline ::idl::Unknown* mcp_get_game_score_by_imei_or_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_score_by_imei_or_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_score_by_imei_or_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_score_by_imei_or_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_score_by_imei_or_uid_response* mcp_get_game_score_by_imei_or_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_score_by_imei_or_uid_response* tmp=(mcp_get_game_score_by_imei_or_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_score_by_imei_or_uid_response(pool);
return tmp;
}
inline void mcp_get_game_score_by_imei_or_uid_response::destroy(mcp_get_game_score_by_imei_or_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_score_by_imei_or_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_score_by_imei_or_uid_response::mcp_get_game_score_by_imei_or_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_score_by_imei_or_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_score_by_imei_or_uid_response::mcp_get_game_score_by_imei_or_uid_response(const mcp_get_game_score_by_imei_or_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_score_by_imei_or_uid_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_score_by_imei_or_uid_response::~mcp_get_game_score_by_imei_or_uid_response(){
if(_m_result_params){
::idl::mcp_get_game_score_by_imei_or_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_score_by_imei_or_uid_response& mcp_get_game_score_by_imei_or_uid_response::operator=(const mcp_get_game_score_by_imei_or_uid_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_score_by_imei_or_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_score_by_imei_or_uid_response::check() const{
// @@mcp_get_game_score_by_imei_or_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_score_by_imei_or_uid_result_params& item=const_cast< ::idl::mcp_get_game_score_by_imei_or_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_score_by_imei_or_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_score_by_imei_or_uid_response& mcp_get_game_score_by_imei_or_uid_response::assign(const mcp_get_game_score_by_imei_or_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_score_by_imei_or_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_score_by_imei_or_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_score_by_imei_or_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_score_by_imei_or_uid_result_params& mcp_get_game_score_by_imei_or_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_score_by_imei_or_uid_result_params* mcp_get_game_score_by_imei_or_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_score_by_imei_or_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_score_by_imei_or_uid_result_params* mcp_get_game_score_by_imei_or_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_score_by_imei_or_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_score_by_imei_or_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_score_by_imei_or_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_score_by_imei_or_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_score_by_imei_or_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_score_by_imei_or_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_appinfo_by_packagename_params* mcp_get_appinfo_by_packagename_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_appinfo_by_packagename_params* tmp=(mcp_get_appinfo_by_packagename_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_appinfo_by_packagename_params(pool);
return tmp;
}
inline void mcp_get_appinfo_by_packagename_params::destroy(mcp_get_appinfo_by_packagename_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_appinfo_by_packagename_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_appinfo_by_packagename_params::mcp_get_appinfo_by_packagename_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_packagename(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_appinfo_by_packagename_params::mcp_get_appinfo_by_packagename_params(const mcp_get_appinfo_by_packagename_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_packagename(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_appinfo_by_packagename_params::~mcp_get_appinfo_by_packagename_params(){
}
inline mcp_get_appinfo_by_packagename_params& mcp_get_appinfo_by_packagename_params::operator=(const mcp_get_appinfo_by_packagename_params& v){
assign(v);
return *this;
}
inline void mcp_get_appinfo_by_packagename_params::clear(){
_m_packagename.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_appinfo_by_packagename_params::check() const{
// @@string packagename=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "packagename" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_packagename.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_appinfo_by_packagename_params::detach(){
_m_packagename.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_appinfo_by_packagename_params& mcp_get_appinfo_by_packagename_params::assign(const mcp_get_appinfo_by_packagename_params& v){
_m_packagename=v._m_packagename;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_appinfo_by_packagename_params::has_packagename() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_appinfo_by_packagename_params::packagename(unsigned int* size) const{
return _m_packagename.get(size);
}
inline mcp_get_appinfo_by_packagename_params& mcp_get_appinfo_by_packagename_params::set_packagename(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_packagename.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_appinfo_by_packagename_params& mcp_get_appinfo_by_packagename_params::set_ptr_packagename(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_packagename.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_appinfo_by_packagename_params::clear_packagename(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_packagename.clear();
}
inline ::idl::Unknown* mcp_get_appinfo_by_packagename_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_appinfo_by_packagename_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_appinfo_by_packagename_params::unknown(){
return _unknown;
}
inline size_t mcp_get_appinfo_by_packagename_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_appinfo_by_packagename_result_params* mcp_get_appinfo_by_packagename_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_appinfo_by_packagename_result_params* tmp=(mcp_get_appinfo_by_packagename_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_appinfo_by_packagename_result_params(pool);
return tmp;
}
inline void mcp_get_appinfo_by_packagename_result_params::destroy(mcp_get_appinfo_by_packagename_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_appinfo_by_packagename_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_appinfo_by_packagename_result_params::mcp_get_appinfo_by_packagename_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_package_info(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_appinfo_by_packagename_result_params::mcp_get_appinfo_by_packagename_result_params(const mcp_get_appinfo_by_packagename_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_package_info(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_appinfo_by_packagename_result_params::~mcp_get_appinfo_by_packagename_result_params(){
}
inline mcp_get_appinfo_by_packagename_result_params& mcp_get_appinfo_by_packagename_result_params::operator=(const mcp_get_appinfo_by_packagename_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_appinfo_by_packagename_result_params::clear(){
_m_package_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_appinfo_by_packagename_result_params::check() const{
// @@string package_info=out(),array(0);
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "package_info" << "' not found";
}
{
// level 0 begin
typeof(_m_package_info)& lr0=(_m_package_info);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_appinfo_by_packagename_result_params::detach(){
_m_package_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_appinfo_by_packagename_result_params& mcp_get_appinfo_by_packagename_result_params::assign(const mcp_get_appinfo_by_packagename_result_params& v){
_m_package_info=v._m_package_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_appinfo_by_packagename_result_params::has_package_info() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_appinfo_by_packagename_result_params::package_info() const{
 return _m_package_info;
}
inline void mcp_get_appinfo_by_packagename_result_params::clear_package_info(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_package_info.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_appinfo_by_packagename_result_params::mutable_package_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_package_info);
}
inline ::idl::vector< ::idl::string >* mcp_get_appinfo_by_packagename_result_params::m_package_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_package_info);
}
inline size_t mcp_get_appinfo_by_packagename_result_params::package_info_size() const{
/*  */ return _m_package_info.size();
}
inline const char* mcp_get_appinfo_by_packagename_result_params::package_info(size_t i0,unsigned int* size) const{
 return _m_package_info.get(i0).get(size);
}
inline mcp_get_appinfo_by_packagename_result_params& mcp_get_appinfo_by_packagename_result_params::set_package_info(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_package_info.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_appinfo_by_packagename_result_params& mcp_get_appinfo_by_packagename_result_params::set_ptr_package_info(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_package_info.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_appinfo_by_packagename_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_appinfo_by_packagename_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_appinfo_by_packagename_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_appinfo_by_packagename_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_appinfo_by_packagename_response* mcp_get_appinfo_by_packagename_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_appinfo_by_packagename_response* tmp=(mcp_get_appinfo_by_packagename_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_appinfo_by_packagename_response(pool);
return tmp;
}
inline void mcp_get_appinfo_by_packagename_response::destroy(mcp_get_appinfo_by_packagename_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_appinfo_by_packagename_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_appinfo_by_packagename_response::mcp_get_appinfo_by_packagename_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_appinfo_by_packagename_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_appinfo_by_packagename_response::mcp_get_appinfo_by_packagename_response(const mcp_get_appinfo_by_packagename_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_appinfo_by_packagename_result_params::create(_pool);
assign(v);
}
inline mcp_get_appinfo_by_packagename_response::~mcp_get_appinfo_by_packagename_response(){
if(_m_result_params){
::idl::mcp_get_appinfo_by_packagename_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_appinfo_by_packagename_response& mcp_get_appinfo_by_packagename_response::operator=(const mcp_get_appinfo_by_packagename_response& v){
assign(v);
return *this;
}
inline void mcp_get_appinfo_by_packagename_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_appinfo_by_packagename_response::check() const{
// @@mcp_get_appinfo_by_packagename_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_appinfo_by_packagename_result_params& item=const_cast< ::idl::mcp_get_appinfo_by_packagename_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_appinfo_by_packagename_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_appinfo_by_packagename_response& mcp_get_appinfo_by_packagename_response::assign(const mcp_get_appinfo_by_packagename_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_appinfo_by_packagename_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_appinfo_by_packagename_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_appinfo_by_packagename_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_appinfo_by_packagename_result_params& mcp_get_appinfo_by_packagename_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_appinfo_by_packagename_result_params* mcp_get_appinfo_by_packagename_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_appinfo_by_packagename_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_appinfo_by_packagename_result_params* mcp_get_appinfo_by_packagename_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_appinfo_by_packagename_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_appinfo_by_packagename_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_appinfo_by_packagename_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_appinfo_by_packagename_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_appinfo_by_packagename_response::unknown(){
return _unknown;
}
inline size_t mcp_get_appinfo_by_packagename_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_score_by_packagename_and_versioncode_params* mcp_get_score_by_packagename_and_versioncode_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_score_by_packagename_and_versioncode_params* tmp=(mcp_get_score_by_packagename_and_versioncode_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_score_by_packagename_and_versioncode_params(pool);
return tmp;
}
inline void mcp_get_score_by_packagename_and_versioncode_params::destroy(mcp_get_score_by_packagename_and_versioncode_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_score_by_packagename_and_versioncode_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_score_by_packagename_and_versioncode_params::mcp_get_score_by_packagename_and_versioncode_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_packagename_versioncode_json(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_score_by_packagename_and_versioncode_params::mcp_get_score_by_packagename_and_versioncode_params(const mcp_get_score_by_packagename_and_versioncode_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_packagename_versioncode_json(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_score_by_packagename_and_versioncode_params::~mcp_get_score_by_packagename_and_versioncode_params(){
}
inline mcp_get_score_by_packagename_and_versioncode_params& mcp_get_score_by_packagename_and_versioncode_params::operator=(const mcp_get_score_by_packagename_and_versioncode_params& v){
assign(v);
return *this;
}
inline void mcp_get_score_by_packagename_and_versioncode_params::clear(){
_m_packagename_versioncode_json.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_score_by_packagename_and_versioncode_params::check() const{
// @@string packagename_versioncode_json=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "packagename_versioncode_json" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_packagename_versioncode_json.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_score_by_packagename_and_versioncode_params::detach(){
_m_packagename_versioncode_json.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_score_by_packagename_and_versioncode_params& mcp_get_score_by_packagename_and_versioncode_params::assign(const mcp_get_score_by_packagename_and_versioncode_params& v){
_m_packagename_versioncode_json=v._m_packagename_versioncode_json;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_score_by_packagename_and_versioncode_params::has_packagename_versioncode_json() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_score_by_packagename_and_versioncode_params::packagename_versioncode_json(unsigned int* size) const{
return _m_packagename_versioncode_json.get(size);
}
inline mcp_get_score_by_packagename_and_versioncode_params& mcp_get_score_by_packagename_and_versioncode_params::set_packagename_versioncode_json(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_packagename_versioncode_json.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_score_by_packagename_and_versioncode_params& mcp_get_score_by_packagename_and_versioncode_params::set_ptr_packagename_versioncode_json(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_packagename_versioncode_json.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_score_by_packagename_and_versioncode_params::clear_packagename_versioncode_json(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_packagename_versioncode_json.clear();
}
inline ::idl::Unknown* mcp_get_score_by_packagename_and_versioncode_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_score_by_packagename_and_versioncode_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_score_by_packagename_and_versioncode_params::unknown(){
return _unknown;
}
inline size_t mcp_get_score_by_packagename_and_versioncode_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_score_by_packagename_and_versioncode_result_params* mcp_get_score_by_packagename_and_versioncode_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_score_by_packagename_and_versioncode_result_params* tmp=(mcp_get_score_by_packagename_and_versioncode_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_score_by_packagename_and_versioncode_result_params(pool);
return tmp;
}
inline void mcp_get_score_by_packagename_and_versioncode_result_params::destroy(mcp_get_score_by_packagename_and_versioncode_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_score_by_packagename_and_versioncode_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_score_by_packagename_and_versioncode_result_params::mcp_get_score_by_packagename_and_versioncode_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_scores_json(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_score_by_packagename_and_versioncode_result_params::mcp_get_score_by_packagename_and_versioncode_result_params(const mcp_get_score_by_packagename_and_versioncode_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_scores_json(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_score_by_packagename_and_versioncode_result_params::~mcp_get_score_by_packagename_and_versioncode_result_params(){
}
inline mcp_get_score_by_packagename_and_versioncode_result_params& mcp_get_score_by_packagename_and_versioncode_result_params::operator=(const mcp_get_score_by_packagename_and_versioncode_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_score_by_packagename_and_versioncode_result_params::clear(){
_m_scores_json.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_score_by_packagename_and_versioncode_result_params::check() const{
// @@string scores_json=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "scores_json" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_scores_json.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_score_by_packagename_and_versioncode_result_params::detach(){
_m_scores_json.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_score_by_packagename_and_versioncode_result_params& mcp_get_score_by_packagename_and_versioncode_result_params::assign(const mcp_get_score_by_packagename_and_versioncode_result_params& v){
_m_scores_json=v._m_scores_json;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_score_by_packagename_and_versioncode_result_params::has_scores_json() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_score_by_packagename_and_versioncode_result_params::scores_json(unsigned int* size) const{
return _m_scores_json.get(size);
}
inline mcp_get_score_by_packagename_and_versioncode_result_params& mcp_get_score_by_packagename_and_versioncode_result_params::set_scores_json(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_scores_json.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_score_by_packagename_and_versioncode_result_params& mcp_get_score_by_packagename_and_versioncode_result_params::set_ptr_scores_json(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_scores_json.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_score_by_packagename_and_versioncode_result_params::clear_scores_json(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_scores_json.clear();
}
inline ::idl::Unknown* mcp_get_score_by_packagename_and_versioncode_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_score_by_packagename_and_versioncode_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_score_by_packagename_and_versioncode_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_score_by_packagename_and_versioncode_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_score_by_packagename_and_versioncode_response* mcp_get_score_by_packagename_and_versioncode_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_score_by_packagename_and_versioncode_response* tmp=(mcp_get_score_by_packagename_and_versioncode_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_score_by_packagename_and_versioncode_response(pool);
return tmp;
}
inline void mcp_get_score_by_packagename_and_versioncode_response::destroy(mcp_get_score_by_packagename_and_versioncode_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_score_by_packagename_and_versioncode_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_score_by_packagename_and_versioncode_response::mcp_get_score_by_packagename_and_versioncode_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_score_by_packagename_and_versioncode_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_score_by_packagename_and_versioncode_response::mcp_get_score_by_packagename_and_versioncode_response(const mcp_get_score_by_packagename_and_versioncode_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_score_by_packagename_and_versioncode_result_params::create(_pool);
assign(v);
}
inline mcp_get_score_by_packagename_and_versioncode_response::~mcp_get_score_by_packagename_and_versioncode_response(){
if(_m_result_params){
::idl::mcp_get_score_by_packagename_and_versioncode_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_score_by_packagename_and_versioncode_response& mcp_get_score_by_packagename_and_versioncode_response::operator=(const mcp_get_score_by_packagename_and_versioncode_response& v){
assign(v);
return *this;
}
inline void mcp_get_score_by_packagename_and_versioncode_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_score_by_packagename_and_versioncode_response::check() const{
// @@mcp_get_score_by_packagename_and_versioncode_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_score_by_packagename_and_versioncode_result_params& item=const_cast< ::idl::mcp_get_score_by_packagename_and_versioncode_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_score_by_packagename_and_versioncode_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_score_by_packagename_and_versioncode_response& mcp_get_score_by_packagename_and_versioncode_response::assign(const mcp_get_score_by_packagename_and_versioncode_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_score_by_packagename_and_versioncode_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_score_by_packagename_and_versioncode_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_score_by_packagename_and_versioncode_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_score_by_packagename_and_versioncode_result_params& mcp_get_score_by_packagename_and_versioncode_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_score_by_packagename_and_versioncode_result_params* mcp_get_score_by_packagename_and_versioncode_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_score_by_packagename_and_versioncode_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_score_by_packagename_and_versioncode_result_params* mcp_get_score_by_packagename_and_versioncode_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_score_by_packagename_and_versioncode_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_score_by_packagename_and_versioncode_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_score_by_packagename_and_versioncode_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_score_by_packagename_and_versioncode_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_score_by_packagename_and_versioncode_response::unknown(){
return _unknown;
}
inline size_t mcp_get_score_by_packagename_and_versioncode_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_info_by_packagename_and_versioncode_params* mcp_get_content_info_by_packagename_and_versioncode_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_info_by_packagename_and_versioncode_params* tmp=(mcp_get_content_info_by_packagename_and_versioncode_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_info_by_packagename_and_versioncode_params(pool);
return tmp;
}
inline void mcp_get_content_info_by_packagename_and_versioncode_params::destroy(mcp_get_content_info_by_packagename_and_versioncode_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_info_by_packagename_and_versioncode_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_info_by_packagename_and_versioncode_params::mcp_get_content_info_by_packagename_and_versioncode_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_packagename(_pool)
,_m_versioncode(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_info_by_packagename_and_versioncode_params::mcp_get_content_info_by_packagename_and_versioncode_params(const mcp_get_content_info_by_packagename_and_versioncode_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_packagename(_pool)
,_m_versioncode(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_info_by_packagename_and_versioncode_params::~mcp_get_content_info_by_packagename_and_versioncode_params(){
}
inline mcp_get_content_info_by_packagename_and_versioncode_params& mcp_get_content_info_by_packagename_and_versioncode_params::operator=(const mcp_get_content_info_by_packagename_and_versioncode_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_info_by_packagename_and_versioncode_params::clear(){
_m_packagename.clear();
_m_versioncode.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_info_by_packagename_and_versioncode_params::check() const{
// @@string packagename=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "packagename" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_packagename.get();

}
// @@string versioncode=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "versioncode" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_versioncode.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_info_by_packagename_and_versioncode_params::detach(){
_m_packagename.detach();
_m_versioncode.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_info_by_packagename_and_versioncode_params& mcp_get_content_info_by_packagename_and_versioncode_params::assign(const mcp_get_content_info_by_packagename_and_versioncode_params& v){
_m_packagename=v._m_packagename;
_m_versioncode=v._m_versioncode;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_info_by_packagename_and_versioncode_params::has_packagename() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_info_by_packagename_and_versioncode_params::packagename(unsigned int* size) const{
return _m_packagename.get(size);
}
inline mcp_get_content_info_by_packagename_and_versioncode_params& mcp_get_content_info_by_packagename_and_versioncode_params::set_packagename(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_packagename.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_info_by_packagename_and_versioncode_params& mcp_get_content_info_by_packagename_and_versioncode_params::set_ptr_packagename(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_packagename.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_info_by_packagename_and_versioncode_params::clear_packagename(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_packagename.clear();
}
inline bool mcp_get_content_info_by_packagename_and_versioncode_params::has_versioncode() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_content_info_by_packagename_and_versioncode_params::versioncode(unsigned int* size) const{
return _m_versioncode.get(size);
}
inline mcp_get_content_info_by_packagename_and_versioncode_params& mcp_get_content_info_by_packagename_and_versioncode_params::set_versioncode(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_versioncode.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_info_by_packagename_and_versioncode_params& mcp_get_content_info_by_packagename_and_versioncode_params::set_ptr_versioncode(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_versioncode.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_info_by_packagename_and_versioncode_params::clear_versioncode(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_versioncode.clear();
}
inline ::idl::Unknown* mcp_get_content_info_by_packagename_and_versioncode_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_info_by_packagename_and_versioncode_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_info_by_packagename_and_versioncode_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_info_by_packagename_and_versioncode_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_info_by_packagename_and_versioncode_result_params* mcp_get_content_info_by_packagename_and_versioncode_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_info_by_packagename_and_versioncode_result_params* tmp=(mcp_get_content_info_by_packagename_and_versioncode_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_info_by_packagename_and_versioncode_result_params(pool);
return tmp;
}
inline void mcp_get_content_info_by_packagename_and_versioncode_result_params::destroy(mcp_get_content_info_by_packagename_and_versioncode_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_info_by_packagename_and_versioncode_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_info_by_packagename_and_versioncode_result_params::mcp_get_content_info_by_packagename_and_versioncode_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_info_by_packagename_and_versioncode_result_params::mcp_get_content_info_by_packagename_and_versioncode_result_params(const mcp_get_content_info_by_packagename_and_versioncode_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_info_by_packagename_and_versioncode_result_params::~mcp_get_content_info_by_packagename_and_versioncode_result_params(){
}
inline mcp_get_content_info_by_packagename_and_versioncode_result_params& mcp_get_content_info_by_packagename_and_versioncode_result_params::operator=(const mcp_get_content_info_by_packagename_and_versioncode_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_info_by_packagename_and_versioncode_result_params::clear(){
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_info_by_packagename_and_versioncode_result_params::check() const{
// @@string info_list=out(),array(0);
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_info_by_packagename_and_versioncode_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_info_by_packagename_and_versioncode_result_params& mcp_get_content_info_by_packagename_and_versioncode_result_params::assign(const mcp_get_content_info_by_packagename_and_versioncode_result_params& v){
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_info_by_packagename_and_versioncode_result_params::has_info_list() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_content_info_by_packagename_and_versioncode_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_content_info_by_packagename_and_versioncode_result_params::clear_info_list(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_content_info_by_packagename_and_versioncode_result_params::mutable_info_list(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::string >* mcp_get_content_info_by_packagename_and_versioncode_result_params::m_info_list(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_content_info_by_packagename_and_versioncode_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const char* mcp_get_content_info_by_packagename_and_versioncode_result_params::info_list(size_t i0,unsigned int* size) const{
 return _m_info_list.get(i0).get(size);
}
inline mcp_get_content_info_by_packagename_and_versioncode_result_params& mcp_get_content_info_by_packagename_and_versioncode_result_params::set_info_list(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_list.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_info_by_packagename_and_versioncode_result_params& mcp_get_content_info_by_packagename_and_versioncode_result_params::set_ptr_info_list(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_list.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_info_by_packagename_and_versioncode_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_info_by_packagename_and_versioncode_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_info_by_packagename_and_versioncode_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_info_by_packagename_and_versioncode_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_info_by_packagename_and_versioncode_response* mcp_get_content_info_by_packagename_and_versioncode_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_info_by_packagename_and_versioncode_response* tmp=(mcp_get_content_info_by_packagename_and_versioncode_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_info_by_packagename_and_versioncode_response(pool);
return tmp;
}
inline void mcp_get_content_info_by_packagename_and_versioncode_response::destroy(mcp_get_content_info_by_packagename_and_versioncode_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_info_by_packagename_and_versioncode_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_info_by_packagename_and_versioncode_response::mcp_get_content_info_by_packagename_and_versioncode_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_info_by_packagename_and_versioncode_response::mcp_get_content_info_by_packagename_and_versioncode_response(const mcp_get_content_info_by_packagename_and_versioncode_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_info_by_packagename_and_versioncode_response::~mcp_get_content_info_by_packagename_and_versioncode_response(){
if(_m_result_params){
::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_info_by_packagename_and_versioncode_response& mcp_get_content_info_by_packagename_and_versioncode_response::operator=(const mcp_get_content_info_by_packagename_and_versioncode_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_info_by_packagename_and_versioncode_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_info_by_packagename_and_versioncode_response::check() const{
// @@mcp_get_content_info_by_packagename_and_versioncode_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params& item=const_cast< ::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_info_by_packagename_and_versioncode_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_info_by_packagename_and_versioncode_response& mcp_get_content_info_by_packagename_and_versioncode_response::assign(const mcp_get_content_info_by_packagename_and_versioncode_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_info_by_packagename_and_versioncode_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params& mcp_get_content_info_by_packagename_and_versioncode_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params* mcp_get_content_info_by_packagename_and_versioncode_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params* mcp_get_content_info_by_packagename_and_versioncode_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_info_by_packagename_and_versioncode_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_info_by_packagename_and_versioncode_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_info_by_packagename_and_versioncode_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_info_by_packagename_and_versioncode_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_info_by_packagename_and_versioncode_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_info_by_packagename_params* mcp_get_content_info_by_packagename_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_info_by_packagename_params* tmp=(mcp_get_content_info_by_packagename_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_info_by_packagename_params(pool);
return tmp;
}
inline void mcp_get_content_info_by_packagename_params::destroy(mcp_get_content_info_by_packagename_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_info_by_packagename_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_info_by_packagename_params::mcp_get_content_info_by_packagename_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_packagename(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_info_by_packagename_params::mcp_get_content_info_by_packagename_params(const mcp_get_content_info_by_packagename_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_packagename(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_info_by_packagename_params::~mcp_get_content_info_by_packagename_params(){
}
inline mcp_get_content_info_by_packagename_params& mcp_get_content_info_by_packagename_params::operator=(const mcp_get_content_info_by_packagename_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_info_by_packagename_params::clear(){
_m_packagename.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_info_by_packagename_params::check() const{
// @@string packagename=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "packagename" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_packagename.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_info_by_packagename_params::detach(){
_m_packagename.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_info_by_packagename_params& mcp_get_content_info_by_packagename_params::assign(const mcp_get_content_info_by_packagename_params& v){
_m_packagename=v._m_packagename;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_info_by_packagename_params::has_packagename() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_info_by_packagename_params::packagename(unsigned int* size) const{
return _m_packagename.get(size);
}
inline mcp_get_content_info_by_packagename_params& mcp_get_content_info_by_packagename_params::set_packagename(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_packagename.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_info_by_packagename_params& mcp_get_content_info_by_packagename_params::set_ptr_packagename(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_packagename.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_info_by_packagename_params::clear_packagename(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_packagename.clear();
}
inline ::idl::Unknown* mcp_get_content_info_by_packagename_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_info_by_packagename_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_info_by_packagename_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_info_by_packagename_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_info_by_packagename_result_params* mcp_get_content_info_by_packagename_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_info_by_packagename_result_params* tmp=(mcp_get_content_info_by_packagename_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_info_by_packagename_result_params(pool);
return tmp;
}
inline void mcp_get_content_info_by_packagename_result_params::destroy(mcp_get_content_info_by_packagename_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_info_by_packagename_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_info_by_packagename_result_params::mcp_get_content_info_by_packagename_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_info_by_packagename_result_params::mcp_get_content_info_by_packagename_result_params(const mcp_get_content_info_by_packagename_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_info_by_packagename_result_params::~mcp_get_content_info_by_packagename_result_params(){
}
inline mcp_get_content_info_by_packagename_result_params& mcp_get_content_info_by_packagename_result_params::operator=(const mcp_get_content_info_by_packagename_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_info_by_packagename_result_params::clear(){
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_info_by_packagename_result_params::check() const{
// @@string info_list=out(),array(0);
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_info_by_packagename_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_info_by_packagename_result_params& mcp_get_content_info_by_packagename_result_params::assign(const mcp_get_content_info_by_packagename_result_params& v){
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_info_by_packagename_result_params::has_info_list() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_content_info_by_packagename_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_content_info_by_packagename_result_params::clear_info_list(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_content_info_by_packagename_result_params::mutable_info_list(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::string >* mcp_get_content_info_by_packagename_result_params::m_info_list(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_content_info_by_packagename_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const char* mcp_get_content_info_by_packagename_result_params::info_list(size_t i0,unsigned int* size) const{
 return _m_info_list.get(i0).get(size);
}
inline mcp_get_content_info_by_packagename_result_params& mcp_get_content_info_by_packagename_result_params::set_info_list(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_list.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_info_by_packagename_result_params& mcp_get_content_info_by_packagename_result_params::set_ptr_info_list(size_t i0,const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_list.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_info_by_packagename_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_info_by_packagename_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_info_by_packagename_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_info_by_packagename_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_info_by_packagename_response* mcp_get_content_info_by_packagename_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_info_by_packagename_response* tmp=(mcp_get_content_info_by_packagename_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_info_by_packagename_response(pool);
return tmp;
}
inline void mcp_get_content_info_by_packagename_response::destroy(mcp_get_content_info_by_packagename_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_info_by_packagename_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_info_by_packagename_response::mcp_get_content_info_by_packagename_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_info_by_packagename_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_info_by_packagename_response::mcp_get_content_info_by_packagename_response(const mcp_get_content_info_by_packagename_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_info_by_packagename_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_info_by_packagename_response::~mcp_get_content_info_by_packagename_response(){
if(_m_result_params){
::idl::mcp_get_content_info_by_packagename_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_info_by_packagename_response& mcp_get_content_info_by_packagename_response::operator=(const mcp_get_content_info_by_packagename_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_info_by_packagename_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_info_by_packagename_response::check() const{
// @@mcp_get_content_info_by_packagename_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_info_by_packagename_result_params& item=const_cast< ::idl::mcp_get_content_info_by_packagename_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_info_by_packagename_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_info_by_packagename_response& mcp_get_content_info_by_packagename_response::assign(const mcp_get_content_info_by_packagename_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_info_by_packagename_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_info_by_packagename_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_info_by_packagename_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_info_by_packagename_result_params& mcp_get_content_info_by_packagename_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_info_by_packagename_result_params* mcp_get_content_info_by_packagename_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_info_by_packagename_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_info_by_packagename_result_params* mcp_get_content_info_by_packagename_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_info_by_packagename_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_info_by_packagename_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_info_by_packagename_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_info_by_packagename_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_info_by_packagename_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_info_by_packagename_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_id_params* mcp_get_online_game_by_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_id_params* tmp=(mcp_get_online_game_by_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_id_params(pool);
return tmp;
}
inline void mcp_get_online_game_by_id_params::destroy(mcp_get_online_game_by_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_id_params::mcp_get_online_game_by_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_id_params::mcp_get_online_game_by_id_params(const mcp_get_online_game_by_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_online_game_by_id_params::~mcp_get_online_game_by_id_params(){
}
inline mcp_get_online_game_by_id_params& mcp_get_online_game_by_id_params::operator=(const mcp_get_online_game_by_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_id_params::clear(){
_m_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_id_params::check() const{
// @@string id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_id_params::detach(){
_m_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_id_params& mcp_get_online_game_by_id_params::assign(const mcp_get_online_game_by_id_params& v){
_m_id=v._m_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_id_params::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_online_game_by_id_params::id(unsigned int* size) const{
return _m_id.get(size);
}
inline mcp_get_online_game_by_id_params& mcp_get_online_game_by_id_params::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_online_game_by_id_params& mcp_get_online_game_by_id_params::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_online_game_by_id_params::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline ::idl::Unknown* mcp_get_online_game_by_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_id_result_params* mcp_get_online_game_by_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_id_result_params* tmp=(mcp_get_online_game_by_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_id_result_params(pool);
return tmp;
}
inline void mcp_get_online_game_by_id_result_params::destroy(mcp_get_online_game_by_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_id_result_params::mcp_get_online_game_by_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_info(0)
,_unknown(_pool){
_m_info=::idl::online_game_info_t::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_id_result_params::mcp_get_online_game_by_id_result_params(const mcp_get_online_game_by_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_info(0)
,_unknown(_pool){
_m_info=::idl::online_game_info_t::create(_pool);
assign(v);
}
inline mcp_get_online_game_by_id_result_params::~mcp_get_online_game_by_id_result_params(){
if(_m_info){
::idl::online_game_info_t::destroy(_m_info);
_m_info=0;
}
}
inline mcp_get_online_game_by_id_result_params& mcp_get_online_game_by_id_result_params::operator=(const mcp_get_online_game_by_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_id_result_params::clear(){
// _m_result=0;
if(_m_info){
_m_info->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_id_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}
// @@online_game_info_t info=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info" << "' not found";
}
{
::idl::online_game_info_t& item=const_cast< ::idl::online_game_info_t& >(*_m_info);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_id_result_params::detach(){
if(_m_info){
_m_info->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_id_result_params& mcp_get_online_game_by_id_result_params::assign(const mcp_get_online_game_by_id_result_params& v){
_m_result=v._m_result;
if(!v._m_info){
if(_m_info){
::idl::online_game_info_t::destroy(_m_info);
}
_m_info=0;
}else{
if(!_m_info){
_m_info=::idl::online_game_info_t::create(_pool);
}
*_m_info=*v._m_info;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_id_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_online_game_by_id_result_params::result() const{
return _m_result;
}
inline mcp_get_online_game_by_id_result_params& mcp_get_online_game_by_id_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_get_online_game_by_id_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_get_online_game_by_id_result_params::has_info() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::online_game_info_t& mcp_get_online_game_by_id_result_params::info() const{
 return *_m_info;
}
inline ::idl::online_game_info_t* mcp_get_online_game_by_id_result_params::mutable_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 if(!_m_info){
_m_info=::idl::online_game_info_t::create(_pool);
}
return _m_info;
}
inline ::idl::online_game_info_t* mcp_get_online_game_by_id_result_params::m_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 if(!_m_info){
_m_info=::idl::online_game_info_t::create(_pool);
}
return _m_info;
}
inline void mcp_get_online_game_by_id_result_params::clear_info(){
if(_m_info){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info->clear();
}
}
inline ::idl::Unknown* mcp_get_online_game_by_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_id_response* mcp_get_online_game_by_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_id_response* tmp=(mcp_get_online_game_by_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_id_response(pool);
return tmp;
}
inline void mcp_get_online_game_by_id_response::destroy(mcp_get_online_game_by_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_id_response::mcp_get_online_game_by_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_online_game_by_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_id_response::mcp_get_online_game_by_id_response(const mcp_get_online_game_by_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_online_game_by_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_online_game_by_id_response::~mcp_get_online_game_by_id_response(){
if(_m_result_params){
::idl::mcp_get_online_game_by_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_online_game_by_id_response& mcp_get_online_game_by_id_response::operator=(const mcp_get_online_game_by_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_id_response::check() const{
// @@mcp_get_online_game_by_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_online_game_by_id_result_params& item=const_cast< ::idl::mcp_get_online_game_by_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_id_response& mcp_get_online_game_by_id_response::assign(const mcp_get_online_game_by_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_online_game_by_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_online_game_by_id_result_params& mcp_get_online_game_by_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_online_game_by_id_result_params* mcp_get_online_game_by_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_online_game_by_id_result_params* mcp_get_online_game_by_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_online_game_by_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_online_game_by_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_class_id_params* mcp_get_online_game_by_class_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_class_id_params* tmp=(mcp_get_online_game_by_class_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_class_id_params(pool);
return tmp;
}
inline void mcp_get_online_game_by_class_id_params::destroy(mcp_get_online_game_by_class_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_class_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_class_id_params::mcp_get_online_game_by_class_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_class_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_class_id_params::mcp_get_online_game_by_class_id_params(const mcp_get_online_game_by_class_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_class_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_online_game_by_class_id_params::~mcp_get_online_game_by_class_id_params(){
}
inline mcp_get_online_game_by_class_id_params& mcp_get_online_game_by_class_id_params::operator=(const mcp_get_online_game_by_class_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_class_id_params::clear(){
_m_class_id.clear();
_m_type_id.clear();
// _m_orderby=0;
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_class_id_params::check() const{
// @@string class_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}
// @@string type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t orderby=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "orderby" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_orderby;

}
// @@uint32_t page=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_class_id_params::detach(){
_m_class_id.detach();
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_class_id_params& mcp_get_online_game_by_class_id_params::assign(const mcp_get_online_game_by_class_id_params& v){
_m_class_id=v._m_class_id;
_m_type_id=v._m_type_id;
_m_orderby=v._m_orderby;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_class_id_params::has_class_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_online_game_by_class_id_params::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_get_online_game_by_class_id_params& mcp_get_online_game_by_class_id_params::set_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_online_game_by_class_id_params& mcp_get_online_game_by_class_id_params::set_ptr_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_online_game_by_class_id_params::clear_class_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_class_id.clear();
}
inline bool mcp_get_online_game_by_class_id_params::has_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_online_game_by_class_id_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_online_game_by_class_id_params& mcp_get_online_game_by_class_id_params::set_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_online_game_by_class_id_params& mcp_get_online_game_by_class_id_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_online_game_by_class_id_params::clear_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_online_game_by_class_id_params::has_orderby() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_online_game_by_class_id_params::orderby() const{
return _m_orderby;
}
inline mcp_get_online_game_by_class_id_params& mcp_get_online_game_by_class_id_params::set_orderby(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_orderby=v;
return *this;
}
inline void mcp_get_online_game_by_class_id_params::clear_orderby(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_orderby=0;
}
inline bool mcp_get_online_game_by_class_id_params::has_page() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_online_game_by_class_id_params::page() const{
return _m_page;
}
inline mcp_get_online_game_by_class_id_params& mcp_get_online_game_by_class_id_params::set_page(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_online_game_by_class_id_params::clear_page(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page=0;
}
inline bool mcp_get_online_game_by_class_id_params::has_page_size() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_online_game_by_class_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_online_game_by_class_id_params& mcp_get_online_game_by_class_id_params::set_page_size(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_online_game_by_class_id_params::clear_page_size(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_online_game_by_class_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_class_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_class_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_class_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_class_id_result_params* mcp_get_online_game_by_class_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_class_id_result_params* tmp=(mcp_get_online_game_by_class_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_class_id_result_params(pool);
return tmp;
}
inline void mcp_get_online_game_by_class_id_result_params::destroy(mcp_get_online_game_by_class_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_class_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_class_id_result_params::mcp_get_online_game_by_class_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_class_name(_pool)
,_m_class_icon(_pool)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_class_id_result_params::mcp_get_online_game_by_class_id_result_params(const mcp_get_online_game_by_class_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_class_name(_pool)
,_m_class_icon(_pool)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_online_game_by_class_id_result_params::~mcp_get_online_game_by_class_id_result_params(){
}
inline mcp_get_online_game_by_class_id_result_params& mcp_get_online_game_by_class_id_result_params::operator=(const mcp_get_online_game_by_class_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_class_id_result_params::clear(){
// _m_count=0;
_m_class_name.clear();
_m_class_icon.clear();
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_class_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string class_name=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_name.get();

}
// @@string class_icon=out();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_icon" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_icon.get();

}
// @@online_game_info_t info_list=out(),array(0);
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::online_game_info_t& item=const_cast< ::idl::online_game_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_class_id_result_params::detach(){
_m_class_name.detach();
_m_class_icon.detach();
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_class_id_result_params& mcp_get_online_game_by_class_id_result_params::assign(const mcp_get_online_game_by_class_id_result_params& v){
_m_count=v._m_count;
_m_class_name=v._m_class_name;
_m_class_icon=v._m_class_icon;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_class_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_online_game_by_class_id_result_params::count() const{
return _m_count;
}
inline mcp_get_online_game_by_class_id_result_params& mcp_get_online_game_by_class_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_online_game_by_class_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_online_game_by_class_id_result_params::has_class_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_online_game_by_class_id_result_params::class_name(unsigned int* size) const{
return _m_class_name.get(size);
}
inline mcp_get_online_game_by_class_id_result_params& mcp_get_online_game_by_class_id_result_params::set_class_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_class_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_online_game_by_class_id_result_params& mcp_get_online_game_by_class_id_result_params::set_ptr_class_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_class_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_online_game_by_class_id_result_params::clear_class_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_class_name.clear();
}
inline bool mcp_get_online_game_by_class_id_result_params::has_class_icon() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_online_game_by_class_id_result_params::class_icon(unsigned int* size) const{
return _m_class_icon.get(size);
}
inline mcp_get_online_game_by_class_id_result_params& mcp_get_online_game_by_class_id_result_params::set_class_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_class_icon.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_online_game_by_class_id_result_params& mcp_get_online_game_by_class_id_result_params::set_ptr_class_icon(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_class_icon.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_online_game_by_class_id_result_params::clear_class_icon(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_class_icon.clear();
}
inline bool mcp_get_online_game_by_class_id_result_params::has_info_list() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const ::idl::vector< ::idl::online_game_info_t >& mcp_get_online_game_by_class_id_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_online_game_by_class_id_result_params::clear_info_list(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::online_game_info_t >* mcp_get_online_game_by_class_id_result_params::mutable_info_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::online_game_info_t >* mcp_get_online_game_by_class_id_result_params::m_info_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_online_game_by_class_id_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const ::idl::online_game_info_t& mcp_get_online_game_by_class_id_result_params::info_list(size_t i0) const{
 return _m_info_list.get(i0);
}
inline ::idl::online_game_info_t* mcp_get_online_game_by_class_id_result_params::mutable_info_list(size_t i0){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::online_game_info_t* mcp_get_online_game_by_class_id_result_params::m_info_list(size_t i0){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_online_game_by_class_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_class_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_class_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_class_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_class_id_response* mcp_get_online_game_by_class_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_class_id_response* tmp=(mcp_get_online_game_by_class_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_class_id_response(pool);
return tmp;
}
inline void mcp_get_online_game_by_class_id_response::destroy(mcp_get_online_game_by_class_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_class_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_class_id_response::mcp_get_online_game_by_class_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_online_game_by_class_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_class_id_response::mcp_get_online_game_by_class_id_response(const mcp_get_online_game_by_class_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_online_game_by_class_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_online_game_by_class_id_response::~mcp_get_online_game_by_class_id_response(){
if(_m_result_params){
::idl::mcp_get_online_game_by_class_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_online_game_by_class_id_response& mcp_get_online_game_by_class_id_response::operator=(const mcp_get_online_game_by_class_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_class_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_class_id_response::check() const{
// @@mcp_get_online_game_by_class_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_online_game_by_class_id_result_params& item=const_cast< ::idl::mcp_get_online_game_by_class_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_class_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_class_id_response& mcp_get_online_game_by_class_id_response::assign(const mcp_get_online_game_by_class_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_online_game_by_class_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_class_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_class_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_online_game_by_class_id_result_params& mcp_get_online_game_by_class_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_online_game_by_class_id_result_params* mcp_get_online_game_by_class_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_class_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_online_game_by_class_id_result_params* mcp_get_online_game_by_class_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_class_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_online_game_by_class_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_online_game_by_class_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_class_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_class_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_class_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_cp_id_params* mcp_get_online_game_by_cp_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_cp_id_params* tmp=(mcp_get_online_game_by_cp_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_cp_id_params(pool);
return tmp;
}
inline void mcp_get_online_game_by_cp_id_params::destroy(mcp_get_online_game_by_cp_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_cp_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_cp_id_params::mcp_get_online_game_by_cp_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_cp_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_cp_id_params::mcp_get_online_game_by_cp_id_params(const mcp_get_online_game_by_cp_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_cp_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_online_game_by_cp_id_params::~mcp_get_online_game_by_cp_id_params(){
}
inline mcp_get_online_game_by_cp_id_params& mcp_get_online_game_by_cp_id_params::operator=(const mcp_get_online_game_by_cp_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_cp_id_params::clear(){
_m_cp_id.clear();
_m_type_id.clear();
// _m_orderby=0;
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_cp_id_params::check() const{
// @@string cp_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cp_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_cp_id.get();

}
// @@string type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t orderby=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "orderby" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_orderby;

}
// @@uint32_t page=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_cp_id_params::detach(){
_m_cp_id.detach();
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_cp_id_params& mcp_get_online_game_by_cp_id_params::assign(const mcp_get_online_game_by_cp_id_params& v){
_m_cp_id=v._m_cp_id;
_m_type_id=v._m_type_id;
_m_orderby=v._m_orderby;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_cp_id_params::has_cp_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_online_game_by_cp_id_params::cp_id(unsigned int* size) const{
return _m_cp_id.get(size);
}
inline mcp_get_online_game_by_cp_id_params& mcp_get_online_game_by_cp_id_params::set_cp_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_cp_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_online_game_by_cp_id_params& mcp_get_online_game_by_cp_id_params::set_ptr_cp_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_cp_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_online_game_by_cp_id_params::clear_cp_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_cp_id.clear();
}
inline bool mcp_get_online_game_by_cp_id_params::has_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_online_game_by_cp_id_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_online_game_by_cp_id_params& mcp_get_online_game_by_cp_id_params::set_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_online_game_by_cp_id_params& mcp_get_online_game_by_cp_id_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_online_game_by_cp_id_params::clear_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_online_game_by_cp_id_params::has_orderby() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_online_game_by_cp_id_params::orderby() const{
return _m_orderby;
}
inline mcp_get_online_game_by_cp_id_params& mcp_get_online_game_by_cp_id_params::set_orderby(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_orderby=v;
return *this;
}
inline void mcp_get_online_game_by_cp_id_params::clear_orderby(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_orderby=0;
}
inline bool mcp_get_online_game_by_cp_id_params::has_page() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_online_game_by_cp_id_params::page() const{
return _m_page;
}
inline mcp_get_online_game_by_cp_id_params& mcp_get_online_game_by_cp_id_params::set_page(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_online_game_by_cp_id_params::clear_page(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page=0;
}
inline bool mcp_get_online_game_by_cp_id_params::has_page_size() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_online_game_by_cp_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_online_game_by_cp_id_params& mcp_get_online_game_by_cp_id_params::set_page_size(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_online_game_by_cp_id_params::clear_page_size(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_online_game_by_cp_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_cp_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_cp_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_cp_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_cp_id_result_params* mcp_get_online_game_by_cp_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_cp_id_result_params* tmp=(mcp_get_online_game_by_cp_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_cp_id_result_params(pool);
return tmp;
}
inline void mcp_get_online_game_by_cp_id_result_params::destroy(mcp_get_online_game_by_cp_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_cp_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_cp_id_result_params::mcp_get_online_game_by_cp_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_cp_name(_pool)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_cp_id_result_params::mcp_get_online_game_by_cp_id_result_params(const mcp_get_online_game_by_cp_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_cp_name(_pool)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_online_game_by_cp_id_result_params::~mcp_get_online_game_by_cp_id_result_params(){
}
inline mcp_get_online_game_by_cp_id_result_params& mcp_get_online_game_by_cp_id_result_params::operator=(const mcp_get_online_game_by_cp_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_cp_id_result_params::clear(){
// _m_count=0;
_m_cp_name.clear();
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_cp_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string cp_name=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cp_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_cp_name.get();

}
// @@online_game_info_t info_list=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::online_game_info_t& item=const_cast< ::idl::online_game_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_cp_id_result_params::detach(){
_m_cp_name.detach();
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_cp_id_result_params& mcp_get_online_game_by_cp_id_result_params::assign(const mcp_get_online_game_by_cp_id_result_params& v){
_m_count=v._m_count;
_m_cp_name=v._m_cp_name;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_cp_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_online_game_by_cp_id_result_params::count() const{
return _m_count;
}
inline mcp_get_online_game_by_cp_id_result_params& mcp_get_online_game_by_cp_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_online_game_by_cp_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_online_game_by_cp_id_result_params::has_cp_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_online_game_by_cp_id_result_params::cp_name(unsigned int* size) const{
return _m_cp_name.get(size);
}
inline mcp_get_online_game_by_cp_id_result_params& mcp_get_online_game_by_cp_id_result_params::set_cp_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_cp_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_online_game_by_cp_id_result_params& mcp_get_online_game_by_cp_id_result_params::set_ptr_cp_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_cp_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_online_game_by_cp_id_result_params::clear_cp_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_cp_name.clear();
}
inline bool mcp_get_online_game_by_cp_id_result_params::has_info_list() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::online_game_info_t >& mcp_get_online_game_by_cp_id_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_online_game_by_cp_id_result_params::clear_info_list(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::online_game_info_t >* mcp_get_online_game_by_cp_id_result_params::mutable_info_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::online_game_info_t >* mcp_get_online_game_by_cp_id_result_params::m_info_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_online_game_by_cp_id_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const ::idl::online_game_info_t& mcp_get_online_game_by_cp_id_result_params::info_list(size_t i0) const{
 return _m_info_list.get(i0);
}
inline ::idl::online_game_info_t* mcp_get_online_game_by_cp_id_result_params::mutable_info_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::online_game_info_t* mcp_get_online_game_by_cp_id_result_params::m_info_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_online_game_by_cp_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_cp_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_cp_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_cp_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_cp_id_response* mcp_get_online_game_by_cp_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_cp_id_response* tmp=(mcp_get_online_game_by_cp_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_cp_id_response(pool);
return tmp;
}
inline void mcp_get_online_game_by_cp_id_response::destroy(mcp_get_online_game_by_cp_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_cp_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_cp_id_response::mcp_get_online_game_by_cp_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_online_game_by_cp_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_cp_id_response::mcp_get_online_game_by_cp_id_response(const mcp_get_online_game_by_cp_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_online_game_by_cp_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_online_game_by_cp_id_response::~mcp_get_online_game_by_cp_id_response(){
if(_m_result_params){
::idl::mcp_get_online_game_by_cp_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_online_game_by_cp_id_response& mcp_get_online_game_by_cp_id_response::operator=(const mcp_get_online_game_by_cp_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_cp_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_cp_id_response::check() const{
// @@mcp_get_online_game_by_cp_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_online_game_by_cp_id_result_params& item=const_cast< ::idl::mcp_get_online_game_by_cp_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_cp_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_cp_id_response& mcp_get_online_game_by_cp_id_response::assign(const mcp_get_online_game_by_cp_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_online_game_by_cp_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_cp_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_cp_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_online_game_by_cp_id_result_params& mcp_get_online_game_by_cp_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_online_game_by_cp_id_result_params* mcp_get_online_game_by_cp_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_cp_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_online_game_by_cp_id_result_params* mcp_get_online_game_by_cp_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_cp_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_online_game_by_cp_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_online_game_by_cp_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_cp_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_cp_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_cp_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_col_id_params* mcp_get_online_game_by_col_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_col_id_params* tmp=(mcp_get_online_game_by_col_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_col_id_params(pool);
return tmp;
}
inline void mcp_get_online_game_by_col_id_params::destroy(mcp_get_online_game_by_col_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_col_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_col_id_params::mcp_get_online_game_by_col_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_column_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_col_id_params::mcp_get_online_game_by_col_id_params(const mcp_get_online_game_by_col_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_column_id(_pool)
,_m_type_id(_pool)
,_m_orderby(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_online_game_by_col_id_params::~mcp_get_online_game_by_col_id_params(){
}
inline mcp_get_online_game_by_col_id_params& mcp_get_online_game_by_col_id_params::operator=(const mcp_get_online_game_by_col_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_col_id_params::clear(){
_m_column_id.clear();
_m_type_id.clear();
// _m_orderby=0;
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_col_id_params::check() const{
// @@string column_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "column_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_column_id.get();

}
// @@string type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t orderby=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "orderby" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_orderby;

}
// @@uint32_t page=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_col_id_params::detach(){
_m_column_id.detach();
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_col_id_params& mcp_get_online_game_by_col_id_params::assign(const mcp_get_online_game_by_col_id_params& v){
_m_column_id=v._m_column_id;
_m_type_id=v._m_type_id;
_m_orderby=v._m_orderby;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_col_id_params::has_column_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_online_game_by_col_id_params::column_id(unsigned int* size) const{
return _m_column_id.get(size);
}
inline mcp_get_online_game_by_col_id_params& mcp_get_online_game_by_col_id_params::set_column_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_column_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_online_game_by_col_id_params& mcp_get_online_game_by_col_id_params::set_ptr_column_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_column_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_online_game_by_col_id_params::clear_column_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_column_id.clear();
}
inline bool mcp_get_online_game_by_col_id_params::has_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_online_game_by_col_id_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_online_game_by_col_id_params& mcp_get_online_game_by_col_id_params::set_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_online_game_by_col_id_params& mcp_get_online_game_by_col_id_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_online_game_by_col_id_params::clear_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_online_game_by_col_id_params::has_orderby() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_online_game_by_col_id_params::orderby() const{
return _m_orderby;
}
inline mcp_get_online_game_by_col_id_params& mcp_get_online_game_by_col_id_params::set_orderby(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_orderby=v;
return *this;
}
inline void mcp_get_online_game_by_col_id_params::clear_orderby(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_orderby=0;
}
inline bool mcp_get_online_game_by_col_id_params::has_page() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_online_game_by_col_id_params::page() const{
return _m_page;
}
inline mcp_get_online_game_by_col_id_params& mcp_get_online_game_by_col_id_params::set_page(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_online_game_by_col_id_params::clear_page(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page=0;
}
inline bool mcp_get_online_game_by_col_id_params::has_page_size() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_online_game_by_col_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_online_game_by_col_id_params& mcp_get_online_game_by_col_id_params::set_page_size(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_online_game_by_col_id_params::clear_page_size(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_online_game_by_col_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_col_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_col_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_col_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_col_id_result_params* mcp_get_online_game_by_col_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_col_id_result_params* tmp=(mcp_get_online_game_by_col_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_col_id_result_params(pool);
return tmp;
}
inline void mcp_get_online_game_by_col_id_result_params::destroy(mcp_get_online_game_by_col_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_col_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_col_id_result_params::mcp_get_online_game_by_col_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_name(_pool)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_col_id_result_params::mcp_get_online_game_by_col_id_result_params(const mcp_get_online_game_by_col_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_name(_pool)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_online_game_by_col_id_result_params::~mcp_get_online_game_by_col_id_result_params(){
}
inline mcp_get_online_game_by_col_id_result_params& mcp_get_online_game_by_col_id_result_params::operator=(const mcp_get_online_game_by_col_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_col_id_result_params::clear(){
// _m_count=0;
_m_name.clear();
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_col_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string name=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@online_game_info_t info_list=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::online_game_info_t& item=const_cast< ::idl::online_game_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_col_id_result_params::detach(){
_m_name.detach();
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_col_id_result_params& mcp_get_online_game_by_col_id_result_params::assign(const mcp_get_online_game_by_col_id_result_params& v){
_m_count=v._m_count;
_m_name=v._m_name;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_col_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_online_game_by_col_id_result_params::count() const{
return _m_count;
}
inline mcp_get_online_game_by_col_id_result_params& mcp_get_online_game_by_col_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_online_game_by_col_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_online_game_by_col_id_result_params::has_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_online_game_by_col_id_result_params::name(unsigned int* size) const{
return _m_name.get(size);
}
inline mcp_get_online_game_by_col_id_result_params& mcp_get_online_game_by_col_id_result_params::set_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_online_game_by_col_id_result_params& mcp_get_online_game_by_col_id_result_params::set_ptr_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_online_game_by_col_id_result_params::clear_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_name.clear();
}
inline bool mcp_get_online_game_by_col_id_result_params::has_info_list() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::online_game_info_t >& mcp_get_online_game_by_col_id_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_online_game_by_col_id_result_params::clear_info_list(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::online_game_info_t >* mcp_get_online_game_by_col_id_result_params::mutable_info_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::online_game_info_t >* mcp_get_online_game_by_col_id_result_params::m_info_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_online_game_by_col_id_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const ::idl::online_game_info_t& mcp_get_online_game_by_col_id_result_params::info_list(size_t i0) const{
 return _m_info_list.get(i0);
}
inline ::idl::online_game_info_t* mcp_get_online_game_by_col_id_result_params::mutable_info_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::online_game_info_t* mcp_get_online_game_by_col_id_result_params::m_info_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_online_game_by_col_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_col_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_col_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_col_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_col_id_response* mcp_get_online_game_by_col_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_col_id_response* tmp=(mcp_get_online_game_by_col_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_col_id_response(pool);
return tmp;
}
inline void mcp_get_online_game_by_col_id_response::destroy(mcp_get_online_game_by_col_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_col_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_col_id_response::mcp_get_online_game_by_col_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_online_game_by_col_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_col_id_response::mcp_get_online_game_by_col_id_response(const mcp_get_online_game_by_col_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_online_game_by_col_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_online_game_by_col_id_response::~mcp_get_online_game_by_col_id_response(){
if(_m_result_params){
::idl::mcp_get_online_game_by_col_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_online_game_by_col_id_response& mcp_get_online_game_by_col_id_response::operator=(const mcp_get_online_game_by_col_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_col_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_col_id_response::check() const{
// @@mcp_get_online_game_by_col_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_online_game_by_col_id_result_params& item=const_cast< ::idl::mcp_get_online_game_by_col_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_col_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_col_id_response& mcp_get_online_game_by_col_id_response::assign(const mcp_get_online_game_by_col_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_online_game_by_col_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_col_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_col_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_online_game_by_col_id_result_params& mcp_get_online_game_by_col_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_online_game_by_col_id_result_params* mcp_get_online_game_by_col_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_col_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_online_game_by_col_id_result_params* mcp_get_online_game_by_col_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_col_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_online_game_by_col_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_online_game_by_col_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_col_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_col_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_col_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_rank_params* mcp_get_online_game_by_rank_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_rank_params* tmp=(mcp_get_online_game_by_rank_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_rank_params(pool);
return tmp;
}
inline void mcp_get_online_game_by_rank_params::destroy(mcp_get_online_game_by_rank_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_rank_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_rank_params::mcp_get_online_game_by_rank_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_type_id(_pool)
,_m_p_type(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_rank_params::mcp_get_online_game_by_rank_params(const mcp_get_online_game_by_rank_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_type_id(_pool)
,_m_p_type(0)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_online_game_by_rank_params::~mcp_get_online_game_by_rank_params(){
}
inline mcp_get_online_game_by_rank_params& mcp_get_online_game_by_rank_params::operator=(const mcp_get_online_game_by_rank_params& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_rank_params::clear(){
_m_type_id.clear();
// _m_p_type=0;
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_rank_params::check() const{
// @@string type_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t p_type=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "p_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_p_type;

}
// @@uint32_t page=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_rank_params::detach(){
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_rank_params& mcp_get_online_game_by_rank_params::assign(const mcp_get_online_game_by_rank_params& v){
_m_type_id=v._m_type_id;
_m_p_type=v._m_p_type;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_rank_params::has_type_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_online_game_by_rank_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_online_game_by_rank_params& mcp_get_online_game_by_rank_params::set_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_online_game_by_rank_params& mcp_get_online_game_by_rank_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_online_game_by_rank_params::clear_type_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_online_game_by_rank_params::has_p_type() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_online_game_by_rank_params::p_type() const{
return _m_p_type;
}
inline mcp_get_online_game_by_rank_params& mcp_get_online_game_by_rank_params::set_p_type(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_p_type=v;
return *this;
}
inline void mcp_get_online_game_by_rank_params::clear_p_type(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_p_type=0;
}
inline bool mcp_get_online_game_by_rank_params::has_page() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_online_game_by_rank_params::page() const{
return _m_page;
}
inline mcp_get_online_game_by_rank_params& mcp_get_online_game_by_rank_params::set_page(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_online_game_by_rank_params::clear_page(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page=0;
}
inline bool mcp_get_online_game_by_rank_params::has_page_size() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_online_game_by_rank_params::page_size() const{
return _m_page_size;
}
inline mcp_get_online_game_by_rank_params& mcp_get_online_game_by_rank_params::set_page_size(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_online_game_by_rank_params::clear_page_size(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_online_game_by_rank_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_rank_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_rank_params::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_rank_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_rank_result_params* mcp_get_online_game_by_rank_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_rank_result_params* tmp=(mcp_get_online_game_by_rank_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_rank_result_params(pool);
return tmp;
}
inline void mcp_get_online_game_by_rank_result_params::destroy(mcp_get_online_game_by_rank_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_rank_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_rank_result_params::mcp_get_online_game_by_rank_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_rank_result_params::mcp_get_online_game_by_rank_result_params(const mcp_get_online_game_by_rank_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_online_game_by_rank_result_params::~mcp_get_online_game_by_rank_result_params(){
}
inline mcp_get_online_game_by_rank_result_params& mcp_get_online_game_by_rank_result_params::operator=(const mcp_get_online_game_by_rank_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_rank_result_params::clear(){
// _m_count=0;
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_rank_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@online_game_info_t info_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::online_game_info_t& item=const_cast< ::idl::online_game_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_rank_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_rank_result_params& mcp_get_online_game_by_rank_result_params::assign(const mcp_get_online_game_by_rank_result_params& v){
_m_count=v._m_count;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_rank_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_online_game_by_rank_result_params::count() const{
return _m_count;
}
inline mcp_get_online_game_by_rank_result_params& mcp_get_online_game_by_rank_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_online_game_by_rank_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_online_game_by_rank_result_params::has_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::online_game_info_t >& mcp_get_online_game_by_rank_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_online_game_by_rank_result_params::clear_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::online_game_info_t >* mcp_get_online_game_by_rank_result_params::mutable_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::online_game_info_t >* mcp_get_online_game_by_rank_result_params::m_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_online_game_by_rank_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const ::idl::online_game_info_t& mcp_get_online_game_by_rank_result_params::info_list(size_t i0) const{
 return _m_info_list.get(i0);
}
inline ::idl::online_game_info_t* mcp_get_online_game_by_rank_result_params::mutable_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::online_game_info_t* mcp_get_online_game_by_rank_result_params::m_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_online_game_by_rank_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_rank_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_rank_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_rank_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_online_game_by_rank_response* mcp_get_online_game_by_rank_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_online_game_by_rank_response* tmp=(mcp_get_online_game_by_rank_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_online_game_by_rank_response(pool);
return tmp;
}
inline void mcp_get_online_game_by_rank_response::destroy(mcp_get_online_game_by_rank_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_online_game_by_rank_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_online_game_by_rank_response::mcp_get_online_game_by_rank_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_online_game_by_rank_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_online_game_by_rank_response::mcp_get_online_game_by_rank_response(const mcp_get_online_game_by_rank_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_online_game_by_rank_result_params::create(_pool);
assign(v);
}
inline mcp_get_online_game_by_rank_response::~mcp_get_online_game_by_rank_response(){
if(_m_result_params){
::idl::mcp_get_online_game_by_rank_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_online_game_by_rank_response& mcp_get_online_game_by_rank_response::operator=(const mcp_get_online_game_by_rank_response& v){
assign(v);
return *this;
}
inline void mcp_get_online_game_by_rank_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_online_game_by_rank_response::check() const{
// @@mcp_get_online_game_by_rank_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_online_game_by_rank_result_params& item=const_cast< ::idl::mcp_get_online_game_by_rank_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_online_game_by_rank_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_online_game_by_rank_response& mcp_get_online_game_by_rank_response::assign(const mcp_get_online_game_by_rank_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_online_game_by_rank_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_rank_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_online_game_by_rank_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_online_game_by_rank_result_params& mcp_get_online_game_by_rank_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_online_game_by_rank_result_params* mcp_get_online_game_by_rank_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_rank_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_online_game_by_rank_result_params* mcp_get_online_game_by_rank_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_online_game_by_rank_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_online_game_by_rank_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_online_game_by_rank_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_online_game_by_rank_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_online_game_by_rank_response::unknown(){
return _unknown;
}
inline size_t mcp_get_online_game_by_rank_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_grab_list_by_type_params* mcp_get_grab_list_by_type_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_grab_list_by_type_params* tmp=(mcp_get_grab_list_by_type_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_grab_list_by_type_params(pool);
return tmp;
}
inline void mcp_get_grab_list_by_type_params::destroy(mcp_get_grab_list_by_type_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_grab_list_by_type_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_grab_list_by_type_params::mcp_get_grab_list_by_type_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_type_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_grab_list_by_type_params::mcp_get_grab_list_by_type_params(const mcp_get_grab_list_by_type_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_type_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_grab_list_by_type_params::~mcp_get_grab_list_by_type_params(){
}
inline mcp_get_grab_list_by_type_params& mcp_get_grab_list_by_type_params::operator=(const mcp_get_grab_list_by_type_params& v){
assign(v);
return *this;
}
inline void mcp_get_grab_list_by_type_params::clear(){
_m_type_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_grab_list_by_type_params::check() const{
// @@string type_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t page=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_grab_list_by_type_params::detach(){
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_grab_list_by_type_params& mcp_get_grab_list_by_type_params::assign(const mcp_get_grab_list_by_type_params& v){
_m_type_id=v._m_type_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_grab_list_by_type_params::has_type_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_grab_list_by_type_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_grab_list_by_type_params& mcp_get_grab_list_by_type_params::set_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_grab_list_by_type_params& mcp_get_grab_list_by_type_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_grab_list_by_type_params::clear_type_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_grab_list_by_type_params::has_page() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_grab_list_by_type_params::page() const{
return _m_page;
}
inline mcp_get_grab_list_by_type_params& mcp_get_grab_list_by_type_params::set_page(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_grab_list_by_type_params::clear_page(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page=0;
}
inline bool mcp_get_grab_list_by_type_params::has_page_size() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_grab_list_by_type_params::page_size() const{
return _m_page_size;
}
inline mcp_get_grab_list_by_type_params& mcp_get_grab_list_by_type_params::set_page_size(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_grab_list_by_type_params::clear_page_size(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_grab_list_by_type_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_grab_list_by_type_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_grab_list_by_type_params::unknown(){
return _unknown;
}
inline size_t mcp_get_grab_list_by_type_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_grab_list_by_type_result_params* mcp_get_grab_list_by_type_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_grab_list_by_type_result_params* tmp=(mcp_get_grab_list_by_type_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_grab_list_by_type_result_params(pool);
return tmp;
}
inline void mcp_get_grab_list_by_type_result_params::destroy(mcp_get_grab_list_by_type_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_grab_list_by_type_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_grab_list_by_type_result_params::mcp_get_grab_list_by_type_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_grab_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_grab_list_by_type_result_params::mcp_get_grab_list_by_type_result_params(const mcp_get_grab_list_by_type_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_grab_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_grab_list_by_type_result_params::~mcp_get_grab_list_by_type_result_params(){
}
inline mcp_get_grab_list_by_type_result_params& mcp_get_grab_list_by_type_result_params::operator=(const mcp_get_grab_list_by_type_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_grab_list_by_type_result_params::clear(){
// _m_result=0;
_m_grab_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_grab_list_by_type_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}
// @@grab_info_t grab_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "grab_list" << "' not found";
}
{
// level 0 begin
typeof(_m_grab_list)& lr0=(_m_grab_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::grab_info_t& item=const_cast< ::idl::grab_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_grab_list_by_type_result_params::detach(){
_m_grab_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_grab_list_by_type_result_params& mcp_get_grab_list_by_type_result_params::assign(const mcp_get_grab_list_by_type_result_params& v){
_m_result=v._m_result;
_m_grab_list=v._m_grab_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_grab_list_by_type_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_grab_list_by_type_result_params::result() const{
return _m_result;
}
inline mcp_get_grab_list_by_type_result_params& mcp_get_grab_list_by_type_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_get_grab_list_by_type_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_get_grab_list_by_type_result_params::has_grab_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::grab_info_t >& mcp_get_grab_list_by_type_result_params::grab_list() const{
 return _m_grab_list;
}
inline void mcp_get_grab_list_by_type_result_params::clear_grab_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_grab_list.clear();
}
inline ::idl::vector< ::idl::grab_info_t >* mcp_get_grab_list_by_type_result_params::mutable_grab_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_grab_list);
}
inline ::idl::vector< ::idl::grab_info_t >* mcp_get_grab_list_by_type_result_params::m_grab_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_grab_list);
}
inline size_t mcp_get_grab_list_by_type_result_params::grab_list_size() const{
/*  */ return _m_grab_list.size();
}
inline const ::idl::grab_info_t& mcp_get_grab_list_by_type_result_params::grab_list(size_t i0) const{
 return _m_grab_list.get(i0);
}
inline ::idl::grab_info_t* mcp_get_grab_list_by_type_result_params::mutable_grab_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_grab_list.mutable_get(i0);
}
inline ::idl::grab_info_t* mcp_get_grab_list_by_type_result_params::m_grab_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_grab_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_grab_list_by_type_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_grab_list_by_type_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_grab_list_by_type_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_grab_list_by_type_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_grab_list_by_type_response* mcp_get_grab_list_by_type_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_grab_list_by_type_response* tmp=(mcp_get_grab_list_by_type_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_grab_list_by_type_response(pool);
return tmp;
}
inline void mcp_get_grab_list_by_type_response::destroy(mcp_get_grab_list_by_type_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_grab_list_by_type_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_grab_list_by_type_response::mcp_get_grab_list_by_type_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_grab_list_by_type_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_grab_list_by_type_response::mcp_get_grab_list_by_type_response(const mcp_get_grab_list_by_type_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_grab_list_by_type_result_params::create(_pool);
assign(v);
}
inline mcp_get_grab_list_by_type_response::~mcp_get_grab_list_by_type_response(){
if(_m_result_params){
::idl::mcp_get_grab_list_by_type_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_grab_list_by_type_response& mcp_get_grab_list_by_type_response::operator=(const mcp_get_grab_list_by_type_response& v){
assign(v);
return *this;
}
inline void mcp_get_grab_list_by_type_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_grab_list_by_type_response::check() const{
// @@mcp_get_grab_list_by_type_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_grab_list_by_type_result_params& item=const_cast< ::idl::mcp_get_grab_list_by_type_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_grab_list_by_type_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_grab_list_by_type_response& mcp_get_grab_list_by_type_response::assign(const mcp_get_grab_list_by_type_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_grab_list_by_type_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_grab_list_by_type_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_grab_list_by_type_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_grab_list_by_type_result_params& mcp_get_grab_list_by_type_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_grab_list_by_type_result_params* mcp_get_grab_list_by_type_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_grab_list_by_type_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_grab_list_by_type_result_params* mcp_get_grab_list_by_type_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_grab_list_by_type_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_grab_list_by_type_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_grab_list_by_type_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_grab_list_by_type_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_grab_list_by_type_response::unknown(){
return _unknown;
}
inline size_t mcp_get_grab_list_by_type_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_grab_info_by_c_id_params* mcp_get_grab_info_by_c_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_grab_info_by_c_id_params* tmp=(mcp_get_grab_info_by_c_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_grab_info_by_c_id_params(pool);
return tmp;
}
inline void mcp_get_grab_info_by_c_id_params::destroy(mcp_get_grab_info_by_c_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_grab_info_by_c_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_grab_info_by_c_id_params::mcp_get_grab_info_by_c_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_c_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_grab_info_by_c_id_params::mcp_get_grab_info_by_c_id_params(const mcp_get_grab_info_by_c_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_c_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_grab_info_by_c_id_params::~mcp_get_grab_info_by_c_id_params(){
}
inline mcp_get_grab_info_by_c_id_params& mcp_get_grab_info_by_c_id_params::operator=(const mcp_get_grab_info_by_c_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_grab_info_by_c_id_params::clear(){
_m_c_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_grab_info_by_c_id_params::check() const{
// @@string c_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_grab_info_by_c_id_params::detach(){
_m_c_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_grab_info_by_c_id_params& mcp_get_grab_info_by_c_id_params::assign(const mcp_get_grab_info_by_c_id_params& v){
_m_c_id=v._m_c_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_grab_info_by_c_id_params::has_c_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_grab_info_by_c_id_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_get_grab_info_by_c_id_params& mcp_get_grab_info_by_c_id_params::set_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_grab_info_by_c_id_params& mcp_get_grab_info_by_c_id_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_grab_info_by_c_id_params::clear_c_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_c_id.clear();
}
inline ::idl::Unknown* mcp_get_grab_info_by_c_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_grab_info_by_c_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_grab_info_by_c_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_grab_info_by_c_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_grab_info_by_c_id_result_params* mcp_get_grab_info_by_c_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_grab_info_by_c_id_result_params* tmp=(mcp_get_grab_info_by_c_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_grab_info_by_c_id_result_params(pool);
return tmp;
}
inline void mcp_get_grab_info_by_c_id_result_params::destroy(mcp_get_grab_info_by_c_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_grab_info_by_c_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_grab_info_by_c_id_result_params::mcp_get_grab_info_by_c_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_grab_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_grab_info_by_c_id_result_params::mcp_get_grab_info_by_c_id_result_params(const mcp_get_grab_info_by_c_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_grab_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_grab_info_by_c_id_result_params::~mcp_get_grab_info_by_c_id_result_params(){
}
inline mcp_get_grab_info_by_c_id_result_params& mcp_get_grab_info_by_c_id_result_params::operator=(const mcp_get_grab_info_by_c_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_grab_info_by_c_id_result_params::clear(){
// _m_result=0;
_m_grab_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_grab_info_by_c_id_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}
// @@grab_info_t grab_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "grab_list" << "' not found";
}
{
// level 0 begin
typeof(_m_grab_list)& lr0=(_m_grab_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::grab_info_t& item=const_cast< ::idl::grab_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_grab_info_by_c_id_result_params::detach(){
_m_grab_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_grab_info_by_c_id_result_params& mcp_get_grab_info_by_c_id_result_params::assign(const mcp_get_grab_info_by_c_id_result_params& v){
_m_result=v._m_result;
_m_grab_list=v._m_grab_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_grab_info_by_c_id_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_grab_info_by_c_id_result_params::result() const{
return _m_result;
}
inline mcp_get_grab_info_by_c_id_result_params& mcp_get_grab_info_by_c_id_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_get_grab_info_by_c_id_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_get_grab_info_by_c_id_result_params::has_grab_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::grab_info_t >& mcp_get_grab_info_by_c_id_result_params::grab_list() const{
 return _m_grab_list;
}
inline void mcp_get_grab_info_by_c_id_result_params::clear_grab_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_grab_list.clear();
}
inline ::idl::vector< ::idl::grab_info_t >* mcp_get_grab_info_by_c_id_result_params::mutable_grab_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_grab_list);
}
inline ::idl::vector< ::idl::grab_info_t >* mcp_get_grab_info_by_c_id_result_params::m_grab_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_grab_list);
}
inline size_t mcp_get_grab_info_by_c_id_result_params::grab_list_size() const{
/*  */ return _m_grab_list.size();
}
inline const ::idl::grab_info_t& mcp_get_grab_info_by_c_id_result_params::grab_list(size_t i0) const{
 return _m_grab_list.get(i0);
}
inline ::idl::grab_info_t* mcp_get_grab_info_by_c_id_result_params::mutable_grab_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_grab_list.mutable_get(i0);
}
inline ::idl::grab_info_t* mcp_get_grab_info_by_c_id_result_params::m_grab_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_grab_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_grab_info_by_c_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_grab_info_by_c_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_grab_info_by_c_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_grab_info_by_c_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_grab_info_by_c_id_response* mcp_get_grab_info_by_c_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_grab_info_by_c_id_response* tmp=(mcp_get_grab_info_by_c_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_grab_info_by_c_id_response(pool);
return tmp;
}
inline void mcp_get_grab_info_by_c_id_response::destroy(mcp_get_grab_info_by_c_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_grab_info_by_c_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_grab_info_by_c_id_response::mcp_get_grab_info_by_c_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_grab_info_by_c_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_grab_info_by_c_id_response::mcp_get_grab_info_by_c_id_response(const mcp_get_grab_info_by_c_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_grab_info_by_c_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_grab_info_by_c_id_response::~mcp_get_grab_info_by_c_id_response(){
if(_m_result_params){
::idl::mcp_get_grab_info_by_c_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_grab_info_by_c_id_response& mcp_get_grab_info_by_c_id_response::operator=(const mcp_get_grab_info_by_c_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_grab_info_by_c_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_grab_info_by_c_id_response::check() const{
// @@mcp_get_grab_info_by_c_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_grab_info_by_c_id_result_params& item=const_cast< ::idl::mcp_get_grab_info_by_c_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_grab_info_by_c_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_grab_info_by_c_id_response& mcp_get_grab_info_by_c_id_response::assign(const mcp_get_grab_info_by_c_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_grab_info_by_c_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_grab_info_by_c_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_grab_info_by_c_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_grab_info_by_c_id_result_params& mcp_get_grab_info_by_c_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_grab_info_by_c_id_result_params* mcp_get_grab_info_by_c_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_grab_info_by_c_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_grab_info_by_c_id_result_params* mcp_get_grab_info_by_c_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_grab_info_by_c_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_grab_info_by_c_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_grab_info_by_c_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_grab_info_by_c_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_grab_info_by_c_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_grab_info_by_c_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_grab_info_by_id_params* mcp_get_grab_info_by_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_grab_info_by_id_params* tmp=(mcp_get_grab_info_by_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_grab_info_by_id_params(pool);
return tmp;
}
inline void mcp_get_grab_info_by_id_params::destroy(mcp_get_grab_info_by_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_grab_info_by_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_grab_info_by_id_params::mcp_get_grab_info_by_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_grab_info_by_id_params::mcp_get_grab_info_by_id_params(const mcp_get_grab_info_by_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_grab_info_by_id_params::~mcp_get_grab_info_by_id_params(){
}
inline mcp_get_grab_info_by_id_params& mcp_get_grab_info_by_id_params::operator=(const mcp_get_grab_info_by_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_grab_info_by_id_params::clear(){
// _m_id=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_grab_info_by_id_params::check() const{
// @@uint32_t id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_id;

}

::idl::McpackBean::check();
}
inline void mcp_get_grab_info_by_id_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_grab_info_by_id_params& mcp_get_grab_info_by_id_params::assign(const mcp_get_grab_info_by_id_params& v){
_m_id=v._m_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_grab_info_by_id_params::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_grab_info_by_id_params::id() const{
return _m_id;
}
inline mcp_get_grab_info_by_id_params& mcp_get_grab_info_by_id_params::set_id(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id=v;
return *this;
}
inline void mcp_get_grab_info_by_id_params::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id=0;
}
inline ::idl::Unknown* mcp_get_grab_info_by_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_grab_info_by_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_grab_info_by_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_grab_info_by_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_grab_info_by_id_result_params* mcp_get_grab_info_by_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_grab_info_by_id_result_params* tmp=(mcp_get_grab_info_by_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_grab_info_by_id_result_params(pool);
return tmp;
}
inline void mcp_get_grab_info_by_id_result_params::destroy(mcp_get_grab_info_by_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_grab_info_by_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_grab_info_by_id_result_params::mcp_get_grab_info_by_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_info(0)
,_unknown(_pool){
_m_info=::idl::grab_info_t::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_grab_info_by_id_result_params::mcp_get_grab_info_by_id_result_params(const mcp_get_grab_info_by_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_info(0)
,_unknown(_pool){
_m_info=::idl::grab_info_t::create(_pool);
assign(v);
}
inline mcp_get_grab_info_by_id_result_params::~mcp_get_grab_info_by_id_result_params(){
if(_m_info){
::idl::grab_info_t::destroy(_m_info);
_m_info=0;
}
}
inline mcp_get_grab_info_by_id_result_params& mcp_get_grab_info_by_id_result_params::operator=(const mcp_get_grab_info_by_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_grab_info_by_id_result_params::clear(){
// _m_result=0;
if(_m_info){
_m_info->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_grab_info_by_id_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}
// @@grab_info_t info=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info" << "' not found";
}
{
::idl::grab_info_t& item=const_cast< ::idl::grab_info_t& >(*_m_info);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_grab_info_by_id_result_params::detach(){
if(_m_info){
_m_info->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_grab_info_by_id_result_params& mcp_get_grab_info_by_id_result_params::assign(const mcp_get_grab_info_by_id_result_params& v){
_m_result=v._m_result;
if(!v._m_info){
if(_m_info){
::idl::grab_info_t::destroy(_m_info);
}
_m_info=0;
}else{
if(!_m_info){
_m_info=::idl::grab_info_t::create(_pool);
}
*_m_info=*v._m_info;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_grab_info_by_id_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_grab_info_by_id_result_params::result() const{
return _m_result;
}
inline mcp_get_grab_info_by_id_result_params& mcp_get_grab_info_by_id_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_get_grab_info_by_id_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_get_grab_info_by_id_result_params::has_info() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::grab_info_t& mcp_get_grab_info_by_id_result_params::info() const{
 return *_m_info;
}
inline ::idl::grab_info_t* mcp_get_grab_info_by_id_result_params::mutable_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 if(!_m_info){
_m_info=::idl::grab_info_t::create(_pool);
}
return _m_info;
}
inline ::idl::grab_info_t* mcp_get_grab_info_by_id_result_params::m_info(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 if(!_m_info){
_m_info=::idl::grab_info_t::create(_pool);
}
return _m_info;
}
inline void mcp_get_grab_info_by_id_result_params::clear_info(){
if(_m_info){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info->clear();
}
}
inline ::idl::Unknown* mcp_get_grab_info_by_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_grab_info_by_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_grab_info_by_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_grab_info_by_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_grab_info_by_id_response* mcp_get_grab_info_by_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_grab_info_by_id_response* tmp=(mcp_get_grab_info_by_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_grab_info_by_id_response(pool);
return tmp;
}
inline void mcp_get_grab_info_by_id_response::destroy(mcp_get_grab_info_by_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_grab_info_by_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_grab_info_by_id_response::mcp_get_grab_info_by_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_grab_info_by_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_grab_info_by_id_response::mcp_get_grab_info_by_id_response(const mcp_get_grab_info_by_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_grab_info_by_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_grab_info_by_id_response::~mcp_get_grab_info_by_id_response(){
if(_m_result_params){
::idl::mcp_get_grab_info_by_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_grab_info_by_id_response& mcp_get_grab_info_by_id_response::operator=(const mcp_get_grab_info_by_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_grab_info_by_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_grab_info_by_id_response::check() const{
// @@mcp_get_grab_info_by_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_grab_info_by_id_result_params& item=const_cast< ::idl::mcp_get_grab_info_by_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_grab_info_by_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_grab_info_by_id_response& mcp_get_grab_info_by_id_response::assign(const mcp_get_grab_info_by_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_grab_info_by_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_grab_info_by_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_grab_info_by_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_grab_info_by_id_result_params& mcp_get_grab_info_by_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_grab_info_by_id_result_params* mcp_get_grab_info_by_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_grab_info_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_grab_info_by_id_result_params* mcp_get_grab_info_by_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_grab_info_by_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_grab_info_by_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_grab_info_by_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_grab_info_by_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_grab_info_by_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_grab_info_by_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_user_grab_num_params* mcp_user_grab_num_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_user_grab_num_params* tmp=(mcp_user_grab_num_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_user_grab_num_params(pool);
return tmp;
}
inline void mcp_user_grab_num_params::destroy(mcp_user_grab_num_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_user_grab_num_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_user_grab_num_params::mcp_user_grab_num_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_user_id(_pool)
,_m_grab_id(0)
,_m_push_channelid(_pool)
,_m_push_userid(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_user_grab_num_params::mcp_user_grab_num_params(const mcp_user_grab_num_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_user_id(_pool)
,_m_grab_id(0)
,_m_push_channelid(_pool)
,_m_push_userid(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_user_grab_num_params::~mcp_user_grab_num_params(){
}
inline mcp_user_grab_num_params& mcp_user_grab_num_params::operator=(const mcp_user_grab_num_params& v){
assign(v);
return *this;
}
inline void mcp_user_grab_num_params::clear(){
_m_user_id.clear();
// _m_grab_id=0;
_m_push_channelid.clear();
_m_push_userid.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_user_grab_num_params::check() const{
// @@string user_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}
// @@uint32_t grab_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "grab_id" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_grab_id;

}
// @@string push_channelid=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "push_channelid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_push_channelid.get();

}
// @@string push_userid=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "push_userid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_push_userid.get();

}

::idl::McpackBean::check();
}
inline void mcp_user_grab_num_params::detach(){
_m_user_id.detach();
_m_push_channelid.detach();
_m_push_userid.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_user_grab_num_params& mcp_user_grab_num_params::assign(const mcp_user_grab_num_params& v){
_m_user_id=v._m_user_id;
_m_grab_id=v._m_grab_id;
_m_push_channelid=v._m_push_channelid;
_m_push_userid=v._m_push_userid;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_user_grab_num_params::has_user_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_user_grab_num_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_user_grab_num_params& mcp_user_grab_num_params::set_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_user_grab_num_params& mcp_user_grab_num_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_user_grab_num_params::clear_user_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_user_id.clear();
}
inline bool mcp_user_grab_num_params::has_grab_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_user_grab_num_params::grab_id() const{
return _m_grab_id;
}
inline mcp_user_grab_num_params& mcp_user_grab_num_params::set_grab_id(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_grab_id=v;
return *this;
}
inline void mcp_user_grab_num_params::clear_grab_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_grab_id=0;
}
inline bool mcp_user_grab_num_params::has_push_channelid() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_user_grab_num_params::push_channelid(unsigned int* size) const{
return _m_push_channelid.get(size);
}
inline mcp_user_grab_num_params& mcp_user_grab_num_params::set_push_channelid(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_push_channelid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_user_grab_num_params& mcp_user_grab_num_params::set_ptr_push_channelid(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_push_channelid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_user_grab_num_params::clear_push_channelid(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_push_channelid.clear();
}
inline bool mcp_user_grab_num_params::has_push_userid() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_user_grab_num_params::push_userid(unsigned int* size) const{
return _m_push_userid.get(size);
}
inline mcp_user_grab_num_params& mcp_user_grab_num_params::set_push_userid(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_push_userid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_user_grab_num_params& mcp_user_grab_num_params::set_ptr_push_userid(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_push_userid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_user_grab_num_params::clear_push_userid(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_push_userid.clear();
}
inline ::idl::Unknown* mcp_user_grab_num_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_user_grab_num_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_user_grab_num_params::unknown(){
return _unknown;
}
inline size_t mcp_user_grab_num_params::unknown_size() const{
return _unknown.size();
}
inline mcp_user_grab_num_result_params* mcp_user_grab_num_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_user_grab_num_result_params* tmp=(mcp_user_grab_num_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_user_grab_num_result_params(pool);
return tmp;
}
inline void mcp_user_grab_num_result_params::destroy(mcp_user_grab_num_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_user_grab_num_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_user_grab_num_result_params::mcp_user_grab_num_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_num(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_user_grab_num_result_params::mcp_user_grab_num_result_params(const mcp_user_grab_num_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_num(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_user_grab_num_result_params::~mcp_user_grab_num_result_params(){
}
inline mcp_user_grab_num_result_params& mcp_user_grab_num_result_params::operator=(const mcp_user_grab_num_result_params& v){
assign(v);
return *this;
}
inline void mcp_user_grab_num_result_params::clear(){
// _m_result=0;
_m_num.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_user_grab_num_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}
// @@string num=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "num" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_num.get();

}

::idl::McpackBean::check();
}
inline void mcp_user_grab_num_result_params::detach(){
_m_num.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_user_grab_num_result_params& mcp_user_grab_num_result_params::assign(const mcp_user_grab_num_result_params& v){
_m_result=v._m_result;
_m_num=v._m_num;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_user_grab_num_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_user_grab_num_result_params::result() const{
return _m_result;
}
inline mcp_user_grab_num_result_params& mcp_user_grab_num_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_user_grab_num_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_user_grab_num_result_params::has_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_user_grab_num_result_params::num(unsigned int* size) const{
return _m_num.get(size);
}
inline mcp_user_grab_num_result_params& mcp_user_grab_num_result_params::set_num(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_num.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_user_grab_num_result_params& mcp_user_grab_num_result_params::set_ptr_num(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_num.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_user_grab_num_result_params::clear_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_num.clear();
}
inline ::idl::Unknown* mcp_user_grab_num_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_user_grab_num_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_user_grab_num_result_params::unknown(){
return _unknown;
}
inline size_t mcp_user_grab_num_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_user_grab_num_response* mcp_user_grab_num_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_user_grab_num_response* tmp=(mcp_user_grab_num_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_user_grab_num_response(pool);
return tmp;
}
inline void mcp_user_grab_num_response::destroy(mcp_user_grab_num_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_user_grab_num_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_user_grab_num_response::mcp_user_grab_num_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_user_grab_num_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_user_grab_num_response::mcp_user_grab_num_response(const mcp_user_grab_num_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_user_grab_num_result_params::create(_pool);
assign(v);
}
inline mcp_user_grab_num_response::~mcp_user_grab_num_response(){
if(_m_result_params){
::idl::mcp_user_grab_num_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_user_grab_num_response& mcp_user_grab_num_response::operator=(const mcp_user_grab_num_response& v){
assign(v);
return *this;
}
inline void mcp_user_grab_num_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_user_grab_num_response::check() const{
// @@mcp_user_grab_num_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_user_grab_num_result_params& item=const_cast< ::idl::mcp_user_grab_num_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_user_grab_num_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_user_grab_num_response& mcp_user_grab_num_response::assign(const mcp_user_grab_num_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_user_grab_num_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_user_grab_num_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_user_grab_num_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_user_grab_num_result_params& mcp_user_grab_num_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_user_grab_num_result_params* mcp_user_grab_num_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_user_grab_num_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_user_grab_num_result_params* mcp_user_grab_num_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_user_grab_num_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_user_grab_num_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_user_grab_num_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_user_grab_num_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_user_grab_num_response::unknown(){
return _unknown;
}
inline size_t mcp_user_grab_num_response::unknown_size() const{
return _unknown.size();
}
inline mcp_user_grab_num_pre_params* mcp_user_grab_num_pre_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_user_grab_num_pre_params* tmp=(mcp_user_grab_num_pre_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_user_grab_num_pre_params(pool);
return tmp;
}
inline void mcp_user_grab_num_pre_params::destroy(mcp_user_grab_num_pre_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_user_grab_num_pre_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_user_grab_num_pre_params::mcp_user_grab_num_pre_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_user_id(_pool)
,_m_grab_id(0)
,_m_push_channelid(_pool)
,_m_push_userid(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_user_grab_num_pre_params::mcp_user_grab_num_pre_params(const mcp_user_grab_num_pre_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_user_id(_pool)
,_m_grab_id(0)
,_m_push_channelid(_pool)
,_m_push_userid(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_user_grab_num_pre_params::~mcp_user_grab_num_pre_params(){
}
inline mcp_user_grab_num_pre_params& mcp_user_grab_num_pre_params::operator=(const mcp_user_grab_num_pre_params& v){
assign(v);
return *this;
}
inline void mcp_user_grab_num_pre_params::clear(){
_m_user_id.clear();
// _m_grab_id=0;
_m_push_channelid.clear();
_m_push_userid.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_user_grab_num_pre_params::check() const{
// @@string user_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}
// @@uint32_t grab_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "grab_id" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_grab_id;

}
// @@string push_channelid=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "push_channelid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_push_channelid.get();

}
// @@string push_userid=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "push_userid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_push_userid.get();

}

::idl::McpackBean::check();
}
inline void mcp_user_grab_num_pre_params::detach(){
_m_user_id.detach();
_m_push_channelid.detach();
_m_push_userid.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_user_grab_num_pre_params& mcp_user_grab_num_pre_params::assign(const mcp_user_grab_num_pre_params& v){
_m_user_id=v._m_user_id;
_m_grab_id=v._m_grab_id;
_m_push_channelid=v._m_push_channelid;
_m_push_userid=v._m_push_userid;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_user_grab_num_pre_params::has_user_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_user_grab_num_pre_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_user_grab_num_pre_params& mcp_user_grab_num_pre_params::set_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_user_grab_num_pre_params& mcp_user_grab_num_pre_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_user_grab_num_pre_params::clear_user_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_user_id.clear();
}
inline bool mcp_user_grab_num_pre_params::has_grab_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_user_grab_num_pre_params::grab_id() const{
return _m_grab_id;
}
inline mcp_user_grab_num_pre_params& mcp_user_grab_num_pre_params::set_grab_id(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_grab_id=v;
return *this;
}
inline void mcp_user_grab_num_pre_params::clear_grab_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_grab_id=0;
}
inline bool mcp_user_grab_num_pre_params::has_push_channelid() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_user_grab_num_pre_params::push_channelid(unsigned int* size) const{
return _m_push_channelid.get(size);
}
inline mcp_user_grab_num_pre_params& mcp_user_grab_num_pre_params::set_push_channelid(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_push_channelid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_user_grab_num_pre_params& mcp_user_grab_num_pre_params::set_ptr_push_channelid(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_push_channelid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_user_grab_num_pre_params::clear_push_channelid(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_push_channelid.clear();
}
inline bool mcp_user_grab_num_pre_params::has_push_userid() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_user_grab_num_pre_params::push_userid(unsigned int* size) const{
return _m_push_userid.get(size);
}
inline mcp_user_grab_num_pre_params& mcp_user_grab_num_pre_params::set_push_userid(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_push_userid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_user_grab_num_pre_params& mcp_user_grab_num_pre_params::set_ptr_push_userid(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_push_userid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_user_grab_num_pre_params::clear_push_userid(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_push_userid.clear();
}
inline ::idl::Unknown* mcp_user_grab_num_pre_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_user_grab_num_pre_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_user_grab_num_pre_params::unknown(){
return _unknown;
}
inline size_t mcp_user_grab_num_pre_params::unknown_size() const{
return _unknown.size();
}
inline mcp_user_grab_num_pre_result_params* mcp_user_grab_num_pre_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_user_grab_num_pre_result_params* tmp=(mcp_user_grab_num_pre_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_user_grab_num_pre_result_params(pool);
return tmp;
}
inline void mcp_user_grab_num_pre_result_params::destroy(mcp_user_grab_num_pre_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_user_grab_num_pre_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_user_grab_num_pre_result_params::mcp_user_grab_num_pre_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_num(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_user_grab_num_pre_result_params::mcp_user_grab_num_pre_result_params(const mcp_user_grab_num_pre_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_num(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_user_grab_num_pre_result_params::~mcp_user_grab_num_pre_result_params(){
}
inline mcp_user_grab_num_pre_result_params& mcp_user_grab_num_pre_result_params::operator=(const mcp_user_grab_num_pre_result_params& v){
assign(v);
return *this;
}
inline void mcp_user_grab_num_pre_result_params::clear(){
// _m_result=0;
_m_num.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_user_grab_num_pre_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}
// @@string num=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "num" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_num.get();

}

::idl::McpackBean::check();
}
inline void mcp_user_grab_num_pre_result_params::detach(){
_m_num.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_user_grab_num_pre_result_params& mcp_user_grab_num_pre_result_params::assign(const mcp_user_grab_num_pre_result_params& v){
_m_result=v._m_result;
_m_num=v._m_num;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_user_grab_num_pre_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_user_grab_num_pre_result_params::result() const{
return _m_result;
}
inline mcp_user_grab_num_pre_result_params& mcp_user_grab_num_pre_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_user_grab_num_pre_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_user_grab_num_pre_result_params::has_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_user_grab_num_pre_result_params::num(unsigned int* size) const{
return _m_num.get(size);
}
inline mcp_user_grab_num_pre_result_params& mcp_user_grab_num_pre_result_params::set_num(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_num.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_user_grab_num_pre_result_params& mcp_user_grab_num_pre_result_params::set_ptr_num(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_num.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_user_grab_num_pre_result_params::clear_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_num.clear();
}
inline ::idl::Unknown* mcp_user_grab_num_pre_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_user_grab_num_pre_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_user_grab_num_pre_result_params::unknown(){
return _unknown;
}
inline size_t mcp_user_grab_num_pre_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_user_grab_num_pre_response* mcp_user_grab_num_pre_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_user_grab_num_pre_response* tmp=(mcp_user_grab_num_pre_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_user_grab_num_pre_response(pool);
return tmp;
}
inline void mcp_user_grab_num_pre_response::destroy(mcp_user_grab_num_pre_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_user_grab_num_pre_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_user_grab_num_pre_response::mcp_user_grab_num_pre_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_user_grab_num_pre_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_user_grab_num_pre_response::mcp_user_grab_num_pre_response(const mcp_user_grab_num_pre_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_user_grab_num_pre_result_params::create(_pool);
assign(v);
}
inline mcp_user_grab_num_pre_response::~mcp_user_grab_num_pre_response(){
if(_m_result_params){
::idl::mcp_user_grab_num_pre_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_user_grab_num_pre_response& mcp_user_grab_num_pre_response::operator=(const mcp_user_grab_num_pre_response& v){
assign(v);
return *this;
}
inline void mcp_user_grab_num_pre_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_user_grab_num_pre_response::check() const{
// @@mcp_user_grab_num_pre_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_user_grab_num_pre_result_params& item=const_cast< ::idl::mcp_user_grab_num_pre_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_user_grab_num_pre_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_user_grab_num_pre_response& mcp_user_grab_num_pre_response::assign(const mcp_user_grab_num_pre_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_user_grab_num_pre_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_user_grab_num_pre_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_user_grab_num_pre_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_user_grab_num_pre_result_params& mcp_user_grab_num_pre_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_user_grab_num_pre_result_params* mcp_user_grab_num_pre_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_user_grab_num_pre_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_user_grab_num_pre_result_params* mcp_user_grab_num_pre_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_user_grab_num_pre_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_user_grab_num_pre_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_user_grab_num_pre_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_user_grab_num_pre_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_user_grab_num_pre_response::unknown(){
return _unknown;
}
inline size_t mcp_user_grab_num_pre_response::unknown_size() const{
return _unknown.size();
}
inline mcp_set_user_rating_params* mcp_set_user_rating_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_set_user_rating_params* tmp=(mcp_set_user_rating_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_set_user_rating_params(pool);
return tmp;
}
inline void mcp_set_user_rating_params::destroy(mcp_set_user_rating_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_set_user_rating_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_set_user_rating_params::mcp_set_user_rating_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_user_id(_pool)
,_m_c_id(_pool)
,_m_rating(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_set_user_rating_params::mcp_set_user_rating_params(const mcp_set_user_rating_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_user_id(_pool)
,_m_c_id(_pool)
,_m_rating(0)
,_unknown(_pool){
assign(v);
}
inline mcp_set_user_rating_params::~mcp_set_user_rating_params(){
}
inline mcp_set_user_rating_params& mcp_set_user_rating_params::operator=(const mcp_set_user_rating_params& v){
assign(v);
return *this;
}
inline void mcp_set_user_rating_params::clear(){
_m_user_id.clear();
_m_c_id.clear();
// _m_rating=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_set_user_rating_params::check() const{
// @@string user_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}
// @@string c_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@uint32_t rating=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "rating" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_rating;

}

::idl::McpackBean::check();
}
inline void mcp_set_user_rating_params::detach(){
_m_user_id.detach();
_m_c_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_set_user_rating_params& mcp_set_user_rating_params::assign(const mcp_set_user_rating_params& v){
_m_user_id=v._m_user_id;
_m_c_id=v._m_c_id;
_m_rating=v._m_rating;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_set_user_rating_params::has_user_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_set_user_rating_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_set_user_rating_params& mcp_set_user_rating_params::set_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_set_user_rating_params& mcp_set_user_rating_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_set_user_rating_params::clear_user_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_user_id.clear();
}
inline bool mcp_set_user_rating_params::has_c_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_set_user_rating_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_set_user_rating_params& mcp_set_user_rating_params::set_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_set_user_rating_params& mcp_set_user_rating_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_set_user_rating_params::clear_c_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_c_id.clear();
}
inline bool mcp_set_user_rating_params::has_rating() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_set_user_rating_params::rating() const{
return _m_rating;
}
inline mcp_set_user_rating_params& mcp_set_user_rating_params::set_rating(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_rating=v;
return *this;
}
inline void mcp_set_user_rating_params::clear_rating(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_rating=0;
}
inline ::idl::Unknown* mcp_set_user_rating_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_set_user_rating_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_set_user_rating_params::unknown(){
return _unknown;
}
inline size_t mcp_set_user_rating_params::unknown_size() const{
return _unknown.size();
}
inline mcp_set_user_rating_result_params* mcp_set_user_rating_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_set_user_rating_result_params* tmp=(mcp_set_user_rating_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_set_user_rating_result_params(pool);
return tmp;
}
inline void mcp_set_user_rating_result_params::destroy(mcp_set_user_rating_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_set_user_rating_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_set_user_rating_result_params::mcp_set_user_rating_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_set_user_rating_result_params::mcp_set_user_rating_result_params(const mcp_set_user_rating_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_unknown(_pool){
assign(v);
}
inline mcp_set_user_rating_result_params::~mcp_set_user_rating_result_params(){
}
inline mcp_set_user_rating_result_params& mcp_set_user_rating_result_params::operator=(const mcp_set_user_rating_result_params& v){
assign(v);
return *this;
}
inline void mcp_set_user_rating_result_params::clear(){
// _m_result=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_set_user_rating_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}

::idl::McpackBean::check();
}
inline void mcp_set_user_rating_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_set_user_rating_result_params& mcp_set_user_rating_result_params::assign(const mcp_set_user_rating_result_params& v){
_m_result=v._m_result;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_set_user_rating_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_set_user_rating_result_params::result() const{
return _m_result;
}
inline mcp_set_user_rating_result_params& mcp_set_user_rating_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_set_user_rating_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline ::idl::Unknown* mcp_set_user_rating_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_set_user_rating_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_set_user_rating_result_params::unknown(){
return _unknown;
}
inline size_t mcp_set_user_rating_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_set_user_rating_response* mcp_set_user_rating_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_set_user_rating_response* tmp=(mcp_set_user_rating_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_set_user_rating_response(pool);
return tmp;
}
inline void mcp_set_user_rating_response::destroy(mcp_set_user_rating_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_set_user_rating_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_set_user_rating_response::mcp_set_user_rating_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_set_user_rating_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_set_user_rating_response::mcp_set_user_rating_response(const mcp_set_user_rating_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_set_user_rating_result_params::create(_pool);
assign(v);
}
inline mcp_set_user_rating_response::~mcp_set_user_rating_response(){
if(_m_result_params){
::idl::mcp_set_user_rating_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_set_user_rating_response& mcp_set_user_rating_response::operator=(const mcp_set_user_rating_response& v){
assign(v);
return *this;
}
inline void mcp_set_user_rating_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_set_user_rating_response::check() const{
// @@mcp_set_user_rating_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_set_user_rating_result_params& item=const_cast< ::idl::mcp_set_user_rating_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_set_user_rating_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_set_user_rating_response& mcp_set_user_rating_response::assign(const mcp_set_user_rating_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_set_user_rating_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_set_user_rating_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_set_user_rating_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_set_user_rating_result_params& mcp_set_user_rating_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_set_user_rating_result_params* mcp_set_user_rating_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_set_user_rating_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_set_user_rating_result_params* mcp_set_user_rating_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_set_user_rating_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_set_user_rating_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_set_user_rating_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_set_user_rating_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_set_user_rating_response::unknown(){
return _unknown;
}
inline size_t mcp_set_user_rating_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_user_rating_params* mcp_get_user_rating_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_user_rating_params* tmp=(mcp_get_user_rating_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_user_rating_params(pool);
return tmp;
}
inline void mcp_get_user_rating_params::destroy(mcp_get_user_rating_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_user_rating_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_user_rating_params::mcp_get_user_rating_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_user_id(_pool)
,_m_c_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_user_rating_params::mcp_get_user_rating_params(const mcp_get_user_rating_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_user_id(_pool)
,_m_c_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_user_rating_params::~mcp_get_user_rating_params(){
}
inline mcp_get_user_rating_params& mcp_get_user_rating_params::operator=(const mcp_get_user_rating_params& v){
assign(v);
return *this;
}
inline void mcp_get_user_rating_params::clear(){
_m_user_id.clear();
_m_c_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_user_rating_params::check() const{
// @@string user_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}
// @@string c_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_user_rating_params::detach(){
_m_user_id.detach();
_m_c_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_user_rating_params& mcp_get_user_rating_params::assign(const mcp_get_user_rating_params& v){
_m_user_id=v._m_user_id;
_m_c_id=v._m_c_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_user_rating_params::has_user_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_user_rating_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_get_user_rating_params& mcp_get_user_rating_params::set_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_user_rating_params& mcp_get_user_rating_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_user_rating_params::clear_user_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_user_id.clear();
}
inline bool mcp_get_user_rating_params::has_c_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_user_rating_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_get_user_rating_params& mcp_get_user_rating_params::set_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_user_rating_params& mcp_get_user_rating_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_user_rating_params::clear_c_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_c_id.clear();
}
inline ::idl::Unknown* mcp_get_user_rating_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_user_rating_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_user_rating_params::unknown(){
return _unknown;
}
inline size_t mcp_get_user_rating_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_user_rating_result_params* mcp_get_user_rating_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_user_rating_result_params* tmp=(mcp_get_user_rating_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_user_rating_result_params(pool);
return tmp;
}
inline void mcp_get_user_rating_result_params::destroy(mcp_get_user_rating_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_user_rating_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_user_rating_result_params::mcp_get_user_rating_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_user_rating_result_params::mcp_get_user_rating_result_params(const mcp_get_user_rating_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_user_rating_result_params::~mcp_get_user_rating_result_params(){
}
inline mcp_get_user_rating_result_params& mcp_get_user_rating_result_params::operator=(const mcp_get_user_rating_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_user_rating_result_params::clear(){
// _m_result=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_user_rating_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}

::idl::McpackBean::check();
}
inline void mcp_get_user_rating_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_user_rating_result_params& mcp_get_user_rating_result_params::assign(const mcp_get_user_rating_result_params& v){
_m_result=v._m_result;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_user_rating_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_user_rating_result_params::result() const{
return _m_result;
}
inline mcp_get_user_rating_result_params& mcp_get_user_rating_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_get_user_rating_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline ::idl::Unknown* mcp_get_user_rating_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_user_rating_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_user_rating_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_user_rating_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_user_rating_response* mcp_get_user_rating_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_user_rating_response* tmp=(mcp_get_user_rating_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_user_rating_response(pool);
return tmp;
}
inline void mcp_get_user_rating_response::destroy(mcp_get_user_rating_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_user_rating_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_user_rating_response::mcp_get_user_rating_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_user_rating_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_user_rating_response::mcp_get_user_rating_response(const mcp_get_user_rating_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_user_rating_result_params::create(_pool);
assign(v);
}
inline mcp_get_user_rating_response::~mcp_get_user_rating_response(){
if(_m_result_params){
::idl::mcp_get_user_rating_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_user_rating_response& mcp_get_user_rating_response::operator=(const mcp_get_user_rating_response& v){
assign(v);
return *this;
}
inline void mcp_get_user_rating_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_user_rating_response::check() const{
// @@mcp_get_user_rating_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_user_rating_result_params& item=const_cast< ::idl::mcp_get_user_rating_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_user_rating_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_user_rating_response& mcp_get_user_rating_response::assign(const mcp_get_user_rating_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_user_rating_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_user_rating_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_user_rating_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_user_rating_result_params& mcp_get_user_rating_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_user_rating_result_params* mcp_get_user_rating_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_user_rating_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_user_rating_result_params* mcp_get_user_rating_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_user_rating_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_user_rating_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_user_rating_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_user_rating_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_user_rating_response::unknown(){
return _unknown;
}
inline size_t mcp_get_user_rating_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_calender_list_params* mcp_get_calender_list_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_calender_list_params* tmp=(mcp_get_calender_list_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_calender_list_params(pool);
return tmp;
}
inline void mcp_get_calender_list_params::destroy(mcp_get_calender_list_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_calender_list_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_calender_list_params::mcp_get_calender_list_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_calender_list_params::mcp_get_calender_list_params(const mcp_get_calender_list_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_calender_list_params::~mcp_get_calender_list_params(){
}
inline mcp_get_calender_list_params& mcp_get_calender_list_params::operator=(const mcp_get_calender_list_params& v){
assign(v);
return *this;
}
inline void mcp_get_calender_list_params::clear(){
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_calender_list_params::check() const{

::idl::McpackBean::check();
}
inline void mcp_get_calender_list_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_calender_list_params& mcp_get_calender_list_params::assign(const mcp_get_calender_list_params& v){
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline ::idl::Unknown* mcp_get_calender_list_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_calender_list_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_calender_list_params::unknown(){
return _unknown;
}
inline size_t mcp_get_calender_list_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_calender_list_result_params* mcp_get_calender_list_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_calender_list_result_params* tmp=(mcp_get_calender_list_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_calender_list_result_params(pool);
return tmp;
}
inline void mcp_get_calender_list_result_params::destroy(mcp_get_calender_list_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_calender_list_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_calender_list_result_params::mcp_get_calender_list_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_calender_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_calender_list_result_params::mcp_get_calender_list_result_params(const mcp_get_calender_list_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_calender_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_calender_list_result_params::~mcp_get_calender_list_result_params(){
}
inline mcp_get_calender_list_result_params& mcp_get_calender_list_result_params::operator=(const mcp_get_calender_list_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_calender_list_result_params::clear(){
// _m_result=0;
_m_calender_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_calender_list_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}
// @@calender_info_t calender_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "calender_list" << "' not found";
}
{
// level 0 begin
typeof(_m_calender_list)& lr0=(_m_calender_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::calender_info_t& item=const_cast< ::idl::calender_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_calender_list_result_params::detach(){
_m_calender_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_calender_list_result_params& mcp_get_calender_list_result_params::assign(const mcp_get_calender_list_result_params& v){
_m_result=v._m_result;
_m_calender_list=v._m_calender_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_calender_list_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_calender_list_result_params::result() const{
return _m_result;
}
inline mcp_get_calender_list_result_params& mcp_get_calender_list_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_get_calender_list_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_get_calender_list_result_params::has_calender_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::calender_info_t >& mcp_get_calender_list_result_params::calender_list() const{
 return _m_calender_list;
}
inline void mcp_get_calender_list_result_params::clear_calender_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_calender_list.clear();
}
inline ::idl::vector< ::idl::calender_info_t >* mcp_get_calender_list_result_params::mutable_calender_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_calender_list);
}
inline ::idl::vector< ::idl::calender_info_t >* mcp_get_calender_list_result_params::m_calender_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_calender_list);
}
inline size_t mcp_get_calender_list_result_params::calender_list_size() const{
/*  */ return _m_calender_list.size();
}
inline const ::idl::calender_info_t& mcp_get_calender_list_result_params::calender_list(size_t i0) const{
 return _m_calender_list.get(i0);
}
inline ::idl::calender_info_t* mcp_get_calender_list_result_params::mutable_calender_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_calender_list.mutable_get(i0);
}
inline ::idl::calender_info_t* mcp_get_calender_list_result_params::m_calender_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_calender_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_calender_list_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_calender_list_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_calender_list_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_calender_list_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_calender_list_response* mcp_get_calender_list_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_calender_list_response* tmp=(mcp_get_calender_list_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_calender_list_response(pool);
return tmp;
}
inline void mcp_get_calender_list_response::destroy(mcp_get_calender_list_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_calender_list_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_calender_list_response::mcp_get_calender_list_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_calender_list_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_calender_list_response::mcp_get_calender_list_response(const mcp_get_calender_list_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_calender_list_result_params::create(_pool);
assign(v);
}
inline mcp_get_calender_list_response::~mcp_get_calender_list_response(){
if(_m_result_params){
::idl::mcp_get_calender_list_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_calender_list_response& mcp_get_calender_list_response::operator=(const mcp_get_calender_list_response& v){
assign(v);
return *this;
}
inline void mcp_get_calender_list_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_calender_list_response::check() const{
// @@mcp_get_calender_list_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_calender_list_result_params& item=const_cast< ::idl::mcp_get_calender_list_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_calender_list_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_calender_list_response& mcp_get_calender_list_response::assign(const mcp_get_calender_list_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_calender_list_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_calender_list_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_calender_list_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_calender_list_result_params& mcp_get_calender_list_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_calender_list_result_params* mcp_get_calender_list_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_calender_list_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_calender_list_result_params* mcp_get_calender_list_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_calender_list_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_calender_list_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_calender_list_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_calender_list_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_calender_list_response::unknown(){
return _unknown;
}
inline size_t mcp_get_calender_list_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_mixed_topic_id_params* mcp_get_content_list_by_mixed_topic_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_mixed_topic_id_params* tmp=(mcp_get_content_list_by_mixed_topic_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_mixed_topic_id_params(pool);
return tmp;
}
inline void mcp_get_content_list_by_mixed_topic_id_params::destroy(mcp_get_content_list_by_mixed_topic_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_mixed_topic_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_mixed_topic_id_params::mcp_get_content_list_by_mixed_topic_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_topic_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_mixed_topic_id_params::mcp_get_content_list_by_mixed_topic_id_params(const mcp_get_content_list_by_mixed_topic_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_topic_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_by_mixed_topic_id_params::~mcp_get_content_list_by_mixed_topic_id_params(){
}
inline mcp_get_content_list_by_mixed_topic_id_params& mcp_get_content_list_by_mixed_topic_id_params::operator=(const mcp_get_content_list_by_mixed_topic_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id_params::clear(){
_m_topic_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_mixed_topic_id_params::check() const{
// @@string topic_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "topic_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_topic_id.get();

}
// @@uint32_t page=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_mixed_topic_id_params::detach(){
_m_topic_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_mixed_topic_id_params& mcp_get_content_list_by_mixed_topic_id_params::assign(const mcp_get_content_list_by_mixed_topic_id_params& v){
_m_topic_id=v._m_topic_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_mixed_topic_id_params::has_topic_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_list_by_mixed_topic_id_params::topic_id(unsigned int* size) const{
return _m_topic_id.get(size);
}
inline mcp_get_content_list_by_mixed_topic_id_params& mcp_get_content_list_by_mixed_topic_id_params::set_topic_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_topic_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_by_mixed_topic_id_params& mcp_get_content_list_by_mixed_topic_id_params::set_ptr_topic_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_topic_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id_params::clear_topic_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_topic_id.clear();
}
inline bool mcp_get_content_list_by_mixed_topic_id_params::has_page() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_mixed_topic_id_params::page() const{
return _m_page;
}
inline mcp_get_content_list_by_mixed_topic_id_params& mcp_get_content_list_by_mixed_topic_id_params::set_page(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id_params::clear_page(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page=0;
}
inline bool mcp_get_content_list_by_mixed_topic_id_params::has_page_size() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_mixed_topic_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_content_list_by_mixed_topic_id_params& mcp_get_content_list_by_mixed_topic_id_params::set_page_size(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id_params::clear_page_size(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_content_list_by_mixed_topic_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_mixed_topic_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_mixed_topic_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_mixed_topic_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_mixed_topic_id_result_params* mcp_get_content_list_by_mixed_topic_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_mixed_topic_id_result_params* tmp=(mcp_get_content_list_by_mixed_topic_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_mixed_topic_id_result_params(pool);
return tmp;
}
inline void mcp_get_content_list_by_mixed_topic_id_result_params::destroy(mcp_get_content_list_by_mixed_topic_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_mixed_topic_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_mixed_topic_id_result_params::mcp_get_content_list_by_mixed_topic_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count_soft(0)
,_m_count_theme(0)
,_m_count_song(0)
,_m_soft_info_list(_pool)
,_m_theme_info_list(_pool)
,_m_music_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_mixed_topic_id_result_params::mcp_get_content_list_by_mixed_topic_id_result_params(const mcp_get_content_list_by_mixed_topic_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count_soft(0)
,_m_count_theme(0)
,_m_count_song(0)
,_m_soft_info_list(_pool)
,_m_theme_info_list(_pool)
,_m_music_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_by_mixed_topic_id_result_params::~mcp_get_content_list_by_mixed_topic_id_result_params(){
}
inline mcp_get_content_list_by_mixed_topic_id_result_params& mcp_get_content_list_by_mixed_topic_id_result_params::operator=(const mcp_get_content_list_by_mixed_topic_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id_result_params::clear(){
// _m_count_soft=0;
// _m_count_theme=0;
// _m_count_song=0;
_m_soft_info_list.clear();
_m_theme_info_list.clear();
_m_music_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_mixed_topic_id_result_params::check() const{
// @@uint32_t count_soft=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count_soft" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count_soft;

}
// @@uint32_t count_theme=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count_theme" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count_theme;

}
// @@uint32_t count_song=out();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count_song" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count_song;

}
// @@soft_info_t soft_info_list=out(),array(0);
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "soft_info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_soft_info_list)& lr0=(_m_soft_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::soft_info_t& item=const_cast< ::idl::soft_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@theme_info_t theme_info_list=out(),array(0);
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "theme_info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_theme_info_list)& lr0=(_m_theme_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::theme_info_t& item=const_cast< ::idl::theme_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@music_info_t music_info_list=out(),array(0);
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "music_info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_music_info_list)& lr0=(_m_music_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::music_info_t& item=const_cast< ::idl::music_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_mixed_topic_id_result_params::detach(){
_m_soft_info_list.detach();
_m_theme_info_list.detach();
_m_music_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_mixed_topic_id_result_params& mcp_get_content_list_by_mixed_topic_id_result_params::assign(const mcp_get_content_list_by_mixed_topic_id_result_params& v){
_m_count_soft=v._m_count_soft;
_m_count_theme=v._m_count_theme;
_m_count_song=v._m_count_song;
_m_soft_info_list=v._m_soft_info_list;
_m_theme_info_list=v._m_theme_info_list;
_m_music_info_list=v._m_music_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_mixed_topic_id_result_params::has_count_soft() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_mixed_topic_id_result_params::count_soft() const{
return _m_count_soft;
}
inline mcp_get_content_list_by_mixed_topic_id_result_params& mcp_get_content_list_by_mixed_topic_id_result_params::set_count_soft(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count_soft=v;
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id_result_params::clear_count_soft(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count_soft=0;
}
inline bool mcp_get_content_list_by_mixed_topic_id_result_params::has_count_theme() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_mixed_topic_id_result_params::count_theme() const{
return _m_count_theme;
}
inline mcp_get_content_list_by_mixed_topic_id_result_params& mcp_get_content_list_by_mixed_topic_id_result_params::set_count_theme(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_count_theme=v;
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id_result_params::clear_count_theme(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_count_theme=0;
}
inline bool mcp_get_content_list_by_mixed_topic_id_result_params::has_count_song() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_mixed_topic_id_result_params::count_song() const{
return _m_count_song;
}
inline mcp_get_content_list_by_mixed_topic_id_result_params& mcp_get_content_list_by_mixed_topic_id_result_params::set_count_song(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_count_song=v;
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id_result_params::clear_count_song(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_count_song=0;
}
inline bool mcp_get_content_list_by_mixed_topic_id_result_params::has_soft_info_list() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const ::idl::vector< ::idl::soft_info_t >& mcp_get_content_list_by_mixed_topic_id_result_params::soft_info_list() const{
 return _m_soft_info_list;
}
inline void mcp_get_content_list_by_mixed_topic_id_result_params::clear_soft_info_list(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_soft_info_list.clear();
}
inline ::idl::vector< ::idl::soft_info_t >* mcp_get_content_list_by_mixed_topic_id_result_params::mutable_soft_info_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_soft_info_list);
}
inline ::idl::vector< ::idl::soft_info_t >* mcp_get_content_list_by_mixed_topic_id_result_params::m_soft_info_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_soft_info_list);
}
inline size_t mcp_get_content_list_by_mixed_topic_id_result_params::soft_info_list_size() const{
/*  */ return _m_soft_info_list.size();
}
inline const ::idl::soft_info_t& mcp_get_content_list_by_mixed_topic_id_result_params::soft_info_list(size_t i0) const{
 return _m_soft_info_list.get(i0);
}
inline ::idl::soft_info_t* mcp_get_content_list_by_mixed_topic_id_result_params::mutable_soft_info_list(size_t i0){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return _m_soft_info_list.mutable_get(i0);
}
inline ::idl::soft_info_t* mcp_get_content_list_by_mixed_topic_id_result_params::m_soft_info_list(size_t i0){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return _m_soft_info_list.mutable_get(i0);
}
inline bool mcp_get_content_list_by_mixed_topic_id_result_params::has_theme_info_list() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const ::idl::vector< ::idl::theme_info_t >& mcp_get_content_list_by_mixed_topic_id_result_params::theme_info_list() const{
 return _m_theme_info_list;
}
inline void mcp_get_content_list_by_mixed_topic_id_result_params::clear_theme_info_list(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_theme_info_list.clear();
}
inline ::idl::vector< ::idl::theme_info_t >* mcp_get_content_list_by_mixed_topic_id_result_params::mutable_theme_info_list(){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return &(_m_theme_info_list);
}
inline ::idl::vector< ::idl::theme_info_t >* mcp_get_content_list_by_mixed_topic_id_result_params::m_theme_info_list(){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return &(_m_theme_info_list);
}
inline size_t mcp_get_content_list_by_mixed_topic_id_result_params::theme_info_list_size() const{
/*  */ return _m_theme_info_list.size();
}
inline const ::idl::theme_info_t& mcp_get_content_list_by_mixed_topic_id_result_params::theme_info_list(size_t i0) const{
 return _m_theme_info_list.get(i0);
}
inline ::idl::theme_info_t* mcp_get_content_list_by_mixed_topic_id_result_params::mutable_theme_info_list(size_t i0){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return _m_theme_info_list.mutable_get(i0);
}
inline ::idl::theme_info_t* mcp_get_content_list_by_mixed_topic_id_result_params::m_theme_info_list(size_t i0){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return _m_theme_info_list.mutable_get(i0);
}
inline bool mcp_get_content_list_by_mixed_topic_id_result_params::has_music_info_list() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const ::idl::vector< ::idl::music_info_t >& mcp_get_content_list_by_mixed_topic_id_result_params::music_info_list() const{
 return _m_music_info_list;
}
inline void mcp_get_content_list_by_mixed_topic_id_result_params::clear_music_info_list(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_music_info_list.clear();
}
inline ::idl::vector< ::idl::music_info_t >* mcp_get_content_list_by_mixed_topic_id_result_params::mutable_music_info_list(){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 return &(_m_music_info_list);
}
inline ::idl::vector< ::idl::music_info_t >* mcp_get_content_list_by_mixed_topic_id_result_params::m_music_info_list(){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 return &(_m_music_info_list);
}
inline size_t mcp_get_content_list_by_mixed_topic_id_result_params::music_info_list_size() const{
/*  */ return _m_music_info_list.size();
}
inline const ::idl::music_info_t& mcp_get_content_list_by_mixed_topic_id_result_params::music_info_list(size_t i0) const{
 return _m_music_info_list.get(i0);
}
inline ::idl::music_info_t* mcp_get_content_list_by_mixed_topic_id_result_params::mutable_music_info_list(size_t i0){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 return _m_music_info_list.mutable_get(i0);
}
inline ::idl::music_info_t* mcp_get_content_list_by_mixed_topic_id_result_params::m_music_info_list(size_t i0){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 return _m_music_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_content_list_by_mixed_topic_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_mixed_topic_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_mixed_topic_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_mixed_topic_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_mixed_topic_id_response* mcp_get_content_list_by_mixed_topic_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_mixed_topic_id_response* tmp=(mcp_get_content_list_by_mixed_topic_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_mixed_topic_id_response(pool);
return tmp;
}
inline void mcp_get_content_list_by_mixed_topic_id_response::destroy(mcp_get_content_list_by_mixed_topic_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_mixed_topic_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_mixed_topic_id_response::mcp_get_content_list_by_mixed_topic_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_by_mixed_topic_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_mixed_topic_id_response::mcp_get_content_list_by_mixed_topic_id_response(const mcp_get_content_list_by_mixed_topic_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_by_mixed_topic_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_list_by_mixed_topic_id_response::~mcp_get_content_list_by_mixed_topic_id_response(){
if(_m_result_params){
::idl::mcp_get_content_list_by_mixed_topic_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_list_by_mixed_topic_id_response& mcp_get_content_list_by_mixed_topic_id_response::operator=(const mcp_get_content_list_by_mixed_topic_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_mixed_topic_id_response::check() const{
// @@mcp_get_content_list_by_mixed_topic_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_list_by_mixed_topic_id_result_params& item=const_cast< ::idl::mcp_get_content_list_by_mixed_topic_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_mixed_topic_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_mixed_topic_id_response& mcp_get_content_list_by_mixed_topic_id_response::assign(const mcp_get_content_list_by_mixed_topic_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_list_by_mixed_topic_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_mixed_topic_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_mixed_topic_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_list_by_mixed_topic_id_result_params& mcp_get_content_list_by_mixed_topic_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_list_by_mixed_topic_id_result_params* mcp_get_content_list_by_mixed_topic_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_mixed_topic_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_list_by_mixed_topic_id_result_params* mcp_get_content_list_by_mixed_topic_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_mixed_topic_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_list_by_mixed_topic_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_list_by_mixed_topic_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_mixed_topic_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_mixed_topic_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_mixed_topic_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_mixed_topic_id1_params* mcp_get_content_list_by_mixed_topic_id1_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_mixed_topic_id1_params* tmp=(mcp_get_content_list_by_mixed_topic_id1_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_mixed_topic_id1_params(pool);
return tmp;
}
inline void mcp_get_content_list_by_mixed_topic_id1_params::destroy(mcp_get_content_list_by_mixed_topic_id1_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_mixed_topic_id1_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_mixed_topic_id1_params::mcp_get_content_list_by_mixed_topic_id1_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_topic_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_mixed_topic_id1_params::mcp_get_content_list_by_mixed_topic_id1_params(const mcp_get_content_list_by_mixed_topic_id1_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_topic_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_by_mixed_topic_id1_params::~mcp_get_content_list_by_mixed_topic_id1_params(){
}
inline mcp_get_content_list_by_mixed_topic_id1_params& mcp_get_content_list_by_mixed_topic_id1_params::operator=(const mcp_get_content_list_by_mixed_topic_id1_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id1_params::clear(){
_m_topic_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_mixed_topic_id1_params::check() const{
// @@string topic_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "topic_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_topic_id.get();

}
// @@uint32_t page=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_mixed_topic_id1_params::detach(){
_m_topic_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_mixed_topic_id1_params& mcp_get_content_list_by_mixed_topic_id1_params::assign(const mcp_get_content_list_by_mixed_topic_id1_params& v){
_m_topic_id=v._m_topic_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_mixed_topic_id1_params::has_topic_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_list_by_mixed_topic_id1_params::topic_id(unsigned int* size) const{
return _m_topic_id.get(size);
}
inline mcp_get_content_list_by_mixed_topic_id1_params& mcp_get_content_list_by_mixed_topic_id1_params::set_topic_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_topic_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_by_mixed_topic_id1_params& mcp_get_content_list_by_mixed_topic_id1_params::set_ptr_topic_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_topic_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id1_params::clear_topic_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_topic_id.clear();
}
inline bool mcp_get_content_list_by_mixed_topic_id1_params::has_page() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_mixed_topic_id1_params::page() const{
return _m_page;
}
inline mcp_get_content_list_by_mixed_topic_id1_params& mcp_get_content_list_by_mixed_topic_id1_params::set_page(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id1_params::clear_page(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page=0;
}
inline bool mcp_get_content_list_by_mixed_topic_id1_params::has_page_size() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_mixed_topic_id1_params::page_size() const{
return _m_page_size;
}
inline mcp_get_content_list_by_mixed_topic_id1_params& mcp_get_content_list_by_mixed_topic_id1_params::set_page_size(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id1_params::clear_page_size(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_content_list_by_mixed_topic_id1_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_mixed_topic_id1_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_mixed_topic_id1_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_mixed_topic_id1_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params* mcp_get_content_list_by_mixed_topic_id1_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_mixed_topic_id1_result_params* tmp=(mcp_get_content_list_by_mixed_topic_id1_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_mixed_topic_id1_result_params(pool);
return tmp;
}
inline void mcp_get_content_list_by_mixed_topic_id1_result_params::destroy(mcp_get_content_list_by_mixed_topic_id1_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_mixed_topic_id1_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params::mcp_get_content_list_by_mixed_topic_id1_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_col_num1(0)
,_m_col_num2(0)
,_m_col_num3(0)
,_m_col_id(_pool)
,_m_col_name(_pool)
,_m_soft_info_list(_pool)
,_m_theme_info_list(_pool)
,_m_music_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params::mcp_get_content_list_by_mixed_topic_id1_result_params(const mcp_get_content_list_by_mixed_topic_id1_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_col_num1(0)
,_m_col_num2(0)
,_m_col_num3(0)
,_m_col_id(_pool)
,_m_col_name(_pool)
,_m_soft_info_list(_pool)
,_m_theme_info_list(_pool)
,_m_music_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params::~mcp_get_content_list_by_mixed_topic_id1_result_params(){
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params& mcp_get_content_list_by_mixed_topic_id1_result_params::operator=(const mcp_get_content_list_by_mixed_topic_id1_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id1_result_params::clear(){
// _m_col_num1=0;
// _m_col_num2=0;
// _m_col_num3=0;
_m_col_id.clear();
_m_col_name.clear();
_m_soft_info_list.clear();
_m_theme_info_list.clear();
_m_music_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_mixed_topic_id1_result_params::check() const{
// @@uint32_t col_num1=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_num1" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_col_num1;

}
// @@uint32_t col_num2=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_num2" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_col_num2;

}
// @@uint32_t col_num3=out();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_num3" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_col_num3;

}
// @@string col_id=out(),array(0);
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_id" << "' not found";
}
{
// level 0 begin
typeof(_m_col_id)& lr0=(_m_col_id);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@string col_name=out(),array(0);
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_name" << "' not found";
}
{
// level 0 begin
typeof(_m_col_name)& lr0=(_m_col_name);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@soft_info_t soft_info_list=out(),array(0);
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "soft_info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_soft_info_list)& lr0=(_m_soft_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::soft_info_t& item=const_cast< ::idl::soft_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@theme_info_t theme_info_list=out(),array(0);
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "theme_info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_theme_info_list)& lr0=(_m_theme_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::theme_info_t& item=const_cast< ::idl::theme_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}
// @@string music_id=out(),array(0);
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "music_id" << "' not found";
}
{
// level 0 begin
typeof(_m_music_id)& lr0=(_m_music_id);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_mixed_topic_id1_result_params::detach(){
_m_col_id.detach();
_m_col_name.detach();
_m_soft_info_list.detach();
_m_theme_info_list.detach();
_m_music_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params& mcp_get_content_list_by_mixed_topic_id1_result_params::assign(const mcp_get_content_list_by_mixed_topic_id1_result_params& v){
_m_col_num1=v._m_col_num1;
_m_col_num2=v._m_col_num2;
_m_col_num3=v._m_col_num3;
_m_col_id=v._m_col_id;
_m_col_name=v._m_col_name;
_m_soft_info_list=v._m_soft_info_list;
_m_theme_info_list=v._m_theme_info_list;
_m_music_id=v._m_music_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_mixed_topic_id1_result_params::has_col_num1() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_mixed_topic_id1_result_params::col_num1() const{
return _m_col_num1;
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params& mcp_get_content_list_by_mixed_topic_id1_result_params::set_col_num1(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_col_num1=v;
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id1_result_params::clear_col_num1(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_col_num1=0;
}
inline bool mcp_get_content_list_by_mixed_topic_id1_result_params::has_col_num2() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_mixed_topic_id1_result_params::col_num2() const{
return _m_col_num2;
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params& mcp_get_content_list_by_mixed_topic_id1_result_params::set_col_num2(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_col_num2=v;
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id1_result_params::clear_col_num2(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_col_num2=0;
}
inline bool mcp_get_content_list_by_mixed_topic_id1_result_params::has_col_num3() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_content_list_by_mixed_topic_id1_result_params::col_num3() const{
return _m_col_num3;
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params& mcp_get_content_list_by_mixed_topic_id1_result_params::set_col_num3(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_col_num3=v;
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id1_result_params::clear_col_num3(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_col_num3=0;
}
inline bool mcp_get_content_list_by_mixed_topic_id1_result_params::has_col_id() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_content_list_by_mixed_topic_id1_result_params::col_id() const{
 return _m_col_id;
}
inline void mcp_get_content_list_by_mixed_topic_id1_result_params::clear_col_id(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_col_id.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_content_list_by_mixed_topic_id1_result_params::mutable_col_id(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_col_id);
}
inline ::idl::vector< ::idl::string >* mcp_get_content_list_by_mixed_topic_id1_result_params::m_col_id(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_col_id);
}
inline size_t mcp_get_content_list_by_mixed_topic_id1_result_params::col_id_size() const{
/*  */ return _m_col_id.size();
}
inline const char* mcp_get_content_list_by_mixed_topic_id1_result_params::col_id(size_t i0,unsigned int* size) const{
 return _m_col_id.get(i0).get(size);
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params& mcp_get_content_list_by_mixed_topic_id1_result_params::set_col_id(size_t i0,const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_col_id.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params& mcp_get_content_list_by_mixed_topic_id1_result_params::set_ptr_col_id(size_t i0,const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_col_id.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool mcp_get_content_list_by_mixed_topic_id1_result_params::has_col_name() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_content_list_by_mixed_topic_id1_result_params::col_name() const{
 return _m_col_name;
}
inline void mcp_get_content_list_by_mixed_topic_id1_result_params::clear_col_name(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_col_name.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_content_list_by_mixed_topic_id1_result_params::mutable_col_name(){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return &(_m_col_name);
}
inline ::idl::vector< ::idl::string >* mcp_get_content_list_by_mixed_topic_id1_result_params::m_col_name(){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return &(_m_col_name);
}
inline size_t mcp_get_content_list_by_mixed_topic_id1_result_params::col_name_size() const{
/*  */ return _m_col_name.size();
}
inline const char* mcp_get_content_list_by_mixed_topic_id1_result_params::col_name(size_t i0,unsigned int* size) const{
 return _m_col_name.get(i0).get(size);
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params& mcp_get_content_list_by_mixed_topic_id1_result_params::set_col_name(size_t i0,const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_col_name.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params& mcp_get_content_list_by_mixed_topic_id1_result_params::set_ptr_col_name(size_t i0,const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_col_name.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool mcp_get_content_list_by_mixed_topic_id1_result_params::has_soft_info_list() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const ::idl::vector< ::idl::soft_info_t >& mcp_get_content_list_by_mixed_topic_id1_result_params::soft_info_list() const{
 return _m_soft_info_list;
}
inline void mcp_get_content_list_by_mixed_topic_id1_result_params::clear_soft_info_list(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_soft_info_list.clear();
}
inline ::idl::vector< ::idl::soft_info_t >* mcp_get_content_list_by_mixed_topic_id1_result_params::mutable_soft_info_list(){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 return &(_m_soft_info_list);
}
inline ::idl::vector< ::idl::soft_info_t >* mcp_get_content_list_by_mixed_topic_id1_result_params::m_soft_info_list(){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 return &(_m_soft_info_list);
}
inline size_t mcp_get_content_list_by_mixed_topic_id1_result_params::soft_info_list_size() const{
/*  */ return _m_soft_info_list.size();
}
inline const ::idl::soft_info_t& mcp_get_content_list_by_mixed_topic_id1_result_params::soft_info_list(size_t i0) const{
 return _m_soft_info_list.get(i0);
}
inline ::idl::soft_info_t* mcp_get_content_list_by_mixed_topic_id1_result_params::mutable_soft_info_list(size_t i0){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 return _m_soft_info_list.mutable_get(i0);
}
inline ::idl::soft_info_t* mcp_get_content_list_by_mixed_topic_id1_result_params::m_soft_info_list(size_t i0){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 return _m_soft_info_list.mutable_get(i0);
}
inline bool mcp_get_content_list_by_mixed_topic_id1_result_params::has_theme_info_list() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const ::idl::vector< ::idl::theme_info_t >& mcp_get_content_list_by_mixed_topic_id1_result_params::theme_info_list() const{
 return _m_theme_info_list;
}
inline void mcp_get_content_list_by_mixed_topic_id1_result_params::clear_theme_info_list(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_theme_info_list.clear();
}
inline ::idl::vector< ::idl::theme_info_t >* mcp_get_content_list_by_mixed_topic_id1_result_params::mutable_theme_info_list(){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 return &(_m_theme_info_list);
}
inline ::idl::vector< ::idl::theme_info_t >* mcp_get_content_list_by_mixed_topic_id1_result_params::m_theme_info_list(){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 return &(_m_theme_info_list);
}
inline size_t mcp_get_content_list_by_mixed_topic_id1_result_params::theme_info_list_size() const{
/*  */ return _m_theme_info_list.size();
}
inline const ::idl::theme_info_t& mcp_get_content_list_by_mixed_topic_id1_result_params::theme_info_list(size_t i0) const{
 return _m_theme_info_list.get(i0);
}
inline ::idl::theme_info_t* mcp_get_content_list_by_mixed_topic_id1_result_params::mutable_theme_info_list(size_t i0){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 return _m_theme_info_list.mutable_get(i0);
}
inline ::idl::theme_info_t* mcp_get_content_list_by_mixed_topic_id1_result_params::m_theme_info_list(size_t i0){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 return _m_theme_info_list.mutable_get(i0);
}
inline bool mcp_get_content_list_by_mixed_topic_id1_result_params::has_music_id() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_content_list_by_mixed_topic_id1_result_params::music_id() const{
 return _m_music_id;
}
inline void mcp_get_content_list_by_mixed_topic_id1_result_params::clear_music_id(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_music_id.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_content_list_by_mixed_topic_id1_result_params::mutable_music_id(){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 return &(_m_music_id);
}
inline ::idl::vector< ::idl::string >* mcp_get_content_list_by_mixed_topic_id1_result_params::m_music_id(){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 return &(_m_music_id);
}
inline size_t mcp_get_content_list_by_mixed_topic_id1_result_params::music_id_size() const{
/*  */ return _m_music_id.size();
}
inline const char* mcp_get_content_list_by_mixed_topic_id1_result_params::music_id(size_t i0,unsigned int* size) const{
 return _m_music_id.get(i0).get(size);
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params& mcp_get_content_list_by_mixed_topic_id1_result_params::set_music_id(size_t i0,const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_music_id.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_list_by_mixed_topic_id1_result_params& mcp_get_content_list_by_mixed_topic_id1_result_params::set_ptr_music_id(size_t i0,const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_music_id.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_list_by_mixed_topic_id1_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_mixed_topic_id1_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_mixed_topic_id1_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_mixed_topic_id1_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_by_mixed_topic_id1_response* mcp_get_content_list_by_mixed_topic_id1_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_by_mixed_topic_id1_response* tmp=(mcp_get_content_list_by_mixed_topic_id1_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_by_mixed_topic_id1_response(pool);
return tmp;
}
inline void mcp_get_content_list_by_mixed_topic_id1_response::destroy(mcp_get_content_list_by_mixed_topic_id1_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_by_mixed_topic_id1_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_by_mixed_topic_id1_response::mcp_get_content_list_by_mixed_topic_id1_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_by_mixed_topic_id1_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_by_mixed_topic_id1_response::mcp_get_content_list_by_mixed_topic_id1_response(const mcp_get_content_list_by_mixed_topic_id1_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_by_mixed_topic_id1_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_list_by_mixed_topic_id1_response::~mcp_get_content_list_by_mixed_topic_id1_response(){
if(_m_result_params){
::idl::mcp_get_content_list_by_mixed_topic_id1_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_list_by_mixed_topic_id1_response& mcp_get_content_list_by_mixed_topic_id1_response::operator=(const mcp_get_content_list_by_mixed_topic_id1_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_by_mixed_topic_id1_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_by_mixed_topic_id1_response::check() const{
// @@mcp_get_content_list_by_mixed_topic_id1_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_list_by_mixed_topic_id1_result_params& item=const_cast< ::idl::mcp_get_content_list_by_mixed_topic_id1_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_by_mixed_topic_id1_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_by_mixed_topic_id1_response& mcp_get_content_list_by_mixed_topic_id1_response::assign(const mcp_get_content_list_by_mixed_topic_id1_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_list_by_mixed_topic_id1_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_mixed_topic_id1_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_by_mixed_topic_id1_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_list_by_mixed_topic_id1_result_params& mcp_get_content_list_by_mixed_topic_id1_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_list_by_mixed_topic_id1_result_params* mcp_get_content_list_by_mixed_topic_id1_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_mixed_topic_id1_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_list_by_mixed_topic_id1_result_params* mcp_get_content_list_by_mixed_topic_id1_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_by_mixed_topic_id1_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_list_by_mixed_topic_id1_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_list_by_mixed_topic_id1_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_by_mixed_topic_id1_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_by_mixed_topic_id1_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_by_mixed_topic_id1_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_user_grab_num_params* mcp_get_user_grab_num_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_user_grab_num_params* tmp=(mcp_get_user_grab_num_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_user_grab_num_params(pool);
return tmp;
}
inline void mcp_get_user_grab_num_params::destroy(mcp_get_user_grab_num_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_user_grab_num_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_user_grab_num_params::mcp_get_user_grab_num_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_user_id(_pool)
,_m_grab_id(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_user_grab_num_params::mcp_get_user_grab_num_params(const mcp_get_user_grab_num_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_user_id(_pool)
,_m_grab_id(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_user_grab_num_params::~mcp_get_user_grab_num_params(){
}
inline mcp_get_user_grab_num_params& mcp_get_user_grab_num_params::operator=(const mcp_get_user_grab_num_params& v){
assign(v);
return *this;
}
inline void mcp_get_user_grab_num_params::clear(){
_m_user_id.clear();
// _m_grab_id=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_user_grab_num_params::check() const{
// @@string user_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}
// @@uint32_t grab_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "grab_id" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_grab_id;

}

::idl::McpackBean::check();
}
inline void mcp_get_user_grab_num_params::detach(){
_m_user_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_user_grab_num_params& mcp_get_user_grab_num_params::assign(const mcp_get_user_grab_num_params& v){
_m_user_id=v._m_user_id;
_m_grab_id=v._m_grab_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_user_grab_num_params::has_user_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_user_grab_num_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_get_user_grab_num_params& mcp_get_user_grab_num_params::set_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_user_grab_num_params& mcp_get_user_grab_num_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_user_grab_num_params::clear_user_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_user_id.clear();
}
inline bool mcp_get_user_grab_num_params::has_grab_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_user_grab_num_params::grab_id() const{
return _m_grab_id;
}
inline mcp_get_user_grab_num_params& mcp_get_user_grab_num_params::set_grab_id(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_grab_id=v;
return *this;
}
inline void mcp_get_user_grab_num_params::clear_grab_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_grab_id=0;
}
inline ::idl::Unknown* mcp_get_user_grab_num_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_user_grab_num_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_user_grab_num_params::unknown(){
return _unknown;
}
inline size_t mcp_get_user_grab_num_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_user_grab_num_result_params* mcp_get_user_grab_num_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_user_grab_num_result_params* tmp=(mcp_get_user_grab_num_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_user_grab_num_result_params(pool);
return tmp;
}
inline void mcp_get_user_grab_num_result_params::destroy(mcp_get_user_grab_num_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_user_grab_num_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_user_grab_num_result_params::mcp_get_user_grab_num_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_num(_pool)
,_m_occupy(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_user_grab_num_result_params::mcp_get_user_grab_num_result_params(const mcp_get_user_grab_num_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_num(_pool)
,_m_occupy(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_user_grab_num_result_params::~mcp_get_user_grab_num_result_params(){
}
inline mcp_get_user_grab_num_result_params& mcp_get_user_grab_num_result_params::operator=(const mcp_get_user_grab_num_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_user_grab_num_result_params::clear(){
// _m_result=0;
_m_num.clear();
// _m_occupy=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_user_grab_num_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}
// @@string num=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "num" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_num.get();

}
// @@int32_t occupy=out();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "occupy" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_occupy;

}

::idl::McpackBean::check();
}
inline void mcp_get_user_grab_num_result_params::detach(){
_m_num.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_user_grab_num_result_params& mcp_get_user_grab_num_result_params::assign(const mcp_get_user_grab_num_result_params& v){
_m_result=v._m_result;
_m_num=v._m_num;
_m_occupy=v._m_occupy;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_user_grab_num_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_user_grab_num_result_params::result() const{
return _m_result;
}
inline mcp_get_user_grab_num_result_params& mcp_get_user_grab_num_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_get_user_grab_num_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_get_user_grab_num_result_params::has_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_user_grab_num_result_params::num(unsigned int* size) const{
return _m_num.get(size);
}
inline mcp_get_user_grab_num_result_params& mcp_get_user_grab_num_result_params::set_num(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_num.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_user_grab_num_result_params& mcp_get_user_grab_num_result_params::set_ptr_num(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_num.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_user_grab_num_result_params::clear_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_num.clear();
}
inline bool mcp_get_user_grab_num_result_params::has_occupy() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline int32_t mcp_get_user_grab_num_result_params::occupy() const{
return _m_occupy;
}
inline mcp_get_user_grab_num_result_params& mcp_get_user_grab_num_result_params::set_occupy(int32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_occupy=v;
return *this;
}
inline void mcp_get_user_grab_num_result_params::clear_occupy(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_occupy=0;
}
inline ::idl::Unknown* mcp_get_user_grab_num_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_user_grab_num_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_user_grab_num_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_user_grab_num_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_user_grab_num_response* mcp_get_user_grab_num_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_user_grab_num_response* tmp=(mcp_get_user_grab_num_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_user_grab_num_response(pool);
return tmp;
}
inline void mcp_get_user_grab_num_response::destroy(mcp_get_user_grab_num_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_user_grab_num_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_user_grab_num_response::mcp_get_user_grab_num_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_user_grab_num_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_user_grab_num_response::mcp_get_user_grab_num_response(const mcp_get_user_grab_num_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_user_grab_num_result_params::create(_pool);
assign(v);
}
inline mcp_get_user_grab_num_response::~mcp_get_user_grab_num_response(){
if(_m_result_params){
::idl::mcp_get_user_grab_num_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_user_grab_num_response& mcp_get_user_grab_num_response::operator=(const mcp_get_user_grab_num_response& v){
assign(v);
return *this;
}
inline void mcp_get_user_grab_num_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_user_grab_num_response::check() const{
// @@mcp_get_user_grab_num_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_user_grab_num_result_params& item=const_cast< ::idl::mcp_get_user_grab_num_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_user_grab_num_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_user_grab_num_response& mcp_get_user_grab_num_response::assign(const mcp_get_user_grab_num_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_user_grab_num_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_user_grab_num_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_user_grab_num_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_user_grab_num_result_params& mcp_get_user_grab_num_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_user_grab_num_result_params* mcp_get_user_grab_num_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_user_grab_num_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_user_grab_num_result_params* mcp_get_user_grab_num_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_user_grab_num_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_user_grab_num_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_user_grab_num_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_user_grab_num_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_user_grab_num_response::unknown(){
return _unknown;
}
inline size_t mcp_get_user_grab_num_response::unknown_size() const{
return _unknown.size();
}
inline mcp_set_recently_played_params* mcp_set_recently_played_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_set_recently_played_params* tmp=(mcp_set_recently_played_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_set_recently_played_params(pool);
return tmp;
}
inline void mcp_set_recently_played_params::destroy(mcp_set_recently_played_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_set_recently_played_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_set_recently_played_params::mcp_set_recently_played_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_m_c_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_set_recently_played_params::mcp_set_recently_played_params(const mcp_set_recently_played_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_m_c_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_set_recently_played_params::~mcp_set_recently_played_params(){
}
inline mcp_set_recently_played_params& mcp_set_recently_played_params::operator=(const mcp_set_recently_played_params& v){
assign(v);
return *this;
}
inline void mcp_set_recently_played_params::clear(){
_m_u_id.clear();
_m_c_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_set_recently_played_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}
// @@string c_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_set_recently_played_params::detach(){
_m_u_id.detach();
_m_c_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_set_recently_played_params& mcp_set_recently_played_params::assign(const mcp_set_recently_played_params& v){
_m_u_id=v._m_u_id;
_m_c_id=v._m_c_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_set_recently_played_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_set_recently_played_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_set_recently_played_params& mcp_set_recently_played_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_set_recently_played_params& mcp_set_recently_played_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_set_recently_played_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline bool mcp_set_recently_played_params::has_c_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_set_recently_played_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_set_recently_played_params& mcp_set_recently_played_params::set_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_set_recently_played_params& mcp_set_recently_played_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_set_recently_played_params::clear_c_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_c_id.clear();
}
inline ::idl::Unknown* mcp_set_recently_played_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_set_recently_played_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_set_recently_played_params::unknown(){
return _unknown;
}
inline size_t mcp_set_recently_played_params::unknown_size() const{
return _unknown.size();
}
inline mcp_set_recently_played_result_params* mcp_set_recently_played_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_set_recently_played_result_params* tmp=(mcp_set_recently_played_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_set_recently_played_result_params(pool);
return tmp;
}
inline void mcp_set_recently_played_result_params::destroy(mcp_set_recently_played_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_set_recently_played_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_set_recently_played_result_params::mcp_set_recently_played_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_set_recently_played_result_params::mcp_set_recently_played_result_params(const mcp_set_recently_played_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_unknown(_pool){
assign(v);
}
inline mcp_set_recently_played_result_params::~mcp_set_recently_played_result_params(){
}
inline mcp_set_recently_played_result_params& mcp_set_recently_played_result_params::operator=(const mcp_set_recently_played_result_params& v){
assign(v);
return *this;
}
inline void mcp_set_recently_played_result_params::clear(){
// _m_result=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_set_recently_played_result_params::check() const{
// @@int32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_result;

}

::idl::McpackBean::check();
}
inline void mcp_set_recently_played_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_set_recently_played_result_params& mcp_set_recently_played_result_params::assign(const mcp_set_recently_played_result_params& v){
_m_result=v._m_result;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_set_recently_played_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_set_recently_played_result_params::result() const{
return _m_result;
}
inline mcp_set_recently_played_result_params& mcp_set_recently_played_result_params::set_result(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_set_recently_played_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline ::idl::Unknown* mcp_set_recently_played_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_set_recently_played_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_set_recently_played_result_params::unknown(){
return _unknown;
}
inline size_t mcp_set_recently_played_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_set_recently_played_response* mcp_set_recently_played_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_set_recently_played_response* tmp=(mcp_set_recently_played_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_set_recently_played_response(pool);
return tmp;
}
inline void mcp_set_recently_played_response::destroy(mcp_set_recently_played_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_set_recently_played_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_set_recently_played_response::mcp_set_recently_played_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_set_recently_played_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_set_recently_played_response::mcp_set_recently_played_response(const mcp_set_recently_played_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_set_recently_played_result_params::create(_pool);
assign(v);
}
inline mcp_set_recently_played_response::~mcp_set_recently_played_response(){
if(_m_result_params){
::idl::mcp_set_recently_played_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_set_recently_played_response& mcp_set_recently_played_response::operator=(const mcp_set_recently_played_response& v){
assign(v);
return *this;
}
inline void mcp_set_recently_played_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_set_recently_played_response::check() const{
// @@mcp_set_recently_played_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_set_recently_played_result_params& item=const_cast< ::idl::mcp_set_recently_played_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_set_recently_played_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_set_recently_played_response& mcp_set_recently_played_response::assign(const mcp_set_recently_played_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_set_recently_played_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_set_recently_played_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_set_recently_played_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_set_recently_played_result_params& mcp_set_recently_played_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_set_recently_played_result_params* mcp_set_recently_played_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_set_recently_played_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_set_recently_played_result_params* mcp_set_recently_played_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_set_recently_played_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_set_recently_played_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_set_recently_played_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_set_recently_played_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_set_recently_played_response::unknown(){
return _unknown;
}
inline size_t mcp_set_recently_played_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_recently_played_by_uid_params* mcp_get_recently_played_by_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_recently_played_by_uid_params* tmp=(mcp_get_recently_played_by_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_recently_played_by_uid_params(pool);
return tmp;
}
inline void mcp_get_recently_played_by_uid_params::destroy(mcp_get_recently_played_by_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_recently_played_by_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_recently_played_by_uid_params::mcp_get_recently_played_by_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_recently_played_by_uid_params::mcp_get_recently_played_by_uid_params(const mcp_get_recently_played_by_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_recently_played_by_uid_params::~mcp_get_recently_played_by_uid_params(){
}
inline mcp_get_recently_played_by_uid_params& mcp_get_recently_played_by_uid_params::operator=(const mcp_get_recently_played_by_uid_params& v){
assign(v);
return *this;
}
inline void mcp_get_recently_played_by_uid_params::clear(){
_m_u_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_recently_played_by_uid_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_recently_played_by_uid_params::detach(){
_m_u_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_recently_played_by_uid_params& mcp_get_recently_played_by_uid_params::assign(const mcp_get_recently_played_by_uid_params& v){
_m_u_id=v._m_u_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_recently_played_by_uid_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_recently_played_by_uid_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_get_recently_played_by_uid_params& mcp_get_recently_played_by_uid_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_recently_played_by_uid_params& mcp_get_recently_played_by_uid_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_recently_played_by_uid_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline ::idl::Unknown* mcp_get_recently_played_by_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_recently_played_by_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_recently_played_by_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_get_recently_played_by_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_recently_played_by_uid_result_params* mcp_get_recently_played_by_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_recently_played_by_uid_result_params* tmp=(mcp_get_recently_played_by_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_recently_played_by_uid_result_params(pool);
return tmp;
}
inline void mcp_get_recently_played_by_uid_result_params::destroy(mcp_get_recently_played_by_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_recently_played_by_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_recently_played_by_uid_result_params::mcp_get_recently_played_by_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_recently_played_by_uid_result_params::mcp_get_recently_played_by_uid_result_params(const mcp_get_recently_played_by_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_recently_played_by_uid_result_params::~mcp_get_recently_played_by_uid_result_params(){
}
inline mcp_get_recently_played_by_uid_result_params& mcp_get_recently_played_by_uid_result_params::operator=(const mcp_get_recently_played_by_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_recently_played_by_uid_result_params::clear(){
// _m_count=0;
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_recently_played_by_uid_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string info_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_recently_played_by_uid_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_recently_played_by_uid_result_params& mcp_get_recently_played_by_uid_result_params::assign(const mcp_get_recently_played_by_uid_result_params& v){
_m_count=v._m_count;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_recently_played_by_uid_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_recently_played_by_uid_result_params::count() const{
return _m_count;
}
inline mcp_get_recently_played_by_uid_result_params& mcp_get_recently_played_by_uid_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_recently_played_by_uid_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_recently_played_by_uid_result_params::has_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_recently_played_by_uid_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_recently_played_by_uid_result_params::clear_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_recently_played_by_uid_result_params::mutable_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_recently_played_by_uid_result_params::m_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_recently_played_by_uid_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const char* mcp_get_recently_played_by_uid_result_params::info_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_info_list.get(i0).get(i1).get(size);
}
inline mcp_get_recently_played_by_uid_result_params& mcp_get_recently_played_by_uid_result_params::set_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_recently_played_by_uid_result_params& mcp_get_recently_played_by_uid_result_params::set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_recently_played_by_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_recently_played_by_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_recently_played_by_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_recently_played_by_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_recently_played_by_uid_response* mcp_get_recently_played_by_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_recently_played_by_uid_response* tmp=(mcp_get_recently_played_by_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_recently_played_by_uid_response(pool);
return tmp;
}
inline void mcp_get_recently_played_by_uid_response::destroy(mcp_get_recently_played_by_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_recently_played_by_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_recently_played_by_uid_response::mcp_get_recently_played_by_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_recently_played_by_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_recently_played_by_uid_response::mcp_get_recently_played_by_uid_response(const mcp_get_recently_played_by_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_recently_played_by_uid_result_params::create(_pool);
assign(v);
}
inline mcp_get_recently_played_by_uid_response::~mcp_get_recently_played_by_uid_response(){
if(_m_result_params){
::idl::mcp_get_recently_played_by_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_recently_played_by_uid_response& mcp_get_recently_played_by_uid_response::operator=(const mcp_get_recently_played_by_uid_response& v){
assign(v);
return *this;
}
inline void mcp_get_recently_played_by_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_recently_played_by_uid_response::check() const{
// @@mcp_get_recently_played_by_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_recently_played_by_uid_result_params& item=const_cast< ::idl::mcp_get_recently_played_by_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_recently_played_by_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_recently_played_by_uid_response& mcp_get_recently_played_by_uid_response::assign(const mcp_get_recently_played_by_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_recently_played_by_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_recently_played_by_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_recently_played_by_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_recently_played_by_uid_result_params& mcp_get_recently_played_by_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_recently_played_by_uid_result_params* mcp_get_recently_played_by_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_recently_played_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_recently_played_by_uid_result_params* mcp_get_recently_played_by_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_recently_played_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_recently_played_by_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_recently_played_by_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_recently_played_by_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_recently_played_by_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_get_recently_played_by_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_add_game_to_favorite_params* mcp_add_game_to_favorite_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_game_to_favorite_params* tmp=(mcp_add_game_to_favorite_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_game_to_favorite_params(pool);
return tmp;
}
inline void mcp_add_game_to_favorite_params::destroy(mcp_add_game_to_favorite_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_game_to_favorite_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_game_to_favorite_params::mcp_add_game_to_favorite_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_m_c_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_game_to_favorite_params::mcp_add_game_to_favorite_params(const mcp_add_game_to_favorite_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_m_c_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_add_game_to_favorite_params::~mcp_add_game_to_favorite_params(){
}
inline mcp_add_game_to_favorite_params& mcp_add_game_to_favorite_params::operator=(const mcp_add_game_to_favorite_params& v){
assign(v);
return *this;
}
inline void mcp_add_game_to_favorite_params::clear(){
_m_u_id.clear();
_m_c_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_game_to_favorite_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}
// @@string c_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_add_game_to_favorite_params::detach(){
_m_u_id.detach();
_m_c_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_game_to_favorite_params& mcp_add_game_to_favorite_params::assign(const mcp_add_game_to_favorite_params& v){
_m_u_id=v._m_u_id;
_m_c_id=v._m_c_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_game_to_favorite_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_add_game_to_favorite_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_add_game_to_favorite_params& mcp_add_game_to_favorite_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_game_to_favorite_params& mcp_add_game_to_favorite_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_game_to_favorite_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline bool mcp_add_game_to_favorite_params::has_c_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_add_game_to_favorite_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_add_game_to_favorite_params& mcp_add_game_to_favorite_params::set_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_game_to_favorite_params& mcp_add_game_to_favorite_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_game_to_favorite_params::clear_c_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_c_id.clear();
}
inline ::idl::Unknown* mcp_add_game_to_favorite_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_game_to_favorite_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_game_to_favorite_params::unknown(){
return _unknown;
}
inline size_t mcp_add_game_to_favorite_params::unknown_size() const{
return _unknown.size();
}
inline mcp_add_game_to_favorite_result_params* mcp_add_game_to_favorite_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_game_to_favorite_result_params* tmp=(mcp_add_game_to_favorite_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_game_to_favorite_result_params(pool);
return tmp;
}
inline void mcp_add_game_to_favorite_result_params::destroy(mcp_add_game_to_favorite_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_game_to_favorite_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_game_to_favorite_result_params::mcp_add_game_to_favorite_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_game_to_favorite_result_params::mcp_add_game_to_favorite_result_params(const mcp_add_game_to_favorite_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_unknown(_pool){
assign(v);
}
inline mcp_add_game_to_favorite_result_params::~mcp_add_game_to_favorite_result_params(){
}
inline mcp_add_game_to_favorite_result_params& mcp_add_game_to_favorite_result_params::operator=(const mcp_add_game_to_favorite_result_params& v){
assign(v);
return *this;
}
inline void mcp_add_game_to_favorite_result_params::clear(){
// _m_result=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_game_to_favorite_result_params::check() const{
// @@uint32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_result;

}

::idl::McpackBean::check();
}
inline void mcp_add_game_to_favorite_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_game_to_favorite_result_params& mcp_add_game_to_favorite_result_params::assign(const mcp_add_game_to_favorite_result_params& v){
_m_result=v._m_result;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_game_to_favorite_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_add_game_to_favorite_result_params::result() const{
return _m_result;
}
inline mcp_add_game_to_favorite_result_params& mcp_add_game_to_favorite_result_params::set_result(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_add_game_to_favorite_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline ::idl::Unknown* mcp_add_game_to_favorite_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_game_to_favorite_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_game_to_favorite_result_params::unknown(){
return _unknown;
}
inline size_t mcp_add_game_to_favorite_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_add_game_to_favorite_response* mcp_add_game_to_favorite_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_game_to_favorite_response* tmp=(mcp_add_game_to_favorite_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_game_to_favorite_response(pool);
return tmp;
}
inline void mcp_add_game_to_favorite_response::destroy(mcp_add_game_to_favorite_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_game_to_favorite_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_game_to_favorite_response::mcp_add_game_to_favorite_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_add_game_to_favorite_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_game_to_favorite_response::mcp_add_game_to_favorite_response(const mcp_add_game_to_favorite_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_add_game_to_favorite_result_params::create(_pool);
assign(v);
}
inline mcp_add_game_to_favorite_response::~mcp_add_game_to_favorite_response(){
if(_m_result_params){
::idl::mcp_add_game_to_favorite_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_add_game_to_favorite_response& mcp_add_game_to_favorite_response::operator=(const mcp_add_game_to_favorite_response& v){
assign(v);
return *this;
}
inline void mcp_add_game_to_favorite_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_game_to_favorite_response::check() const{
// @@mcp_add_game_to_favorite_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_add_game_to_favorite_result_params& item=const_cast< ::idl::mcp_add_game_to_favorite_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_add_game_to_favorite_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_game_to_favorite_response& mcp_add_game_to_favorite_response::assign(const mcp_add_game_to_favorite_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_add_game_to_favorite_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_add_game_to_favorite_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_game_to_favorite_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_add_game_to_favorite_result_params& mcp_add_game_to_favorite_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_add_game_to_favorite_result_params* mcp_add_game_to_favorite_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_add_game_to_favorite_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_add_game_to_favorite_result_params* mcp_add_game_to_favorite_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_add_game_to_favorite_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_add_game_to_favorite_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_add_game_to_favorite_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_game_to_favorite_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_game_to_favorite_response::unknown(){
return _unknown;
}
inline size_t mcp_add_game_to_favorite_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_favoraite_by_uid_params* mcp_get_favoraite_by_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_favoraite_by_uid_params* tmp=(mcp_get_favoraite_by_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_favoraite_by_uid_params(pool);
return tmp;
}
inline void mcp_get_favoraite_by_uid_params::destroy(mcp_get_favoraite_by_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_favoraite_by_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_favoraite_by_uid_params::mcp_get_favoraite_by_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_favoraite_by_uid_params::mcp_get_favoraite_by_uid_params(const mcp_get_favoraite_by_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_favoraite_by_uid_params::~mcp_get_favoraite_by_uid_params(){
}
inline mcp_get_favoraite_by_uid_params& mcp_get_favoraite_by_uid_params::operator=(const mcp_get_favoraite_by_uid_params& v){
assign(v);
return *this;
}
inline void mcp_get_favoraite_by_uid_params::clear(){
_m_u_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_favoraite_by_uid_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_favoraite_by_uid_params::detach(){
_m_u_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_favoraite_by_uid_params& mcp_get_favoraite_by_uid_params::assign(const mcp_get_favoraite_by_uid_params& v){
_m_u_id=v._m_u_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_favoraite_by_uid_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_favoraite_by_uid_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_get_favoraite_by_uid_params& mcp_get_favoraite_by_uid_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_favoraite_by_uid_params& mcp_get_favoraite_by_uid_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_favoraite_by_uid_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline ::idl::Unknown* mcp_get_favoraite_by_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_favoraite_by_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_favoraite_by_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_get_favoraite_by_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_favoraite_by_uid_result_params* mcp_get_favoraite_by_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_favoraite_by_uid_result_params* tmp=(mcp_get_favoraite_by_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_favoraite_by_uid_result_params(pool);
return tmp;
}
inline void mcp_get_favoraite_by_uid_result_params::destroy(mcp_get_favoraite_by_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_favoraite_by_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_favoraite_by_uid_result_params::mcp_get_favoraite_by_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_favoraite_by_uid_result_params::mcp_get_favoraite_by_uid_result_params(const mcp_get_favoraite_by_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_favoraite_by_uid_result_params::~mcp_get_favoraite_by_uid_result_params(){
}
inline mcp_get_favoraite_by_uid_result_params& mcp_get_favoraite_by_uid_result_params::operator=(const mcp_get_favoraite_by_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_favoraite_by_uid_result_params::clear(){
// _m_count=0;
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_favoraite_by_uid_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string info_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_favoraite_by_uid_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_favoraite_by_uid_result_params& mcp_get_favoraite_by_uid_result_params::assign(const mcp_get_favoraite_by_uid_result_params& v){
_m_count=v._m_count;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_favoraite_by_uid_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_favoraite_by_uid_result_params::count() const{
return _m_count;
}
inline mcp_get_favoraite_by_uid_result_params& mcp_get_favoraite_by_uid_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_favoraite_by_uid_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_favoraite_by_uid_result_params::has_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_favoraite_by_uid_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_favoraite_by_uid_result_params::clear_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_favoraite_by_uid_result_params::mutable_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_favoraite_by_uid_result_params::m_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_favoraite_by_uid_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const char* mcp_get_favoraite_by_uid_result_params::info_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_info_list.get(i0).get(i1).get(size);
}
inline mcp_get_favoraite_by_uid_result_params& mcp_get_favoraite_by_uid_result_params::set_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_favoraite_by_uid_result_params& mcp_get_favoraite_by_uid_result_params::set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_favoraite_by_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_favoraite_by_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_favoraite_by_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_favoraite_by_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_favoraite_by_uid_response* mcp_get_favoraite_by_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_favoraite_by_uid_response* tmp=(mcp_get_favoraite_by_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_favoraite_by_uid_response(pool);
return tmp;
}
inline void mcp_get_favoraite_by_uid_response::destroy(mcp_get_favoraite_by_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_favoraite_by_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_favoraite_by_uid_response::mcp_get_favoraite_by_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_favoraite_by_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_favoraite_by_uid_response::mcp_get_favoraite_by_uid_response(const mcp_get_favoraite_by_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_favoraite_by_uid_result_params::create(_pool);
assign(v);
}
inline mcp_get_favoraite_by_uid_response::~mcp_get_favoraite_by_uid_response(){
if(_m_result_params){
::idl::mcp_get_favoraite_by_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_favoraite_by_uid_response& mcp_get_favoraite_by_uid_response::operator=(const mcp_get_favoraite_by_uid_response& v){
assign(v);
return *this;
}
inline void mcp_get_favoraite_by_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_favoraite_by_uid_response::check() const{
// @@mcp_get_favoraite_by_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_favoraite_by_uid_result_params& item=const_cast< ::idl::mcp_get_favoraite_by_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_favoraite_by_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_favoraite_by_uid_response& mcp_get_favoraite_by_uid_response::assign(const mcp_get_favoraite_by_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_favoraite_by_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_favoraite_by_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_favoraite_by_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_favoraite_by_uid_result_params& mcp_get_favoraite_by_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_favoraite_by_uid_result_params* mcp_get_favoraite_by_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_favoraite_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_favoraite_by_uid_result_params* mcp_get_favoraite_by_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_favoraite_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_favoraite_by_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_favoraite_by_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_favoraite_by_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_favoraite_by_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_get_favoraite_by_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_H5_latest_on_shelf_by_date_params* mcp_get_H5_latest_on_shelf_by_date_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_H5_latest_on_shelf_by_date_params* tmp=(mcp_get_H5_latest_on_shelf_by_date_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_H5_latest_on_shelf_by_date_params(pool);
return tmp;
}
inline void mcp_get_H5_latest_on_shelf_by_date_params::destroy(mcp_get_H5_latest_on_shelf_by_date_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_H5_latest_on_shelf_by_date_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_H5_latest_on_shelf_by_date_params::mcp_get_H5_latest_on_shelf_by_date_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_H5_latest_on_shelf_by_date_params::mcp_get_H5_latest_on_shelf_by_date_params(const mcp_get_H5_latest_on_shelf_by_date_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_H5_latest_on_shelf_by_date_params::~mcp_get_H5_latest_on_shelf_by_date_params(){
}
inline mcp_get_H5_latest_on_shelf_by_date_params& mcp_get_H5_latest_on_shelf_by_date_params::operator=(const mcp_get_H5_latest_on_shelf_by_date_params& v){
assign(v);
return *this;
}
inline void mcp_get_H5_latest_on_shelf_by_date_params::clear(){
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_H5_latest_on_shelf_by_date_params::check() const{
// @@uint32_t unit_num=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_H5_latest_on_shelf_by_date_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_H5_latest_on_shelf_by_date_params& mcp_get_H5_latest_on_shelf_by_date_params::assign(const mcp_get_H5_latest_on_shelf_by_date_params& v){
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_H5_latest_on_shelf_by_date_params::has_unit_num() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_H5_latest_on_shelf_by_date_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_H5_latest_on_shelf_by_date_params& mcp_get_H5_latest_on_shelf_by_date_params::set_unit_num(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_H5_latest_on_shelf_by_date_params::clear_unit_num(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_H5_latest_on_shelf_by_date_params::has_unit_times() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_H5_latest_on_shelf_by_date_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_H5_latest_on_shelf_by_date_params& mcp_get_H5_latest_on_shelf_by_date_params::set_unit_times(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_H5_latest_on_shelf_by_date_params::clear_unit_times(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_H5_latest_on_shelf_by_date_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_H5_latest_on_shelf_by_date_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_H5_latest_on_shelf_by_date_params::unknown(){
return _unknown;
}
inline size_t mcp_get_H5_latest_on_shelf_by_date_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_H5_latest_on_shelf_by_date_result_params* mcp_get_H5_latest_on_shelf_by_date_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_H5_latest_on_shelf_by_date_result_params* tmp=(mcp_get_H5_latest_on_shelf_by_date_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_H5_latest_on_shelf_by_date_result_params(pool);
return tmp;
}
inline void mcp_get_H5_latest_on_shelf_by_date_result_params::destroy(mcp_get_H5_latest_on_shelf_by_date_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_H5_latest_on_shelf_by_date_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_H5_latest_on_shelf_by_date_result_params::mcp_get_H5_latest_on_shelf_by_date_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_H5_latest_on_shelf_by_date_result_params::mcp_get_H5_latest_on_shelf_by_date_result_params(const mcp_get_H5_latest_on_shelf_by_date_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_H5_latest_on_shelf_by_date_result_params::~mcp_get_H5_latest_on_shelf_by_date_result_params(){
}
inline mcp_get_H5_latest_on_shelf_by_date_result_params& mcp_get_H5_latest_on_shelf_by_date_result_params::operator=(const mcp_get_H5_latest_on_shelf_by_date_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_H5_latest_on_shelf_by_date_result_params::clear(){
// _m_count=0;
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_H5_latest_on_shelf_by_date_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string info_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_H5_latest_on_shelf_by_date_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_H5_latest_on_shelf_by_date_result_params& mcp_get_H5_latest_on_shelf_by_date_result_params::assign(const mcp_get_H5_latest_on_shelf_by_date_result_params& v){
_m_count=v._m_count;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_H5_latest_on_shelf_by_date_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_H5_latest_on_shelf_by_date_result_params::count() const{
return _m_count;
}
inline mcp_get_H5_latest_on_shelf_by_date_result_params& mcp_get_H5_latest_on_shelf_by_date_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_H5_latest_on_shelf_by_date_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_H5_latest_on_shelf_by_date_result_params::has_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_H5_latest_on_shelf_by_date_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_H5_latest_on_shelf_by_date_result_params::clear_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_H5_latest_on_shelf_by_date_result_params::mutable_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_H5_latest_on_shelf_by_date_result_params::m_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_H5_latest_on_shelf_by_date_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const char* mcp_get_H5_latest_on_shelf_by_date_result_params::info_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_info_list.get(i0).get(i1).get(size);
}
inline mcp_get_H5_latest_on_shelf_by_date_result_params& mcp_get_H5_latest_on_shelf_by_date_result_params::set_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_H5_latest_on_shelf_by_date_result_params& mcp_get_H5_latest_on_shelf_by_date_result_params::set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_H5_latest_on_shelf_by_date_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_H5_latest_on_shelf_by_date_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_H5_latest_on_shelf_by_date_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_H5_latest_on_shelf_by_date_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_H5_latest_on_shelf_by_date_response* mcp_get_H5_latest_on_shelf_by_date_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_H5_latest_on_shelf_by_date_response* tmp=(mcp_get_H5_latest_on_shelf_by_date_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_H5_latest_on_shelf_by_date_response(pool);
return tmp;
}
inline void mcp_get_H5_latest_on_shelf_by_date_response::destroy(mcp_get_H5_latest_on_shelf_by_date_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_H5_latest_on_shelf_by_date_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_H5_latest_on_shelf_by_date_response::mcp_get_H5_latest_on_shelf_by_date_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_H5_latest_on_shelf_by_date_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_H5_latest_on_shelf_by_date_response::mcp_get_H5_latest_on_shelf_by_date_response(const mcp_get_H5_latest_on_shelf_by_date_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_H5_latest_on_shelf_by_date_result_params::create(_pool);
assign(v);
}
inline mcp_get_H5_latest_on_shelf_by_date_response::~mcp_get_H5_latest_on_shelf_by_date_response(){
if(_m_result_params){
::idl::mcp_get_H5_latest_on_shelf_by_date_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_H5_latest_on_shelf_by_date_response& mcp_get_H5_latest_on_shelf_by_date_response::operator=(const mcp_get_H5_latest_on_shelf_by_date_response& v){
assign(v);
return *this;
}
inline void mcp_get_H5_latest_on_shelf_by_date_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_H5_latest_on_shelf_by_date_response::check() const{
// @@mcp_get_H5_latest_on_shelf_by_date_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_H5_latest_on_shelf_by_date_result_params& item=const_cast< ::idl::mcp_get_H5_latest_on_shelf_by_date_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_H5_latest_on_shelf_by_date_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_H5_latest_on_shelf_by_date_response& mcp_get_H5_latest_on_shelf_by_date_response::assign(const mcp_get_H5_latest_on_shelf_by_date_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_H5_latest_on_shelf_by_date_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_H5_latest_on_shelf_by_date_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_H5_latest_on_shelf_by_date_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_H5_latest_on_shelf_by_date_result_params& mcp_get_H5_latest_on_shelf_by_date_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_H5_latest_on_shelf_by_date_result_params* mcp_get_H5_latest_on_shelf_by_date_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_H5_latest_on_shelf_by_date_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_H5_latest_on_shelf_by_date_result_params* mcp_get_H5_latest_on_shelf_by_date_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_H5_latest_on_shelf_by_date_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_H5_latest_on_shelf_by_date_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_H5_latest_on_shelf_by_date_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_H5_latest_on_shelf_by_date_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_H5_latest_on_shelf_by_date_response::unknown(){
return _unknown;
}
inline size_t mcp_get_H5_latest_on_shelf_by_date_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params* mcp_get_H5_latest_on_shelf_by_date_and_type_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_H5_latest_on_shelf_by_date_and_type_params* tmp=(mcp_get_H5_latest_on_shelf_by_date_and_type_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_H5_latest_on_shelf_by_date_and_type_params(pool);
return tmp;
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_params::destroy(mcp_get_H5_latest_on_shelf_by_date_and_type_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_H5_latest_on_shelf_by_date_and_type_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params::mcp_get_H5_latest_on_shelf_by_date_and_type_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_content_type(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params::mcp_get_H5_latest_on_shelf_by_date_and_type_params(const mcp_get_H5_latest_on_shelf_by_date_and_type_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_content_type(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params::~mcp_get_H5_latest_on_shelf_by_date_and_type_params(){
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params& mcp_get_H5_latest_on_shelf_by_date_and_type_params::operator=(const mcp_get_H5_latest_on_shelf_by_date_and_type_params& v){
assign(v);
return *this;
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_params::clear(){
// _m_unit_num=0;
// _m_unit_times=0;
_m_content_type.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_params::check() const{
// @@uint32_t unit_num=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}
// @@string content_type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_type.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_params::detach(){
_m_content_type.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params& mcp_get_H5_latest_on_shelf_by_date_and_type_params::assign(const mcp_get_H5_latest_on_shelf_by_date_and_type_params& v){
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_m_content_type=v._m_content_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_H5_latest_on_shelf_by_date_and_type_params::has_unit_num() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_H5_latest_on_shelf_by_date_and_type_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params& mcp_get_H5_latest_on_shelf_by_date_and_type_params::set_unit_num(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_params::clear_unit_num(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_H5_latest_on_shelf_by_date_and_type_params::has_unit_times() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_H5_latest_on_shelf_by_date_and_type_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params& mcp_get_H5_latest_on_shelf_by_date_and_type_params::set_unit_times(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_params::clear_unit_times(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_times=0;
}
inline bool mcp_get_H5_latest_on_shelf_by_date_and_type_params::has_content_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_H5_latest_on_shelf_by_date_and_type_params::content_type(unsigned int* size) const{
return _m_content_type.get(size);
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params& mcp_get_H5_latest_on_shelf_by_date_and_type_params::set_content_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_content_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_params& mcp_get_H5_latest_on_shelf_by_date_and_type_params::set_ptr_content_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_content_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_params::clear_content_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_content_type.clear();
}
inline ::idl::Unknown* mcp_get_H5_latest_on_shelf_by_date_and_type_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_H5_latest_on_shelf_by_date_and_type_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_H5_latest_on_shelf_by_date_and_type_params::unknown(){
return _unknown;
}
inline size_t mcp_get_H5_latest_on_shelf_by_date_and_type_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_result_params* mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_H5_latest_on_shelf_by_date_and_type_result_params* tmp=(mcp_get_H5_latest_on_shelf_by_date_and_type_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_H5_latest_on_shelf_by_date_and_type_result_params(pool);
return tmp;
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::destroy(mcp_get_H5_latest_on_shelf_by_date_and_type_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_H5_latest_on_shelf_by_date_and_type_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params(const mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::~mcp_get_H5_latest_on_shelf_by_date_and_type_result_params(){
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::operator=(const mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::clear(){
// _m_count=0;
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string info_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::assign(const mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& v){
_m_count=v._m_count;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::count() const{
return _m_count;
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::has_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::clear_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::mutable_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::m_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const char* mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::info_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_info_list.get(i0).get(i1).get(size);
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::set_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_response* mcp_get_H5_latest_on_shelf_by_date_and_type_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_H5_latest_on_shelf_by_date_and_type_response* tmp=(mcp_get_H5_latest_on_shelf_by_date_and_type_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_H5_latest_on_shelf_by_date_and_type_response(pool);
return tmp;
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_response::destroy(mcp_get_H5_latest_on_shelf_by_date_and_type_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_H5_latest_on_shelf_by_date_and_type_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_response::mcp_get_H5_latest_on_shelf_by_date_and_type_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_response::mcp_get_H5_latest_on_shelf_by_date_and_type_response(const mcp_get_H5_latest_on_shelf_by_date_and_type_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::create(_pool);
assign(v);
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_response::~mcp_get_H5_latest_on_shelf_by_date_and_type_response(){
if(_m_result_params){
::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_response& mcp_get_H5_latest_on_shelf_by_date_and_type_response::operator=(const mcp_get_H5_latest_on_shelf_by_date_and_type_response& v){
assign(v);
return *this;
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_response::check() const{
// @@mcp_get_H5_latest_on_shelf_by_date_and_type_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& item=const_cast< ::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_H5_latest_on_shelf_by_date_and_type_response& mcp_get_H5_latest_on_shelf_by_date_and_type_response::assign(const mcp_get_H5_latest_on_shelf_by_date_and_type_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_H5_latest_on_shelf_by_date_and_type_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params& mcp_get_H5_latest_on_shelf_by_date_and_type_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params* mcp_get_H5_latest_on_shelf_by_date_and_type_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params* mcp_get_H5_latest_on_shelf_by_date_and_type_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_H5_latest_on_shelf_by_date_and_type_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_H5_latest_on_shelf_by_date_and_type_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_H5_latest_on_shelf_by_date_and_type_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_H5_latest_on_shelf_by_date_and_type_response::unknown(){
return _unknown;
}
inline size_t mcp_get_H5_latest_on_shelf_by_date_and_type_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_H5_info_list_by_col_id_params* mcp_get_H5_info_list_by_col_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_H5_info_list_by_col_id_params* tmp=(mcp_get_H5_info_list_by_col_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_H5_info_list_by_col_id_params(pool);
return tmp;
}
inline void mcp_get_H5_info_list_by_col_id_params::destroy(mcp_get_H5_info_list_by_col_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_H5_info_list_by_col_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_H5_info_list_by_col_id_params::mcp_get_H5_info_list_by_col_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_col_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_H5_info_list_by_col_id_params::mcp_get_H5_info_list_by_col_id_params(const mcp_get_H5_info_list_by_col_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_col_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_H5_info_list_by_col_id_params::~mcp_get_H5_info_list_by_col_id_params(){
}
inline mcp_get_H5_info_list_by_col_id_params& mcp_get_H5_info_list_by_col_id_params::operator=(const mcp_get_H5_info_list_by_col_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_H5_info_list_by_col_id_params::clear(){
// _m_unit_num=0;
// _m_unit_times=0;
_m_col_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_H5_info_list_by_col_id_params::check() const{
// @@uint32_t unit_num=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}
// @@string col_id=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_col_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_H5_info_list_by_col_id_params::detach(){
_m_col_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_H5_info_list_by_col_id_params& mcp_get_H5_info_list_by_col_id_params::assign(const mcp_get_H5_info_list_by_col_id_params& v){
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_m_col_id=v._m_col_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_H5_info_list_by_col_id_params::has_unit_num() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_H5_info_list_by_col_id_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_H5_info_list_by_col_id_params& mcp_get_H5_info_list_by_col_id_params::set_unit_num(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_H5_info_list_by_col_id_params::clear_unit_num(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_H5_info_list_by_col_id_params::has_unit_times() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_H5_info_list_by_col_id_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_H5_info_list_by_col_id_params& mcp_get_H5_info_list_by_col_id_params::set_unit_times(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_H5_info_list_by_col_id_params::clear_unit_times(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_times=0;
}
inline bool mcp_get_H5_info_list_by_col_id_params::has_col_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_H5_info_list_by_col_id_params::col_id(unsigned int* size) const{
return _m_col_id.get(size);
}
inline mcp_get_H5_info_list_by_col_id_params& mcp_get_H5_info_list_by_col_id_params::set_col_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_col_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_H5_info_list_by_col_id_params& mcp_get_H5_info_list_by_col_id_params::set_ptr_col_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_col_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_H5_info_list_by_col_id_params::clear_col_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_col_id.clear();
}
inline ::idl::Unknown* mcp_get_H5_info_list_by_col_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_H5_info_list_by_col_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_H5_info_list_by_col_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_H5_info_list_by_col_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_H5_info_list_by_col_id_result_params* mcp_get_H5_info_list_by_col_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_H5_info_list_by_col_id_result_params* tmp=(mcp_get_H5_info_list_by_col_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_H5_info_list_by_col_id_result_params(pool);
return tmp;
}
inline void mcp_get_H5_info_list_by_col_id_result_params::destroy(mcp_get_H5_info_list_by_col_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_H5_info_list_by_col_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_H5_info_list_by_col_id_result_params::mcp_get_H5_info_list_by_col_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_H5_info_list_by_col_id_result_params::mcp_get_H5_info_list_by_col_id_result_params(const mcp_get_H5_info_list_by_col_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_H5_info_list_by_col_id_result_params::~mcp_get_H5_info_list_by_col_id_result_params(){
}
inline mcp_get_H5_info_list_by_col_id_result_params& mcp_get_H5_info_list_by_col_id_result_params::operator=(const mcp_get_H5_info_list_by_col_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_H5_info_list_by_col_id_result_params::clear(){
// _m_count=0;
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_H5_info_list_by_col_id_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string info_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_H5_info_list_by_col_id_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_H5_info_list_by_col_id_result_params& mcp_get_H5_info_list_by_col_id_result_params::assign(const mcp_get_H5_info_list_by_col_id_result_params& v){
_m_count=v._m_count;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_H5_info_list_by_col_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_H5_info_list_by_col_id_result_params::count() const{
return _m_count;
}
inline mcp_get_H5_info_list_by_col_id_result_params& mcp_get_H5_info_list_by_col_id_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_H5_info_list_by_col_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_H5_info_list_by_col_id_result_params::has_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_H5_info_list_by_col_id_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_H5_info_list_by_col_id_result_params::clear_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_H5_info_list_by_col_id_result_params::mutable_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_H5_info_list_by_col_id_result_params::m_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_H5_info_list_by_col_id_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const char* mcp_get_H5_info_list_by_col_id_result_params::info_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_info_list.get(i0).get(i1).get(size);
}
inline mcp_get_H5_info_list_by_col_id_result_params& mcp_get_H5_info_list_by_col_id_result_params::set_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_H5_info_list_by_col_id_result_params& mcp_get_H5_info_list_by_col_id_result_params::set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_H5_info_list_by_col_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_H5_info_list_by_col_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_H5_info_list_by_col_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_H5_info_list_by_col_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_H5_info_list_by_col_id_response* mcp_get_H5_info_list_by_col_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_H5_info_list_by_col_id_response* tmp=(mcp_get_H5_info_list_by_col_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_H5_info_list_by_col_id_response(pool);
return tmp;
}
inline void mcp_get_H5_info_list_by_col_id_response::destroy(mcp_get_H5_info_list_by_col_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_H5_info_list_by_col_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_H5_info_list_by_col_id_response::mcp_get_H5_info_list_by_col_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_H5_info_list_by_col_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_H5_info_list_by_col_id_response::mcp_get_H5_info_list_by_col_id_response(const mcp_get_H5_info_list_by_col_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_H5_info_list_by_col_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_H5_info_list_by_col_id_response::~mcp_get_H5_info_list_by_col_id_response(){
if(_m_result_params){
::idl::mcp_get_H5_info_list_by_col_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_H5_info_list_by_col_id_response& mcp_get_H5_info_list_by_col_id_response::operator=(const mcp_get_H5_info_list_by_col_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_H5_info_list_by_col_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_H5_info_list_by_col_id_response::check() const{
// @@mcp_get_H5_info_list_by_col_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_H5_info_list_by_col_id_result_params& item=const_cast< ::idl::mcp_get_H5_info_list_by_col_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_H5_info_list_by_col_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_H5_info_list_by_col_id_response& mcp_get_H5_info_list_by_col_id_response::assign(const mcp_get_H5_info_list_by_col_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_H5_info_list_by_col_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_H5_info_list_by_col_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_H5_info_list_by_col_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_H5_info_list_by_col_id_result_params& mcp_get_H5_info_list_by_col_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_H5_info_list_by_col_id_result_params* mcp_get_H5_info_list_by_col_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_H5_info_list_by_col_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_H5_info_list_by_col_id_result_params* mcp_get_H5_info_list_by_col_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_H5_info_list_by_col_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_H5_info_list_by_col_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_H5_info_list_by_col_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_H5_info_list_by_col_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_H5_info_list_by_col_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_H5_info_list_by_col_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_params* mcp_get_imgurls_and_favorite_by_uid_cid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_imgurls_and_favorite_by_uid_cid_params* tmp=(mcp_get_imgurls_and_favorite_by_uid_cid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_imgurls_and_favorite_by_uid_cid_params(pool);
return tmp;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_params::destroy(mcp_get_imgurls_and_favorite_by_uid_cid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_imgurls_and_favorite_by_uid_cid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_params::mcp_get_imgurls_and_favorite_by_uid_cid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_uid(_pool)
,_m_cid(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_params::mcp_get_imgurls_and_favorite_by_uid_cid_params(const mcp_get_imgurls_and_favorite_by_uid_cid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_uid(_pool)
,_m_cid(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_params::~mcp_get_imgurls_and_favorite_by_uid_cid_params(){
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_params& mcp_get_imgurls_and_favorite_by_uid_cid_params::operator=(const mcp_get_imgurls_and_favorite_by_uid_cid_params& v){
assign(v);
return *this;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_params::clear(){
_m_uid.clear();
_m_cid.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_imgurls_and_favorite_by_uid_cid_params::check() const{
// @@string uid=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "uid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_uid.get();

}
// @@string cid=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "cid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_cid.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_params::detach(){
_m_uid.detach();
_m_cid.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_params& mcp_get_imgurls_and_favorite_by_uid_cid_params::assign(const mcp_get_imgurls_and_favorite_by_uid_cid_params& v){
_m_uid=v._m_uid;
_m_cid=v._m_cid;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_imgurls_and_favorite_by_uid_cid_params::has_uid() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_imgurls_and_favorite_by_uid_cid_params::uid(unsigned int* size) const{
return _m_uid.get(size);
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_params& mcp_get_imgurls_and_favorite_by_uid_cid_params::set_uid(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_uid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_params& mcp_get_imgurls_and_favorite_by_uid_cid_params::set_ptr_uid(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_uid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_params::clear_uid(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_uid.clear();
}
inline bool mcp_get_imgurls_and_favorite_by_uid_cid_params::has_cid() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_imgurls_and_favorite_by_uid_cid_params::cid(unsigned int* size) const{
return _m_cid.get(size);
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_params& mcp_get_imgurls_and_favorite_by_uid_cid_params::set_cid(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_cid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_params& mcp_get_imgurls_and_favorite_by_uid_cid_params::set_ptr_cid(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_cid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_params::clear_cid(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_cid.clear();
}
inline ::idl::Unknown* mcp_get_imgurls_and_favorite_by_uid_cid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_imgurls_and_favorite_by_uid_cid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_imgurls_and_favorite_by_uid_cid_params::unknown(){
return _unknown;
}
inline size_t mcp_get_imgurls_and_favorite_by_uid_cid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params* mcp_get_imgurls_and_favorite_by_uid_cid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_imgurls_and_favorite_by_uid_cid_result_params* tmp=(mcp_get_imgurls_and_favorite_by_uid_cid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_imgurls_and_favorite_by_uid_cid_result_params(pool);
return tmp;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_result_params::destroy(mcp_get_imgurls_and_favorite_by_uid_cid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_imgurls_and_favorite_by_uid_cid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params::mcp_get_imgurls_and_favorite_by_uid_cid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_icon_url(_pool)
,_m_xc_url1(_pool)
,_m_xc_url2(_pool)
,_m_count(0)
,_m_xq_url(_pool)
,_m_is_favorite(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params::mcp_get_imgurls_and_favorite_by_uid_cid_result_params(const mcp_get_imgurls_and_favorite_by_uid_cid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_icon_url(_pool)
,_m_xc_url1(_pool)
,_m_xc_url2(_pool)
,_m_count(0)
,_m_xq_url(_pool)
,_m_is_favorite(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params::~mcp_get_imgurls_and_favorite_by_uid_cid_result_params(){
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::operator=(const mcp_get_imgurls_and_favorite_by_uid_cid_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_result_params::clear(){
_m_icon_url.clear();
_m_xc_url1.clear();
_m_xc_url2.clear();
// _m_count=0;
_m_xq_url.clear();
// _m_is_favorite=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_imgurls_and_favorite_by_uid_cid_result_params::check() const{
// @@string icon_url=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "icon_url" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_icon_url.get();

}
// @@string xc_url1=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "xc_url1" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_xc_url1.get();

}
// @@string xc_url2=out();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "xc_url2" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_xc_url2.get();

}
// @@uint32_t count=out();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string xq_url=out(),array(0);
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "xq_url" << "' not found";
}
{
// level 0 begin
typeof(_m_xq_url)& lr0=(_m_xq_url);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) const char* item=lr0.GetWithoutCheck(i0).get();

}

}
// @@uint32_t is_favorite=out();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "is_favorite" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_is_favorite;

}

::idl::McpackBean::check();
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_result_params::detach(){
_m_icon_url.detach();
_m_xc_url1.detach();
_m_xc_url2.detach();
_m_xq_url.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::assign(const mcp_get_imgurls_and_favorite_by_uid_cid_result_params& v){
_m_icon_url=v._m_icon_url;
_m_xc_url1=v._m_xc_url1;
_m_xc_url2=v._m_xc_url2;
_m_count=v._m_count;
_m_xq_url=v._m_xq_url;
_m_is_favorite=v._m_is_favorite;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_imgurls_and_favorite_by_uid_cid_result_params::has_icon_url() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_imgurls_and_favorite_by_uid_cid_result_params::icon_url(unsigned int* size) const{
return _m_icon_url.get(size);
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::set_icon_url(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_icon_url.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::set_ptr_icon_url(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_icon_url.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_result_params::clear_icon_url(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_icon_url.clear();
}
inline bool mcp_get_imgurls_and_favorite_by_uid_cid_result_params::has_xc_url1() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_imgurls_and_favorite_by_uid_cid_result_params::xc_url1(unsigned int* size) const{
return _m_xc_url1.get(size);
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::set_xc_url1(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_xc_url1.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::set_ptr_xc_url1(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_xc_url1.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_result_params::clear_xc_url1(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_xc_url1.clear();
}
inline bool mcp_get_imgurls_and_favorite_by_uid_cid_result_params::has_xc_url2() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_imgurls_and_favorite_by_uid_cid_result_params::xc_url2(unsigned int* size) const{
return _m_xc_url2.get(size);
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::set_xc_url2(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_xc_url2.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::set_ptr_xc_url2(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_xc_url2.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_result_params::clear_xc_url2(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_xc_url2.clear();
}
inline bool mcp_get_imgurls_and_favorite_by_uid_cid_result_params::has_count() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_imgurls_and_favorite_by_uid_cid_result_params::count() const{
return _m_count;
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::set_count(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_result_params::clear_count(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_count=0;
}
inline bool mcp_get_imgurls_and_favorite_by_uid_cid_result_params::has_xq_url() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const ::idl::vector< ::idl::string >& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::xq_url() const{
 return _m_xq_url;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_result_params::clear_xq_url(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_xq_url.clear();
}
inline ::idl::vector< ::idl::string >* mcp_get_imgurls_and_favorite_by_uid_cid_result_params::mutable_xq_url(){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return &(_m_xq_url);
}
inline ::idl::vector< ::idl::string >* mcp_get_imgurls_and_favorite_by_uid_cid_result_params::m_xq_url(){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 return &(_m_xq_url);
}
inline size_t mcp_get_imgurls_and_favorite_by_uid_cid_result_params::xq_url_size() const{
/*  */ return _m_xq_url.size();
}
inline const char* mcp_get_imgurls_and_favorite_by_uid_cid_result_params::xq_url(size_t i0,unsigned int* size) const{
 return _m_xq_url.get(i0).get(size);
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::set_xq_url(size_t i0,const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_xq_url.mutable_get(i0)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::set_ptr_xq_url(size_t i0,const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_xq_url.mutable_get(i0)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline bool mcp_get_imgurls_and_favorite_by_uid_cid_result_params::has_is_favorite() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline uint32_t mcp_get_imgurls_and_favorite_by_uid_cid_result_params::is_favorite() const{
return _m_is_favorite;
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_result_params& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::set_is_favorite(uint32_t v){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_is_favorite=v;
return *this;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_result_params::clear_is_favorite(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_is_favorite=0;
}
inline ::idl::Unknown* mcp_get_imgurls_and_favorite_by_uid_cid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_imgurls_and_favorite_by_uid_cid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_imgurls_and_favorite_by_uid_cid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_response* mcp_get_imgurls_and_favorite_by_uid_cid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_imgurls_and_favorite_by_uid_cid_response* tmp=(mcp_get_imgurls_and_favorite_by_uid_cid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_imgurls_and_favorite_by_uid_cid_response(pool);
return tmp;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_response::destroy(mcp_get_imgurls_and_favorite_by_uid_cid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_imgurls_and_favorite_by_uid_cid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_response::mcp_get_imgurls_and_favorite_by_uid_cid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_response::mcp_get_imgurls_and_favorite_by_uid_cid_response(const mcp_get_imgurls_and_favorite_by_uid_cid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params::create(_pool);
assign(v);
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_response::~mcp_get_imgurls_and_favorite_by_uid_cid_response(){
if(_m_result_params){
::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_response& mcp_get_imgurls_and_favorite_by_uid_cid_response::operator=(const mcp_get_imgurls_and_favorite_by_uid_cid_response& v){
assign(v);
return *this;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_imgurls_and_favorite_by_uid_cid_response::check() const{
// @@mcp_get_imgurls_and_favorite_by_uid_cid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params& item=const_cast< ::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_imgurls_and_favorite_by_uid_cid_response& mcp_get_imgurls_and_favorite_by_uid_cid_response::assign(const mcp_get_imgurls_and_favorite_by_uid_cid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_imgurls_and_favorite_by_uid_cid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params& mcp_get_imgurls_and_favorite_by_uid_cid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params* mcp_get_imgurls_and_favorite_by_uid_cid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params* mcp_get_imgurls_and_favorite_by_uid_cid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_imgurls_and_favorite_by_uid_cid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_imgurls_and_favorite_by_uid_cid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_imgurls_and_favorite_by_uid_cid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_imgurls_and_favorite_by_uid_cid_response::unknown(){
return _unknown;
}
inline size_t mcp_get_imgurls_and_favorite_by_uid_cid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_random_h5_games_params* mcp_get_random_h5_games_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_random_h5_games_params* tmp=(mcp_get_random_h5_games_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_random_h5_games_params(pool);
return tmp;
}
inline void mcp_get_random_h5_games_params::destroy(mcp_get_random_h5_games_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_random_h5_games_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_random_h5_games_params::mcp_get_random_h5_games_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_random_h5_games_params::mcp_get_random_h5_games_params(const mcp_get_random_h5_games_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_random_h5_games_params::~mcp_get_random_h5_games_params(){
}
inline mcp_get_random_h5_games_params& mcp_get_random_h5_games_params::operator=(const mcp_get_random_h5_games_params& v){
assign(v);
return *this;
}
inline void mcp_get_random_h5_games_params::clear(){
// _m_count=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_random_h5_games_params::check() const{
// @@uint32_t count=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}

::idl::McpackBean::check();
}
inline void mcp_get_random_h5_games_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_random_h5_games_params& mcp_get_random_h5_games_params::assign(const mcp_get_random_h5_games_params& v){
_m_count=v._m_count;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_random_h5_games_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_random_h5_games_params::count() const{
return _m_count;
}
inline mcp_get_random_h5_games_params& mcp_get_random_h5_games_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_random_h5_games_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline ::idl::Unknown* mcp_get_random_h5_games_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_random_h5_games_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_random_h5_games_params::unknown(){
return _unknown;
}
inline size_t mcp_get_random_h5_games_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_random_h5_games_result_params* mcp_get_random_h5_games_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_random_h5_games_result_params* tmp=(mcp_get_random_h5_games_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_random_h5_games_result_params(pool);
return tmp;
}
inline void mcp_get_random_h5_games_result_params::destroy(mcp_get_random_h5_games_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_random_h5_games_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_random_h5_games_result_params::mcp_get_random_h5_games_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_actual_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_random_h5_games_result_params::mcp_get_random_h5_games_result_params(const mcp_get_random_h5_games_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_actual_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_random_h5_games_result_params::~mcp_get_random_h5_games_result_params(){
}
inline mcp_get_random_h5_games_result_params& mcp_get_random_h5_games_result_params::operator=(const mcp_get_random_h5_games_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_random_h5_games_result_params::clear(){
// _m_actual_count=0;
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_random_h5_games_result_params::check() const{
// @@uint32_t actual_count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "actual_count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_actual_count;

}
// @@string info_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_random_h5_games_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_random_h5_games_result_params& mcp_get_random_h5_games_result_params::assign(const mcp_get_random_h5_games_result_params& v){
_m_actual_count=v._m_actual_count;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_random_h5_games_result_params::has_actual_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_random_h5_games_result_params::actual_count() const{
return _m_actual_count;
}
inline mcp_get_random_h5_games_result_params& mcp_get_random_h5_games_result_params::set_actual_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_actual_count=v;
return *this;
}
inline void mcp_get_random_h5_games_result_params::clear_actual_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_actual_count=0;
}
inline bool mcp_get_random_h5_games_result_params::has_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_random_h5_games_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_random_h5_games_result_params::clear_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_random_h5_games_result_params::mutable_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_random_h5_games_result_params::m_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_random_h5_games_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const char* mcp_get_random_h5_games_result_params::info_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_info_list.get(i0).get(i1).get(size);
}
inline mcp_get_random_h5_games_result_params& mcp_get_random_h5_games_result_params::set_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_random_h5_games_result_params& mcp_get_random_h5_games_result_params::set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_random_h5_games_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_random_h5_games_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_random_h5_games_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_random_h5_games_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_random_h5_games_response* mcp_get_random_h5_games_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_random_h5_games_response* tmp=(mcp_get_random_h5_games_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_random_h5_games_response(pool);
return tmp;
}
inline void mcp_get_random_h5_games_response::destroy(mcp_get_random_h5_games_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_random_h5_games_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_random_h5_games_response::mcp_get_random_h5_games_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_random_h5_games_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_random_h5_games_response::mcp_get_random_h5_games_response(const mcp_get_random_h5_games_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_random_h5_games_result_params::create(_pool);
assign(v);
}
inline mcp_get_random_h5_games_response::~mcp_get_random_h5_games_response(){
if(_m_result_params){
::idl::mcp_get_random_h5_games_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_random_h5_games_response& mcp_get_random_h5_games_response::operator=(const mcp_get_random_h5_games_response& v){
assign(v);
return *this;
}
inline void mcp_get_random_h5_games_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_random_h5_games_response::check() const{
// @@mcp_get_random_h5_games_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_random_h5_games_result_params& item=const_cast< ::idl::mcp_get_random_h5_games_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_random_h5_games_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_random_h5_games_response& mcp_get_random_h5_games_response::assign(const mcp_get_random_h5_games_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_random_h5_games_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_random_h5_games_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_random_h5_games_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_random_h5_games_result_params& mcp_get_random_h5_games_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_random_h5_games_result_params* mcp_get_random_h5_games_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_random_h5_games_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_random_h5_games_result_params* mcp_get_random_h5_games_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_random_h5_games_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_random_h5_games_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_random_h5_games_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_random_h5_games_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_random_h5_games_response::unknown(){
return _unknown;
}
inline size_t mcp_get_random_h5_games_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_info_by_col_id_and_type_id_params* mcp_get_info_by_col_id_and_type_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_info_by_col_id_and_type_id_params* tmp=(mcp_get_info_by_col_id_and_type_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_info_by_col_id_and_type_id_params(pool);
return tmp;
}
inline void mcp_get_info_by_col_id_and_type_id_params::destroy(mcp_get_info_by_col_id_and_type_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_info_by_col_id_and_type_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_info_by_col_id_and_type_id_params::mcp_get_info_by_col_id_and_type_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_col_id(_pool)
,_m_type_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_info_by_col_id_and_type_id_params::mcp_get_info_by_col_id_and_type_id_params(const mcp_get_info_by_col_id_and_type_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_col_id(_pool)
,_m_type_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_info_by_col_id_and_type_id_params::~mcp_get_info_by_col_id_and_type_id_params(){
}
inline mcp_get_info_by_col_id_and_type_id_params& mcp_get_info_by_col_id_and_type_id_params::operator=(const mcp_get_info_by_col_id_and_type_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_info_by_col_id_and_type_id_params::clear(){
_m_col_id.clear();
_m_type_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_info_by_col_id_and_type_id_params::check() const{
// @@string col_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_col_id.get();

}
// @@string type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t page=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_info_by_col_id_and_type_id_params::detach(){
_m_col_id.detach();
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_info_by_col_id_and_type_id_params& mcp_get_info_by_col_id_and_type_id_params::assign(const mcp_get_info_by_col_id_and_type_id_params& v){
_m_col_id=v._m_col_id;
_m_type_id=v._m_type_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_info_by_col_id_and_type_id_params::has_col_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_info_by_col_id_and_type_id_params::col_id(unsigned int* size) const{
return _m_col_id.get(size);
}
inline mcp_get_info_by_col_id_and_type_id_params& mcp_get_info_by_col_id_and_type_id_params::set_col_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_col_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_info_by_col_id_and_type_id_params& mcp_get_info_by_col_id_and_type_id_params::set_ptr_col_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_col_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_info_by_col_id_and_type_id_params::clear_col_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_col_id.clear();
}
inline bool mcp_get_info_by_col_id_and_type_id_params::has_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_info_by_col_id_and_type_id_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_info_by_col_id_and_type_id_params& mcp_get_info_by_col_id_and_type_id_params::set_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_info_by_col_id_and_type_id_params& mcp_get_info_by_col_id_and_type_id_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_info_by_col_id_and_type_id_params::clear_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_info_by_col_id_and_type_id_params::has_page() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_info_by_col_id_and_type_id_params::page() const{
return _m_page;
}
inline mcp_get_info_by_col_id_and_type_id_params& mcp_get_info_by_col_id_and_type_id_params::set_page(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_info_by_col_id_and_type_id_params::clear_page(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page=0;
}
inline bool mcp_get_info_by_col_id_and_type_id_params::has_page_size() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_info_by_col_id_and_type_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_info_by_col_id_and_type_id_params& mcp_get_info_by_col_id_and_type_id_params::set_page_size(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_info_by_col_id_and_type_id_params::clear_page_size(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_info_by_col_id_and_type_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_info_by_col_id_and_type_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_info_by_col_id_and_type_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_info_by_col_id_and_type_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_info_by_col_id_and_type_id_result_params* mcp_get_info_by_col_id_and_type_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_info_by_col_id_and_type_id_result_params* tmp=(mcp_get_info_by_col_id_and_type_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_info_by_col_id_and_type_id_result_params(pool);
return tmp;
}
inline void mcp_get_info_by_col_id_and_type_id_result_params::destroy(mcp_get_info_by_col_id_and_type_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_info_by_col_id_and_type_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_info_by_col_id_and_type_id_result_params::mcp_get_info_by_col_id_and_type_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_info_by_col_id_and_type_id_result_params::mcp_get_info_by_col_id_and_type_id_result_params(const mcp_get_info_by_col_id_and_type_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_info_by_col_id_and_type_id_result_params::~mcp_get_info_by_col_id_and_type_id_result_params(){
}
inline mcp_get_info_by_col_id_and_type_id_result_params& mcp_get_info_by_col_id_and_type_id_result_params::operator=(const mcp_get_info_by_col_id_and_type_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_info_by_col_id_and_type_id_result_params::clear(){
// _m_count=0;
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_info_by_col_id_and_type_id_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string info_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_info_by_col_id_and_type_id_result_params::detach(){
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_info_by_col_id_and_type_id_result_params& mcp_get_info_by_col_id_and_type_id_result_params::assign(const mcp_get_info_by_col_id_and_type_id_result_params& v){
_m_count=v._m_count;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_info_by_col_id_and_type_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_info_by_col_id_and_type_id_result_params::count() const{
return _m_count;
}
inline mcp_get_info_by_col_id_and_type_id_result_params& mcp_get_info_by_col_id_and_type_id_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_info_by_col_id_and_type_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_info_by_col_id_and_type_id_result_params::has_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_info_by_col_id_and_type_id_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_info_by_col_id_and_type_id_result_params::clear_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_info_by_col_id_and_type_id_result_params::mutable_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_info_by_col_id_and_type_id_result_params::m_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_info_by_col_id_and_type_id_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const char* mcp_get_info_by_col_id_and_type_id_result_params::info_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_info_list.get(i0).get(i1).get(size);
}
inline mcp_get_info_by_col_id_and_type_id_result_params& mcp_get_info_by_col_id_and_type_id_result_params::set_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_info_by_col_id_and_type_id_result_params& mcp_get_info_by_col_id_and_type_id_result_params::set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_info_by_col_id_and_type_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_info_by_col_id_and_type_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_info_by_col_id_and_type_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_info_by_col_id_and_type_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_info_by_col_id_and_type_id_response* mcp_get_info_by_col_id_and_type_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_info_by_col_id_and_type_id_response* tmp=(mcp_get_info_by_col_id_and_type_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_info_by_col_id_and_type_id_response(pool);
return tmp;
}
inline void mcp_get_info_by_col_id_and_type_id_response::destroy(mcp_get_info_by_col_id_and_type_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_info_by_col_id_and_type_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_info_by_col_id_and_type_id_response::mcp_get_info_by_col_id_and_type_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_info_by_col_id_and_type_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_info_by_col_id_and_type_id_response::mcp_get_info_by_col_id_and_type_id_response(const mcp_get_info_by_col_id_and_type_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_info_by_col_id_and_type_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_info_by_col_id_and_type_id_response::~mcp_get_info_by_col_id_and_type_id_response(){
if(_m_result_params){
::idl::mcp_get_info_by_col_id_and_type_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_info_by_col_id_and_type_id_response& mcp_get_info_by_col_id_and_type_id_response::operator=(const mcp_get_info_by_col_id_and_type_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_info_by_col_id_and_type_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_info_by_col_id_and_type_id_response::check() const{
// @@mcp_get_info_by_col_id_and_type_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_info_by_col_id_and_type_id_result_params& item=const_cast< ::idl::mcp_get_info_by_col_id_and_type_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_info_by_col_id_and_type_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_info_by_col_id_and_type_id_response& mcp_get_info_by_col_id_and_type_id_response::assign(const mcp_get_info_by_col_id_and_type_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_info_by_col_id_and_type_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_info_by_col_id_and_type_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_info_by_col_id_and_type_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_info_by_col_id_and_type_id_result_params& mcp_get_info_by_col_id_and_type_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_info_by_col_id_and_type_id_result_params* mcp_get_info_by_col_id_and_type_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_info_by_col_id_and_type_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_info_by_col_id_and_type_id_result_params* mcp_get_info_by_col_id_and_type_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_info_by_col_id_and_type_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_info_by_col_id_and_type_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_info_by_col_id_and_type_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_info_by_col_id_and_type_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_info_by_col_id_and_type_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_info_by_col_id_and_type_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_info_by_col_id_params* mcp_get_info_by_col_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_info_by_col_id_params* tmp=(mcp_get_info_by_col_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_info_by_col_id_params(pool);
return tmp;
}
inline void mcp_get_info_by_col_id_params::destroy(mcp_get_info_by_col_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_info_by_col_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_info_by_col_id_params::mcp_get_info_by_col_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_col_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_info_by_col_id_params::mcp_get_info_by_col_id_params(const mcp_get_info_by_col_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_col_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_info_by_col_id_params::~mcp_get_info_by_col_id_params(){
}
inline mcp_get_info_by_col_id_params& mcp_get_info_by_col_id_params::operator=(const mcp_get_info_by_col_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_info_by_col_id_params::clear(){
_m_col_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_info_by_col_id_params::check() const{
// @@string col_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_col_id.get();

}
// @@uint32_t page=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_info_by_col_id_params::detach(){
_m_col_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_info_by_col_id_params& mcp_get_info_by_col_id_params::assign(const mcp_get_info_by_col_id_params& v){
_m_col_id=v._m_col_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_info_by_col_id_params::has_col_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_info_by_col_id_params::col_id(unsigned int* size) const{
return _m_col_id.get(size);
}
inline mcp_get_info_by_col_id_params& mcp_get_info_by_col_id_params::set_col_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_col_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_info_by_col_id_params& mcp_get_info_by_col_id_params::set_ptr_col_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_col_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_info_by_col_id_params::clear_col_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_col_id.clear();
}
inline bool mcp_get_info_by_col_id_params::has_page() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_info_by_col_id_params::page() const{
return _m_page;
}
inline mcp_get_info_by_col_id_params& mcp_get_info_by_col_id_params::set_page(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_info_by_col_id_params::clear_page(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page=0;
}
inline bool mcp_get_info_by_col_id_params::has_page_size() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_info_by_col_id_params::page_size() const{
return _m_page_size;
}
inline mcp_get_info_by_col_id_params& mcp_get_info_by_col_id_params::set_page_size(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_info_by_col_id_params::clear_page_size(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_info_by_col_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_info_by_col_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_info_by_col_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_info_by_col_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_info_by_col_id_result_params* mcp_get_info_by_col_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_info_by_col_id_result_params* tmp=(mcp_get_info_by_col_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_info_by_col_id_result_params(pool);
return tmp;
}
inline void mcp_get_info_by_col_id_result_params::destroy(mcp_get_info_by_col_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_info_by_col_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_info_by_col_id_result_params::mcp_get_info_by_col_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_col_name(_pool)
,_m_type_id(_pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_info_by_col_id_result_params::mcp_get_info_by_col_id_result_params(const mcp_get_info_by_col_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_col_name(_pool)
,_m_type_id(_pool)
,_m_count(0)
,_m_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_info_by_col_id_result_params::~mcp_get_info_by_col_id_result_params(){
}
inline mcp_get_info_by_col_id_result_params& mcp_get_info_by_col_id_result_params::operator=(const mcp_get_info_by_col_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_info_by_col_id_result_params::clear(){
_m_col_name.clear();
_m_type_id.clear();
// _m_count=0;
_m_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_info_by_col_id_result_params::check() const{
// @@string col_name=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "col_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_col_name.get();

}
// @@string type_id=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@uint32_t count=out();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string info_list=out(),array(0,0);
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_info_list)& lr0=(_m_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_info_by_col_id_result_params::detach(){
_m_col_name.detach();
_m_type_id.detach();
_m_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_info_by_col_id_result_params& mcp_get_info_by_col_id_result_params::assign(const mcp_get_info_by_col_id_result_params& v){
_m_col_name=v._m_col_name;
_m_type_id=v._m_type_id;
_m_count=v._m_count;
_m_info_list=v._m_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_info_by_col_id_result_params::has_col_name() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_info_by_col_id_result_params::col_name(unsigned int* size) const{
return _m_col_name.get(size);
}
inline mcp_get_info_by_col_id_result_params& mcp_get_info_by_col_id_result_params::set_col_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_col_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_info_by_col_id_result_params& mcp_get_info_by_col_id_result_params::set_ptr_col_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_col_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_info_by_col_id_result_params::clear_col_name(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_col_name.clear();
}
inline bool mcp_get_info_by_col_id_result_params::has_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_info_by_col_id_result_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_info_by_col_id_result_params& mcp_get_info_by_col_id_result_params::set_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_info_by_col_id_result_params& mcp_get_info_by_col_id_result_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_info_by_col_id_result_params::clear_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_info_by_col_id_result_params::has_count() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_info_by_col_id_result_params::count() const{
return _m_count;
}
inline mcp_get_info_by_col_id_result_params& mcp_get_info_by_col_id_result_params::set_count(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_info_by_col_id_result_params::clear_count(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_count=0;
}
inline bool mcp_get_info_by_col_id_result_params::has_info_list() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_info_by_col_id_result_params::info_list() const{
 return _m_info_list;
}
inline void mcp_get_info_by_col_id_result_params::clear_info_list(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_info_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_info_by_col_id_result_params::mutable_info_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_info_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_info_by_col_id_result_params::m_info_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_info_list);
}
inline size_t mcp_get_info_by_col_id_result_params::info_list_size() const{
/*  */ return _m_info_list.size();
}
inline const char* mcp_get_info_by_col_id_result_params::info_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_info_list.get(i0).get(i1).get(size);
}
inline mcp_get_info_by_col_id_result_params& mcp_get_info_by_col_id_result_params::set_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_info_by_col_id_result_params& mcp_get_info_by_col_id_result_params::set_ptr_info_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_info_by_col_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_info_by_col_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_info_by_col_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_info_by_col_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_info_by_col_id_response* mcp_get_info_by_col_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_info_by_col_id_response* tmp=(mcp_get_info_by_col_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_info_by_col_id_response(pool);
return tmp;
}
inline void mcp_get_info_by_col_id_response::destroy(mcp_get_info_by_col_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_info_by_col_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_info_by_col_id_response::mcp_get_info_by_col_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_info_by_col_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_info_by_col_id_response::mcp_get_info_by_col_id_response(const mcp_get_info_by_col_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_info_by_col_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_info_by_col_id_response::~mcp_get_info_by_col_id_response(){
if(_m_result_params){
::idl::mcp_get_info_by_col_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_info_by_col_id_response& mcp_get_info_by_col_id_response::operator=(const mcp_get_info_by_col_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_info_by_col_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_info_by_col_id_response::check() const{
// @@mcp_get_info_by_col_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_info_by_col_id_result_params& item=const_cast< ::idl::mcp_get_info_by_col_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_info_by_col_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_info_by_col_id_response& mcp_get_info_by_col_id_response::assign(const mcp_get_info_by_col_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_info_by_col_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_info_by_col_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_info_by_col_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_info_by_col_id_result_params& mcp_get_info_by_col_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_info_by_col_id_result_params* mcp_get_info_by_col_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_info_by_col_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_info_by_col_id_result_params* mcp_get_info_by_col_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_info_by_col_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_info_by_col_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_info_by_col_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_info_by_col_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_info_by_col_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_info_by_col_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_soft_by_date_or_star_params* mcp_get_soft_by_date_or_star_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_soft_by_date_or_star_params* tmp=(mcp_get_soft_by_date_or_star_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_soft_by_date_or_star_params(pool);
return tmp;
}
inline void mcp_get_soft_by_date_or_star_params::destroy(mcp_get_soft_by_date_or_star_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_soft_by_date_or_star_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_soft_by_date_or_star_params::mcp_get_soft_by_date_or_star_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_page(0)
,_m_page_size(0)
,_m_orderby(0)
,_m_for_adapt(0)
,_m_except_class_ids(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_soft_by_date_or_star_params::mcp_get_soft_by_date_or_star_params(const mcp_get_soft_by_date_or_star_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_page(0)
,_m_page_size(0)
,_m_orderby(0)
,_m_for_adapt(0)
,_m_except_class_ids(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_soft_by_date_or_star_params::~mcp_get_soft_by_date_or_star_params(){
}
inline mcp_get_soft_by_date_or_star_params& mcp_get_soft_by_date_or_star_params::operator=(const mcp_get_soft_by_date_or_star_params& v){
assign(v);
return *this;
}
inline void mcp_get_soft_by_date_or_star_params::clear(){
// _m_page=0;
// _m_page_size=0;
// _m_orderby=0;
// _m_for_adapt=0;
_m_except_class_ids.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_soft_by_date_or_star_params::check() const{
// @@uint32_t page=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}
// @@uint32_t orderby=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "orderby" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_orderby;

}
// @@uint32_t for_adapt=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "for_adapt" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_for_adapt;

}
// @@string except_class_ids=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "except_class_ids" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_except_class_ids.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_soft_by_date_or_star_params::detach(){
_m_except_class_ids.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_soft_by_date_or_star_params& mcp_get_soft_by_date_or_star_params::assign(const mcp_get_soft_by_date_or_star_params& v){
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_m_orderby=v._m_orderby;
_m_for_adapt=v._m_for_adapt;
_m_except_class_ids=v._m_except_class_ids;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_soft_by_date_or_star_params::has_page() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_soft_by_date_or_star_params::page() const{
return _m_page;
}
inline mcp_get_soft_by_date_or_star_params& mcp_get_soft_by_date_or_star_params::set_page(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_soft_by_date_or_star_params::clear_page(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_page=0;
}
inline bool mcp_get_soft_by_date_or_star_params::has_page_size() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_soft_by_date_or_star_params::page_size() const{
return _m_page_size;
}
inline mcp_get_soft_by_date_or_star_params& mcp_get_soft_by_date_or_star_params::set_page_size(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_soft_by_date_or_star_params::clear_page_size(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page_size=0;
}
inline bool mcp_get_soft_by_date_or_star_params::has_orderby() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_soft_by_date_or_star_params::orderby() const{
return _m_orderby;
}
inline mcp_get_soft_by_date_or_star_params& mcp_get_soft_by_date_or_star_params::set_orderby(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_orderby=v;
return *this;
}
inline void mcp_get_soft_by_date_or_star_params::clear_orderby(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_orderby=0;
}
inline bool mcp_get_soft_by_date_or_star_params::has_for_adapt() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_soft_by_date_or_star_params::for_adapt() const{
return _m_for_adapt;
}
inline mcp_get_soft_by_date_or_star_params& mcp_get_soft_by_date_or_star_params::set_for_adapt(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_for_adapt=v;
return *this;
}
inline void mcp_get_soft_by_date_or_star_params::clear_for_adapt(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_for_adapt=0;
}
inline bool mcp_get_soft_by_date_or_star_params::has_except_class_ids() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_get_soft_by_date_or_star_params::except_class_ids(unsigned int* size) const{
return _m_except_class_ids.get(size);
}
inline mcp_get_soft_by_date_or_star_params& mcp_get_soft_by_date_or_star_params::set_except_class_ids(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_except_class_ids.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_soft_by_date_or_star_params& mcp_get_soft_by_date_or_star_params::set_ptr_except_class_ids(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_except_class_ids.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_soft_by_date_or_star_params::clear_except_class_ids(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_except_class_ids.clear();
}
inline ::idl::Unknown* mcp_get_soft_by_date_or_star_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_soft_by_date_or_star_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_soft_by_date_or_star_params::unknown(){
return _unknown;
}
inline size_t mcp_get_soft_by_date_or_star_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_soft_by_date_or_star_result_params* mcp_get_soft_by_date_or_star_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_soft_by_date_or_star_result_params* tmp=(mcp_get_soft_by_date_or_star_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_soft_by_date_or_star_result_params(pool);
return tmp;
}
inline void mcp_get_soft_by_date_or_star_result_params::destroy(mcp_get_soft_by_date_or_star_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_soft_by_date_or_star_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_soft_by_date_or_star_result_params::mcp_get_soft_by_date_or_star_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_soft_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_soft_by_date_or_star_result_params::mcp_get_soft_by_date_or_star_result_params(const mcp_get_soft_by_date_or_star_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_soft_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_soft_by_date_or_star_result_params::~mcp_get_soft_by_date_or_star_result_params(){
}
inline mcp_get_soft_by_date_or_star_result_params& mcp_get_soft_by_date_or_star_result_params::operator=(const mcp_get_soft_by_date_or_star_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_soft_by_date_or_star_result_params::clear(){
// _m_count=0;
_m_soft_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_soft_by_date_or_star_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string soft_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "soft_list" << "' not found";
}
{
// level 0 begin
typeof(_m_soft_list)& lr0=(_m_soft_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_soft_by_date_or_star_result_params::detach(){
_m_soft_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_soft_by_date_or_star_result_params& mcp_get_soft_by_date_or_star_result_params::assign(const mcp_get_soft_by_date_or_star_result_params& v){
_m_count=v._m_count;
_m_soft_list=v._m_soft_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_soft_by_date_or_star_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_soft_by_date_or_star_result_params::count() const{
return _m_count;
}
inline mcp_get_soft_by_date_or_star_result_params& mcp_get_soft_by_date_or_star_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_soft_by_date_or_star_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_soft_by_date_or_star_result_params::has_soft_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_soft_by_date_or_star_result_params::soft_list() const{
 return _m_soft_list;
}
inline void mcp_get_soft_by_date_or_star_result_params::clear_soft_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_soft_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_soft_by_date_or_star_result_params::mutable_soft_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_soft_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_soft_by_date_or_star_result_params::m_soft_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_soft_list);
}
inline size_t mcp_get_soft_by_date_or_star_result_params::soft_list_size() const{
/*  */ return _m_soft_list.size();
}
inline const char* mcp_get_soft_by_date_or_star_result_params::soft_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_soft_list.get(i0).get(i1).get(size);
}
inline mcp_get_soft_by_date_or_star_result_params& mcp_get_soft_by_date_or_star_result_params::set_soft_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_soft_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_soft_by_date_or_star_result_params& mcp_get_soft_by_date_or_star_result_params::set_ptr_soft_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_soft_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_soft_by_date_or_star_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_soft_by_date_or_star_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_soft_by_date_or_star_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_soft_by_date_or_star_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_soft_by_date_or_star_response* mcp_get_soft_by_date_or_star_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_soft_by_date_or_star_response* tmp=(mcp_get_soft_by_date_or_star_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_soft_by_date_or_star_response(pool);
return tmp;
}
inline void mcp_get_soft_by_date_or_star_response::destroy(mcp_get_soft_by_date_or_star_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_soft_by_date_or_star_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_soft_by_date_or_star_response::mcp_get_soft_by_date_or_star_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_soft_by_date_or_star_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_soft_by_date_or_star_response::mcp_get_soft_by_date_or_star_response(const mcp_get_soft_by_date_or_star_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_soft_by_date_or_star_result_params::create(_pool);
assign(v);
}
inline mcp_get_soft_by_date_or_star_response::~mcp_get_soft_by_date_or_star_response(){
if(_m_result_params){
::idl::mcp_get_soft_by_date_or_star_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_soft_by_date_or_star_response& mcp_get_soft_by_date_or_star_response::operator=(const mcp_get_soft_by_date_or_star_response& v){
assign(v);
return *this;
}
inline void mcp_get_soft_by_date_or_star_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_soft_by_date_or_star_response::check() const{
// @@mcp_get_soft_by_date_or_star_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_soft_by_date_or_star_result_params& item=const_cast< ::idl::mcp_get_soft_by_date_or_star_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_soft_by_date_or_star_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_soft_by_date_or_star_response& mcp_get_soft_by_date_or_star_response::assign(const mcp_get_soft_by_date_or_star_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_soft_by_date_or_star_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_soft_by_date_or_star_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_soft_by_date_or_star_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_soft_by_date_or_star_result_params& mcp_get_soft_by_date_or_star_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_soft_by_date_or_star_result_params* mcp_get_soft_by_date_or_star_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_soft_by_date_or_star_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_soft_by_date_or_star_result_params* mcp_get_soft_by_date_or_star_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_soft_by_date_or_star_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_soft_by_date_or_star_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_soft_by_date_or_star_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_soft_by_date_or_star_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_soft_by_date_or_star_response::unknown(){
return _unknown;
}
inline size_t mcp_get_soft_by_date_or_star_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_star_by_cid_and_type_params* mcp_get_star_by_cid_and_type_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_star_by_cid_and_type_params* tmp=(mcp_get_star_by_cid_and_type_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_star_by_cid_and_type_params(pool);
return tmp;
}
inline void mcp_get_star_by_cid_and_type_params::destroy(mcp_get_star_by_cid_and_type_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_star_by_cid_and_type_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_star_by_cid_and_type_params::mcp_get_star_by_cid_and_type_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_c_id(_pool)
,_m_type_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_star_by_cid_and_type_params::mcp_get_star_by_cid_and_type_params(const mcp_get_star_by_cid_and_type_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_c_id(_pool)
,_m_type_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_star_by_cid_and_type_params::~mcp_get_star_by_cid_and_type_params(){
}
inline mcp_get_star_by_cid_and_type_params& mcp_get_star_by_cid_and_type_params::operator=(const mcp_get_star_by_cid_and_type_params& v){
assign(v);
return *this;
}
inline void mcp_get_star_by_cid_and_type_params::clear(){
_m_c_id.clear();
_m_type_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_star_by_cid_and_type_params::check() const{
// @@string c_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_star_by_cid_and_type_params::detach(){
_m_c_id.detach();
_m_type_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_star_by_cid_and_type_params& mcp_get_star_by_cid_and_type_params::assign(const mcp_get_star_by_cid_and_type_params& v){
_m_c_id=v._m_c_id;
_m_type_id=v._m_type_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_star_by_cid_and_type_params::has_c_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_star_by_cid_and_type_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_get_star_by_cid_and_type_params& mcp_get_star_by_cid_and_type_params::set_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_star_by_cid_and_type_params& mcp_get_star_by_cid_and_type_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_star_by_cid_and_type_params::clear_c_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_c_id.clear();
}
inline bool mcp_get_star_by_cid_and_type_params::has_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_star_by_cid_and_type_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_star_by_cid_and_type_params& mcp_get_star_by_cid_and_type_params::set_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_star_by_cid_and_type_params& mcp_get_star_by_cid_and_type_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_star_by_cid_and_type_params::clear_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_type_id.clear();
}
inline ::idl::Unknown* mcp_get_star_by_cid_and_type_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_star_by_cid_and_type_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_star_by_cid_and_type_params::unknown(){
return _unknown;
}
inline size_t mcp_get_star_by_cid_and_type_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_star_by_cid_and_type_result_params* mcp_get_star_by_cid_and_type_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_star_by_cid_and_type_result_params* tmp=(mcp_get_star_by_cid_and_type_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_star_by_cid_and_type_result_params(pool);
return tmp;
}
inline void mcp_get_star_by_cid_and_type_result_params::destroy(mcp_get_star_by_cid_and_type_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_star_by_cid_and_type_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_star_by_cid_and_type_result_params::mcp_get_star_by_cid_and_type_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_star(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_star_by_cid_and_type_result_params::mcp_get_star_by_cid_and_type_result_params(const mcp_get_star_by_cid_and_type_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_star(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_star_by_cid_and_type_result_params::~mcp_get_star_by_cid_and_type_result_params(){
}
inline mcp_get_star_by_cid_and_type_result_params& mcp_get_star_by_cid_and_type_result_params::operator=(const mcp_get_star_by_cid_and_type_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_star_by_cid_and_type_result_params::clear(){
// _m_star=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_star_by_cid_and_type_result_params::check() const{
// @@uint32_t star=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "star" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_star;

}

::idl::McpackBean::check();
}
inline void mcp_get_star_by_cid_and_type_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_star_by_cid_and_type_result_params& mcp_get_star_by_cid_and_type_result_params::assign(const mcp_get_star_by_cid_and_type_result_params& v){
_m_star=v._m_star;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_star_by_cid_and_type_result_params::has_star() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_star_by_cid_and_type_result_params::star() const{
return _m_star;
}
inline mcp_get_star_by_cid_and_type_result_params& mcp_get_star_by_cid_and_type_result_params::set_star(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_star=v;
return *this;
}
inline void mcp_get_star_by_cid_and_type_result_params::clear_star(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_star=0;
}
inline ::idl::Unknown* mcp_get_star_by_cid_and_type_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_star_by_cid_and_type_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_star_by_cid_and_type_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_star_by_cid_and_type_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_star_by_cid_and_type_response* mcp_get_star_by_cid_and_type_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_star_by_cid_and_type_response* tmp=(mcp_get_star_by_cid_and_type_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_star_by_cid_and_type_response(pool);
return tmp;
}
inline void mcp_get_star_by_cid_and_type_response::destroy(mcp_get_star_by_cid_and_type_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_star_by_cid_and_type_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_star_by_cid_and_type_response::mcp_get_star_by_cid_and_type_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_star_by_cid_and_type_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_star_by_cid_and_type_response::mcp_get_star_by_cid_and_type_response(const mcp_get_star_by_cid_and_type_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_star_by_cid_and_type_result_params::create(_pool);
assign(v);
}
inline mcp_get_star_by_cid_and_type_response::~mcp_get_star_by_cid_and_type_response(){
if(_m_result_params){
::idl::mcp_get_star_by_cid_and_type_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_star_by_cid_and_type_response& mcp_get_star_by_cid_and_type_response::operator=(const mcp_get_star_by_cid_and_type_response& v){
assign(v);
return *this;
}
inline void mcp_get_star_by_cid_and_type_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_star_by_cid_and_type_response::check() const{
// @@mcp_get_star_by_cid_and_type_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_star_by_cid_and_type_result_params& item=const_cast< ::idl::mcp_get_star_by_cid_and_type_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_star_by_cid_and_type_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_star_by_cid_and_type_response& mcp_get_star_by_cid_and_type_response::assign(const mcp_get_star_by_cid_and_type_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_star_by_cid_and_type_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_star_by_cid_and_type_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_star_by_cid_and_type_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_star_by_cid_and_type_result_params& mcp_get_star_by_cid_and_type_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_star_by_cid_and_type_result_params* mcp_get_star_by_cid_and_type_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_star_by_cid_and_type_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_star_by_cid_and_type_result_params* mcp_get_star_by_cid_and_type_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_star_by_cid_and_type_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_star_by_cid_and_type_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_star_by_cid_and_type_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_star_by_cid_and_type_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_star_by_cid_and_type_response::unknown(){
return _unknown;
}
inline size_t mcp_get_star_by_cid_and_type_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_classID_with_weight_params* mcp_get_content_list_from_classID_with_weight_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_classID_with_weight_params* tmp=(mcp_get_content_list_from_classID_with_weight_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_classID_with_weight_params(pool);
return tmp;
}
inline void mcp_get_content_list_from_classID_with_weight_params::destroy(mcp_get_content_list_from_classID_with_weight_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_classID_with_weight_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_classID_with_weight_params::mcp_get_content_list_from_classID_with_weight_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_class_id(_pool)
,_m_content_type_id(_pool)
,_m_priority(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_img_size(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_for_adapt(0)
,_m_weight_type(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_classID_with_weight_params::mcp_get_content_list_from_classID_with_weight_params(const mcp_get_content_list_from_classID_with_weight_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_class_id(_pool)
,_m_content_type_id(_pool)
,_m_priority(0)
,_m_info_id(_pool)
,_m_info_type(0)
,_m_img_size(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_m_for_adapt(0)
,_m_weight_type(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_from_classID_with_weight_params::~mcp_get_content_list_from_classID_with_weight_params(){
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::operator=(const mcp_get_content_list_from_classID_with_weight_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_params::clear(){
_m_class_id.clear();
_m_content_type_id.clear();
// _m_priority=0;
_m_info_id.clear();
// _m_info_type=0;
_m_img_size.clear();
// _m_unit_num=0;
// _m_unit_times=0;
// _m_for_adapt=0;
// _m_weight_type=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_classID_with_weight_params::check() const{
// @@string class_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}
// @@string content_type_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_content_type_id.get();

}
// @@uint32_t priority=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "priority" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_priority;

}
// @@string info_id=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@uint32_t info_type=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_info_type;

}
// @@string img_size=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "img_size" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_img_size.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}
// @@uint32_t for_adapt=in();
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "for_adapt" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_for_adapt;

}
// @@int32_t weight_type=in();
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "weight_type" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_weight_type;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_classID_with_weight_params::detach(){
_m_class_id.detach();
_m_content_type_id.detach();
_m_info_id.detach();
_m_img_size.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::assign(const mcp_get_content_list_from_classID_with_weight_params& v){
_m_class_id=v._m_class_id;
_m_content_type_id=v._m_content_type_id;
_m_priority=v._m_priority;
_m_info_id=v._m_info_id;
_m_info_type=v._m_info_type;
_m_img_size=v._m_img_size;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_m_for_adapt=v._m_for_adapt;
_m_weight_type=v._m_weight_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_classID_with_weight_params::has_class_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_content_list_from_classID_with_weight_params::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_ptr_class_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_params::clear_class_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_class_id.clear();
}
inline bool mcp_get_content_list_from_classID_with_weight_params::has_content_type_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_content_list_from_classID_with_weight_params::content_type_id(unsigned int* size) const{
return _m_content_type_id.get(size);
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_content_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_ptr_content_type_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_params::clear_content_type_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_type_id.clear();
}
inline bool mcp_get_content_list_from_classID_with_weight_params::has_priority() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_classID_with_weight_params::priority() const{
return _m_priority;
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_priority(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_priority=v;
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_params::clear_priority(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_priority=0;
}
inline bool mcp_get_content_list_from_classID_with_weight_params::has_info_id() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_content_list_from_classID_with_weight_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_info_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_params::clear_info_id(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_content_list_from_classID_with_weight_params::has_info_type() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_classID_with_weight_params::info_type() const{
return _m_info_type;
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_info_type(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_info_type=v;
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_params::clear_info_type(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_info_type=0;
}
inline bool mcp_get_content_list_from_classID_with_weight_params::has_img_size() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* mcp_get_content_list_from_classID_with_weight_params::img_size(unsigned int* size) const{
return _m_img_size.get(size);
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_img_size(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_img_size.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_ptr_img_size(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_img_size.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_params::clear_img_size(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_img_size.clear();
}
inline bool mcp_get_content_list_from_classID_with_weight_params::has_unit_num() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_classID_with_weight_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_unit_num(uint32_t v){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_params::clear_unit_num(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_content_list_from_classID_with_weight_params::has_unit_times() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_classID_with_weight_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_unit_times(uint32_t v){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_params::clear_unit_times(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_unit_times=0;
}
inline bool mcp_get_content_list_from_classID_with_weight_params::has_for_adapt() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_classID_with_weight_params::for_adapt() const{
return _m_for_adapt;
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_for_adapt(uint32_t v){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_for_adapt=v;
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_params::clear_for_adapt(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_for_adapt=0;
}
inline bool mcp_get_content_list_from_classID_with_weight_params::has_weight_type() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline int32_t mcp_get_content_list_from_classID_with_weight_params::weight_type() const{
return _m_weight_type;
}
inline mcp_get_content_list_from_classID_with_weight_params& mcp_get_content_list_from_classID_with_weight_params::set_weight_type(int32_t v){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_weight_type=v;
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_params::clear_weight_type(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_weight_type=0;
}
inline ::idl::Unknown* mcp_get_content_list_from_classID_with_weight_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_classID_with_weight_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_classID_with_weight_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_classID_with_weight_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_classID_with_weight_result_params* mcp_get_content_list_from_classID_with_weight_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_classID_with_weight_result_params* tmp=(mcp_get_content_list_from_classID_with_weight_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_classID_with_weight_result_params(pool);
return tmp;
}
inline void mcp_get_content_list_from_classID_with_weight_result_params::destroy(mcp_get_content_list_from_classID_with_weight_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_classID_with_weight_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_classID_with_weight_result_params::mcp_get_content_list_from_classID_with_weight_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_classID_with_weight_result_params::mcp_get_content_list_from_classID_with_weight_result_params(const mcp_get_content_list_from_classID_with_weight_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_content_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_list_from_classID_with_weight_result_params::~mcp_get_content_list_from_classID_with_weight_result_params(){
}
inline mcp_get_content_list_from_classID_with_weight_result_params& mcp_get_content_list_from_classID_with_weight_result_params::operator=(const mcp_get_content_list_from_classID_with_weight_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_result_params::clear(){
// _m_count=0;
_m_content_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_classID_with_weight_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@string content_list=out(),array(0,0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "content_list" << "' not found";
}
{
// level 0 begin
typeof(_m_content_list)& lr0=(_m_content_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
// level 1 begin
typeof(lr0.get(i0)) lr1=lr0.get(i0);
__attribute__((unused)) size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
__attribute__((unused)) const char* item=lr1.GetWithoutCheck(i1).get();

}

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_classID_with_weight_result_params::detach(){
_m_content_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_classID_with_weight_result_params& mcp_get_content_list_from_classID_with_weight_result_params::assign(const mcp_get_content_list_from_classID_with_weight_result_params& v){
_m_count=v._m_count;
_m_content_list=v._m_content_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_classID_with_weight_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_content_list_from_classID_with_weight_result_params::count() const{
return _m_count;
}
inline mcp_get_content_list_from_classID_with_weight_result_params& mcp_get_content_list_from_classID_with_weight_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_content_list_from_classID_with_weight_result_params::has_content_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::vector< ::idl::string > >& mcp_get_content_list_from_classID_with_weight_result_params::content_list() const{
 return _m_content_list;
}
inline void mcp_get_content_list_from_classID_with_weight_result_params::clear_content_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_content_list.clear();
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_from_classID_with_weight_result_params::mutable_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline ::idl::vector< ::idl::vector< ::idl::string > >* mcp_get_content_list_from_classID_with_weight_result_params::m_content_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_content_list);
}
inline size_t mcp_get_content_list_from_classID_with_weight_result_params::content_list_size() const{
/*  */ return _m_content_list.size();
}
inline const char* mcp_get_content_list_from_classID_with_weight_result_params::content_list(size_t i0,size_t i1,unsigned int* size) const{
 return _m_content_list.get(i0).get(i1).get(size);
}
inline mcp_get_content_list_from_classID_with_weight_result_params& mcp_get_content_list_from_classID_with_weight_result_params::set_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set(s,(size==-1)?strlen(s):size);
return *this;
}
inline mcp_get_content_list_from_classID_with_weight_result_params& mcp_get_content_list_from_classID_with_weight_result_params::set_ptr_content_list(size_t i0,size_t i1,const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_content_list.mutable_get(i0)->mutable_get(i1)->set_ptr(s,(size==-1)?strlen(s):size);
return *this;
}
inline ::idl::Unknown* mcp_get_content_list_from_classID_with_weight_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_classID_with_weight_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_classID_with_weight_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_classID_with_weight_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_list_from_classID_with_weight_response* mcp_get_content_list_from_classID_with_weight_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_list_from_classID_with_weight_response* tmp=(mcp_get_content_list_from_classID_with_weight_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_list_from_classID_with_weight_response(pool);
return tmp;
}
inline void mcp_get_content_list_from_classID_with_weight_response::destroy(mcp_get_content_list_from_classID_with_weight_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_list_from_classID_with_weight_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_list_from_classID_with_weight_response::mcp_get_content_list_from_classID_with_weight_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_from_classID_with_weight_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_list_from_classID_with_weight_response::mcp_get_content_list_from_classID_with_weight_response(const mcp_get_content_list_from_classID_with_weight_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_list_from_classID_with_weight_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_list_from_classID_with_weight_response::~mcp_get_content_list_from_classID_with_weight_response(){
if(_m_result_params){
::idl::mcp_get_content_list_from_classID_with_weight_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_list_from_classID_with_weight_response& mcp_get_content_list_from_classID_with_weight_response::operator=(const mcp_get_content_list_from_classID_with_weight_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_list_from_classID_with_weight_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_list_from_classID_with_weight_response::check() const{
// @@mcp_get_content_list_from_classID_with_weight_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_list_from_classID_with_weight_result_params& item=const_cast< ::idl::mcp_get_content_list_from_classID_with_weight_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_list_from_classID_with_weight_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_list_from_classID_with_weight_response& mcp_get_content_list_from_classID_with_weight_response::assign(const mcp_get_content_list_from_classID_with_weight_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_list_from_classID_with_weight_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_classID_with_weight_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_list_from_classID_with_weight_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_list_from_classID_with_weight_result_params& mcp_get_content_list_from_classID_with_weight_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_list_from_classID_with_weight_result_params* mcp_get_content_list_from_classID_with_weight_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_classID_with_weight_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_list_from_classID_with_weight_result_params* mcp_get_content_list_from_classID_with_weight_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_list_from_classID_with_weight_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_list_from_classID_with_weight_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_list_from_classID_with_weight_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_list_from_classID_with_weight_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_list_from_classID_with_weight_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_list_from_classID_with_weight_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_with_download_info_params* mcp_get_content_with_download_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_with_download_info_params* tmp=(mcp_get_content_with_download_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_with_download_info_params(pool);
return tmp;
}
inline void mcp_get_content_with_download_info_params::destroy(mcp_get_content_with_download_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_with_download_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_with_download_info_params::mcp_get_content_with_download_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_in_param(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
_m_in_param=::idl::mcp_content_in_param::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_with_download_info_params::mcp_get_content_with_download_info_params(const mcp_get_content_with_download_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_in_param(0)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
_m_in_param=::idl::mcp_content_in_param::create(_pool);
assign(v);
}
inline mcp_get_content_with_download_info_params::~mcp_get_content_with_download_info_params(){
if(_m_in_param){
::idl::mcp_content_in_param::destroy(_m_in_param);
_m_in_param=0;
}
}
inline mcp_get_content_with_download_info_params& mcp_get_content_with_download_info_params::operator=(const mcp_get_content_with_download_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_with_download_info_params::clear(){
if(_m_in_param){
_m_in_param->clear();
}
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_with_download_info_params::check() const{
// @@mcp_content_in_param in_param=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "in_param" << "' not found";
}
{
::idl::mcp_content_in_param& item=const_cast< ::idl::mcp_content_in_param& >(*_m_in_param);
item.check();

}
// @@uint32_t unit_num=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_content_with_download_info_params::detach(){
if(_m_in_param){
_m_in_param->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_with_download_info_params& mcp_get_content_with_download_info_params::assign(const mcp_get_content_with_download_info_params& v){
if(!v._m_in_param){
if(_m_in_param){
::idl::mcp_content_in_param::destroy(_m_in_param);
}
_m_in_param=0;
}else{
if(!_m_in_param){
_m_in_param=::idl::mcp_content_in_param::create(_pool);
}
*_m_in_param=*v._m_in_param;
}
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_with_download_info_params::has_in_param() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_content_in_param& mcp_get_content_with_download_info_params::in_param() const{
 return *_m_in_param;
}
inline ::idl::mcp_content_in_param* mcp_get_content_with_download_info_params::mutable_in_param(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_in_param){
_m_in_param=::idl::mcp_content_in_param::create(_pool);
}
return _m_in_param;
}
inline ::idl::mcp_content_in_param* mcp_get_content_with_download_info_params::m_in_param(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_in_param){
_m_in_param=::idl::mcp_content_in_param::create(_pool);
}
return _m_in_param;
}
inline void mcp_get_content_with_download_info_params::clear_in_param(){
if(_m_in_param){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_in_param->clear();
}
}
inline bool mcp_get_content_with_download_info_params::has_unit_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_content_with_download_info_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_content_with_download_info_params& mcp_get_content_with_download_info_params::set_unit_num(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_content_with_download_info_params::clear_unit_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_content_with_download_info_params::has_unit_times() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_content_with_download_info_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_content_with_download_info_params& mcp_get_content_with_download_info_params::set_unit_times(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_content_with_download_info_params::clear_unit_times(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_content_with_download_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_with_download_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_with_download_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_with_download_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_with_download_info_result_params* mcp_get_content_with_download_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_with_download_info_result_params* tmp=(mcp_get_content_with_download_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_with_download_info_result_params(pool);
return tmp;
}
inline void mcp_get_content_with_download_info_result_params::destroy(mcp_get_content_with_download_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_with_download_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_with_download_info_result_params::mcp_get_content_with_download_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_with_download_info_result_params::mcp_get_content_with_download_info_result_params(const mcp_get_content_with_download_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_content_with_download_info_result_params::~mcp_get_content_with_download_info_result_params(){
}
inline mcp_get_content_with_download_info_result_params& mcp_get_content_with_download_info_result_params::operator=(const mcp_get_content_with_download_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_content_with_download_info_result_params::clear(){
// _m_count=0;
_m_result_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_with_download_info_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@content_detail_t result_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_list" << "' not found";
}
{
// level 0 begin
typeof(_m_result_list)& lr0=(_m_result_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::content_detail_t& item=const_cast< ::idl::content_detail_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_content_with_download_info_result_params::detach(){
_m_result_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_with_download_info_result_params& mcp_get_content_with_download_info_result_params::assign(const mcp_get_content_with_download_info_result_params& v){
_m_count=v._m_count;
_m_result_list=v._m_result_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_with_download_info_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_content_with_download_info_result_params::count() const{
return _m_count;
}
inline mcp_get_content_with_download_info_result_params& mcp_get_content_with_download_info_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_content_with_download_info_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_content_with_download_info_result_params::has_result_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::content_detail_t >& mcp_get_content_with_download_info_result_params::result_list() const{
 return _m_result_list;
}
inline void mcp_get_content_with_download_info_result_params::clear_result_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_result_list.clear();
}
inline ::idl::vector< ::idl::content_detail_t >* mcp_get_content_with_download_info_result_params::mutable_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline ::idl::vector< ::idl::content_detail_t >* mcp_get_content_with_download_info_result_params::m_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline size_t mcp_get_content_with_download_info_result_params::result_list_size() const{
/*  */ return _m_result_list.size();
}
inline const ::idl::content_detail_t& mcp_get_content_with_download_info_result_params::result_list(size_t i0) const{
 return _m_result_list.get(i0);
}
inline ::idl::content_detail_t* mcp_get_content_with_download_info_result_params::mutable_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::content_detail_t* mcp_get_content_with_download_info_result_params::m_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_content_with_download_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_with_download_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_with_download_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_content_with_download_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_content_with_download_info_response* mcp_get_content_with_download_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_content_with_download_info_response* tmp=(mcp_get_content_with_download_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_content_with_download_info_response(pool);
return tmp;
}
inline void mcp_get_content_with_download_info_response::destroy(mcp_get_content_with_download_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_content_with_download_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_content_with_download_info_response::mcp_get_content_with_download_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_with_download_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_content_with_download_info_response::mcp_get_content_with_download_info_response(const mcp_get_content_with_download_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_content_with_download_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_content_with_download_info_response::~mcp_get_content_with_download_info_response(){
if(_m_result_params){
::idl::mcp_get_content_with_download_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_content_with_download_info_response& mcp_get_content_with_download_info_response::operator=(const mcp_get_content_with_download_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_content_with_download_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_content_with_download_info_response::check() const{
// @@mcp_get_content_with_download_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_content_with_download_info_result_params& item=const_cast< ::idl::mcp_get_content_with_download_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_content_with_download_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_content_with_download_info_response& mcp_get_content_with_download_info_response::assign(const mcp_get_content_with_download_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_content_with_download_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_with_download_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_content_with_download_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_content_with_download_info_result_params& mcp_get_content_with_download_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_content_with_download_info_result_params* mcp_get_content_with_download_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_with_download_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_content_with_download_info_result_params* mcp_get_content_with_download_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_content_with_download_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_content_with_download_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_content_with_download_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_content_with_download_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_content_with_download_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_content_with_download_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_contents_count_params* mcp_get_game_contents_count_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_contents_count_params* tmp=(mcp_get_game_contents_count_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_contents_count_params(pool);
return tmp;
}
inline void mcp_get_game_contents_count_params::destroy(mcp_get_game_contents_count_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_contents_count_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_contents_count_params::mcp_get_game_contents_count_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_type_id(_pool)
,_m_class_id(_pool)
,_m_label_id(_pool)
,_m_column_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_contents_count_params::mcp_get_game_contents_count_params(const mcp_get_game_contents_count_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_type_id(_pool)
,_m_class_id(_pool)
,_m_label_id(_pool)
,_m_column_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_contents_count_params::~mcp_get_game_contents_count_params(){
}
inline mcp_get_game_contents_count_params& mcp_get_game_contents_count_params::operator=(const mcp_get_game_contents_count_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_contents_count_params::clear(){
_m_type_id.clear();
_m_class_id.clear();
_m_label_id.clear();
_m_column_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_contents_count_params::check() const{
// @@string type_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@string class_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "class_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_class_id.get();

}
// @@string label_id=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "label_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_label_id.get();

}
// @@string column_id=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "column_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_column_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_contents_count_params::detach(){
_m_type_id.detach();
_m_class_id.detach();
_m_label_id.detach();
_m_column_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_contents_count_params& mcp_get_game_contents_count_params::assign(const mcp_get_game_contents_count_params& v){
_m_type_id=v._m_type_id;
_m_class_id=v._m_class_id;
_m_label_id=v._m_label_id;
_m_column_id=v._m_column_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_contents_count_params::has_type_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_contents_count_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_game_contents_count_params& mcp_get_game_contents_count_params::set_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_contents_count_params& mcp_get_game_contents_count_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_contents_count_params::clear_type_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_game_contents_count_params::has_class_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_game_contents_count_params::class_id(unsigned int* size) const{
return _m_class_id.get(size);
}
inline mcp_get_game_contents_count_params& mcp_get_game_contents_count_params::set_class_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_class_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_contents_count_params& mcp_get_game_contents_count_params::set_ptr_class_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_class_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_contents_count_params::clear_class_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_class_id.clear();
}
inline bool mcp_get_game_contents_count_params::has_label_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_game_contents_count_params::label_id(unsigned int* size) const{
return _m_label_id.get(size);
}
inline mcp_get_game_contents_count_params& mcp_get_game_contents_count_params::set_label_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_label_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_contents_count_params& mcp_get_game_contents_count_params::set_ptr_label_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_label_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_contents_count_params::clear_label_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_label_id.clear();
}
inline bool mcp_get_game_contents_count_params::has_column_id() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_game_contents_count_params::column_id(unsigned int* size) const{
return _m_column_id.get(size);
}
inline mcp_get_game_contents_count_params& mcp_get_game_contents_count_params::set_column_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_column_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_contents_count_params& mcp_get_game_contents_count_params::set_ptr_column_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_column_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_contents_count_params::clear_column_id(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_column_id.clear();
}
inline ::idl::Unknown* mcp_get_game_contents_count_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_contents_count_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_contents_count_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_contents_count_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_contents_count_result_params* mcp_get_game_contents_count_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_contents_count_result_params* tmp=(mcp_get_game_contents_count_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_contents_count_result_params(pool);
return tmp;
}
inline void mcp_get_game_contents_count_result_params::destroy(mcp_get_game_contents_count_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_contents_count_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_contents_count_result_params::mcp_get_game_contents_count_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_contents_count_result_params::mcp_get_game_contents_count_result_params(const mcp_get_game_contents_count_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_contents_count_result_params::~mcp_get_game_contents_count_result_params(){
}
inline mcp_get_game_contents_count_result_params& mcp_get_game_contents_count_result_params::operator=(const mcp_get_game_contents_count_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_contents_count_result_params::clear(){
// _m_count=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_contents_count_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}

::idl::McpackBean::check();
}
inline void mcp_get_game_contents_count_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_contents_count_result_params& mcp_get_game_contents_count_result_params::assign(const mcp_get_game_contents_count_result_params& v){
_m_count=v._m_count;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_contents_count_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_game_contents_count_result_params::count() const{
return _m_count;
}
inline mcp_get_game_contents_count_result_params& mcp_get_game_contents_count_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_game_contents_count_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline ::idl::Unknown* mcp_get_game_contents_count_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_contents_count_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_contents_count_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_contents_count_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_contents_count_response* mcp_get_game_contents_count_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_contents_count_response* tmp=(mcp_get_game_contents_count_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_contents_count_response(pool);
return tmp;
}
inline void mcp_get_game_contents_count_response::destroy(mcp_get_game_contents_count_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_contents_count_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_contents_count_response::mcp_get_game_contents_count_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_contents_count_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_contents_count_response::mcp_get_game_contents_count_response(const mcp_get_game_contents_count_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_contents_count_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_contents_count_response::~mcp_get_game_contents_count_response(){
if(_m_result_params){
::idl::mcp_get_game_contents_count_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_contents_count_response& mcp_get_game_contents_count_response::operator=(const mcp_get_game_contents_count_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_contents_count_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_contents_count_response::check() const{
// @@mcp_get_game_contents_count_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_contents_count_result_params& item=const_cast< ::idl::mcp_get_game_contents_count_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_contents_count_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_contents_count_response& mcp_get_game_contents_count_response::assign(const mcp_get_game_contents_count_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_contents_count_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_contents_count_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_contents_count_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_contents_count_result_params& mcp_get_game_contents_count_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_contents_count_result_params* mcp_get_game_contents_count_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_contents_count_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_contents_count_result_params* mcp_get_game_contents_count_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_contents_count_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_contents_count_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_contents_count_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_contents_count_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_contents_count_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_contents_count_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_columns_info_params* mcp_get_columns_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_columns_info_params* tmp=(mcp_get_columns_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_columns_info_params(pool);
return tmp;
}
inline void mcp_get_columns_info_params::destroy(mcp_get_columns_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_columns_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_columns_info_params::mcp_get_columns_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_type_id(_pool)
,_m_column_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_columns_info_params::mcp_get_columns_info_params(const mcp_get_columns_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_type_id(_pool)
,_m_column_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_columns_info_params::~mcp_get_columns_info_params(){
}
inline mcp_get_columns_info_params& mcp_get_columns_info_params::operator=(const mcp_get_columns_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_columns_info_params::clear(){
_m_type_id.clear();
_m_column_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_columns_info_params::check() const{
// @@string type_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@string column_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "column_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_column_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_columns_info_params::detach(){
_m_type_id.detach();
_m_column_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_columns_info_params& mcp_get_columns_info_params::assign(const mcp_get_columns_info_params& v){
_m_type_id=v._m_type_id;
_m_column_id=v._m_column_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_columns_info_params::has_type_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_columns_info_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_columns_info_params& mcp_get_columns_info_params::set_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_columns_info_params& mcp_get_columns_info_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_columns_info_params::clear_type_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_columns_info_params::has_column_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_columns_info_params::column_id(unsigned int* size) const{
return _m_column_id.get(size);
}
inline mcp_get_columns_info_params& mcp_get_columns_info_params::set_column_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_column_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_columns_info_params& mcp_get_columns_info_params::set_ptr_column_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_column_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_columns_info_params::clear_column_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_column_id.clear();
}
inline ::idl::Unknown* mcp_get_columns_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_columns_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_columns_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_columns_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_columns_info_result_params* mcp_get_columns_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_columns_info_result_params* tmp=(mcp_get_columns_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_columns_info_result_params(pool);
return tmp;
}
inline void mcp_get_columns_info_result_params::destroy(mcp_get_columns_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_columns_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_columns_info_result_params::mcp_get_columns_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_columns_info_result_params::mcp_get_columns_info_result_params(const mcp_get_columns_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_columns_info_result_params::~mcp_get_columns_info_result_params(){
}
inline mcp_get_columns_info_result_params& mcp_get_columns_info_result_params::operator=(const mcp_get_columns_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_columns_info_result_params::clear(){
// _m_count=0;
_m_result_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_columns_info_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@column_info_t result_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_list" << "' not found";
}
{
// level 0 begin
typeof(_m_result_list)& lr0=(_m_result_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::column_info_t& item=const_cast< ::idl::column_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_columns_info_result_params::detach(){
_m_result_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_columns_info_result_params& mcp_get_columns_info_result_params::assign(const mcp_get_columns_info_result_params& v){
_m_count=v._m_count;
_m_result_list=v._m_result_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_columns_info_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_columns_info_result_params::count() const{
return _m_count;
}
inline mcp_get_columns_info_result_params& mcp_get_columns_info_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_columns_info_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_columns_info_result_params::has_result_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::column_info_t >& mcp_get_columns_info_result_params::result_list() const{
 return _m_result_list;
}
inline void mcp_get_columns_info_result_params::clear_result_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_result_list.clear();
}
inline ::idl::vector< ::idl::column_info_t >* mcp_get_columns_info_result_params::mutable_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline ::idl::vector< ::idl::column_info_t >* mcp_get_columns_info_result_params::m_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline size_t mcp_get_columns_info_result_params::result_list_size() const{
/*  */ return _m_result_list.size();
}
inline const ::idl::column_info_t& mcp_get_columns_info_result_params::result_list(size_t i0) const{
 return _m_result_list.get(i0);
}
inline ::idl::column_info_t* mcp_get_columns_info_result_params::mutable_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::column_info_t* mcp_get_columns_info_result_params::m_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_columns_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_columns_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_columns_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_columns_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_columns_info_response* mcp_get_columns_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_columns_info_response* tmp=(mcp_get_columns_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_columns_info_response(pool);
return tmp;
}
inline void mcp_get_columns_info_response::destroy(mcp_get_columns_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_columns_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_columns_info_response::mcp_get_columns_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_columns_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_columns_info_response::mcp_get_columns_info_response(const mcp_get_columns_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_columns_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_columns_info_response::~mcp_get_columns_info_response(){
if(_m_result_params){
::idl::mcp_get_columns_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_columns_info_response& mcp_get_columns_info_response::operator=(const mcp_get_columns_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_columns_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_columns_info_response::check() const{
// @@mcp_get_columns_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_columns_info_result_params& item=const_cast< ::idl::mcp_get_columns_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_columns_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_columns_info_response& mcp_get_columns_info_response::assign(const mcp_get_columns_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_columns_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_columns_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_columns_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_columns_info_result_params& mcp_get_columns_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_columns_info_result_params* mcp_get_columns_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_columns_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_columns_info_result_params* mcp_get_columns_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_columns_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_columns_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_columns_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_columns_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_columns_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_columns_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_once_consume_goods_list_params* mcp_get_once_consume_goods_list_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_once_consume_goods_list_params* tmp=(mcp_get_once_consume_goods_list_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_once_consume_goods_list_params(pool);
return tmp;
}
inline void mcp_get_once_consume_goods_list_params::destroy(mcp_get_once_consume_goods_list_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_once_consume_goods_list_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_once_consume_goods_list_params::mcp_get_once_consume_goods_list_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_udid(_pool)
,_m_app_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_once_consume_goods_list_params::mcp_get_once_consume_goods_list_params(const mcp_get_once_consume_goods_list_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_udid(_pool)
,_m_app_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_once_consume_goods_list_params::~mcp_get_once_consume_goods_list_params(){
}
inline mcp_get_once_consume_goods_list_params& mcp_get_once_consume_goods_list_params::operator=(const mcp_get_once_consume_goods_list_params& v){
assign(v);
return *this;
}
inline void mcp_get_once_consume_goods_list_params::clear(){
_m_udid.clear();
_m_app_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_once_consume_goods_list_params::check() const{
// @@string udid=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "udid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_udid.get();

}
// @@string app_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "app_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_app_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_once_consume_goods_list_params::detach(){
_m_udid.detach();
_m_app_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_once_consume_goods_list_params& mcp_get_once_consume_goods_list_params::assign(const mcp_get_once_consume_goods_list_params& v){
_m_udid=v._m_udid;
_m_app_id=v._m_app_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_once_consume_goods_list_params::has_udid() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_once_consume_goods_list_params::udid(unsigned int* size) const{
return _m_udid.get(size);
}
inline mcp_get_once_consume_goods_list_params& mcp_get_once_consume_goods_list_params::set_udid(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_udid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_once_consume_goods_list_params& mcp_get_once_consume_goods_list_params::set_ptr_udid(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_udid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_once_consume_goods_list_params::clear_udid(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_udid.clear();
}
inline bool mcp_get_once_consume_goods_list_params::has_app_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_once_consume_goods_list_params::app_id(unsigned int* size) const{
return _m_app_id.get(size);
}
inline mcp_get_once_consume_goods_list_params& mcp_get_once_consume_goods_list_params::set_app_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_app_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_once_consume_goods_list_params& mcp_get_once_consume_goods_list_params::set_ptr_app_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_app_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_once_consume_goods_list_params::clear_app_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_app_id.clear();
}
inline ::idl::Unknown* mcp_get_once_consume_goods_list_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_once_consume_goods_list_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_once_consume_goods_list_params::unknown(){
return _unknown;
}
inline size_t mcp_get_once_consume_goods_list_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_once_consume_goods_list_result_params* mcp_get_once_consume_goods_list_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_once_consume_goods_list_result_params* tmp=(mcp_get_once_consume_goods_list_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_once_consume_goods_list_result_params(pool);
return tmp;
}
inline void mcp_get_once_consume_goods_list_result_params::destroy(mcp_get_once_consume_goods_list_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_once_consume_goods_list_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_once_consume_goods_list_result_params::mcp_get_once_consume_goods_list_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_itemcount(0)
,_m_items(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_once_consume_goods_list_result_params::mcp_get_once_consume_goods_list_result_params(const mcp_get_once_consume_goods_list_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_itemcount(0)
,_m_items(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_once_consume_goods_list_result_params::~mcp_get_once_consume_goods_list_result_params(){
}
inline mcp_get_once_consume_goods_list_result_params& mcp_get_once_consume_goods_list_result_params::operator=(const mcp_get_once_consume_goods_list_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_once_consume_goods_list_result_params::clear(){
// _m_itemcount=0;
_m_items.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_once_consume_goods_list_result_params::check() const{
// @@uint32_t itemcount=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "itemcount" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_itemcount;

}
// @@once_consume_goods_t items=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "items" << "' not found";
}
{
// level 0 begin
typeof(_m_items)& lr0=(_m_items);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::once_consume_goods_t& item=const_cast< ::idl::once_consume_goods_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_once_consume_goods_list_result_params::detach(){
_m_items.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_once_consume_goods_list_result_params& mcp_get_once_consume_goods_list_result_params::assign(const mcp_get_once_consume_goods_list_result_params& v){
_m_itemcount=v._m_itemcount;
_m_items=v._m_items;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_once_consume_goods_list_result_params::has_itemcount() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_once_consume_goods_list_result_params::itemcount() const{
return _m_itemcount;
}
inline mcp_get_once_consume_goods_list_result_params& mcp_get_once_consume_goods_list_result_params::set_itemcount(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_itemcount=v;
return *this;
}
inline void mcp_get_once_consume_goods_list_result_params::clear_itemcount(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_itemcount=0;
}
inline bool mcp_get_once_consume_goods_list_result_params::has_items() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::once_consume_goods_t >& mcp_get_once_consume_goods_list_result_params::items() const{
 return _m_items;
}
inline void mcp_get_once_consume_goods_list_result_params::clear_items(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_items.clear();
}
inline ::idl::vector< ::idl::once_consume_goods_t >* mcp_get_once_consume_goods_list_result_params::mutable_items(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_items);
}
inline ::idl::vector< ::idl::once_consume_goods_t >* mcp_get_once_consume_goods_list_result_params::m_items(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_items);
}
inline size_t mcp_get_once_consume_goods_list_result_params::items_size() const{
/*  */ return _m_items.size();
}
inline const ::idl::once_consume_goods_t& mcp_get_once_consume_goods_list_result_params::items(size_t i0) const{
 return _m_items.get(i0);
}
inline ::idl::once_consume_goods_t* mcp_get_once_consume_goods_list_result_params::mutable_items(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_items.mutable_get(i0);
}
inline ::idl::once_consume_goods_t* mcp_get_once_consume_goods_list_result_params::m_items(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_items.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_once_consume_goods_list_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_once_consume_goods_list_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_once_consume_goods_list_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_once_consume_goods_list_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_once_consume_goods_list_response* mcp_get_once_consume_goods_list_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_once_consume_goods_list_response* tmp=(mcp_get_once_consume_goods_list_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_once_consume_goods_list_response(pool);
return tmp;
}
inline void mcp_get_once_consume_goods_list_response::destroy(mcp_get_once_consume_goods_list_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_once_consume_goods_list_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_once_consume_goods_list_response::mcp_get_once_consume_goods_list_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_once_consume_goods_list_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_once_consume_goods_list_response::mcp_get_once_consume_goods_list_response(const mcp_get_once_consume_goods_list_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_once_consume_goods_list_result_params::create(_pool);
assign(v);
}
inline mcp_get_once_consume_goods_list_response::~mcp_get_once_consume_goods_list_response(){
if(_m_result_params){
::idl::mcp_get_once_consume_goods_list_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_once_consume_goods_list_response& mcp_get_once_consume_goods_list_response::operator=(const mcp_get_once_consume_goods_list_response& v){
assign(v);
return *this;
}
inline void mcp_get_once_consume_goods_list_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_once_consume_goods_list_response::check() const{
// @@mcp_get_once_consume_goods_list_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_once_consume_goods_list_result_params& item=const_cast< ::idl::mcp_get_once_consume_goods_list_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_once_consume_goods_list_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_once_consume_goods_list_response& mcp_get_once_consume_goods_list_response::assign(const mcp_get_once_consume_goods_list_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_once_consume_goods_list_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_once_consume_goods_list_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_once_consume_goods_list_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_once_consume_goods_list_result_params& mcp_get_once_consume_goods_list_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_once_consume_goods_list_result_params* mcp_get_once_consume_goods_list_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_once_consume_goods_list_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_once_consume_goods_list_result_params* mcp_get_once_consume_goods_list_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_once_consume_goods_list_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_once_consume_goods_list_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_once_consume_goods_list_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_once_consume_goods_list_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_once_consume_goods_list_response::unknown(){
return _unknown;
}
inline size_t mcp_get_once_consume_goods_list_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_info_list_ext_params* mcp_get_game_info_list_ext_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_info_list_ext_params* tmp=(mcp_get_game_info_list_ext_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_info_list_ext_params(pool);
return tmp;
}
inline void mcp_get_game_info_list_ext_params::destroy(mcp_get_game_info_list_ext_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_info_list_ext_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_info_list_ext_params::mcp_get_game_info_list_ext_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_id(_pool)
,_m_c_id(_pool)
,_m_info_type(_pool)
,_m_game_type(_pool)
,_m_date_limit(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_info_list_ext_params::mcp_get_game_info_list_ext_params(const mcp_get_game_info_list_ext_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_id(_pool)
,_m_c_id(_pool)
,_m_info_type(_pool)
,_m_game_type(_pool)
,_m_date_limit(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_info_list_ext_params::~mcp_get_game_info_list_ext_params(){
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::operator=(const mcp_get_game_info_list_ext_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_info_list_ext_params::clear(){
_m_info_id.clear();
_m_c_id.clear();
_m_info_type.clear();
_m_game_type.clear();
_m_date_limit.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_info_list_ext_params::check() const{
// @@string info_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@string c_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string info_type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_type.get();

}
// @@string game_type=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_type.get();

}
// @@string date_limit=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "date_limit" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_date_limit.get();

}
// @@uint32_t page=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_game_info_list_ext_params::detach(){
_m_info_id.detach();
_m_c_id.detach();
_m_info_type.detach();
_m_game_type.detach();
_m_date_limit.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::assign(const mcp_get_game_info_list_ext_params& v){
_m_info_id=v._m_info_id;
_m_c_id=v._m_c_id;
_m_info_type=v._m_info_type;
_m_game_type=v._m_game_type;
_m_date_limit=v._m_date_limit;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_info_list_ext_params::has_info_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_info_list_ext_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::set_info_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_info_list_ext_params::clear_info_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_game_info_list_ext_params::has_c_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_game_info_list_ext_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::set_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_info_list_ext_params::clear_c_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_c_id.clear();
}
inline bool mcp_get_game_info_list_ext_params::has_info_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_game_info_list_ext_params::info_type(unsigned int* size) const{
return _m_info_type.get(size);
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::set_info_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::set_ptr_info_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_info_list_ext_params::clear_info_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_type.clear();
}
inline bool mcp_get_game_info_list_ext_params::has_game_type() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_game_info_list_ext_params::game_type(unsigned int* size) const{
return _m_game_type.get(size);
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::set_game_type(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_game_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::set_ptr_game_type(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_game_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_info_list_ext_params::clear_game_type(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_game_type.clear();
}
inline bool mcp_get_game_info_list_ext_params::has_date_limit() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_get_game_info_list_ext_params::date_limit(unsigned int* size) const{
return _m_date_limit.get(size);
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::set_date_limit(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_date_limit.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::set_ptr_date_limit(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_date_limit.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_info_list_ext_params::clear_date_limit(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_date_limit.clear();
}
inline bool mcp_get_game_info_list_ext_params::has_page() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline uint32_t mcp_get_game_info_list_ext_params::page() const{
return _m_page;
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::set_page(uint32_t v){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_game_info_list_ext_params::clear_page(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_page=0;
}
inline bool mcp_get_game_info_list_ext_params::has_page_size() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline uint32_t mcp_get_game_info_list_ext_params::page_size() const{
return _m_page_size;
}
inline mcp_get_game_info_list_ext_params& mcp_get_game_info_list_ext_params::set_page_size(uint32_t v){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_game_info_list_ext_params::clear_page_size(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_game_info_list_ext_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_info_list_ext_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_info_list_ext_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_info_list_ext_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_info_list_ext_result_params* mcp_get_game_info_list_ext_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_info_list_ext_result_params* tmp=(mcp_get_game_info_list_ext_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_info_list_ext_result_params(pool);
return tmp;
}
inline void mcp_get_game_info_list_ext_result_params::destroy(mcp_get_game_info_list_ext_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_info_list_ext_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_info_list_ext_result_params::mcp_get_game_info_list_ext_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_game_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_info_list_ext_result_params::mcp_get_game_info_list_ext_result_params(const mcp_get_game_info_list_ext_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_game_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_info_list_ext_result_params::~mcp_get_game_info_list_ext_result_params(){
}
inline mcp_get_game_info_list_ext_result_params& mcp_get_game_info_list_ext_result_params::operator=(const mcp_get_game_info_list_ext_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_info_list_ext_result_params::clear(){
// _m_count=0;
_m_game_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_info_list_ext_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@game_info_t game_info_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_game_info_list)& lr0=(_m_game_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_info_t& item=const_cast< ::idl::game_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_game_info_list_ext_result_params::detach(){
_m_game_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_info_list_ext_result_params& mcp_get_game_info_list_ext_result_params::assign(const mcp_get_game_info_list_ext_result_params& v){
_m_count=v._m_count;
_m_game_info_list=v._m_game_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_info_list_ext_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_game_info_list_ext_result_params::count() const{
return _m_count;
}
inline mcp_get_game_info_list_ext_result_params& mcp_get_game_info_list_ext_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_game_info_list_ext_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_game_info_list_ext_result_params::has_game_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_info_t >& mcp_get_game_info_list_ext_result_params::game_info_list() const{
 return _m_game_info_list;
}
inline void mcp_get_game_info_list_ext_result_params::clear_game_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_info_list.clear();
}
inline ::idl::vector< ::idl::game_info_t >* mcp_get_game_info_list_ext_result_params::mutable_game_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_info_list);
}
inline ::idl::vector< ::idl::game_info_t >* mcp_get_game_info_list_ext_result_params::m_game_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_info_list);
}
inline size_t mcp_get_game_info_list_ext_result_params::game_info_list_size() const{
/*  */ return _m_game_info_list.size();
}
inline const ::idl::game_info_t& mcp_get_game_info_list_ext_result_params::game_info_list(size_t i0) const{
 return _m_game_info_list.get(i0);
}
inline ::idl::game_info_t* mcp_get_game_info_list_ext_result_params::mutable_game_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_info_list.mutable_get(i0);
}
inline ::idl::game_info_t* mcp_get_game_info_list_ext_result_params::m_game_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_game_info_list_ext_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_info_list_ext_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_info_list_ext_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_info_list_ext_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_info_list_ext_response* mcp_get_game_info_list_ext_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_info_list_ext_response* tmp=(mcp_get_game_info_list_ext_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_info_list_ext_response(pool);
return tmp;
}
inline void mcp_get_game_info_list_ext_response::destroy(mcp_get_game_info_list_ext_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_info_list_ext_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_info_list_ext_response::mcp_get_game_info_list_ext_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_info_list_ext_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_info_list_ext_response::mcp_get_game_info_list_ext_response(const mcp_get_game_info_list_ext_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_info_list_ext_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_info_list_ext_response::~mcp_get_game_info_list_ext_response(){
if(_m_result_params){
::idl::mcp_get_game_info_list_ext_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_info_list_ext_response& mcp_get_game_info_list_ext_response::operator=(const mcp_get_game_info_list_ext_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_info_list_ext_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_info_list_ext_response::check() const{
// @@mcp_get_game_info_list_ext_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_info_list_ext_result_params& item=const_cast< ::idl::mcp_get_game_info_list_ext_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_info_list_ext_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_info_list_ext_response& mcp_get_game_info_list_ext_response::assign(const mcp_get_game_info_list_ext_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_info_list_ext_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_info_list_ext_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_info_list_ext_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_info_list_ext_result_params& mcp_get_game_info_list_ext_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_info_list_ext_result_params* mcp_get_game_info_list_ext_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_info_list_ext_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_info_list_ext_result_params* mcp_get_game_info_list_ext_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_info_list_ext_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_info_list_ext_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_info_list_ext_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_info_list_ext_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_info_list_ext_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_info_list_ext_response::unknown_size() const{
return _unknown.size();
}
inline mcp_add_new_download_game_by_uid_params* mcp_add_new_download_game_by_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_new_download_game_by_uid_params* tmp=(mcp_add_new_download_game_by_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_new_download_game_by_uid_params(pool);
return tmp;
}
inline void mcp_add_new_download_game_by_uid_params::destroy(mcp_add_new_download_game_by_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_new_download_game_by_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_new_download_game_by_uid_params::mcp_add_new_download_game_by_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_m_game_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_new_download_game_by_uid_params::mcp_add_new_download_game_by_uid_params(const mcp_add_new_download_game_by_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_m_game_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_add_new_download_game_by_uid_params::~mcp_add_new_download_game_by_uid_params(){
}
inline mcp_add_new_download_game_by_uid_params& mcp_add_new_download_game_by_uid_params::operator=(const mcp_add_new_download_game_by_uid_params& v){
assign(v);
return *this;
}
inline void mcp_add_new_download_game_by_uid_params::clear(){
_m_u_id.clear();
_m_game_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_new_download_game_by_uid_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}
// @@string game_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_add_new_download_game_by_uid_params::detach(){
_m_u_id.detach();
_m_game_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_new_download_game_by_uid_params& mcp_add_new_download_game_by_uid_params::assign(const mcp_add_new_download_game_by_uid_params& v){
_m_u_id=v._m_u_id;
_m_game_id=v._m_game_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_new_download_game_by_uid_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_add_new_download_game_by_uid_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_add_new_download_game_by_uid_params& mcp_add_new_download_game_by_uid_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_new_download_game_by_uid_params& mcp_add_new_download_game_by_uid_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_new_download_game_by_uid_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline bool mcp_add_new_download_game_by_uid_params::has_game_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_add_new_download_game_by_uid_params::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline mcp_add_new_download_game_by_uid_params& mcp_add_new_download_game_by_uid_params::set_game_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_new_download_game_by_uid_params& mcp_add_new_download_game_by_uid_params::set_ptr_game_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_new_download_game_by_uid_params::clear_game_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_id.clear();
}
inline ::idl::Unknown* mcp_add_new_download_game_by_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_new_download_game_by_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_new_download_game_by_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_add_new_download_game_by_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_add_new_download_game_by_uid_result_params* mcp_add_new_download_game_by_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_new_download_game_by_uid_result_params* tmp=(mcp_add_new_download_game_by_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_new_download_game_by_uid_result_params(pool);
return tmp;
}
inline void mcp_add_new_download_game_by_uid_result_params::destroy(mcp_add_new_download_game_by_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_new_download_game_by_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_new_download_game_by_uid_result_params::mcp_add_new_download_game_by_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ret_code(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_new_download_game_by_uid_result_params::mcp_add_new_download_game_by_uid_result_params(const mcp_add_new_download_game_by_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ret_code(0)
,_unknown(_pool){
assign(v);
}
inline mcp_add_new_download_game_by_uid_result_params::~mcp_add_new_download_game_by_uid_result_params(){
}
inline mcp_add_new_download_game_by_uid_result_params& mcp_add_new_download_game_by_uid_result_params::operator=(const mcp_add_new_download_game_by_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_add_new_download_game_by_uid_result_params::clear(){
// _m_ret_code=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_new_download_game_by_uid_result_params::check() const{
// @@int32_t ret_code=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ret_code" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_ret_code;

}

::idl::McpackBean::check();
}
inline void mcp_add_new_download_game_by_uid_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_new_download_game_by_uid_result_params& mcp_add_new_download_game_by_uid_result_params::assign(const mcp_add_new_download_game_by_uid_result_params& v){
_m_ret_code=v._m_ret_code;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_new_download_game_by_uid_result_params::has_ret_code() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_add_new_download_game_by_uid_result_params::ret_code() const{
return _m_ret_code;
}
inline mcp_add_new_download_game_by_uid_result_params& mcp_add_new_download_game_by_uid_result_params::set_ret_code(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ret_code=v;
return *this;
}
inline void mcp_add_new_download_game_by_uid_result_params::clear_ret_code(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ret_code=0;
}
inline ::idl::Unknown* mcp_add_new_download_game_by_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_new_download_game_by_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_new_download_game_by_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_add_new_download_game_by_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_add_new_download_game_by_uid_response* mcp_add_new_download_game_by_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_new_download_game_by_uid_response* tmp=(mcp_add_new_download_game_by_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_new_download_game_by_uid_response(pool);
return tmp;
}
inline void mcp_add_new_download_game_by_uid_response::destroy(mcp_add_new_download_game_by_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_new_download_game_by_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_new_download_game_by_uid_response::mcp_add_new_download_game_by_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_add_new_download_game_by_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_new_download_game_by_uid_response::mcp_add_new_download_game_by_uid_response(const mcp_add_new_download_game_by_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_add_new_download_game_by_uid_result_params::create(_pool);
assign(v);
}
inline mcp_add_new_download_game_by_uid_response::~mcp_add_new_download_game_by_uid_response(){
if(_m_result_params){
::idl::mcp_add_new_download_game_by_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_add_new_download_game_by_uid_response& mcp_add_new_download_game_by_uid_response::operator=(const mcp_add_new_download_game_by_uid_response& v){
assign(v);
return *this;
}
inline void mcp_add_new_download_game_by_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_new_download_game_by_uid_response::check() const{
// @@mcp_add_new_download_game_by_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_add_new_download_game_by_uid_result_params& item=const_cast< ::idl::mcp_add_new_download_game_by_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_add_new_download_game_by_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_new_download_game_by_uid_response& mcp_add_new_download_game_by_uid_response::assign(const mcp_add_new_download_game_by_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_add_new_download_game_by_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_add_new_download_game_by_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_new_download_game_by_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_add_new_download_game_by_uid_result_params& mcp_add_new_download_game_by_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_add_new_download_game_by_uid_result_params* mcp_add_new_download_game_by_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_add_new_download_game_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_add_new_download_game_by_uid_result_params* mcp_add_new_download_game_by_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_add_new_download_game_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_add_new_download_game_by_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_add_new_download_game_by_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_new_download_game_by_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_new_download_game_by_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_add_new_download_game_by_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_download_games_count_by_uid_params* mcp_get_download_games_count_by_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_download_games_count_by_uid_params* tmp=(mcp_get_download_games_count_by_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_download_games_count_by_uid_params(pool);
return tmp;
}
inline void mcp_get_download_games_count_by_uid_params::destroy(mcp_get_download_games_count_by_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_download_games_count_by_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_download_games_count_by_uid_params::mcp_get_download_games_count_by_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_download_games_count_by_uid_params::mcp_get_download_games_count_by_uid_params(const mcp_get_download_games_count_by_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_download_games_count_by_uid_params::~mcp_get_download_games_count_by_uid_params(){
}
inline mcp_get_download_games_count_by_uid_params& mcp_get_download_games_count_by_uid_params::operator=(const mcp_get_download_games_count_by_uid_params& v){
assign(v);
return *this;
}
inline void mcp_get_download_games_count_by_uid_params::clear(){
_m_u_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_download_games_count_by_uid_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_download_games_count_by_uid_params::detach(){
_m_u_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_download_games_count_by_uid_params& mcp_get_download_games_count_by_uid_params::assign(const mcp_get_download_games_count_by_uid_params& v){
_m_u_id=v._m_u_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_download_games_count_by_uid_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_download_games_count_by_uid_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_get_download_games_count_by_uid_params& mcp_get_download_games_count_by_uid_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_download_games_count_by_uid_params& mcp_get_download_games_count_by_uid_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_download_games_count_by_uid_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline ::idl::Unknown* mcp_get_download_games_count_by_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_download_games_count_by_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_download_games_count_by_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_get_download_games_count_by_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_download_games_count_by_uid_result_params* mcp_get_download_games_count_by_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_download_games_count_by_uid_result_params* tmp=(mcp_get_download_games_count_by_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_download_games_count_by_uid_result_params(pool);
return tmp;
}
inline void mcp_get_download_games_count_by_uid_result_params::destroy(mcp_get_download_games_count_by_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_download_games_count_by_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_download_games_count_by_uid_result_params::mcp_get_download_games_count_by_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_download_games_count_by_uid_result_params::mcp_get_download_games_count_by_uid_result_params(const mcp_get_download_games_count_by_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_download_games_count_by_uid_result_params::~mcp_get_download_games_count_by_uid_result_params(){
}
inline mcp_get_download_games_count_by_uid_result_params& mcp_get_download_games_count_by_uid_result_params::operator=(const mcp_get_download_games_count_by_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_download_games_count_by_uid_result_params::clear(){
// _m_count=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_download_games_count_by_uid_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}

::idl::McpackBean::check();
}
inline void mcp_get_download_games_count_by_uid_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_download_games_count_by_uid_result_params& mcp_get_download_games_count_by_uid_result_params::assign(const mcp_get_download_games_count_by_uid_result_params& v){
_m_count=v._m_count;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_download_games_count_by_uid_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_download_games_count_by_uid_result_params::count() const{
return _m_count;
}
inline mcp_get_download_games_count_by_uid_result_params& mcp_get_download_games_count_by_uid_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_download_games_count_by_uid_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline ::idl::Unknown* mcp_get_download_games_count_by_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_download_games_count_by_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_download_games_count_by_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_download_games_count_by_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_download_games_count_by_uid_response* mcp_get_download_games_count_by_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_download_games_count_by_uid_response* tmp=(mcp_get_download_games_count_by_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_download_games_count_by_uid_response(pool);
return tmp;
}
inline void mcp_get_download_games_count_by_uid_response::destroy(mcp_get_download_games_count_by_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_download_games_count_by_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_download_games_count_by_uid_response::mcp_get_download_games_count_by_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_download_games_count_by_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_download_games_count_by_uid_response::mcp_get_download_games_count_by_uid_response(const mcp_get_download_games_count_by_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_download_games_count_by_uid_result_params::create(_pool);
assign(v);
}
inline mcp_get_download_games_count_by_uid_response::~mcp_get_download_games_count_by_uid_response(){
if(_m_result_params){
::idl::mcp_get_download_games_count_by_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_download_games_count_by_uid_response& mcp_get_download_games_count_by_uid_response::operator=(const mcp_get_download_games_count_by_uid_response& v){
assign(v);
return *this;
}
inline void mcp_get_download_games_count_by_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_download_games_count_by_uid_response::check() const{
// @@mcp_get_download_games_count_by_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_download_games_count_by_uid_result_params& item=const_cast< ::idl::mcp_get_download_games_count_by_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_download_games_count_by_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_download_games_count_by_uid_response& mcp_get_download_games_count_by_uid_response::assign(const mcp_get_download_games_count_by_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_download_games_count_by_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_download_games_count_by_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_download_games_count_by_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_download_games_count_by_uid_result_params& mcp_get_download_games_count_by_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_download_games_count_by_uid_result_params* mcp_get_download_games_count_by_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_download_games_count_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_download_games_count_by_uid_result_params* mcp_get_download_games_count_by_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_download_games_count_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_download_games_count_by_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_download_games_count_by_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_download_games_count_by_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_download_games_count_by_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_get_download_games_count_by_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_is_user_has_relation_with_params* mcp_is_user_has_relation_with_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_is_user_has_relation_with_params* tmp=(mcp_is_user_has_relation_with_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_is_user_has_relation_with_params(pool);
return tmp;
}
inline void mcp_is_user_has_relation_with_params::destroy(mcp_is_user_has_relation_with_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_is_user_has_relation_with_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_is_user_has_relation_with_params::mcp_is_user_has_relation_with_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_m_c_id(_pool)
,_m_c_type(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_is_user_has_relation_with_params::mcp_is_user_has_relation_with_params(const mcp_is_user_has_relation_with_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_m_c_id(_pool)
,_m_c_type(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_is_user_has_relation_with_params::~mcp_is_user_has_relation_with_params(){
}
inline mcp_is_user_has_relation_with_params& mcp_is_user_has_relation_with_params::operator=(const mcp_is_user_has_relation_with_params& v){
assign(v);
return *this;
}
inline void mcp_is_user_has_relation_with_params::clear(){
_m_u_id.clear();
_m_c_id.clear();
_m_c_type.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_is_user_has_relation_with_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}
// @@string c_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string c_type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_type.get();

}

::idl::McpackBean::check();
}
inline void mcp_is_user_has_relation_with_params::detach(){
_m_u_id.detach();
_m_c_id.detach();
_m_c_type.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_is_user_has_relation_with_params& mcp_is_user_has_relation_with_params::assign(const mcp_is_user_has_relation_with_params& v){
_m_u_id=v._m_u_id;
_m_c_id=v._m_c_id;
_m_c_type=v._m_c_type;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_is_user_has_relation_with_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_is_user_has_relation_with_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_is_user_has_relation_with_params& mcp_is_user_has_relation_with_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_is_user_has_relation_with_params& mcp_is_user_has_relation_with_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_is_user_has_relation_with_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline bool mcp_is_user_has_relation_with_params::has_c_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_is_user_has_relation_with_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_is_user_has_relation_with_params& mcp_is_user_has_relation_with_params::set_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_is_user_has_relation_with_params& mcp_is_user_has_relation_with_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_is_user_has_relation_with_params::clear_c_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_c_id.clear();
}
inline bool mcp_is_user_has_relation_with_params::has_c_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_is_user_has_relation_with_params::c_type(unsigned int* size) const{
return _m_c_type.get(size);
}
inline mcp_is_user_has_relation_with_params& mcp_is_user_has_relation_with_params::set_c_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_c_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_is_user_has_relation_with_params& mcp_is_user_has_relation_with_params::set_ptr_c_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_c_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_is_user_has_relation_with_params::clear_c_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_c_type.clear();
}
inline ::idl::Unknown* mcp_is_user_has_relation_with_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_is_user_has_relation_with_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_is_user_has_relation_with_params::unknown(){
return _unknown;
}
inline size_t mcp_is_user_has_relation_with_params::unknown_size() const{
return _unknown.size();
}
inline mcp_is_user_has_relation_with_result_params* mcp_is_user_has_relation_with_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_is_user_has_relation_with_result_params* tmp=(mcp_is_user_has_relation_with_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_is_user_has_relation_with_result_params(pool);
return tmp;
}
inline void mcp_is_user_has_relation_with_result_params::destroy(mcp_is_user_has_relation_with_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_is_user_has_relation_with_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_is_user_has_relation_with_result_params::mcp_is_user_has_relation_with_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_has_relation(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_is_user_has_relation_with_result_params::mcp_is_user_has_relation_with_result_params(const mcp_is_user_has_relation_with_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_has_relation(0)
,_unknown(_pool){
assign(v);
}
inline mcp_is_user_has_relation_with_result_params::~mcp_is_user_has_relation_with_result_params(){
}
inline mcp_is_user_has_relation_with_result_params& mcp_is_user_has_relation_with_result_params::operator=(const mcp_is_user_has_relation_with_result_params& v){
assign(v);
return *this;
}
inline void mcp_is_user_has_relation_with_result_params::clear(){
// _m_has_relation=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_is_user_has_relation_with_result_params::check() const{
// @@int32_t has_relation=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "has_relation" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_has_relation;

}

::idl::McpackBean::check();
}
inline void mcp_is_user_has_relation_with_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_is_user_has_relation_with_result_params& mcp_is_user_has_relation_with_result_params::assign(const mcp_is_user_has_relation_with_result_params& v){
_m_has_relation=v._m_has_relation;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_is_user_has_relation_with_result_params::has_has_relation() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_is_user_has_relation_with_result_params::has_relation() const{
return _m_has_relation;
}
inline mcp_is_user_has_relation_with_result_params& mcp_is_user_has_relation_with_result_params::set_has_relation(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_has_relation=v;
return *this;
}
inline void mcp_is_user_has_relation_with_result_params::clear_has_relation(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_has_relation=0;
}
inline ::idl::Unknown* mcp_is_user_has_relation_with_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_is_user_has_relation_with_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_is_user_has_relation_with_result_params::unknown(){
return _unknown;
}
inline size_t mcp_is_user_has_relation_with_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_is_user_has_relation_with_response* mcp_is_user_has_relation_with_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_is_user_has_relation_with_response* tmp=(mcp_is_user_has_relation_with_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_is_user_has_relation_with_response(pool);
return tmp;
}
inline void mcp_is_user_has_relation_with_response::destroy(mcp_is_user_has_relation_with_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_is_user_has_relation_with_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_is_user_has_relation_with_response::mcp_is_user_has_relation_with_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_is_user_has_relation_with_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_is_user_has_relation_with_response::mcp_is_user_has_relation_with_response(const mcp_is_user_has_relation_with_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_is_user_has_relation_with_result_params::create(_pool);
assign(v);
}
inline mcp_is_user_has_relation_with_response::~mcp_is_user_has_relation_with_response(){
if(_m_result_params){
::idl::mcp_is_user_has_relation_with_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_is_user_has_relation_with_response& mcp_is_user_has_relation_with_response::operator=(const mcp_is_user_has_relation_with_response& v){
assign(v);
return *this;
}
inline void mcp_is_user_has_relation_with_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_is_user_has_relation_with_response::check() const{
// @@mcp_is_user_has_relation_with_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_is_user_has_relation_with_result_params& item=const_cast< ::idl::mcp_is_user_has_relation_with_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_is_user_has_relation_with_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_is_user_has_relation_with_response& mcp_is_user_has_relation_with_response::assign(const mcp_is_user_has_relation_with_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_is_user_has_relation_with_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_is_user_has_relation_with_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_is_user_has_relation_with_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_is_user_has_relation_with_result_params& mcp_is_user_has_relation_with_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_is_user_has_relation_with_result_params* mcp_is_user_has_relation_with_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_is_user_has_relation_with_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_is_user_has_relation_with_result_params* mcp_is_user_has_relation_with_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_is_user_has_relation_with_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_is_user_has_relation_with_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_is_user_has_relation_with_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_is_user_has_relation_with_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_is_user_has_relation_with_response::unknown(){
return _unknown;
}
inline size_t mcp_is_user_has_relation_with_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_download_games_info_by_uid_params* mcp_get_download_games_info_by_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_download_games_info_by_uid_params* tmp=(mcp_get_download_games_info_by_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_download_games_info_by_uid_params(pool);
return tmp;
}
inline void mcp_get_download_games_info_by_uid_params::destroy(mcp_get_download_games_info_by_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_download_games_info_by_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_download_games_info_by_uid_params::mcp_get_download_games_info_by_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_m_img_types(_pool)
,_m_filter(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_download_games_info_by_uid_params::mcp_get_download_games_info_by_uid_params(const mcp_get_download_games_info_by_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_m_img_types(_pool)
,_m_filter(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_download_games_info_by_uid_params::~mcp_get_download_games_info_by_uid_params(){
}
inline mcp_get_download_games_info_by_uid_params& mcp_get_download_games_info_by_uid_params::operator=(const mcp_get_download_games_info_by_uid_params& v){
assign(v);
return *this;
}
inline void mcp_get_download_games_info_by_uid_params::clear(){
_m_u_id.clear();
_m_img_types.clear();
_m_filter.clear();
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_download_games_info_by_uid_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}
// @@string img_types=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "img_types" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_img_types.get();

}
// @@string filter=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "filter" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_filter.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_download_games_info_by_uid_params::detach(){
_m_u_id.detach();
_m_img_types.detach();
_m_filter.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_download_games_info_by_uid_params& mcp_get_download_games_info_by_uid_params::assign(const mcp_get_download_games_info_by_uid_params& v){
_m_u_id=v._m_u_id;
_m_img_types=v._m_img_types;
_m_filter=v._m_filter;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_download_games_info_by_uid_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_download_games_info_by_uid_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_get_download_games_info_by_uid_params& mcp_get_download_games_info_by_uid_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_download_games_info_by_uid_params& mcp_get_download_games_info_by_uid_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_download_games_info_by_uid_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline bool mcp_get_download_games_info_by_uid_params::has_img_types() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_download_games_info_by_uid_params::img_types(unsigned int* size) const{
return _m_img_types.get(size);
}
inline mcp_get_download_games_info_by_uid_params& mcp_get_download_games_info_by_uid_params::set_img_types(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_img_types.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_download_games_info_by_uid_params& mcp_get_download_games_info_by_uid_params::set_ptr_img_types(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_img_types.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_download_games_info_by_uid_params::clear_img_types(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_img_types.clear();
}
inline bool mcp_get_download_games_info_by_uid_params::has_filter() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_download_games_info_by_uid_params::filter(unsigned int* size) const{
return _m_filter.get(size);
}
inline mcp_get_download_games_info_by_uid_params& mcp_get_download_games_info_by_uid_params::set_filter(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_filter.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_download_games_info_by_uid_params& mcp_get_download_games_info_by_uid_params::set_ptr_filter(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_filter.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_download_games_info_by_uid_params::clear_filter(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_filter.clear();
}
inline bool mcp_get_download_games_info_by_uid_params::has_unit_num() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_download_games_info_by_uid_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_download_games_info_by_uid_params& mcp_get_download_games_info_by_uid_params::set_unit_num(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_download_games_info_by_uid_params::clear_unit_num(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_download_games_info_by_uid_params::has_unit_times() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_download_games_info_by_uid_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_download_games_info_by_uid_params& mcp_get_download_games_info_by_uid_params::set_unit_times(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_download_games_info_by_uid_params::clear_unit_times(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_download_games_info_by_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_download_games_info_by_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_download_games_info_by_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_get_download_games_info_by_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_download_games_info_by_uid_result_params* mcp_get_download_games_info_by_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_download_games_info_by_uid_result_params* tmp=(mcp_get_download_games_info_by_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_download_games_info_by_uid_result_params(pool);
return tmp;
}
inline void mcp_get_download_games_info_by_uid_result_params::destroy(mcp_get_download_games_info_by_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_download_games_info_by_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_download_games_info_by_uid_result_params::mcp_get_download_games_info_by_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_download_games_info_by_uid_result_params::mcp_get_download_games_info_by_uid_result_params(const mcp_get_download_games_info_by_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_download_games_info_by_uid_result_params::~mcp_get_download_games_info_by_uid_result_params(){
}
inline mcp_get_download_games_info_by_uid_result_params& mcp_get_download_games_info_by_uid_result_params::operator=(const mcp_get_download_games_info_by_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_download_games_info_by_uid_result_params::clear(){
// _m_count=0;
_m_result_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_download_games_info_by_uid_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@game_content_download_info_t result_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_list" << "' not found";
}
{
// level 0 begin
typeof(_m_result_list)& lr0=(_m_result_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_content_download_info_t& item=const_cast< ::idl::game_content_download_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_download_games_info_by_uid_result_params::detach(){
_m_result_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_download_games_info_by_uid_result_params& mcp_get_download_games_info_by_uid_result_params::assign(const mcp_get_download_games_info_by_uid_result_params& v){
_m_count=v._m_count;
_m_result_list=v._m_result_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_download_games_info_by_uid_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_download_games_info_by_uid_result_params::count() const{
return _m_count;
}
inline mcp_get_download_games_info_by_uid_result_params& mcp_get_download_games_info_by_uid_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_download_games_info_by_uid_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_download_games_info_by_uid_result_params::has_result_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_content_download_info_t >& mcp_get_download_games_info_by_uid_result_params::result_list() const{
 return _m_result_list;
}
inline void mcp_get_download_games_info_by_uid_result_params::clear_result_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_result_list.clear();
}
inline ::idl::vector< ::idl::game_content_download_info_t >* mcp_get_download_games_info_by_uid_result_params::mutable_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline ::idl::vector< ::idl::game_content_download_info_t >* mcp_get_download_games_info_by_uid_result_params::m_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline size_t mcp_get_download_games_info_by_uid_result_params::result_list_size() const{
/*  */ return _m_result_list.size();
}
inline const ::idl::game_content_download_info_t& mcp_get_download_games_info_by_uid_result_params::result_list(size_t i0) const{
 return _m_result_list.get(i0);
}
inline ::idl::game_content_download_info_t* mcp_get_download_games_info_by_uid_result_params::mutable_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::game_content_download_info_t* mcp_get_download_games_info_by_uid_result_params::m_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_download_games_info_by_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_download_games_info_by_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_download_games_info_by_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_download_games_info_by_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_download_games_info_by_uid_response* mcp_get_download_games_info_by_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_download_games_info_by_uid_response* tmp=(mcp_get_download_games_info_by_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_download_games_info_by_uid_response(pool);
return tmp;
}
inline void mcp_get_download_games_info_by_uid_response::destroy(mcp_get_download_games_info_by_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_download_games_info_by_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_download_games_info_by_uid_response::mcp_get_download_games_info_by_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_download_games_info_by_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_download_games_info_by_uid_response::mcp_get_download_games_info_by_uid_response(const mcp_get_download_games_info_by_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_download_games_info_by_uid_result_params::create(_pool);
assign(v);
}
inline mcp_get_download_games_info_by_uid_response::~mcp_get_download_games_info_by_uid_response(){
if(_m_result_params){
::idl::mcp_get_download_games_info_by_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_download_games_info_by_uid_response& mcp_get_download_games_info_by_uid_response::operator=(const mcp_get_download_games_info_by_uid_response& v){
assign(v);
return *this;
}
inline void mcp_get_download_games_info_by_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_download_games_info_by_uid_response::check() const{
// @@mcp_get_download_games_info_by_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_download_games_info_by_uid_result_params& item=const_cast< ::idl::mcp_get_download_games_info_by_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_download_games_info_by_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_download_games_info_by_uid_response& mcp_get_download_games_info_by_uid_response::assign(const mcp_get_download_games_info_by_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_download_games_info_by_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_download_games_info_by_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_download_games_info_by_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_download_games_info_by_uid_result_params& mcp_get_download_games_info_by_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_download_games_info_by_uid_result_params* mcp_get_download_games_info_by_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_download_games_info_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_download_games_info_by_uid_result_params* mcp_get_download_games_info_by_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_download_games_info_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_download_games_info_by_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_download_games_info_by_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_download_games_info_by_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_download_games_info_by_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_get_download_games_info_by_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_add_new_guide_by_uid_params* mcp_add_new_guide_by_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_new_guide_by_uid_params* tmp=(mcp_add_new_guide_by_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_new_guide_by_uid_params(pool);
return tmp;
}
inline void mcp_add_new_guide_by_uid_params::destroy(mcp_add_new_guide_by_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_new_guide_by_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_new_guide_by_uid_params::mcp_add_new_guide_by_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_m_guide_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_new_guide_by_uid_params::mcp_add_new_guide_by_uid_params(const mcp_add_new_guide_by_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_m_guide_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_add_new_guide_by_uid_params::~mcp_add_new_guide_by_uid_params(){
}
inline mcp_add_new_guide_by_uid_params& mcp_add_new_guide_by_uid_params::operator=(const mcp_add_new_guide_by_uid_params& v){
assign(v);
return *this;
}
inline void mcp_add_new_guide_by_uid_params::clear(){
_m_u_id.clear();
_m_guide_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_new_guide_by_uid_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}
// @@string guide_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "guide_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_guide_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_add_new_guide_by_uid_params::detach(){
_m_u_id.detach();
_m_guide_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_new_guide_by_uid_params& mcp_add_new_guide_by_uid_params::assign(const mcp_add_new_guide_by_uid_params& v){
_m_u_id=v._m_u_id;
_m_guide_id=v._m_guide_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_new_guide_by_uid_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_add_new_guide_by_uid_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_add_new_guide_by_uid_params& mcp_add_new_guide_by_uid_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_new_guide_by_uid_params& mcp_add_new_guide_by_uid_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_new_guide_by_uid_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline bool mcp_add_new_guide_by_uid_params::has_guide_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_add_new_guide_by_uid_params::guide_id(unsigned int* size) const{
return _m_guide_id.get(size);
}
inline mcp_add_new_guide_by_uid_params& mcp_add_new_guide_by_uid_params::set_guide_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_guide_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_new_guide_by_uid_params& mcp_add_new_guide_by_uid_params::set_ptr_guide_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_guide_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_new_guide_by_uid_params::clear_guide_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_guide_id.clear();
}
inline ::idl::Unknown* mcp_add_new_guide_by_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_new_guide_by_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_new_guide_by_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_add_new_guide_by_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_add_new_guide_by_uid_result_params* mcp_add_new_guide_by_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_new_guide_by_uid_result_params* tmp=(mcp_add_new_guide_by_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_new_guide_by_uid_result_params(pool);
return tmp;
}
inline void mcp_add_new_guide_by_uid_result_params::destroy(mcp_add_new_guide_by_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_new_guide_by_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_new_guide_by_uid_result_params::mcp_add_new_guide_by_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ret_code(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_new_guide_by_uid_result_params::mcp_add_new_guide_by_uid_result_params(const mcp_add_new_guide_by_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ret_code(0)
,_unknown(_pool){
assign(v);
}
inline mcp_add_new_guide_by_uid_result_params::~mcp_add_new_guide_by_uid_result_params(){
}
inline mcp_add_new_guide_by_uid_result_params& mcp_add_new_guide_by_uid_result_params::operator=(const mcp_add_new_guide_by_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_add_new_guide_by_uid_result_params::clear(){
// _m_ret_code=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_new_guide_by_uid_result_params::check() const{
// @@int32_t ret_code=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ret_code" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_ret_code;

}

::idl::McpackBean::check();
}
inline void mcp_add_new_guide_by_uid_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_new_guide_by_uid_result_params& mcp_add_new_guide_by_uid_result_params::assign(const mcp_add_new_guide_by_uid_result_params& v){
_m_ret_code=v._m_ret_code;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_new_guide_by_uid_result_params::has_ret_code() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_add_new_guide_by_uid_result_params::ret_code() const{
return _m_ret_code;
}
inline mcp_add_new_guide_by_uid_result_params& mcp_add_new_guide_by_uid_result_params::set_ret_code(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ret_code=v;
return *this;
}
inline void mcp_add_new_guide_by_uid_result_params::clear_ret_code(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ret_code=0;
}
inline ::idl::Unknown* mcp_add_new_guide_by_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_new_guide_by_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_new_guide_by_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_add_new_guide_by_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_add_new_guide_by_uid_response* mcp_add_new_guide_by_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_new_guide_by_uid_response* tmp=(mcp_add_new_guide_by_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_new_guide_by_uid_response(pool);
return tmp;
}
inline void mcp_add_new_guide_by_uid_response::destroy(mcp_add_new_guide_by_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_new_guide_by_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_new_guide_by_uid_response::mcp_add_new_guide_by_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_add_new_guide_by_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_new_guide_by_uid_response::mcp_add_new_guide_by_uid_response(const mcp_add_new_guide_by_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_add_new_guide_by_uid_result_params::create(_pool);
assign(v);
}
inline mcp_add_new_guide_by_uid_response::~mcp_add_new_guide_by_uid_response(){
if(_m_result_params){
::idl::mcp_add_new_guide_by_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_add_new_guide_by_uid_response& mcp_add_new_guide_by_uid_response::operator=(const mcp_add_new_guide_by_uid_response& v){
assign(v);
return *this;
}
inline void mcp_add_new_guide_by_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_new_guide_by_uid_response::check() const{
// @@mcp_add_new_guide_by_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_add_new_guide_by_uid_result_params& item=const_cast< ::idl::mcp_add_new_guide_by_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_add_new_guide_by_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_new_guide_by_uid_response& mcp_add_new_guide_by_uid_response::assign(const mcp_add_new_guide_by_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_add_new_guide_by_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_add_new_guide_by_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_new_guide_by_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_add_new_guide_by_uid_result_params& mcp_add_new_guide_by_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_add_new_guide_by_uid_result_params* mcp_add_new_guide_by_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_add_new_guide_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_add_new_guide_by_uid_result_params* mcp_add_new_guide_by_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_add_new_guide_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_add_new_guide_by_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_add_new_guide_by_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_new_guide_by_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_new_guide_by_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_add_new_guide_by_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_remove_guide_by_uid_params* mcp_remove_guide_by_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_remove_guide_by_uid_params* tmp=(mcp_remove_guide_by_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_remove_guide_by_uid_params(pool);
return tmp;
}
inline void mcp_remove_guide_by_uid_params::destroy(mcp_remove_guide_by_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_remove_guide_by_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_remove_guide_by_uid_params::mcp_remove_guide_by_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_m_guide_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_remove_guide_by_uid_params::mcp_remove_guide_by_uid_params(const mcp_remove_guide_by_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_m_guide_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_remove_guide_by_uid_params::~mcp_remove_guide_by_uid_params(){
}
inline mcp_remove_guide_by_uid_params& mcp_remove_guide_by_uid_params::operator=(const mcp_remove_guide_by_uid_params& v){
assign(v);
return *this;
}
inline void mcp_remove_guide_by_uid_params::clear(){
_m_u_id.clear();
_m_guide_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_remove_guide_by_uid_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}
// @@string guide_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "guide_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_guide_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_remove_guide_by_uid_params::detach(){
_m_u_id.detach();
_m_guide_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_remove_guide_by_uid_params& mcp_remove_guide_by_uid_params::assign(const mcp_remove_guide_by_uid_params& v){
_m_u_id=v._m_u_id;
_m_guide_id=v._m_guide_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_remove_guide_by_uid_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_remove_guide_by_uid_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_remove_guide_by_uid_params& mcp_remove_guide_by_uid_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_remove_guide_by_uid_params& mcp_remove_guide_by_uid_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_remove_guide_by_uid_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline bool mcp_remove_guide_by_uid_params::has_guide_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_remove_guide_by_uid_params::guide_id(unsigned int* size) const{
return _m_guide_id.get(size);
}
inline mcp_remove_guide_by_uid_params& mcp_remove_guide_by_uid_params::set_guide_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_guide_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_remove_guide_by_uid_params& mcp_remove_guide_by_uid_params::set_ptr_guide_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_guide_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_remove_guide_by_uid_params::clear_guide_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_guide_id.clear();
}
inline ::idl::Unknown* mcp_remove_guide_by_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_remove_guide_by_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_remove_guide_by_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_remove_guide_by_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_remove_guide_by_uid_result_params* mcp_remove_guide_by_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_remove_guide_by_uid_result_params* tmp=(mcp_remove_guide_by_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_remove_guide_by_uid_result_params(pool);
return tmp;
}
inline void mcp_remove_guide_by_uid_result_params::destroy(mcp_remove_guide_by_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_remove_guide_by_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_remove_guide_by_uid_result_params::mcp_remove_guide_by_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ret_code(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_remove_guide_by_uid_result_params::mcp_remove_guide_by_uid_result_params(const mcp_remove_guide_by_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ret_code(0)
,_unknown(_pool){
assign(v);
}
inline mcp_remove_guide_by_uid_result_params::~mcp_remove_guide_by_uid_result_params(){
}
inline mcp_remove_guide_by_uid_result_params& mcp_remove_guide_by_uid_result_params::operator=(const mcp_remove_guide_by_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_remove_guide_by_uid_result_params::clear(){
// _m_ret_code=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_remove_guide_by_uid_result_params::check() const{
// @@int32_t ret_code=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ret_code" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_ret_code;

}

::idl::McpackBean::check();
}
inline void mcp_remove_guide_by_uid_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_remove_guide_by_uid_result_params& mcp_remove_guide_by_uid_result_params::assign(const mcp_remove_guide_by_uid_result_params& v){
_m_ret_code=v._m_ret_code;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_remove_guide_by_uid_result_params::has_ret_code() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_remove_guide_by_uid_result_params::ret_code() const{
return _m_ret_code;
}
inline mcp_remove_guide_by_uid_result_params& mcp_remove_guide_by_uid_result_params::set_ret_code(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ret_code=v;
return *this;
}
inline void mcp_remove_guide_by_uid_result_params::clear_ret_code(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ret_code=0;
}
inline ::idl::Unknown* mcp_remove_guide_by_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_remove_guide_by_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_remove_guide_by_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_remove_guide_by_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_remove_guide_by_uid_response* mcp_remove_guide_by_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_remove_guide_by_uid_response* tmp=(mcp_remove_guide_by_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_remove_guide_by_uid_response(pool);
return tmp;
}
inline void mcp_remove_guide_by_uid_response::destroy(mcp_remove_guide_by_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_remove_guide_by_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_remove_guide_by_uid_response::mcp_remove_guide_by_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_remove_guide_by_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_remove_guide_by_uid_response::mcp_remove_guide_by_uid_response(const mcp_remove_guide_by_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_remove_guide_by_uid_result_params::create(_pool);
assign(v);
}
inline mcp_remove_guide_by_uid_response::~mcp_remove_guide_by_uid_response(){
if(_m_result_params){
::idl::mcp_remove_guide_by_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_remove_guide_by_uid_response& mcp_remove_guide_by_uid_response::operator=(const mcp_remove_guide_by_uid_response& v){
assign(v);
return *this;
}
inline void mcp_remove_guide_by_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_remove_guide_by_uid_response::check() const{
// @@mcp_remove_guide_by_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_remove_guide_by_uid_result_params& item=const_cast< ::idl::mcp_remove_guide_by_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_remove_guide_by_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_remove_guide_by_uid_response& mcp_remove_guide_by_uid_response::assign(const mcp_remove_guide_by_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_remove_guide_by_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_remove_guide_by_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_remove_guide_by_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_remove_guide_by_uid_result_params& mcp_remove_guide_by_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_remove_guide_by_uid_result_params* mcp_remove_guide_by_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_remove_guide_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_remove_guide_by_uid_result_params* mcp_remove_guide_by_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_remove_guide_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_remove_guide_by_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_remove_guide_by_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_remove_guide_by_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_remove_guide_by_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_remove_guide_by_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_guides_count_by_uid_params* mcp_get_guides_count_by_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_guides_count_by_uid_params* tmp=(mcp_get_guides_count_by_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_guides_count_by_uid_params(pool);
return tmp;
}
inline void mcp_get_guides_count_by_uid_params::destroy(mcp_get_guides_count_by_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_guides_count_by_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_guides_count_by_uid_params::mcp_get_guides_count_by_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_guides_count_by_uid_params::mcp_get_guides_count_by_uid_params(const mcp_get_guides_count_by_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_guides_count_by_uid_params::~mcp_get_guides_count_by_uid_params(){
}
inline mcp_get_guides_count_by_uid_params& mcp_get_guides_count_by_uid_params::operator=(const mcp_get_guides_count_by_uid_params& v){
assign(v);
return *this;
}
inline void mcp_get_guides_count_by_uid_params::clear(){
_m_u_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_guides_count_by_uid_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_guides_count_by_uid_params::detach(){
_m_u_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_guides_count_by_uid_params& mcp_get_guides_count_by_uid_params::assign(const mcp_get_guides_count_by_uid_params& v){
_m_u_id=v._m_u_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_guides_count_by_uid_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_guides_count_by_uid_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_get_guides_count_by_uid_params& mcp_get_guides_count_by_uid_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_guides_count_by_uid_params& mcp_get_guides_count_by_uid_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_guides_count_by_uid_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline ::idl::Unknown* mcp_get_guides_count_by_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_guides_count_by_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_guides_count_by_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_get_guides_count_by_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_guides_count_by_uid_result_params* mcp_get_guides_count_by_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_guides_count_by_uid_result_params* tmp=(mcp_get_guides_count_by_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_guides_count_by_uid_result_params(pool);
return tmp;
}
inline void mcp_get_guides_count_by_uid_result_params::destroy(mcp_get_guides_count_by_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_guides_count_by_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_guides_count_by_uid_result_params::mcp_get_guides_count_by_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_guides_count_by_uid_result_params::mcp_get_guides_count_by_uid_result_params(const mcp_get_guides_count_by_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_guides_count_by_uid_result_params::~mcp_get_guides_count_by_uid_result_params(){
}
inline mcp_get_guides_count_by_uid_result_params& mcp_get_guides_count_by_uid_result_params::operator=(const mcp_get_guides_count_by_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_guides_count_by_uid_result_params::clear(){
// _m_count=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_guides_count_by_uid_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}

::idl::McpackBean::check();
}
inline void mcp_get_guides_count_by_uid_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_guides_count_by_uid_result_params& mcp_get_guides_count_by_uid_result_params::assign(const mcp_get_guides_count_by_uid_result_params& v){
_m_count=v._m_count;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_guides_count_by_uid_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_guides_count_by_uid_result_params::count() const{
return _m_count;
}
inline mcp_get_guides_count_by_uid_result_params& mcp_get_guides_count_by_uid_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_guides_count_by_uid_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline ::idl::Unknown* mcp_get_guides_count_by_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_guides_count_by_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_guides_count_by_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_guides_count_by_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_guides_count_by_uid_response* mcp_get_guides_count_by_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_guides_count_by_uid_response* tmp=(mcp_get_guides_count_by_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_guides_count_by_uid_response(pool);
return tmp;
}
inline void mcp_get_guides_count_by_uid_response::destroy(mcp_get_guides_count_by_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_guides_count_by_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_guides_count_by_uid_response::mcp_get_guides_count_by_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_guides_count_by_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_guides_count_by_uid_response::mcp_get_guides_count_by_uid_response(const mcp_get_guides_count_by_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_guides_count_by_uid_result_params::create(_pool);
assign(v);
}
inline mcp_get_guides_count_by_uid_response::~mcp_get_guides_count_by_uid_response(){
if(_m_result_params){
::idl::mcp_get_guides_count_by_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_guides_count_by_uid_response& mcp_get_guides_count_by_uid_response::operator=(const mcp_get_guides_count_by_uid_response& v){
assign(v);
return *this;
}
inline void mcp_get_guides_count_by_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_guides_count_by_uid_response::check() const{
// @@mcp_get_guides_count_by_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_guides_count_by_uid_result_params& item=const_cast< ::idl::mcp_get_guides_count_by_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_guides_count_by_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_guides_count_by_uid_response& mcp_get_guides_count_by_uid_response::assign(const mcp_get_guides_count_by_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_guides_count_by_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_guides_count_by_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_guides_count_by_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_guides_count_by_uid_result_params& mcp_get_guides_count_by_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_guides_count_by_uid_result_params* mcp_get_guides_count_by_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_guides_count_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_guides_count_by_uid_result_params* mcp_get_guides_count_by_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_guides_count_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_guides_count_by_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_guides_count_by_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_guides_count_by_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_guides_count_by_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_get_guides_count_by_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_guides_info_by_uid_params* mcp_get_guides_info_by_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_guides_info_by_uid_params* tmp=(mcp_get_guides_info_by_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_guides_info_by_uid_params(pool);
return tmp;
}
inline void mcp_get_guides_info_by_uid_params::destroy(mcp_get_guides_info_by_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_guides_info_by_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_guides_info_by_uid_params::mcp_get_guides_info_by_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_guides_info_by_uid_params::mcp_get_guides_info_by_uid_params(const mcp_get_guides_info_by_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_guides_info_by_uid_params::~mcp_get_guides_info_by_uid_params(){
}
inline mcp_get_guides_info_by_uid_params& mcp_get_guides_info_by_uid_params::operator=(const mcp_get_guides_info_by_uid_params& v){
assign(v);
return *this;
}
inline void mcp_get_guides_info_by_uid_params::clear(){
_m_u_id.clear();
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_guides_info_by_uid_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_guides_info_by_uid_params::detach(){
_m_u_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_guides_info_by_uid_params& mcp_get_guides_info_by_uid_params::assign(const mcp_get_guides_info_by_uid_params& v){
_m_u_id=v._m_u_id;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_guides_info_by_uid_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_guides_info_by_uid_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_get_guides_info_by_uid_params& mcp_get_guides_info_by_uid_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_guides_info_by_uid_params& mcp_get_guides_info_by_uid_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_guides_info_by_uid_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline bool mcp_get_guides_info_by_uid_params::has_unit_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_guides_info_by_uid_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_guides_info_by_uid_params& mcp_get_guides_info_by_uid_params::set_unit_num(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_guides_info_by_uid_params::clear_unit_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_guides_info_by_uid_params::has_unit_times() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_guides_info_by_uid_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_guides_info_by_uid_params& mcp_get_guides_info_by_uid_params::set_unit_times(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_guides_info_by_uid_params::clear_unit_times(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_guides_info_by_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_guides_info_by_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_guides_info_by_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_get_guides_info_by_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_guides_info_by_uid_result_params* mcp_get_guides_info_by_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_guides_info_by_uid_result_params* tmp=(mcp_get_guides_info_by_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_guides_info_by_uid_result_params(pool);
return tmp;
}
inline void mcp_get_guides_info_by_uid_result_params::destroy(mcp_get_guides_info_by_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_guides_info_by_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_guides_info_by_uid_result_params::mcp_get_guides_info_by_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_guides_info_by_uid_result_params::mcp_get_guides_info_by_uid_result_params(const mcp_get_guides_info_by_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_guides_info_by_uid_result_params::~mcp_get_guides_info_by_uid_result_params(){
}
inline mcp_get_guides_info_by_uid_result_params& mcp_get_guides_info_by_uid_result_params::operator=(const mcp_get_guides_info_by_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_guides_info_by_uid_result_params::clear(){
// _m_count=0;
_m_result_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_guides_info_by_uid_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@game_info_t result_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_list" << "' not found";
}
{
// level 0 begin
typeof(_m_result_list)& lr0=(_m_result_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_info_t& item=const_cast< ::idl::game_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_guides_info_by_uid_result_params::detach(){
_m_result_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_guides_info_by_uid_result_params& mcp_get_guides_info_by_uid_result_params::assign(const mcp_get_guides_info_by_uid_result_params& v){
_m_count=v._m_count;
_m_result_list=v._m_result_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_guides_info_by_uid_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_guides_info_by_uid_result_params::count() const{
return _m_count;
}
inline mcp_get_guides_info_by_uid_result_params& mcp_get_guides_info_by_uid_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_guides_info_by_uid_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_guides_info_by_uid_result_params::has_result_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_info_t >& mcp_get_guides_info_by_uid_result_params::result_list() const{
 return _m_result_list;
}
inline void mcp_get_guides_info_by_uid_result_params::clear_result_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_result_list.clear();
}
inline ::idl::vector< ::idl::game_info_t >* mcp_get_guides_info_by_uid_result_params::mutable_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline ::idl::vector< ::idl::game_info_t >* mcp_get_guides_info_by_uid_result_params::m_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline size_t mcp_get_guides_info_by_uid_result_params::result_list_size() const{
/*  */ return _m_result_list.size();
}
inline const ::idl::game_info_t& mcp_get_guides_info_by_uid_result_params::result_list(size_t i0) const{
 return _m_result_list.get(i0);
}
inline ::idl::game_info_t* mcp_get_guides_info_by_uid_result_params::mutable_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::game_info_t* mcp_get_guides_info_by_uid_result_params::m_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_guides_info_by_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_guides_info_by_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_guides_info_by_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_guides_info_by_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_guides_info_by_uid_response* mcp_get_guides_info_by_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_guides_info_by_uid_response* tmp=(mcp_get_guides_info_by_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_guides_info_by_uid_response(pool);
return tmp;
}
inline void mcp_get_guides_info_by_uid_response::destroy(mcp_get_guides_info_by_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_guides_info_by_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_guides_info_by_uid_response::mcp_get_guides_info_by_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_guides_info_by_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_guides_info_by_uid_response::mcp_get_guides_info_by_uid_response(const mcp_get_guides_info_by_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_guides_info_by_uid_result_params::create(_pool);
assign(v);
}
inline mcp_get_guides_info_by_uid_response::~mcp_get_guides_info_by_uid_response(){
if(_m_result_params){
::idl::mcp_get_guides_info_by_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_guides_info_by_uid_response& mcp_get_guides_info_by_uid_response::operator=(const mcp_get_guides_info_by_uid_response& v){
assign(v);
return *this;
}
inline void mcp_get_guides_info_by_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_guides_info_by_uid_response::check() const{
// @@mcp_get_guides_info_by_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_guides_info_by_uid_result_params& item=const_cast< ::idl::mcp_get_guides_info_by_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_guides_info_by_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_guides_info_by_uid_response& mcp_get_guides_info_by_uid_response::assign(const mcp_get_guides_info_by_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_guides_info_by_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_guides_info_by_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_guides_info_by_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_guides_info_by_uid_result_params& mcp_get_guides_info_by_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_guides_info_by_uid_result_params* mcp_get_guides_info_by_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_guides_info_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_guides_info_by_uid_result_params* mcp_get_guides_info_by_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_guides_info_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_guides_info_by_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_guides_info_by_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_guides_info_by_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_guides_info_by_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_get_guides_info_by_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_add_new_favorite_by_uid_params* mcp_add_new_favorite_by_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_new_favorite_by_uid_params* tmp=(mcp_add_new_favorite_by_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_new_favorite_by_uid_params(pool);
return tmp;
}
inline void mcp_add_new_favorite_by_uid_params::destroy(mcp_add_new_favorite_by_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_new_favorite_by_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_new_favorite_by_uid_params::mcp_add_new_favorite_by_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_m_favorites_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_new_favorite_by_uid_params::mcp_add_new_favorite_by_uid_params(const mcp_add_new_favorite_by_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_m_favorites_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_add_new_favorite_by_uid_params::~mcp_add_new_favorite_by_uid_params(){
}
inline mcp_add_new_favorite_by_uid_params& mcp_add_new_favorite_by_uid_params::operator=(const mcp_add_new_favorite_by_uid_params& v){
assign(v);
return *this;
}
inline void mcp_add_new_favorite_by_uid_params::clear(){
_m_u_id.clear();
_m_favorites_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_new_favorite_by_uid_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}
// @@string favorites_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "favorites_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_favorites_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_add_new_favorite_by_uid_params::detach(){
_m_u_id.detach();
_m_favorites_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_new_favorite_by_uid_params& mcp_add_new_favorite_by_uid_params::assign(const mcp_add_new_favorite_by_uid_params& v){
_m_u_id=v._m_u_id;
_m_favorites_id=v._m_favorites_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_new_favorite_by_uid_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_add_new_favorite_by_uid_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_add_new_favorite_by_uid_params& mcp_add_new_favorite_by_uid_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_new_favorite_by_uid_params& mcp_add_new_favorite_by_uid_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_new_favorite_by_uid_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline bool mcp_add_new_favorite_by_uid_params::has_favorites_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_add_new_favorite_by_uid_params::favorites_id(unsigned int* size) const{
return _m_favorites_id.get(size);
}
inline mcp_add_new_favorite_by_uid_params& mcp_add_new_favorite_by_uid_params::set_favorites_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_favorites_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_new_favorite_by_uid_params& mcp_add_new_favorite_by_uid_params::set_ptr_favorites_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_favorites_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_new_favorite_by_uid_params::clear_favorites_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_favorites_id.clear();
}
inline ::idl::Unknown* mcp_add_new_favorite_by_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_new_favorite_by_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_new_favorite_by_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_add_new_favorite_by_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_add_new_favorite_by_uid_result_params* mcp_add_new_favorite_by_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_new_favorite_by_uid_result_params* tmp=(mcp_add_new_favorite_by_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_new_favorite_by_uid_result_params(pool);
return tmp;
}
inline void mcp_add_new_favorite_by_uid_result_params::destroy(mcp_add_new_favorite_by_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_new_favorite_by_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_new_favorite_by_uid_result_params::mcp_add_new_favorite_by_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ret_code(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_new_favorite_by_uid_result_params::mcp_add_new_favorite_by_uid_result_params(const mcp_add_new_favorite_by_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ret_code(0)
,_unknown(_pool){
assign(v);
}
inline mcp_add_new_favorite_by_uid_result_params::~mcp_add_new_favorite_by_uid_result_params(){
}
inline mcp_add_new_favorite_by_uid_result_params& mcp_add_new_favorite_by_uid_result_params::operator=(const mcp_add_new_favorite_by_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_add_new_favorite_by_uid_result_params::clear(){
// _m_ret_code=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_new_favorite_by_uid_result_params::check() const{
// @@int32_t ret_code=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ret_code" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_ret_code;

}

::idl::McpackBean::check();
}
inline void mcp_add_new_favorite_by_uid_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_new_favorite_by_uid_result_params& mcp_add_new_favorite_by_uid_result_params::assign(const mcp_add_new_favorite_by_uid_result_params& v){
_m_ret_code=v._m_ret_code;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_new_favorite_by_uid_result_params::has_ret_code() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_add_new_favorite_by_uid_result_params::ret_code() const{
return _m_ret_code;
}
inline mcp_add_new_favorite_by_uid_result_params& mcp_add_new_favorite_by_uid_result_params::set_ret_code(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ret_code=v;
return *this;
}
inline void mcp_add_new_favorite_by_uid_result_params::clear_ret_code(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ret_code=0;
}
inline ::idl::Unknown* mcp_add_new_favorite_by_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_new_favorite_by_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_new_favorite_by_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_add_new_favorite_by_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_add_new_favorite_by_uid_response* mcp_add_new_favorite_by_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_new_favorite_by_uid_response* tmp=(mcp_add_new_favorite_by_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_new_favorite_by_uid_response(pool);
return tmp;
}
inline void mcp_add_new_favorite_by_uid_response::destroy(mcp_add_new_favorite_by_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_new_favorite_by_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_new_favorite_by_uid_response::mcp_add_new_favorite_by_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_add_new_favorite_by_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_new_favorite_by_uid_response::mcp_add_new_favorite_by_uid_response(const mcp_add_new_favorite_by_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_add_new_favorite_by_uid_result_params::create(_pool);
assign(v);
}
inline mcp_add_new_favorite_by_uid_response::~mcp_add_new_favorite_by_uid_response(){
if(_m_result_params){
::idl::mcp_add_new_favorite_by_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_add_new_favorite_by_uid_response& mcp_add_new_favorite_by_uid_response::operator=(const mcp_add_new_favorite_by_uid_response& v){
assign(v);
return *this;
}
inline void mcp_add_new_favorite_by_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_new_favorite_by_uid_response::check() const{
// @@mcp_add_new_favorite_by_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_add_new_favorite_by_uid_result_params& item=const_cast< ::idl::mcp_add_new_favorite_by_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_add_new_favorite_by_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_new_favorite_by_uid_response& mcp_add_new_favorite_by_uid_response::assign(const mcp_add_new_favorite_by_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_add_new_favorite_by_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_add_new_favorite_by_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_new_favorite_by_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_add_new_favorite_by_uid_result_params& mcp_add_new_favorite_by_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_add_new_favorite_by_uid_result_params* mcp_add_new_favorite_by_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_add_new_favorite_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_add_new_favorite_by_uid_result_params* mcp_add_new_favorite_by_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_add_new_favorite_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_add_new_favorite_by_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_add_new_favorite_by_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_new_favorite_by_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_new_favorite_by_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_add_new_favorite_by_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_remove_favorite_by_uid_params* mcp_remove_favorite_by_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_remove_favorite_by_uid_params* tmp=(mcp_remove_favorite_by_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_remove_favorite_by_uid_params(pool);
return tmp;
}
inline void mcp_remove_favorite_by_uid_params::destroy(mcp_remove_favorite_by_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_remove_favorite_by_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_remove_favorite_by_uid_params::mcp_remove_favorite_by_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_m_favorites_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_remove_favorite_by_uid_params::mcp_remove_favorite_by_uid_params(const mcp_remove_favorite_by_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_m_favorites_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_remove_favorite_by_uid_params::~mcp_remove_favorite_by_uid_params(){
}
inline mcp_remove_favorite_by_uid_params& mcp_remove_favorite_by_uid_params::operator=(const mcp_remove_favorite_by_uid_params& v){
assign(v);
return *this;
}
inline void mcp_remove_favorite_by_uid_params::clear(){
_m_u_id.clear();
_m_favorites_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_remove_favorite_by_uid_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}
// @@string favorites_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "favorites_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_favorites_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_remove_favorite_by_uid_params::detach(){
_m_u_id.detach();
_m_favorites_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_remove_favorite_by_uid_params& mcp_remove_favorite_by_uid_params::assign(const mcp_remove_favorite_by_uid_params& v){
_m_u_id=v._m_u_id;
_m_favorites_id=v._m_favorites_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_remove_favorite_by_uid_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_remove_favorite_by_uid_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_remove_favorite_by_uid_params& mcp_remove_favorite_by_uid_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_remove_favorite_by_uid_params& mcp_remove_favorite_by_uid_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_remove_favorite_by_uid_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline bool mcp_remove_favorite_by_uid_params::has_favorites_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_remove_favorite_by_uid_params::favorites_id(unsigned int* size) const{
return _m_favorites_id.get(size);
}
inline mcp_remove_favorite_by_uid_params& mcp_remove_favorite_by_uid_params::set_favorites_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_favorites_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_remove_favorite_by_uid_params& mcp_remove_favorite_by_uid_params::set_ptr_favorites_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_favorites_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_remove_favorite_by_uid_params::clear_favorites_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_favorites_id.clear();
}
inline ::idl::Unknown* mcp_remove_favorite_by_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_remove_favorite_by_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_remove_favorite_by_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_remove_favorite_by_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_remove_favorite_by_uid_result_params* mcp_remove_favorite_by_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_remove_favorite_by_uid_result_params* tmp=(mcp_remove_favorite_by_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_remove_favorite_by_uid_result_params(pool);
return tmp;
}
inline void mcp_remove_favorite_by_uid_result_params::destroy(mcp_remove_favorite_by_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_remove_favorite_by_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_remove_favorite_by_uid_result_params::mcp_remove_favorite_by_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ret_code(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_remove_favorite_by_uid_result_params::mcp_remove_favorite_by_uid_result_params(const mcp_remove_favorite_by_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ret_code(0)
,_unknown(_pool){
assign(v);
}
inline mcp_remove_favorite_by_uid_result_params::~mcp_remove_favorite_by_uid_result_params(){
}
inline mcp_remove_favorite_by_uid_result_params& mcp_remove_favorite_by_uid_result_params::operator=(const mcp_remove_favorite_by_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_remove_favorite_by_uid_result_params::clear(){
// _m_ret_code=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_remove_favorite_by_uid_result_params::check() const{
// @@int32_t ret_code=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ret_code" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_ret_code;

}

::idl::McpackBean::check();
}
inline void mcp_remove_favorite_by_uid_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_remove_favorite_by_uid_result_params& mcp_remove_favorite_by_uid_result_params::assign(const mcp_remove_favorite_by_uid_result_params& v){
_m_ret_code=v._m_ret_code;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_remove_favorite_by_uid_result_params::has_ret_code() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_remove_favorite_by_uid_result_params::ret_code() const{
return _m_ret_code;
}
inline mcp_remove_favorite_by_uid_result_params& mcp_remove_favorite_by_uid_result_params::set_ret_code(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ret_code=v;
return *this;
}
inline void mcp_remove_favorite_by_uid_result_params::clear_ret_code(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ret_code=0;
}
inline ::idl::Unknown* mcp_remove_favorite_by_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_remove_favorite_by_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_remove_favorite_by_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_remove_favorite_by_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_remove_favorite_by_uid_response* mcp_remove_favorite_by_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_remove_favorite_by_uid_response* tmp=(mcp_remove_favorite_by_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_remove_favorite_by_uid_response(pool);
return tmp;
}
inline void mcp_remove_favorite_by_uid_response::destroy(mcp_remove_favorite_by_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_remove_favorite_by_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_remove_favorite_by_uid_response::mcp_remove_favorite_by_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_remove_favorite_by_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_remove_favorite_by_uid_response::mcp_remove_favorite_by_uid_response(const mcp_remove_favorite_by_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_remove_favorite_by_uid_result_params::create(_pool);
assign(v);
}
inline mcp_remove_favorite_by_uid_response::~mcp_remove_favorite_by_uid_response(){
if(_m_result_params){
::idl::mcp_remove_favorite_by_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_remove_favorite_by_uid_response& mcp_remove_favorite_by_uid_response::operator=(const mcp_remove_favorite_by_uid_response& v){
assign(v);
return *this;
}
inline void mcp_remove_favorite_by_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_remove_favorite_by_uid_response::check() const{
// @@mcp_remove_favorite_by_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_remove_favorite_by_uid_result_params& item=const_cast< ::idl::mcp_remove_favorite_by_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_remove_favorite_by_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_remove_favorite_by_uid_response& mcp_remove_favorite_by_uid_response::assign(const mcp_remove_favorite_by_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_remove_favorite_by_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_remove_favorite_by_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_remove_favorite_by_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_remove_favorite_by_uid_result_params& mcp_remove_favorite_by_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_remove_favorite_by_uid_result_params* mcp_remove_favorite_by_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_remove_favorite_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_remove_favorite_by_uid_result_params* mcp_remove_favorite_by_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_remove_favorite_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_remove_favorite_by_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_remove_favorite_by_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_remove_favorite_by_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_remove_favorite_by_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_remove_favorite_by_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_favorites_count_by_uid_params* mcp_get_favorites_count_by_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_favorites_count_by_uid_params* tmp=(mcp_get_favorites_count_by_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_favorites_count_by_uid_params(pool);
return tmp;
}
inline void mcp_get_favorites_count_by_uid_params::destroy(mcp_get_favorites_count_by_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_favorites_count_by_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_favorites_count_by_uid_params::mcp_get_favorites_count_by_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_favorites_count_by_uid_params::mcp_get_favorites_count_by_uid_params(const mcp_get_favorites_count_by_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_favorites_count_by_uid_params::~mcp_get_favorites_count_by_uid_params(){
}
inline mcp_get_favorites_count_by_uid_params& mcp_get_favorites_count_by_uid_params::operator=(const mcp_get_favorites_count_by_uid_params& v){
assign(v);
return *this;
}
inline void mcp_get_favorites_count_by_uid_params::clear(){
_m_u_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_favorites_count_by_uid_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_favorites_count_by_uid_params::detach(){
_m_u_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_favorites_count_by_uid_params& mcp_get_favorites_count_by_uid_params::assign(const mcp_get_favorites_count_by_uid_params& v){
_m_u_id=v._m_u_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_favorites_count_by_uid_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_favorites_count_by_uid_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_get_favorites_count_by_uid_params& mcp_get_favorites_count_by_uid_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_favorites_count_by_uid_params& mcp_get_favorites_count_by_uid_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_favorites_count_by_uid_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline ::idl::Unknown* mcp_get_favorites_count_by_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_favorites_count_by_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_favorites_count_by_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_get_favorites_count_by_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_favorites_count_by_uid_result_params* mcp_get_favorites_count_by_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_favorites_count_by_uid_result_params* tmp=(mcp_get_favorites_count_by_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_favorites_count_by_uid_result_params(pool);
return tmp;
}
inline void mcp_get_favorites_count_by_uid_result_params::destroy(mcp_get_favorites_count_by_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_favorites_count_by_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_favorites_count_by_uid_result_params::mcp_get_favorites_count_by_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_favorites_count_by_uid_result_params::mcp_get_favorites_count_by_uid_result_params(const mcp_get_favorites_count_by_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_favorites_count_by_uid_result_params::~mcp_get_favorites_count_by_uid_result_params(){
}
inline mcp_get_favorites_count_by_uid_result_params& mcp_get_favorites_count_by_uid_result_params::operator=(const mcp_get_favorites_count_by_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_favorites_count_by_uid_result_params::clear(){
// _m_count=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_favorites_count_by_uid_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}

::idl::McpackBean::check();
}
inline void mcp_get_favorites_count_by_uid_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_favorites_count_by_uid_result_params& mcp_get_favorites_count_by_uid_result_params::assign(const mcp_get_favorites_count_by_uid_result_params& v){
_m_count=v._m_count;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_favorites_count_by_uid_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_favorites_count_by_uid_result_params::count() const{
return _m_count;
}
inline mcp_get_favorites_count_by_uid_result_params& mcp_get_favorites_count_by_uid_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_favorites_count_by_uid_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline ::idl::Unknown* mcp_get_favorites_count_by_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_favorites_count_by_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_favorites_count_by_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_favorites_count_by_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_favorites_count_by_uid_response* mcp_get_favorites_count_by_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_favorites_count_by_uid_response* tmp=(mcp_get_favorites_count_by_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_favorites_count_by_uid_response(pool);
return tmp;
}
inline void mcp_get_favorites_count_by_uid_response::destroy(mcp_get_favorites_count_by_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_favorites_count_by_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_favorites_count_by_uid_response::mcp_get_favorites_count_by_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_favorites_count_by_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_favorites_count_by_uid_response::mcp_get_favorites_count_by_uid_response(const mcp_get_favorites_count_by_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_favorites_count_by_uid_result_params::create(_pool);
assign(v);
}
inline mcp_get_favorites_count_by_uid_response::~mcp_get_favorites_count_by_uid_response(){
if(_m_result_params){
::idl::mcp_get_favorites_count_by_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_favorites_count_by_uid_response& mcp_get_favorites_count_by_uid_response::operator=(const mcp_get_favorites_count_by_uid_response& v){
assign(v);
return *this;
}
inline void mcp_get_favorites_count_by_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_favorites_count_by_uid_response::check() const{
// @@mcp_get_favorites_count_by_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_favorites_count_by_uid_result_params& item=const_cast< ::idl::mcp_get_favorites_count_by_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_favorites_count_by_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_favorites_count_by_uid_response& mcp_get_favorites_count_by_uid_response::assign(const mcp_get_favorites_count_by_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_favorites_count_by_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_favorites_count_by_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_favorites_count_by_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_favorites_count_by_uid_result_params& mcp_get_favorites_count_by_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_favorites_count_by_uid_result_params* mcp_get_favorites_count_by_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_favorites_count_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_favorites_count_by_uid_result_params* mcp_get_favorites_count_by_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_favorites_count_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_favorites_count_by_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_favorites_count_by_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_favorites_count_by_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_favorites_count_by_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_get_favorites_count_by_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_favorites_info_by_uid_params* mcp_get_favorites_info_by_uid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_favorites_info_by_uid_params* tmp=(mcp_get_favorites_info_by_uid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_favorites_info_by_uid_params(pool);
return tmp;
}
inline void mcp_get_favorites_info_by_uid_params::destroy(mcp_get_favorites_info_by_uid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_favorites_info_by_uid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_favorites_info_by_uid_params::mcp_get_favorites_info_by_uid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_u_id(_pool)
,_m_img_types(_pool)
,_m_filter(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_favorites_info_by_uid_params::mcp_get_favorites_info_by_uid_params(const mcp_get_favorites_info_by_uid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_u_id(_pool)
,_m_img_types(_pool)
,_m_filter(_pool)
,_m_unit_num(0)
,_m_unit_times(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_favorites_info_by_uid_params::~mcp_get_favorites_info_by_uid_params(){
}
inline mcp_get_favorites_info_by_uid_params& mcp_get_favorites_info_by_uid_params::operator=(const mcp_get_favorites_info_by_uid_params& v){
assign(v);
return *this;
}
inline void mcp_get_favorites_info_by_uid_params::clear(){
_m_u_id.clear();
_m_img_types.clear();
_m_filter.clear();
// _m_unit_num=0;
// _m_unit_times=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_favorites_info_by_uid_params::check() const{
// @@string u_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "u_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_u_id.get();

}
// @@string img_types=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "img_types" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_img_types.get();

}
// @@string filter=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "filter" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_filter.get();

}
// @@uint32_t unit_num=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_num" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_num;

}
// @@uint32_t unit_times=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "unit_times" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_unit_times;

}

::idl::McpackBean::check();
}
inline void mcp_get_favorites_info_by_uid_params::detach(){
_m_u_id.detach();
_m_img_types.detach();
_m_filter.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_favorites_info_by_uid_params& mcp_get_favorites_info_by_uid_params::assign(const mcp_get_favorites_info_by_uid_params& v){
_m_u_id=v._m_u_id;
_m_img_types=v._m_img_types;
_m_filter=v._m_filter;
_m_unit_num=v._m_unit_num;
_m_unit_times=v._m_unit_times;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_favorites_info_by_uid_params::has_u_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_favorites_info_by_uid_params::u_id(unsigned int* size) const{
return _m_u_id.get(size);
}
inline mcp_get_favorites_info_by_uid_params& mcp_get_favorites_info_by_uid_params::set_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_favorites_info_by_uid_params& mcp_get_favorites_info_by_uid_params::set_ptr_u_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_u_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_favorites_info_by_uid_params::clear_u_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_u_id.clear();
}
inline bool mcp_get_favorites_info_by_uid_params::has_img_types() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_favorites_info_by_uid_params::img_types(unsigned int* size) const{
return _m_img_types.get(size);
}
inline mcp_get_favorites_info_by_uid_params& mcp_get_favorites_info_by_uid_params::set_img_types(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_img_types.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_favorites_info_by_uid_params& mcp_get_favorites_info_by_uid_params::set_ptr_img_types(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_img_types.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_favorites_info_by_uid_params::clear_img_types(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_img_types.clear();
}
inline bool mcp_get_favorites_info_by_uid_params::has_filter() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_favorites_info_by_uid_params::filter(unsigned int* size) const{
return _m_filter.get(size);
}
inline mcp_get_favorites_info_by_uid_params& mcp_get_favorites_info_by_uid_params::set_filter(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_filter.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_favorites_info_by_uid_params& mcp_get_favorites_info_by_uid_params::set_ptr_filter(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_filter.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_favorites_info_by_uid_params::clear_filter(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_filter.clear();
}
inline bool mcp_get_favorites_info_by_uid_params::has_unit_num() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline uint32_t mcp_get_favorites_info_by_uid_params::unit_num() const{
return _m_unit_num;
}
inline mcp_get_favorites_info_by_uid_params& mcp_get_favorites_info_by_uid_params::set_unit_num(uint32_t v){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_unit_num=v;
return *this;
}
inline void mcp_get_favorites_info_by_uid_params::clear_unit_num(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_unit_num=0;
}
inline bool mcp_get_favorites_info_by_uid_params::has_unit_times() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_favorites_info_by_uid_params::unit_times() const{
return _m_unit_times;
}
inline mcp_get_favorites_info_by_uid_params& mcp_get_favorites_info_by_uid_params::set_unit_times(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_unit_times=v;
return *this;
}
inline void mcp_get_favorites_info_by_uid_params::clear_unit_times(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_unit_times=0;
}
inline ::idl::Unknown* mcp_get_favorites_info_by_uid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_favorites_info_by_uid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_favorites_info_by_uid_params::unknown(){
return _unknown;
}
inline size_t mcp_get_favorites_info_by_uid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_favorites_info_by_uid_result_params* mcp_get_favorites_info_by_uid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_favorites_info_by_uid_result_params* tmp=(mcp_get_favorites_info_by_uid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_favorites_info_by_uid_result_params(pool);
return tmp;
}
inline void mcp_get_favorites_info_by_uid_result_params::destroy(mcp_get_favorites_info_by_uid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_favorites_info_by_uid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_favorites_info_by_uid_result_params::mcp_get_favorites_info_by_uid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_favorites_info_by_uid_result_params::mcp_get_favorites_info_by_uid_result_params(const mcp_get_favorites_info_by_uid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_favorites_info_by_uid_result_params::~mcp_get_favorites_info_by_uid_result_params(){
}
inline mcp_get_favorites_info_by_uid_result_params& mcp_get_favorites_info_by_uid_result_params::operator=(const mcp_get_favorites_info_by_uid_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_favorites_info_by_uid_result_params::clear(){
// _m_count=0;
_m_result_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_favorites_info_by_uid_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@game_content_download_info_t result_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_list" << "' not found";
}
{
// level 0 begin
typeof(_m_result_list)& lr0=(_m_result_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_content_download_info_t& item=const_cast< ::idl::game_content_download_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_favorites_info_by_uid_result_params::detach(){
_m_result_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_favorites_info_by_uid_result_params& mcp_get_favorites_info_by_uid_result_params::assign(const mcp_get_favorites_info_by_uid_result_params& v){
_m_count=v._m_count;
_m_result_list=v._m_result_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_favorites_info_by_uid_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_favorites_info_by_uid_result_params::count() const{
return _m_count;
}
inline mcp_get_favorites_info_by_uid_result_params& mcp_get_favorites_info_by_uid_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_favorites_info_by_uid_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_favorites_info_by_uid_result_params::has_result_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_content_download_info_t >& mcp_get_favorites_info_by_uid_result_params::result_list() const{
 return _m_result_list;
}
inline void mcp_get_favorites_info_by_uid_result_params::clear_result_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_result_list.clear();
}
inline ::idl::vector< ::idl::game_content_download_info_t >* mcp_get_favorites_info_by_uid_result_params::mutable_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline ::idl::vector< ::idl::game_content_download_info_t >* mcp_get_favorites_info_by_uid_result_params::m_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline size_t mcp_get_favorites_info_by_uid_result_params::result_list_size() const{
/*  */ return _m_result_list.size();
}
inline const ::idl::game_content_download_info_t& mcp_get_favorites_info_by_uid_result_params::result_list(size_t i0) const{
 return _m_result_list.get(i0);
}
inline ::idl::game_content_download_info_t* mcp_get_favorites_info_by_uid_result_params::mutable_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::game_content_download_info_t* mcp_get_favorites_info_by_uid_result_params::m_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_favorites_info_by_uid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_favorites_info_by_uid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_favorites_info_by_uid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_favorites_info_by_uid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_favorites_info_by_uid_response* mcp_get_favorites_info_by_uid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_favorites_info_by_uid_response* tmp=(mcp_get_favorites_info_by_uid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_favorites_info_by_uid_response(pool);
return tmp;
}
inline void mcp_get_favorites_info_by_uid_response::destroy(mcp_get_favorites_info_by_uid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_favorites_info_by_uid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_favorites_info_by_uid_response::mcp_get_favorites_info_by_uid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_favorites_info_by_uid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_favorites_info_by_uid_response::mcp_get_favorites_info_by_uid_response(const mcp_get_favorites_info_by_uid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_favorites_info_by_uid_result_params::create(_pool);
assign(v);
}
inline mcp_get_favorites_info_by_uid_response::~mcp_get_favorites_info_by_uid_response(){
if(_m_result_params){
::idl::mcp_get_favorites_info_by_uid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_favorites_info_by_uid_response& mcp_get_favorites_info_by_uid_response::operator=(const mcp_get_favorites_info_by_uid_response& v){
assign(v);
return *this;
}
inline void mcp_get_favorites_info_by_uid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_favorites_info_by_uid_response::check() const{
// @@mcp_get_favorites_info_by_uid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_favorites_info_by_uid_result_params& item=const_cast< ::idl::mcp_get_favorites_info_by_uid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_favorites_info_by_uid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_favorites_info_by_uid_response& mcp_get_favorites_info_by_uid_response::assign(const mcp_get_favorites_info_by_uid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_favorites_info_by_uid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_favorites_info_by_uid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_favorites_info_by_uid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_favorites_info_by_uid_result_params& mcp_get_favorites_info_by_uid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_favorites_info_by_uid_result_params* mcp_get_favorites_info_by_uid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_favorites_info_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_favorites_info_by_uid_result_params* mcp_get_favorites_info_by_uid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_favorites_info_by_uid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_favorites_info_by_uid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_favorites_info_by_uid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_favorites_info_by_uid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_favorites_info_by_uid_response::unknown(){
return _unknown;
}
inline size_t mcp_get_favorites_info_by_uid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_grab_list_params* mcp_get_grab_list_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_grab_list_params* tmp=(mcp_get_grab_list_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_grab_list_params(pool);
return tmp;
}
inline void mcp_get_grab_list_params::destroy(mcp_get_grab_list_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_grab_list_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_grab_list_params::mcp_get_grab_list_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_type_id(_pool)
,_m_c_id(_pool)
,_m_id(0)
,_m_user_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_grab_list_params::mcp_get_grab_list_params(const mcp_get_grab_list_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_type_id(_pool)
,_m_c_id(_pool)
,_m_id(0)
,_m_user_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_grab_list_params::~mcp_get_grab_list_params(){
}
inline mcp_get_grab_list_params& mcp_get_grab_list_params::operator=(const mcp_get_grab_list_params& v){
assign(v);
return *this;
}
inline void mcp_get_grab_list_params::clear(){
_m_type_id.clear();
_m_c_id.clear();
// _m_id=0;
_m_user_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_grab_list_params::check() const{
// @@string type_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "type_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_type_id.get();

}
// @@string c_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@uint32_t id=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_id;

}
// @@string user_id=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}
// @@uint32_t page=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_grab_list_params::detach(){
_m_type_id.detach();
_m_c_id.detach();
_m_user_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_grab_list_params& mcp_get_grab_list_params::assign(const mcp_get_grab_list_params& v){
_m_type_id=v._m_type_id;
_m_c_id=v._m_c_id;
_m_id=v._m_id;
_m_user_id=v._m_user_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_grab_list_params::has_type_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_grab_list_params::type_id(unsigned int* size) const{
return _m_type_id.get(size);
}
inline mcp_get_grab_list_params& mcp_get_grab_list_params::set_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_grab_list_params& mcp_get_grab_list_params::set_ptr_type_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_type_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_grab_list_params::clear_type_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_type_id.clear();
}
inline bool mcp_get_grab_list_params::has_c_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_grab_list_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_get_grab_list_params& mcp_get_grab_list_params::set_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_grab_list_params& mcp_get_grab_list_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_grab_list_params::clear_c_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_c_id.clear();
}
inline bool mcp_get_grab_list_params::has_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_grab_list_params::id() const{
return _m_id;
}
inline mcp_get_grab_list_params& mcp_get_grab_list_params::set_id(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_id=v;
return *this;
}
inline void mcp_get_grab_list_params::clear_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_id=0;
}
inline bool mcp_get_grab_list_params::has_user_id() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_grab_list_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_get_grab_list_params& mcp_get_grab_list_params::set_user_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_grab_list_params& mcp_get_grab_list_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_grab_list_params::clear_user_id(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_user_id.clear();
}
inline bool mcp_get_grab_list_params::has_page() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline uint32_t mcp_get_grab_list_params::page() const{
return _m_page;
}
inline mcp_get_grab_list_params& mcp_get_grab_list_params::set_page(uint32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_grab_list_params::clear_page(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_page=0;
}
inline bool mcp_get_grab_list_params::has_page_size() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline uint32_t mcp_get_grab_list_params::page_size() const{
return _m_page_size;
}
inline mcp_get_grab_list_params& mcp_get_grab_list_params::set_page_size(uint32_t v){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_grab_list_params::clear_page_size(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_grab_list_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_grab_list_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_grab_list_params::unknown(){
return _unknown;
}
inline size_t mcp_get_grab_list_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_grab_list_result_params* mcp_get_grab_list_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_grab_list_result_params* tmp=(mcp_get_grab_list_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_grab_list_result_params(pool);
return tmp;
}
inline void mcp_get_grab_list_result_params::destroy(mcp_get_grab_list_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_grab_list_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_grab_list_result_params::mcp_get_grab_list_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_grab_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_grab_list_result_params::mcp_get_grab_list_result_params(const mcp_get_grab_list_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_grab_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_grab_list_result_params::~mcp_get_grab_list_result_params(){
}
inline mcp_get_grab_list_result_params& mcp_get_grab_list_result_params::operator=(const mcp_get_grab_list_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_grab_list_result_params::clear(){
// _m_count=0;
_m_grab_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_grab_list_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@grab_info_t grab_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "grab_list" << "' not found";
}
{
// level 0 begin
typeof(_m_grab_list)& lr0=(_m_grab_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::grab_info_t& item=const_cast< ::idl::grab_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_grab_list_result_params::detach(){
_m_grab_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_grab_list_result_params& mcp_get_grab_list_result_params::assign(const mcp_get_grab_list_result_params& v){
_m_count=v._m_count;
_m_grab_list=v._m_grab_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_grab_list_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_grab_list_result_params::count() const{
return _m_count;
}
inline mcp_get_grab_list_result_params& mcp_get_grab_list_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_grab_list_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_grab_list_result_params::has_grab_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::grab_info_t >& mcp_get_grab_list_result_params::grab_list() const{
 return _m_grab_list;
}
inline void mcp_get_grab_list_result_params::clear_grab_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_grab_list.clear();
}
inline ::idl::vector< ::idl::grab_info_t >* mcp_get_grab_list_result_params::mutable_grab_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_grab_list);
}
inline ::idl::vector< ::idl::grab_info_t >* mcp_get_grab_list_result_params::m_grab_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_grab_list);
}
inline size_t mcp_get_grab_list_result_params::grab_list_size() const{
/*  */ return _m_grab_list.size();
}
inline const ::idl::grab_info_t& mcp_get_grab_list_result_params::grab_list(size_t i0) const{
 return _m_grab_list.get(i0);
}
inline ::idl::grab_info_t* mcp_get_grab_list_result_params::mutable_grab_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_grab_list.mutable_get(i0);
}
inline ::idl::grab_info_t* mcp_get_grab_list_result_params::m_grab_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_grab_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_grab_list_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_grab_list_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_grab_list_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_grab_list_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_grab_list_response* mcp_get_grab_list_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_grab_list_response* tmp=(mcp_get_grab_list_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_grab_list_response(pool);
return tmp;
}
inline void mcp_get_grab_list_response::destroy(mcp_get_grab_list_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_grab_list_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_grab_list_response::mcp_get_grab_list_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_grab_list_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_grab_list_response::mcp_get_grab_list_response(const mcp_get_grab_list_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_grab_list_result_params::create(_pool);
assign(v);
}
inline mcp_get_grab_list_response::~mcp_get_grab_list_response(){
if(_m_result_params){
::idl::mcp_get_grab_list_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_grab_list_response& mcp_get_grab_list_response::operator=(const mcp_get_grab_list_response& v){
assign(v);
return *this;
}
inline void mcp_get_grab_list_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_grab_list_response::check() const{
// @@mcp_get_grab_list_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_grab_list_result_params& item=const_cast< ::idl::mcp_get_grab_list_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_grab_list_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_grab_list_response& mcp_get_grab_list_response::assign(const mcp_get_grab_list_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_grab_list_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_grab_list_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_grab_list_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_grab_list_result_params& mcp_get_grab_list_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_grab_list_result_params* mcp_get_grab_list_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_grab_list_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_grab_list_result_params* mcp_get_grab_list_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_grab_list_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_grab_list_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_grab_list_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_grab_list_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_grab_list_response::unknown(){
return _unknown;
}
inline size_t mcp_get_grab_list_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_user_grab_num_list_params* mcp_get_user_grab_num_list_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_user_grab_num_list_params* tmp=(mcp_get_user_grab_num_list_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_user_grab_num_list_params(pool);
return tmp;
}
inline void mcp_get_user_grab_num_list_params::destroy(mcp_get_user_grab_num_list_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_user_grab_num_list_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_user_grab_num_list_params::mcp_get_user_grab_num_list_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_user_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_user_grab_num_list_params::mcp_get_user_grab_num_list_params(const mcp_get_user_grab_num_list_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_user_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_user_grab_num_list_params::~mcp_get_user_grab_num_list_params(){
}
inline mcp_get_user_grab_num_list_params& mcp_get_user_grab_num_list_params::operator=(const mcp_get_user_grab_num_list_params& v){
assign(v);
return *this;
}
inline void mcp_get_user_grab_num_list_params::clear(){
_m_user_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_user_grab_num_list_params::check() const{
// @@string user_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}
// @@uint32_t page=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_user_grab_num_list_params::detach(){
_m_user_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_user_grab_num_list_params& mcp_get_user_grab_num_list_params::assign(const mcp_get_user_grab_num_list_params& v){
_m_user_id=v._m_user_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_user_grab_num_list_params::has_user_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_user_grab_num_list_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_get_user_grab_num_list_params& mcp_get_user_grab_num_list_params::set_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_user_grab_num_list_params& mcp_get_user_grab_num_list_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_user_grab_num_list_params::clear_user_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_user_id.clear();
}
inline bool mcp_get_user_grab_num_list_params::has_page() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_user_grab_num_list_params::page() const{
return _m_page;
}
inline mcp_get_user_grab_num_list_params& mcp_get_user_grab_num_list_params::set_page(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_user_grab_num_list_params::clear_page(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page=0;
}
inline bool mcp_get_user_grab_num_list_params::has_page_size() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_user_grab_num_list_params::page_size() const{
return _m_page_size;
}
inline mcp_get_user_grab_num_list_params& mcp_get_user_grab_num_list_params::set_page_size(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_user_grab_num_list_params::clear_page_size(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_user_grab_num_list_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_user_grab_num_list_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_user_grab_num_list_params::unknown(){
return _unknown;
}
inline size_t mcp_get_user_grab_num_list_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_user_grab_num_list_result_params* mcp_get_user_grab_num_list_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_user_grab_num_list_result_params* tmp=(mcp_get_user_grab_num_list_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_user_grab_num_list_result_params(pool);
return tmp;
}
inline void mcp_get_user_grab_num_list_result_params::destroy(mcp_get_user_grab_num_list_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_user_grab_num_list_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_user_grab_num_list_result_params::mcp_get_user_grab_num_list_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_user_grab_num_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_user_grab_num_list_result_params::mcp_get_user_grab_num_list_result_params(const mcp_get_user_grab_num_list_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_user_grab_num_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_user_grab_num_list_result_params::~mcp_get_user_grab_num_list_result_params(){
}
inline mcp_get_user_grab_num_list_result_params& mcp_get_user_grab_num_list_result_params::operator=(const mcp_get_user_grab_num_list_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_user_grab_num_list_result_params::clear(){
// _m_count=0;
_m_user_grab_num_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_user_grab_num_list_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@user_grab_number_t user_grab_num_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_grab_num_list" << "' not found";
}
{
// level 0 begin
typeof(_m_user_grab_num_list)& lr0=(_m_user_grab_num_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::user_grab_number_t& item=const_cast< ::idl::user_grab_number_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_user_grab_num_list_result_params::detach(){
_m_user_grab_num_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_user_grab_num_list_result_params& mcp_get_user_grab_num_list_result_params::assign(const mcp_get_user_grab_num_list_result_params& v){
_m_count=v._m_count;
_m_user_grab_num_list=v._m_user_grab_num_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_user_grab_num_list_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_user_grab_num_list_result_params::count() const{
return _m_count;
}
inline mcp_get_user_grab_num_list_result_params& mcp_get_user_grab_num_list_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_user_grab_num_list_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_user_grab_num_list_result_params::has_user_grab_num_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::user_grab_number_t >& mcp_get_user_grab_num_list_result_params::user_grab_num_list() const{
 return _m_user_grab_num_list;
}
inline void mcp_get_user_grab_num_list_result_params::clear_user_grab_num_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_user_grab_num_list.clear();
}
inline ::idl::vector< ::idl::user_grab_number_t >* mcp_get_user_grab_num_list_result_params::mutable_user_grab_num_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_user_grab_num_list);
}
inline ::idl::vector< ::idl::user_grab_number_t >* mcp_get_user_grab_num_list_result_params::m_user_grab_num_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_user_grab_num_list);
}
inline size_t mcp_get_user_grab_num_list_result_params::user_grab_num_list_size() const{
/*  */ return _m_user_grab_num_list.size();
}
inline const ::idl::user_grab_number_t& mcp_get_user_grab_num_list_result_params::user_grab_num_list(size_t i0) const{
 return _m_user_grab_num_list.get(i0);
}
inline ::idl::user_grab_number_t* mcp_get_user_grab_num_list_result_params::mutable_user_grab_num_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_user_grab_num_list.mutable_get(i0);
}
inline ::idl::user_grab_number_t* mcp_get_user_grab_num_list_result_params::m_user_grab_num_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_user_grab_num_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_user_grab_num_list_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_user_grab_num_list_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_user_grab_num_list_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_user_grab_num_list_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_user_grab_num_list_response* mcp_get_user_grab_num_list_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_user_grab_num_list_response* tmp=(mcp_get_user_grab_num_list_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_user_grab_num_list_response(pool);
return tmp;
}
inline void mcp_get_user_grab_num_list_response::destroy(mcp_get_user_grab_num_list_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_user_grab_num_list_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_user_grab_num_list_response::mcp_get_user_grab_num_list_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_user_grab_num_list_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_user_grab_num_list_response::mcp_get_user_grab_num_list_response(const mcp_get_user_grab_num_list_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_user_grab_num_list_result_params::create(_pool);
assign(v);
}
inline mcp_get_user_grab_num_list_response::~mcp_get_user_grab_num_list_response(){
if(_m_result_params){
::idl::mcp_get_user_grab_num_list_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_user_grab_num_list_response& mcp_get_user_grab_num_list_response::operator=(const mcp_get_user_grab_num_list_response& v){
assign(v);
return *this;
}
inline void mcp_get_user_grab_num_list_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_user_grab_num_list_response::check() const{
// @@mcp_get_user_grab_num_list_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_user_grab_num_list_result_params& item=const_cast< ::idl::mcp_get_user_grab_num_list_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_user_grab_num_list_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_user_grab_num_list_response& mcp_get_user_grab_num_list_response::assign(const mcp_get_user_grab_num_list_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_user_grab_num_list_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_user_grab_num_list_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_user_grab_num_list_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_user_grab_num_list_result_params& mcp_get_user_grab_num_list_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_user_grab_num_list_result_params* mcp_get_user_grab_num_list_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_user_grab_num_list_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_user_grab_num_list_result_params* mcp_get_user_grab_num_list_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_user_grab_num_list_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_user_grab_num_list_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_user_grab_num_list_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_user_grab_num_list_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_user_grab_num_list_response::unknown(){
return _unknown;
}
inline size_t mcp_get_user_grab_num_list_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_common_adv_info_params* mcp_get_common_adv_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_common_adv_info_params* tmp=(mcp_get_common_adv_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_common_adv_info_params(pool);
return tmp;
}
inline void mcp_get_common_adv_info_params::destroy(mcp_get_common_adv_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_common_adv_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_common_adv_info_params::mcp_get_common_adv_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_common_adv_info_params::mcp_get_common_adv_info_params(const mcp_get_common_adv_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_common_adv_info_params::~mcp_get_common_adv_info_params(){
}
inline mcp_get_common_adv_info_params& mcp_get_common_adv_info_params::operator=(const mcp_get_common_adv_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_common_adv_info_params::clear(){
_m_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_common_adv_info_params::check() const{
// @@string id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_common_adv_info_params::detach(){
_m_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_common_adv_info_params& mcp_get_common_adv_info_params::assign(const mcp_get_common_adv_info_params& v){
_m_id=v._m_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_common_adv_info_params::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_common_adv_info_params::id(unsigned int* size) const{
return _m_id.get(size);
}
inline mcp_get_common_adv_info_params& mcp_get_common_adv_info_params::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_common_adv_info_params& mcp_get_common_adv_info_params::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_common_adv_info_params::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline ::idl::Unknown* mcp_get_common_adv_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_common_adv_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_common_adv_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_common_adv_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_common_adv_info_result_params* mcp_get_common_adv_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_common_adv_info_result_params* tmp=(mcp_get_common_adv_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_common_adv_info_result_params(pool);
return tmp;
}
inline void mcp_get_common_adv_info_result_params::destroy(mcp_get_common_adv_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_common_adv_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_common_adv_info_result_params::mcp_get_common_adv_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_common_adv_info_result_params::mcp_get_common_adv_info_result_params(const mcp_get_common_adv_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_common_adv_info_result_params::~mcp_get_common_adv_info_result_params(){
}
inline mcp_get_common_adv_info_result_params& mcp_get_common_adv_info_result_params::operator=(const mcp_get_common_adv_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_common_adv_info_result_params::clear(){
_m_info.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_common_adv_info_result_params::check() const{
// @@string info=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_common_adv_info_result_params::detach(){
_m_info.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_common_adv_info_result_params& mcp_get_common_adv_info_result_params::assign(const mcp_get_common_adv_info_result_params& v){
_m_info=v._m_info;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_common_adv_info_result_params::has_info() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_common_adv_info_result_params::info(unsigned int* size) const{
return _m_info.get(size);
}
inline mcp_get_common_adv_info_result_params& mcp_get_common_adv_info_result_params::set_info(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_common_adv_info_result_params& mcp_get_common_adv_info_result_params::set_ptr_info(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_common_adv_info_result_params::clear_info(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info.clear();
}
inline ::idl::Unknown* mcp_get_common_adv_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_common_adv_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_common_adv_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_common_adv_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_common_adv_info_response* mcp_get_common_adv_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_common_adv_info_response* tmp=(mcp_get_common_adv_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_common_adv_info_response(pool);
return tmp;
}
inline void mcp_get_common_adv_info_response::destroy(mcp_get_common_adv_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_common_adv_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_common_adv_info_response::mcp_get_common_adv_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_common_adv_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_common_adv_info_response::mcp_get_common_adv_info_response(const mcp_get_common_adv_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_common_adv_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_common_adv_info_response::~mcp_get_common_adv_info_response(){
if(_m_result_params){
::idl::mcp_get_common_adv_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_common_adv_info_response& mcp_get_common_adv_info_response::operator=(const mcp_get_common_adv_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_common_adv_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_common_adv_info_response::check() const{
// @@mcp_get_common_adv_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_common_adv_info_result_params& item=const_cast< ::idl::mcp_get_common_adv_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_common_adv_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_common_adv_info_response& mcp_get_common_adv_info_response::assign(const mcp_get_common_adv_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_common_adv_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_common_adv_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_common_adv_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_common_adv_info_result_params& mcp_get_common_adv_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_common_adv_info_result_params* mcp_get_common_adv_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_common_adv_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_common_adv_info_result_params* mcp_get_common_adv_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_common_adv_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_common_adv_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_common_adv_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_common_adv_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_common_adv_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_common_adv_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_pt_game_basic_list_by_game_id_params* mcp_get_pt_game_basic_list_by_game_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_pt_game_basic_list_by_game_id_params* tmp=(mcp_get_pt_game_basic_list_by_game_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_pt_game_basic_list_by_game_id_params(pool);
return tmp;
}
inline void mcp_get_pt_game_basic_list_by_game_id_params::destroy(mcp_get_pt_game_basic_list_by_game_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_pt_game_basic_list_by_game_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_pt_game_basic_list_by_game_id_params::mcp_get_pt_game_basic_list_by_game_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_game_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_pt_game_basic_list_by_game_id_params::mcp_get_pt_game_basic_list_by_game_id_params(const mcp_get_pt_game_basic_list_by_game_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_game_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_pt_game_basic_list_by_game_id_params::~mcp_get_pt_game_basic_list_by_game_id_params(){
}
inline mcp_get_pt_game_basic_list_by_game_id_params& mcp_get_pt_game_basic_list_by_game_id_params::operator=(const mcp_get_pt_game_basic_list_by_game_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_pt_game_basic_list_by_game_id_params::clear(){
_m_game_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_pt_game_basic_list_by_game_id_params::check() const{
// @@string game_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_pt_game_basic_list_by_game_id_params::detach(){
_m_game_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_pt_game_basic_list_by_game_id_params& mcp_get_pt_game_basic_list_by_game_id_params::assign(const mcp_get_pt_game_basic_list_by_game_id_params& v){
_m_game_id=v._m_game_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_pt_game_basic_list_by_game_id_params::has_game_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_pt_game_basic_list_by_game_id_params::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline mcp_get_pt_game_basic_list_by_game_id_params& mcp_get_pt_game_basic_list_by_game_id_params::set_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_pt_game_basic_list_by_game_id_params& mcp_get_pt_game_basic_list_by_game_id_params::set_ptr_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_pt_game_basic_list_by_game_id_params::clear_game_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_game_id.clear();
}
inline ::idl::Unknown* mcp_get_pt_game_basic_list_by_game_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_pt_game_basic_list_by_game_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_pt_game_basic_list_by_game_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_pt_game_basic_list_by_game_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_pt_game_basic_list_by_game_id_result_params* mcp_get_pt_game_basic_list_by_game_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_pt_game_basic_list_by_game_id_result_params* tmp=(mcp_get_pt_game_basic_list_by_game_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_pt_game_basic_list_by_game_id_result_params(pool);
return tmp;
}
inline void mcp_get_pt_game_basic_list_by_game_id_result_params::destroy(mcp_get_pt_game_basic_list_by_game_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_pt_game_basic_list_by_game_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_pt_game_basic_list_by_game_id_result_params::mcp_get_pt_game_basic_list_by_game_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_pt_game_basic_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_pt_game_basic_list_by_game_id_result_params::mcp_get_pt_game_basic_list_by_game_id_result_params(const mcp_get_pt_game_basic_list_by_game_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_pt_game_basic_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_pt_game_basic_list_by_game_id_result_params::~mcp_get_pt_game_basic_list_by_game_id_result_params(){
}
inline mcp_get_pt_game_basic_list_by_game_id_result_params& mcp_get_pt_game_basic_list_by_game_id_result_params::operator=(const mcp_get_pt_game_basic_list_by_game_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_pt_game_basic_list_by_game_id_result_params::clear(){
// _m_count=0;
_m_pt_game_basic_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_pt_game_basic_list_by_game_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@pt_game_basic_info_t pt_game_basic_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "pt_game_basic_list" << "' not found";
}
{
// level 0 begin
typeof(_m_pt_game_basic_list)& lr0=(_m_pt_game_basic_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::pt_game_basic_info_t& item=const_cast< ::idl::pt_game_basic_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_pt_game_basic_list_by_game_id_result_params::detach(){
_m_pt_game_basic_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_pt_game_basic_list_by_game_id_result_params& mcp_get_pt_game_basic_list_by_game_id_result_params::assign(const mcp_get_pt_game_basic_list_by_game_id_result_params& v){
_m_count=v._m_count;
_m_pt_game_basic_list=v._m_pt_game_basic_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_pt_game_basic_list_by_game_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_pt_game_basic_list_by_game_id_result_params::count() const{
return _m_count;
}
inline mcp_get_pt_game_basic_list_by_game_id_result_params& mcp_get_pt_game_basic_list_by_game_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_pt_game_basic_list_by_game_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_pt_game_basic_list_by_game_id_result_params::has_pt_game_basic_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::pt_game_basic_info_t >& mcp_get_pt_game_basic_list_by_game_id_result_params::pt_game_basic_list() const{
 return _m_pt_game_basic_list;
}
inline void mcp_get_pt_game_basic_list_by_game_id_result_params::clear_pt_game_basic_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_pt_game_basic_list.clear();
}
inline ::idl::vector< ::idl::pt_game_basic_info_t >* mcp_get_pt_game_basic_list_by_game_id_result_params::mutable_pt_game_basic_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_pt_game_basic_list);
}
inline ::idl::vector< ::idl::pt_game_basic_info_t >* mcp_get_pt_game_basic_list_by_game_id_result_params::m_pt_game_basic_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_pt_game_basic_list);
}
inline size_t mcp_get_pt_game_basic_list_by_game_id_result_params::pt_game_basic_list_size() const{
/*  */ return _m_pt_game_basic_list.size();
}
inline const ::idl::pt_game_basic_info_t& mcp_get_pt_game_basic_list_by_game_id_result_params::pt_game_basic_list(size_t i0) const{
 return _m_pt_game_basic_list.get(i0);
}
inline ::idl::pt_game_basic_info_t* mcp_get_pt_game_basic_list_by_game_id_result_params::mutable_pt_game_basic_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_pt_game_basic_list.mutable_get(i0);
}
inline ::idl::pt_game_basic_info_t* mcp_get_pt_game_basic_list_by_game_id_result_params::m_pt_game_basic_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_pt_game_basic_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_pt_game_basic_list_by_game_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_pt_game_basic_list_by_game_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_pt_game_basic_list_by_game_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_pt_game_basic_list_by_game_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_pt_game_basic_list_by_game_id_response* mcp_get_pt_game_basic_list_by_game_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_pt_game_basic_list_by_game_id_response* tmp=(mcp_get_pt_game_basic_list_by_game_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_pt_game_basic_list_by_game_id_response(pool);
return tmp;
}
inline void mcp_get_pt_game_basic_list_by_game_id_response::destroy(mcp_get_pt_game_basic_list_by_game_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_pt_game_basic_list_by_game_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_pt_game_basic_list_by_game_id_response::mcp_get_pt_game_basic_list_by_game_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_pt_game_basic_list_by_game_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_pt_game_basic_list_by_game_id_response::mcp_get_pt_game_basic_list_by_game_id_response(const mcp_get_pt_game_basic_list_by_game_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_pt_game_basic_list_by_game_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_pt_game_basic_list_by_game_id_response::~mcp_get_pt_game_basic_list_by_game_id_response(){
if(_m_result_params){
::idl::mcp_get_pt_game_basic_list_by_game_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_pt_game_basic_list_by_game_id_response& mcp_get_pt_game_basic_list_by_game_id_response::operator=(const mcp_get_pt_game_basic_list_by_game_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_pt_game_basic_list_by_game_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_pt_game_basic_list_by_game_id_response::check() const{
// @@mcp_get_pt_game_basic_list_by_game_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_pt_game_basic_list_by_game_id_result_params& item=const_cast< ::idl::mcp_get_pt_game_basic_list_by_game_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_pt_game_basic_list_by_game_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_pt_game_basic_list_by_game_id_response& mcp_get_pt_game_basic_list_by_game_id_response::assign(const mcp_get_pt_game_basic_list_by_game_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_pt_game_basic_list_by_game_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_pt_game_basic_list_by_game_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_pt_game_basic_list_by_game_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_pt_game_basic_list_by_game_id_result_params& mcp_get_pt_game_basic_list_by_game_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_pt_game_basic_list_by_game_id_result_params* mcp_get_pt_game_basic_list_by_game_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_pt_game_basic_list_by_game_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_pt_game_basic_list_by_game_id_result_params* mcp_get_pt_game_basic_list_by_game_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_pt_game_basic_list_by_game_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_pt_game_basic_list_by_game_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_pt_game_basic_list_by_game_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_pt_game_basic_list_by_game_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_pt_game_basic_list_by_game_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_pt_game_basic_list_by_game_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_pt_game_basic_list_by_app_key_params* mcp_get_pt_game_basic_list_by_app_key_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_pt_game_basic_list_by_app_key_params* tmp=(mcp_get_pt_game_basic_list_by_app_key_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_pt_game_basic_list_by_app_key_params(pool);
return tmp;
}
inline void mcp_get_pt_game_basic_list_by_app_key_params::destroy(mcp_get_pt_game_basic_list_by_app_key_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_pt_game_basic_list_by_app_key_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_pt_game_basic_list_by_app_key_params::mcp_get_pt_game_basic_list_by_app_key_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_app_key(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_pt_game_basic_list_by_app_key_params::mcp_get_pt_game_basic_list_by_app_key_params(const mcp_get_pt_game_basic_list_by_app_key_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_app_key(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_pt_game_basic_list_by_app_key_params::~mcp_get_pt_game_basic_list_by_app_key_params(){
}
inline mcp_get_pt_game_basic_list_by_app_key_params& mcp_get_pt_game_basic_list_by_app_key_params::operator=(const mcp_get_pt_game_basic_list_by_app_key_params& v){
assign(v);
return *this;
}
inline void mcp_get_pt_game_basic_list_by_app_key_params::clear(){
_m_app_key.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_pt_game_basic_list_by_app_key_params::check() const{
// @@string app_key=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "app_key" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_app_key.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_pt_game_basic_list_by_app_key_params::detach(){
_m_app_key.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_pt_game_basic_list_by_app_key_params& mcp_get_pt_game_basic_list_by_app_key_params::assign(const mcp_get_pt_game_basic_list_by_app_key_params& v){
_m_app_key=v._m_app_key;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_pt_game_basic_list_by_app_key_params::has_app_key() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_pt_game_basic_list_by_app_key_params::app_key(unsigned int* size) const{
return _m_app_key.get(size);
}
inline mcp_get_pt_game_basic_list_by_app_key_params& mcp_get_pt_game_basic_list_by_app_key_params::set_app_key(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_app_key.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_pt_game_basic_list_by_app_key_params& mcp_get_pt_game_basic_list_by_app_key_params::set_ptr_app_key(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_app_key.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_pt_game_basic_list_by_app_key_params::clear_app_key(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_app_key.clear();
}
inline ::idl::Unknown* mcp_get_pt_game_basic_list_by_app_key_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_pt_game_basic_list_by_app_key_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_pt_game_basic_list_by_app_key_params::unknown(){
return _unknown;
}
inline size_t mcp_get_pt_game_basic_list_by_app_key_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_pt_game_basic_list_by_app_key_result_params* mcp_get_pt_game_basic_list_by_app_key_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_pt_game_basic_list_by_app_key_result_params* tmp=(mcp_get_pt_game_basic_list_by_app_key_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_pt_game_basic_list_by_app_key_result_params(pool);
return tmp;
}
inline void mcp_get_pt_game_basic_list_by_app_key_result_params::destroy(mcp_get_pt_game_basic_list_by_app_key_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_pt_game_basic_list_by_app_key_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_pt_game_basic_list_by_app_key_result_params::mcp_get_pt_game_basic_list_by_app_key_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_pt_game_basic_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_pt_game_basic_list_by_app_key_result_params::mcp_get_pt_game_basic_list_by_app_key_result_params(const mcp_get_pt_game_basic_list_by_app_key_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_pt_game_basic_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_pt_game_basic_list_by_app_key_result_params::~mcp_get_pt_game_basic_list_by_app_key_result_params(){
}
inline mcp_get_pt_game_basic_list_by_app_key_result_params& mcp_get_pt_game_basic_list_by_app_key_result_params::operator=(const mcp_get_pt_game_basic_list_by_app_key_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_pt_game_basic_list_by_app_key_result_params::clear(){
// _m_count=0;
_m_pt_game_basic_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_pt_game_basic_list_by_app_key_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@pt_game_basic_info_t pt_game_basic_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "pt_game_basic_list" << "' not found";
}
{
// level 0 begin
typeof(_m_pt_game_basic_list)& lr0=(_m_pt_game_basic_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::pt_game_basic_info_t& item=const_cast< ::idl::pt_game_basic_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_pt_game_basic_list_by_app_key_result_params::detach(){
_m_pt_game_basic_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_pt_game_basic_list_by_app_key_result_params& mcp_get_pt_game_basic_list_by_app_key_result_params::assign(const mcp_get_pt_game_basic_list_by_app_key_result_params& v){
_m_count=v._m_count;
_m_pt_game_basic_list=v._m_pt_game_basic_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_pt_game_basic_list_by_app_key_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_pt_game_basic_list_by_app_key_result_params::count() const{
return _m_count;
}
inline mcp_get_pt_game_basic_list_by_app_key_result_params& mcp_get_pt_game_basic_list_by_app_key_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_pt_game_basic_list_by_app_key_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_pt_game_basic_list_by_app_key_result_params::has_pt_game_basic_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::pt_game_basic_info_t >& mcp_get_pt_game_basic_list_by_app_key_result_params::pt_game_basic_list() const{
 return _m_pt_game_basic_list;
}
inline void mcp_get_pt_game_basic_list_by_app_key_result_params::clear_pt_game_basic_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_pt_game_basic_list.clear();
}
inline ::idl::vector< ::idl::pt_game_basic_info_t >* mcp_get_pt_game_basic_list_by_app_key_result_params::mutable_pt_game_basic_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_pt_game_basic_list);
}
inline ::idl::vector< ::idl::pt_game_basic_info_t >* mcp_get_pt_game_basic_list_by_app_key_result_params::m_pt_game_basic_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_pt_game_basic_list);
}
inline size_t mcp_get_pt_game_basic_list_by_app_key_result_params::pt_game_basic_list_size() const{
/*  */ return _m_pt_game_basic_list.size();
}
inline const ::idl::pt_game_basic_info_t& mcp_get_pt_game_basic_list_by_app_key_result_params::pt_game_basic_list(size_t i0) const{
 return _m_pt_game_basic_list.get(i0);
}
inline ::idl::pt_game_basic_info_t* mcp_get_pt_game_basic_list_by_app_key_result_params::mutable_pt_game_basic_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_pt_game_basic_list.mutable_get(i0);
}
inline ::idl::pt_game_basic_info_t* mcp_get_pt_game_basic_list_by_app_key_result_params::m_pt_game_basic_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_pt_game_basic_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_pt_game_basic_list_by_app_key_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_pt_game_basic_list_by_app_key_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_pt_game_basic_list_by_app_key_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_pt_game_basic_list_by_app_key_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_pt_game_basic_list_by_app_key_response* mcp_get_pt_game_basic_list_by_app_key_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_pt_game_basic_list_by_app_key_response* tmp=(mcp_get_pt_game_basic_list_by_app_key_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_pt_game_basic_list_by_app_key_response(pool);
return tmp;
}
inline void mcp_get_pt_game_basic_list_by_app_key_response::destroy(mcp_get_pt_game_basic_list_by_app_key_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_pt_game_basic_list_by_app_key_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_pt_game_basic_list_by_app_key_response::mcp_get_pt_game_basic_list_by_app_key_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_pt_game_basic_list_by_app_key_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_pt_game_basic_list_by_app_key_response::mcp_get_pt_game_basic_list_by_app_key_response(const mcp_get_pt_game_basic_list_by_app_key_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_pt_game_basic_list_by_app_key_result_params::create(_pool);
assign(v);
}
inline mcp_get_pt_game_basic_list_by_app_key_response::~mcp_get_pt_game_basic_list_by_app_key_response(){
if(_m_result_params){
::idl::mcp_get_pt_game_basic_list_by_app_key_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_pt_game_basic_list_by_app_key_response& mcp_get_pt_game_basic_list_by_app_key_response::operator=(const mcp_get_pt_game_basic_list_by_app_key_response& v){
assign(v);
return *this;
}
inline void mcp_get_pt_game_basic_list_by_app_key_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_pt_game_basic_list_by_app_key_response::check() const{
// @@mcp_get_pt_game_basic_list_by_app_key_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_pt_game_basic_list_by_app_key_result_params& item=const_cast< ::idl::mcp_get_pt_game_basic_list_by_app_key_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_pt_game_basic_list_by_app_key_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_pt_game_basic_list_by_app_key_response& mcp_get_pt_game_basic_list_by_app_key_response::assign(const mcp_get_pt_game_basic_list_by_app_key_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_pt_game_basic_list_by_app_key_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_pt_game_basic_list_by_app_key_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_pt_game_basic_list_by_app_key_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_pt_game_basic_list_by_app_key_result_params& mcp_get_pt_game_basic_list_by_app_key_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_pt_game_basic_list_by_app_key_result_params* mcp_get_pt_game_basic_list_by_app_key_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_pt_game_basic_list_by_app_key_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_pt_game_basic_list_by_app_key_result_params* mcp_get_pt_game_basic_list_by_app_key_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_pt_game_basic_list_by_app_key_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_pt_game_basic_list_by_app_key_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_pt_game_basic_list_by_app_key_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_pt_game_basic_list_by_app_key_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_pt_game_basic_list_by_app_key_response::unknown(){
return _unknown;
}
inline size_t mcp_get_pt_game_basic_list_by_app_key_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_pt_app_key_by_game_id_params* mcp_get_pt_app_key_by_game_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_pt_app_key_by_game_id_params* tmp=(mcp_get_pt_app_key_by_game_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_pt_app_key_by_game_id_params(pool);
return tmp;
}
inline void mcp_get_pt_app_key_by_game_id_params::destroy(mcp_get_pt_app_key_by_game_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_pt_app_key_by_game_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_pt_app_key_by_game_id_params::mcp_get_pt_app_key_by_game_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_game_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_pt_app_key_by_game_id_params::mcp_get_pt_app_key_by_game_id_params(const mcp_get_pt_app_key_by_game_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_game_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_pt_app_key_by_game_id_params::~mcp_get_pt_app_key_by_game_id_params(){
}
inline mcp_get_pt_app_key_by_game_id_params& mcp_get_pt_app_key_by_game_id_params::operator=(const mcp_get_pt_app_key_by_game_id_params& v){
assign(v);
return *this;
}
inline void mcp_get_pt_app_key_by_game_id_params::clear(){
_m_game_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_pt_app_key_by_game_id_params::check() const{
// @@string game_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_pt_app_key_by_game_id_params::detach(){
_m_game_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_pt_app_key_by_game_id_params& mcp_get_pt_app_key_by_game_id_params::assign(const mcp_get_pt_app_key_by_game_id_params& v){
_m_game_id=v._m_game_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_pt_app_key_by_game_id_params::has_game_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_pt_app_key_by_game_id_params::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline mcp_get_pt_app_key_by_game_id_params& mcp_get_pt_app_key_by_game_id_params::set_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_pt_app_key_by_game_id_params& mcp_get_pt_app_key_by_game_id_params::set_ptr_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_pt_app_key_by_game_id_params::clear_game_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_game_id.clear();
}
inline ::idl::Unknown* mcp_get_pt_app_key_by_game_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_pt_app_key_by_game_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_pt_app_key_by_game_id_params::unknown(){
return _unknown;
}
inline size_t mcp_get_pt_app_key_by_game_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_pt_app_key_by_game_id_result_params* mcp_get_pt_app_key_by_game_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_pt_app_key_by_game_id_result_params* tmp=(mcp_get_pt_app_key_by_game_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_pt_app_key_by_game_id_result_params(pool);
return tmp;
}
inline void mcp_get_pt_app_key_by_game_id_result_params::destroy(mcp_get_pt_app_key_by_game_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_pt_app_key_by_game_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_pt_app_key_by_game_id_result_params::mcp_get_pt_app_key_by_game_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_app_key(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_pt_app_key_by_game_id_result_params::mcp_get_pt_app_key_by_game_id_result_params(const mcp_get_pt_app_key_by_game_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_app_key(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_pt_app_key_by_game_id_result_params::~mcp_get_pt_app_key_by_game_id_result_params(){
}
inline mcp_get_pt_app_key_by_game_id_result_params& mcp_get_pt_app_key_by_game_id_result_params::operator=(const mcp_get_pt_app_key_by_game_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_pt_app_key_by_game_id_result_params::clear(){
// _m_count=0;
_m_app_key.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_pt_app_key_by_game_id_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string app_key=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "app_key" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_app_key.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_pt_app_key_by_game_id_result_params::detach(){
_m_app_key.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_pt_app_key_by_game_id_result_params& mcp_get_pt_app_key_by_game_id_result_params::assign(const mcp_get_pt_app_key_by_game_id_result_params& v){
_m_count=v._m_count;
_m_app_key=v._m_app_key;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_pt_app_key_by_game_id_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_pt_app_key_by_game_id_result_params::count() const{
return _m_count;
}
inline mcp_get_pt_app_key_by_game_id_result_params& mcp_get_pt_app_key_by_game_id_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_pt_app_key_by_game_id_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_pt_app_key_by_game_id_result_params::has_app_key() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_pt_app_key_by_game_id_result_params::app_key(unsigned int* size) const{
return _m_app_key.get(size);
}
inline mcp_get_pt_app_key_by_game_id_result_params& mcp_get_pt_app_key_by_game_id_result_params::set_app_key(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_app_key.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_pt_app_key_by_game_id_result_params& mcp_get_pt_app_key_by_game_id_result_params::set_ptr_app_key(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_app_key.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_pt_app_key_by_game_id_result_params::clear_app_key(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_app_key.clear();
}
inline ::idl::Unknown* mcp_get_pt_app_key_by_game_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_pt_app_key_by_game_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_pt_app_key_by_game_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_pt_app_key_by_game_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_pt_app_key_by_game_id_response* mcp_get_pt_app_key_by_game_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_pt_app_key_by_game_id_response* tmp=(mcp_get_pt_app_key_by_game_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_pt_app_key_by_game_id_response(pool);
return tmp;
}
inline void mcp_get_pt_app_key_by_game_id_response::destroy(mcp_get_pt_app_key_by_game_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_pt_app_key_by_game_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_pt_app_key_by_game_id_response::mcp_get_pt_app_key_by_game_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_pt_app_key_by_game_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_pt_app_key_by_game_id_response::mcp_get_pt_app_key_by_game_id_response(const mcp_get_pt_app_key_by_game_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_pt_app_key_by_game_id_result_params::create(_pool);
assign(v);
}
inline mcp_get_pt_app_key_by_game_id_response::~mcp_get_pt_app_key_by_game_id_response(){
if(_m_result_params){
::idl::mcp_get_pt_app_key_by_game_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_pt_app_key_by_game_id_response& mcp_get_pt_app_key_by_game_id_response::operator=(const mcp_get_pt_app_key_by_game_id_response& v){
assign(v);
return *this;
}
inline void mcp_get_pt_app_key_by_game_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_pt_app_key_by_game_id_response::check() const{
// @@mcp_get_pt_app_key_by_game_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_pt_app_key_by_game_id_result_params& item=const_cast< ::idl::mcp_get_pt_app_key_by_game_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_pt_app_key_by_game_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_pt_app_key_by_game_id_response& mcp_get_pt_app_key_by_game_id_response::assign(const mcp_get_pt_app_key_by_game_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_pt_app_key_by_game_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_pt_app_key_by_game_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_pt_app_key_by_game_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_pt_app_key_by_game_id_result_params& mcp_get_pt_app_key_by_game_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_pt_app_key_by_game_id_result_params* mcp_get_pt_app_key_by_game_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_pt_app_key_by_game_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_pt_app_key_by_game_id_result_params* mcp_get_pt_app_key_by_game_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_pt_app_key_by_game_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_pt_app_key_by_game_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_pt_app_key_by_game_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_pt_app_key_by_game_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_pt_app_key_by_game_id_response::unknown(){
return _unknown;
}
inline size_t mcp_get_pt_app_key_by_game_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_pt_game_id_by_app_key_params* mcp_get_pt_game_id_by_app_key_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_pt_game_id_by_app_key_params* tmp=(mcp_get_pt_game_id_by_app_key_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_pt_game_id_by_app_key_params(pool);
return tmp;
}
inline void mcp_get_pt_game_id_by_app_key_params::destroy(mcp_get_pt_game_id_by_app_key_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_pt_game_id_by_app_key_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_pt_game_id_by_app_key_params::mcp_get_pt_game_id_by_app_key_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_app_key(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_pt_game_id_by_app_key_params::mcp_get_pt_game_id_by_app_key_params(const mcp_get_pt_game_id_by_app_key_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_app_key(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_pt_game_id_by_app_key_params::~mcp_get_pt_game_id_by_app_key_params(){
}
inline mcp_get_pt_game_id_by_app_key_params& mcp_get_pt_game_id_by_app_key_params::operator=(const mcp_get_pt_game_id_by_app_key_params& v){
assign(v);
return *this;
}
inline void mcp_get_pt_game_id_by_app_key_params::clear(){
_m_app_key.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_pt_game_id_by_app_key_params::check() const{
// @@string app_key=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "app_key" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_app_key.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_pt_game_id_by_app_key_params::detach(){
_m_app_key.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_pt_game_id_by_app_key_params& mcp_get_pt_game_id_by_app_key_params::assign(const mcp_get_pt_game_id_by_app_key_params& v){
_m_app_key=v._m_app_key;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_pt_game_id_by_app_key_params::has_app_key() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_pt_game_id_by_app_key_params::app_key(unsigned int* size) const{
return _m_app_key.get(size);
}
inline mcp_get_pt_game_id_by_app_key_params& mcp_get_pt_game_id_by_app_key_params::set_app_key(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_app_key.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_pt_game_id_by_app_key_params& mcp_get_pt_game_id_by_app_key_params::set_ptr_app_key(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_app_key.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_pt_game_id_by_app_key_params::clear_app_key(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_app_key.clear();
}
inline ::idl::Unknown* mcp_get_pt_game_id_by_app_key_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_pt_game_id_by_app_key_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_pt_game_id_by_app_key_params::unknown(){
return _unknown;
}
inline size_t mcp_get_pt_game_id_by_app_key_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_pt_game_id_by_app_key_result_params* mcp_get_pt_game_id_by_app_key_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_pt_game_id_by_app_key_result_params* tmp=(mcp_get_pt_game_id_by_app_key_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_pt_game_id_by_app_key_result_params(pool);
return tmp;
}
inline void mcp_get_pt_game_id_by_app_key_result_params::destroy(mcp_get_pt_game_id_by_app_key_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_pt_game_id_by_app_key_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_pt_game_id_by_app_key_result_params::mcp_get_pt_game_id_by_app_key_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_game_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_pt_game_id_by_app_key_result_params::mcp_get_pt_game_id_by_app_key_result_params(const mcp_get_pt_game_id_by_app_key_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_game_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_pt_game_id_by_app_key_result_params::~mcp_get_pt_game_id_by_app_key_result_params(){
}
inline mcp_get_pt_game_id_by_app_key_result_params& mcp_get_pt_game_id_by_app_key_result_params::operator=(const mcp_get_pt_game_id_by_app_key_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_pt_game_id_by_app_key_result_params::clear(){
// _m_count=0;
_m_game_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_pt_game_id_by_app_key_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@string game_id=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_pt_game_id_by_app_key_result_params::detach(){
_m_game_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_pt_game_id_by_app_key_result_params& mcp_get_pt_game_id_by_app_key_result_params::assign(const mcp_get_pt_game_id_by_app_key_result_params& v){
_m_count=v._m_count;
_m_game_id=v._m_game_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_pt_game_id_by_app_key_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_pt_game_id_by_app_key_result_params::count() const{
return _m_count;
}
inline mcp_get_pt_game_id_by_app_key_result_params& mcp_get_pt_game_id_by_app_key_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_pt_game_id_by_app_key_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_pt_game_id_by_app_key_result_params::has_game_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_pt_game_id_by_app_key_result_params::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline mcp_get_pt_game_id_by_app_key_result_params& mcp_get_pt_game_id_by_app_key_result_params::set_game_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_pt_game_id_by_app_key_result_params& mcp_get_pt_game_id_by_app_key_result_params::set_ptr_game_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_pt_game_id_by_app_key_result_params::clear_game_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_id.clear();
}
inline ::idl::Unknown* mcp_get_pt_game_id_by_app_key_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_pt_game_id_by_app_key_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_pt_game_id_by_app_key_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_pt_game_id_by_app_key_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_pt_game_id_by_app_key_response* mcp_get_pt_game_id_by_app_key_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_pt_game_id_by_app_key_response* tmp=(mcp_get_pt_game_id_by_app_key_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_pt_game_id_by_app_key_response(pool);
return tmp;
}
inline void mcp_get_pt_game_id_by_app_key_response::destroy(mcp_get_pt_game_id_by_app_key_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_pt_game_id_by_app_key_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_pt_game_id_by_app_key_response::mcp_get_pt_game_id_by_app_key_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_pt_game_id_by_app_key_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_pt_game_id_by_app_key_response::mcp_get_pt_game_id_by_app_key_response(const mcp_get_pt_game_id_by_app_key_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_pt_game_id_by_app_key_result_params::create(_pool);
assign(v);
}
inline mcp_get_pt_game_id_by_app_key_response::~mcp_get_pt_game_id_by_app_key_response(){
if(_m_result_params){
::idl::mcp_get_pt_game_id_by_app_key_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_pt_game_id_by_app_key_response& mcp_get_pt_game_id_by_app_key_response::operator=(const mcp_get_pt_game_id_by_app_key_response& v){
assign(v);
return *this;
}
inline void mcp_get_pt_game_id_by_app_key_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_pt_game_id_by_app_key_response::check() const{
// @@mcp_get_pt_game_id_by_app_key_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_pt_game_id_by_app_key_result_params& item=const_cast< ::idl::mcp_get_pt_game_id_by_app_key_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_pt_game_id_by_app_key_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_pt_game_id_by_app_key_response& mcp_get_pt_game_id_by_app_key_response::assign(const mcp_get_pt_game_id_by_app_key_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_pt_game_id_by_app_key_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_pt_game_id_by_app_key_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_pt_game_id_by_app_key_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_pt_game_id_by_app_key_result_params& mcp_get_pt_game_id_by_app_key_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_pt_game_id_by_app_key_result_params* mcp_get_pt_game_id_by_app_key_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_pt_game_id_by_app_key_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_pt_game_id_by_app_key_result_params* mcp_get_pt_game_id_by_app_key_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_pt_game_id_by_app_key_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_pt_game_id_by_app_key_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_pt_game_id_by_app_key_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_pt_game_id_by_app_key_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_pt_game_id_by_app_key_response::unknown(){
return _unknown;
}
inline size_t mcp_get_pt_game_id_by_app_key_response::unknown_size() const{
return _unknown.size();
}
inline mcp_exist_pt_game_by_game_id_params* mcp_exist_pt_game_by_game_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_exist_pt_game_by_game_id_params* tmp=(mcp_exist_pt_game_by_game_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_exist_pt_game_by_game_id_params(pool);
return tmp;
}
inline void mcp_exist_pt_game_by_game_id_params::destroy(mcp_exist_pt_game_by_game_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_exist_pt_game_by_game_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_exist_pt_game_by_game_id_params::mcp_exist_pt_game_by_game_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_game_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_exist_pt_game_by_game_id_params::mcp_exist_pt_game_by_game_id_params(const mcp_exist_pt_game_by_game_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_game_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_exist_pt_game_by_game_id_params::~mcp_exist_pt_game_by_game_id_params(){
}
inline mcp_exist_pt_game_by_game_id_params& mcp_exist_pt_game_by_game_id_params::operator=(const mcp_exist_pt_game_by_game_id_params& v){
assign(v);
return *this;
}
inline void mcp_exist_pt_game_by_game_id_params::clear(){
_m_game_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_exist_pt_game_by_game_id_params::check() const{
// @@string game_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_exist_pt_game_by_game_id_params::detach(){
_m_game_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_exist_pt_game_by_game_id_params& mcp_exist_pt_game_by_game_id_params::assign(const mcp_exist_pt_game_by_game_id_params& v){
_m_game_id=v._m_game_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_exist_pt_game_by_game_id_params::has_game_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_exist_pt_game_by_game_id_params::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline mcp_exist_pt_game_by_game_id_params& mcp_exist_pt_game_by_game_id_params::set_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_exist_pt_game_by_game_id_params& mcp_exist_pt_game_by_game_id_params::set_ptr_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_exist_pt_game_by_game_id_params::clear_game_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_game_id.clear();
}
inline ::idl::Unknown* mcp_exist_pt_game_by_game_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_exist_pt_game_by_game_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_exist_pt_game_by_game_id_params::unknown(){
return _unknown;
}
inline size_t mcp_exist_pt_game_by_game_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_exist_pt_game_by_game_id_result_params* mcp_exist_pt_game_by_game_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_exist_pt_game_by_game_id_result_params* tmp=(mcp_exist_pt_game_by_game_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_exist_pt_game_by_game_id_result_params(pool);
return tmp;
}
inline void mcp_exist_pt_game_by_game_id_result_params::destroy(mcp_exist_pt_game_by_game_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_exist_pt_game_by_game_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_exist_pt_game_by_game_id_result_params::mcp_exist_pt_game_by_game_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_flag(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_exist_pt_game_by_game_id_result_params::mcp_exist_pt_game_by_game_id_result_params(const mcp_exist_pt_game_by_game_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_flag(0)
,_unknown(_pool){
assign(v);
}
inline mcp_exist_pt_game_by_game_id_result_params::~mcp_exist_pt_game_by_game_id_result_params(){
}
inline mcp_exist_pt_game_by_game_id_result_params& mcp_exist_pt_game_by_game_id_result_params::operator=(const mcp_exist_pt_game_by_game_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_exist_pt_game_by_game_id_result_params::clear(){
// _m_flag=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_exist_pt_game_by_game_id_result_params::check() const{
// @@int32_t flag=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "flag" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_flag;

}

::idl::McpackBean::check();
}
inline void mcp_exist_pt_game_by_game_id_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_exist_pt_game_by_game_id_result_params& mcp_exist_pt_game_by_game_id_result_params::assign(const mcp_exist_pt_game_by_game_id_result_params& v){
_m_flag=v._m_flag;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_exist_pt_game_by_game_id_result_params::has_flag() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_exist_pt_game_by_game_id_result_params::flag() const{
return _m_flag;
}
inline mcp_exist_pt_game_by_game_id_result_params& mcp_exist_pt_game_by_game_id_result_params::set_flag(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_flag=v;
return *this;
}
inline void mcp_exist_pt_game_by_game_id_result_params::clear_flag(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_flag=0;
}
inline ::idl::Unknown* mcp_exist_pt_game_by_game_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_exist_pt_game_by_game_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_exist_pt_game_by_game_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_exist_pt_game_by_game_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_exist_pt_game_by_game_id_response* mcp_exist_pt_game_by_game_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_exist_pt_game_by_game_id_response* tmp=(mcp_exist_pt_game_by_game_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_exist_pt_game_by_game_id_response(pool);
return tmp;
}
inline void mcp_exist_pt_game_by_game_id_response::destroy(mcp_exist_pt_game_by_game_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_exist_pt_game_by_game_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_exist_pt_game_by_game_id_response::mcp_exist_pt_game_by_game_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_exist_pt_game_by_game_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_exist_pt_game_by_game_id_response::mcp_exist_pt_game_by_game_id_response(const mcp_exist_pt_game_by_game_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_exist_pt_game_by_game_id_result_params::create(_pool);
assign(v);
}
inline mcp_exist_pt_game_by_game_id_response::~mcp_exist_pt_game_by_game_id_response(){
if(_m_result_params){
::idl::mcp_exist_pt_game_by_game_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_exist_pt_game_by_game_id_response& mcp_exist_pt_game_by_game_id_response::operator=(const mcp_exist_pt_game_by_game_id_response& v){
assign(v);
return *this;
}
inline void mcp_exist_pt_game_by_game_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_exist_pt_game_by_game_id_response::check() const{
// @@mcp_exist_pt_game_by_game_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_exist_pt_game_by_game_id_result_params& item=const_cast< ::idl::mcp_exist_pt_game_by_game_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_exist_pt_game_by_game_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_exist_pt_game_by_game_id_response& mcp_exist_pt_game_by_game_id_response::assign(const mcp_exist_pt_game_by_game_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_exist_pt_game_by_game_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_exist_pt_game_by_game_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_exist_pt_game_by_game_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_exist_pt_game_by_game_id_result_params& mcp_exist_pt_game_by_game_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_exist_pt_game_by_game_id_result_params* mcp_exist_pt_game_by_game_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_exist_pt_game_by_game_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_exist_pt_game_by_game_id_result_params* mcp_exist_pt_game_by_game_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_exist_pt_game_by_game_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_exist_pt_game_by_game_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_exist_pt_game_by_game_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_exist_pt_game_by_game_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_exist_pt_game_by_game_id_response::unknown(){
return _unknown;
}
inline size_t mcp_exist_pt_game_by_game_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_is_same_pt_game_params* mcp_is_same_pt_game_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_is_same_pt_game_params* tmp=(mcp_is_same_pt_game_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_is_same_pt_game_params(pool);
return tmp;
}
inline void mcp_is_same_pt_game_params::destroy(mcp_is_same_pt_game_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_is_same_pt_game_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_is_same_pt_game_params::mcp_is_same_pt_game_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_game_id(_pool)
,_m_app_key(_pool)
,_m_app_secret(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_is_same_pt_game_params::mcp_is_same_pt_game_params(const mcp_is_same_pt_game_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_game_id(_pool)
,_m_app_key(_pool)
,_m_app_secret(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_is_same_pt_game_params::~mcp_is_same_pt_game_params(){
}
inline mcp_is_same_pt_game_params& mcp_is_same_pt_game_params::operator=(const mcp_is_same_pt_game_params& v){
assign(v);
return *this;
}
inline void mcp_is_same_pt_game_params::clear(){
_m_game_id.clear();
_m_app_key.clear();
_m_app_secret.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_is_same_pt_game_params::check() const{
// @@string game_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}
// @@string app_key=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "app_key" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_app_key.get();

}
// @@string app_secret=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "app_secret" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_app_secret.get();

}

::idl::McpackBean::check();
}
inline void mcp_is_same_pt_game_params::detach(){
_m_game_id.detach();
_m_app_key.detach();
_m_app_secret.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_is_same_pt_game_params& mcp_is_same_pt_game_params::assign(const mcp_is_same_pt_game_params& v){
_m_game_id=v._m_game_id;
_m_app_key=v._m_app_key;
_m_app_secret=v._m_app_secret;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_is_same_pt_game_params::has_game_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_is_same_pt_game_params::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline mcp_is_same_pt_game_params& mcp_is_same_pt_game_params::set_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_is_same_pt_game_params& mcp_is_same_pt_game_params::set_ptr_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_is_same_pt_game_params::clear_game_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_game_id.clear();
}
inline bool mcp_is_same_pt_game_params::has_app_key() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_is_same_pt_game_params::app_key(unsigned int* size) const{
return _m_app_key.get(size);
}
inline mcp_is_same_pt_game_params& mcp_is_same_pt_game_params::set_app_key(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_app_key.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_is_same_pt_game_params& mcp_is_same_pt_game_params::set_ptr_app_key(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_app_key.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_is_same_pt_game_params::clear_app_key(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_app_key.clear();
}
inline bool mcp_is_same_pt_game_params::has_app_secret() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_is_same_pt_game_params::app_secret(unsigned int* size) const{
return _m_app_secret.get(size);
}
inline mcp_is_same_pt_game_params& mcp_is_same_pt_game_params::set_app_secret(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_app_secret.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_is_same_pt_game_params& mcp_is_same_pt_game_params::set_ptr_app_secret(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_app_secret.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_is_same_pt_game_params::clear_app_secret(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_app_secret.clear();
}
inline ::idl::Unknown* mcp_is_same_pt_game_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_is_same_pt_game_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_is_same_pt_game_params::unknown(){
return _unknown;
}
inline size_t mcp_is_same_pt_game_params::unknown_size() const{
return _unknown.size();
}
inline mcp_is_same_pt_game_result_params* mcp_is_same_pt_game_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_is_same_pt_game_result_params* tmp=(mcp_is_same_pt_game_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_is_same_pt_game_result_params(pool);
return tmp;
}
inline void mcp_is_same_pt_game_result_params::destroy(mcp_is_same_pt_game_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_is_same_pt_game_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_is_same_pt_game_result_params::mcp_is_same_pt_game_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_flag(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_is_same_pt_game_result_params::mcp_is_same_pt_game_result_params(const mcp_is_same_pt_game_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_flag(0)
,_unknown(_pool){
assign(v);
}
inline mcp_is_same_pt_game_result_params::~mcp_is_same_pt_game_result_params(){
}
inline mcp_is_same_pt_game_result_params& mcp_is_same_pt_game_result_params::operator=(const mcp_is_same_pt_game_result_params& v){
assign(v);
return *this;
}
inline void mcp_is_same_pt_game_result_params::clear(){
// _m_flag=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_is_same_pt_game_result_params::check() const{
// @@int32_t flag=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "flag" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_flag;

}

::idl::McpackBean::check();
}
inline void mcp_is_same_pt_game_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_is_same_pt_game_result_params& mcp_is_same_pt_game_result_params::assign(const mcp_is_same_pt_game_result_params& v){
_m_flag=v._m_flag;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_is_same_pt_game_result_params::has_flag() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_is_same_pt_game_result_params::flag() const{
return _m_flag;
}
inline mcp_is_same_pt_game_result_params& mcp_is_same_pt_game_result_params::set_flag(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_flag=v;
return *this;
}
inline void mcp_is_same_pt_game_result_params::clear_flag(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_flag=0;
}
inline ::idl::Unknown* mcp_is_same_pt_game_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_is_same_pt_game_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_is_same_pt_game_result_params::unknown(){
return _unknown;
}
inline size_t mcp_is_same_pt_game_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_is_same_pt_game_response* mcp_is_same_pt_game_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_is_same_pt_game_response* tmp=(mcp_is_same_pt_game_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_is_same_pt_game_response(pool);
return tmp;
}
inline void mcp_is_same_pt_game_response::destroy(mcp_is_same_pt_game_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_is_same_pt_game_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_is_same_pt_game_response::mcp_is_same_pt_game_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_is_same_pt_game_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_is_same_pt_game_response::mcp_is_same_pt_game_response(const mcp_is_same_pt_game_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_is_same_pt_game_result_params::create(_pool);
assign(v);
}
inline mcp_is_same_pt_game_response::~mcp_is_same_pt_game_response(){
if(_m_result_params){
::idl::mcp_is_same_pt_game_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_is_same_pt_game_response& mcp_is_same_pt_game_response::operator=(const mcp_is_same_pt_game_response& v){
assign(v);
return *this;
}
inline void mcp_is_same_pt_game_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_is_same_pt_game_response::check() const{
// @@mcp_is_same_pt_game_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_is_same_pt_game_result_params& item=const_cast< ::idl::mcp_is_same_pt_game_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_is_same_pt_game_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_is_same_pt_game_response& mcp_is_same_pt_game_response::assign(const mcp_is_same_pt_game_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_is_same_pt_game_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_is_same_pt_game_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_is_same_pt_game_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_is_same_pt_game_result_params& mcp_is_same_pt_game_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_is_same_pt_game_result_params* mcp_is_same_pt_game_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_is_same_pt_game_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_is_same_pt_game_result_params* mcp_is_same_pt_game_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_is_same_pt_game_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_is_same_pt_game_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_is_same_pt_game_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_is_same_pt_game_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_is_same_pt_game_response::unknown(){
return _unknown;
}
inline size_t mcp_is_same_pt_game_response::unknown_size() const{
return _unknown.size();
}
inline mcp_remove_pt_game_basic_list_by_app_key_params* mcp_remove_pt_game_basic_list_by_app_key_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_remove_pt_game_basic_list_by_app_key_params* tmp=(mcp_remove_pt_game_basic_list_by_app_key_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_remove_pt_game_basic_list_by_app_key_params(pool);
return tmp;
}
inline void mcp_remove_pt_game_basic_list_by_app_key_params::destroy(mcp_remove_pt_game_basic_list_by_app_key_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_remove_pt_game_basic_list_by_app_key_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_remove_pt_game_basic_list_by_app_key_params::mcp_remove_pt_game_basic_list_by_app_key_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_app_key(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_remove_pt_game_basic_list_by_app_key_params::mcp_remove_pt_game_basic_list_by_app_key_params(const mcp_remove_pt_game_basic_list_by_app_key_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_app_key(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_remove_pt_game_basic_list_by_app_key_params::~mcp_remove_pt_game_basic_list_by_app_key_params(){
}
inline mcp_remove_pt_game_basic_list_by_app_key_params& mcp_remove_pt_game_basic_list_by_app_key_params::operator=(const mcp_remove_pt_game_basic_list_by_app_key_params& v){
assign(v);
return *this;
}
inline void mcp_remove_pt_game_basic_list_by_app_key_params::clear(){
_m_app_key.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_remove_pt_game_basic_list_by_app_key_params::check() const{
// @@string app_key=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "app_key" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_app_key.get();

}

::idl::McpackBean::check();
}
inline void mcp_remove_pt_game_basic_list_by_app_key_params::detach(){
_m_app_key.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_remove_pt_game_basic_list_by_app_key_params& mcp_remove_pt_game_basic_list_by_app_key_params::assign(const mcp_remove_pt_game_basic_list_by_app_key_params& v){
_m_app_key=v._m_app_key;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_remove_pt_game_basic_list_by_app_key_params::has_app_key() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_remove_pt_game_basic_list_by_app_key_params::app_key(unsigned int* size) const{
return _m_app_key.get(size);
}
inline mcp_remove_pt_game_basic_list_by_app_key_params& mcp_remove_pt_game_basic_list_by_app_key_params::set_app_key(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_app_key.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_remove_pt_game_basic_list_by_app_key_params& mcp_remove_pt_game_basic_list_by_app_key_params::set_ptr_app_key(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_app_key.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_remove_pt_game_basic_list_by_app_key_params::clear_app_key(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_app_key.clear();
}
inline ::idl::Unknown* mcp_remove_pt_game_basic_list_by_app_key_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_remove_pt_game_basic_list_by_app_key_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_remove_pt_game_basic_list_by_app_key_params::unknown(){
return _unknown;
}
inline size_t mcp_remove_pt_game_basic_list_by_app_key_params::unknown_size() const{
return _unknown.size();
}
inline mcp_remove_pt_game_basic_list_by_app_key_result_params* mcp_remove_pt_game_basic_list_by_app_key_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_remove_pt_game_basic_list_by_app_key_result_params* tmp=(mcp_remove_pt_game_basic_list_by_app_key_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_remove_pt_game_basic_list_by_app_key_result_params(pool);
return tmp;
}
inline void mcp_remove_pt_game_basic_list_by_app_key_result_params::destroy(mcp_remove_pt_game_basic_list_by_app_key_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_remove_pt_game_basic_list_by_app_key_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_remove_pt_game_basic_list_by_app_key_result_params::mcp_remove_pt_game_basic_list_by_app_key_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_flag(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_remove_pt_game_basic_list_by_app_key_result_params::mcp_remove_pt_game_basic_list_by_app_key_result_params(const mcp_remove_pt_game_basic_list_by_app_key_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_flag(0)
,_unknown(_pool){
assign(v);
}
inline mcp_remove_pt_game_basic_list_by_app_key_result_params::~mcp_remove_pt_game_basic_list_by_app_key_result_params(){
}
inline mcp_remove_pt_game_basic_list_by_app_key_result_params& mcp_remove_pt_game_basic_list_by_app_key_result_params::operator=(const mcp_remove_pt_game_basic_list_by_app_key_result_params& v){
assign(v);
return *this;
}
inline void mcp_remove_pt_game_basic_list_by_app_key_result_params::clear(){
// _m_flag=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_remove_pt_game_basic_list_by_app_key_result_params::check() const{
// @@int32_t flag=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "flag" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_flag;

}

::idl::McpackBean::check();
}
inline void mcp_remove_pt_game_basic_list_by_app_key_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_remove_pt_game_basic_list_by_app_key_result_params& mcp_remove_pt_game_basic_list_by_app_key_result_params::assign(const mcp_remove_pt_game_basic_list_by_app_key_result_params& v){
_m_flag=v._m_flag;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_remove_pt_game_basic_list_by_app_key_result_params::has_flag() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_remove_pt_game_basic_list_by_app_key_result_params::flag() const{
return _m_flag;
}
inline mcp_remove_pt_game_basic_list_by_app_key_result_params& mcp_remove_pt_game_basic_list_by_app_key_result_params::set_flag(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_flag=v;
return *this;
}
inline void mcp_remove_pt_game_basic_list_by_app_key_result_params::clear_flag(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_flag=0;
}
inline ::idl::Unknown* mcp_remove_pt_game_basic_list_by_app_key_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_remove_pt_game_basic_list_by_app_key_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_remove_pt_game_basic_list_by_app_key_result_params::unknown(){
return _unknown;
}
inline size_t mcp_remove_pt_game_basic_list_by_app_key_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_remove_pt_game_basic_list_by_app_key_response* mcp_remove_pt_game_basic_list_by_app_key_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_remove_pt_game_basic_list_by_app_key_response* tmp=(mcp_remove_pt_game_basic_list_by_app_key_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_remove_pt_game_basic_list_by_app_key_response(pool);
return tmp;
}
inline void mcp_remove_pt_game_basic_list_by_app_key_response::destroy(mcp_remove_pt_game_basic_list_by_app_key_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_remove_pt_game_basic_list_by_app_key_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_remove_pt_game_basic_list_by_app_key_response::mcp_remove_pt_game_basic_list_by_app_key_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_remove_pt_game_basic_list_by_app_key_response::mcp_remove_pt_game_basic_list_by_app_key_response(const mcp_remove_pt_game_basic_list_by_app_key_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params::create(_pool);
assign(v);
}
inline mcp_remove_pt_game_basic_list_by_app_key_response::~mcp_remove_pt_game_basic_list_by_app_key_response(){
if(_m_result_params){
::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_remove_pt_game_basic_list_by_app_key_response& mcp_remove_pt_game_basic_list_by_app_key_response::operator=(const mcp_remove_pt_game_basic_list_by_app_key_response& v){
assign(v);
return *this;
}
inline void mcp_remove_pt_game_basic_list_by_app_key_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_remove_pt_game_basic_list_by_app_key_response::check() const{
// @@mcp_remove_pt_game_basic_list_by_app_key_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params& item=const_cast< ::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_remove_pt_game_basic_list_by_app_key_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_remove_pt_game_basic_list_by_app_key_response& mcp_remove_pt_game_basic_list_by_app_key_response::assign(const mcp_remove_pt_game_basic_list_by_app_key_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_remove_pt_game_basic_list_by_app_key_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params& mcp_remove_pt_game_basic_list_by_app_key_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params* mcp_remove_pt_game_basic_list_by_app_key_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params* mcp_remove_pt_game_basic_list_by_app_key_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_remove_pt_game_basic_list_by_app_key_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_remove_pt_game_basic_list_by_app_key_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_remove_pt_game_basic_list_by_app_key_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_remove_pt_game_basic_list_by_app_key_response::unknown(){
return _unknown;
}
inline size_t mcp_remove_pt_game_basic_list_by_app_key_response::unknown_size() const{
return _unknown.size();
}
inline mcp_add_new_user_consume_record_params* mcp_add_new_user_consume_record_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_new_user_consume_record_params* tmp=(mcp_add_new_user_consume_record_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_new_user_consume_record_params(pool);
return tmp;
}
inline void mcp_add_new_user_consume_record_params::destroy(mcp_add_new_user_consume_record_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_new_user_consume_record_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_new_user_consume_record_params::mcp_add_new_user_consume_record_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_imei_id(_pool)
,_m_order_id(_pool)
,_m_goods_id(_pool)
,_m_consume_date(_pool)
,_m_udid(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_new_user_consume_record_params::mcp_add_new_user_consume_record_params(const mcp_add_new_user_consume_record_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_imei_id(_pool)
,_m_order_id(_pool)
,_m_goods_id(_pool)
,_m_consume_date(_pool)
,_m_udid(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_add_new_user_consume_record_params::~mcp_add_new_user_consume_record_params(){
}
inline mcp_add_new_user_consume_record_params& mcp_add_new_user_consume_record_params::operator=(const mcp_add_new_user_consume_record_params& v){
assign(v);
return *this;
}
inline void mcp_add_new_user_consume_record_params::clear(){
_m_imei_id.clear();
_m_order_id.clear();
_m_goods_id.clear();
_m_consume_date.clear();
_m_udid.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_new_user_consume_record_params::check() const{
// @@string imei_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "imei_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_imei_id.get();

}
// @@string order_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "order_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_order_id.get();

}
// @@string goods_id=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "goods_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_goods_id.get();

}
// @@string consume_date=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "consume_date" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_consume_date.get();

}
// @@string udid=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "udid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_udid.get();

}

::idl::McpackBean::check();
}
inline void mcp_add_new_user_consume_record_params::detach(){
_m_imei_id.detach();
_m_order_id.detach();
_m_goods_id.detach();
_m_consume_date.detach();
_m_udid.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_new_user_consume_record_params& mcp_add_new_user_consume_record_params::assign(const mcp_add_new_user_consume_record_params& v){
_m_imei_id=v._m_imei_id;
_m_order_id=v._m_order_id;
_m_goods_id=v._m_goods_id;
_m_consume_date=v._m_consume_date;
_m_udid=v._m_udid;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_new_user_consume_record_params::has_imei_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_add_new_user_consume_record_params::imei_id(unsigned int* size) const{
return _m_imei_id.get(size);
}
inline mcp_add_new_user_consume_record_params& mcp_add_new_user_consume_record_params::set_imei_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_imei_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_new_user_consume_record_params& mcp_add_new_user_consume_record_params::set_ptr_imei_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_imei_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_new_user_consume_record_params::clear_imei_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_imei_id.clear();
}
inline bool mcp_add_new_user_consume_record_params::has_order_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_add_new_user_consume_record_params::order_id(unsigned int* size) const{
return _m_order_id.get(size);
}
inline mcp_add_new_user_consume_record_params& mcp_add_new_user_consume_record_params::set_order_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_order_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_new_user_consume_record_params& mcp_add_new_user_consume_record_params::set_ptr_order_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_order_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_new_user_consume_record_params::clear_order_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_order_id.clear();
}
inline bool mcp_add_new_user_consume_record_params::has_goods_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_add_new_user_consume_record_params::goods_id(unsigned int* size) const{
return _m_goods_id.get(size);
}
inline mcp_add_new_user_consume_record_params& mcp_add_new_user_consume_record_params::set_goods_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_goods_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_new_user_consume_record_params& mcp_add_new_user_consume_record_params::set_ptr_goods_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_goods_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_new_user_consume_record_params::clear_goods_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_goods_id.clear();
}
inline bool mcp_add_new_user_consume_record_params::has_consume_date() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_add_new_user_consume_record_params::consume_date(unsigned int* size) const{
return _m_consume_date.get(size);
}
inline mcp_add_new_user_consume_record_params& mcp_add_new_user_consume_record_params::set_consume_date(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_consume_date.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_new_user_consume_record_params& mcp_add_new_user_consume_record_params::set_ptr_consume_date(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_consume_date.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_new_user_consume_record_params::clear_consume_date(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_consume_date.clear();
}
inline bool mcp_add_new_user_consume_record_params::has_udid() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_add_new_user_consume_record_params::udid(unsigned int* size) const{
return _m_udid.get(size);
}
inline mcp_add_new_user_consume_record_params& mcp_add_new_user_consume_record_params::set_udid(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_udid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_new_user_consume_record_params& mcp_add_new_user_consume_record_params::set_ptr_udid(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_udid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_new_user_consume_record_params::clear_udid(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_udid.clear();
}
inline ::idl::Unknown* mcp_add_new_user_consume_record_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_new_user_consume_record_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_new_user_consume_record_params::unknown(){
return _unknown;
}
inline size_t mcp_add_new_user_consume_record_params::unknown_size() const{
return _unknown.size();
}
inline mcp_add_new_user_consume_record_result_params* mcp_add_new_user_consume_record_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_new_user_consume_record_result_params* tmp=(mcp_add_new_user_consume_record_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_new_user_consume_record_result_params(pool);
return tmp;
}
inline void mcp_add_new_user_consume_record_result_params::destroy(mcp_add_new_user_consume_record_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_new_user_consume_record_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_new_user_consume_record_result_params::mcp_add_new_user_consume_record_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ret_code(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_new_user_consume_record_result_params::mcp_add_new_user_consume_record_result_params(const mcp_add_new_user_consume_record_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ret_code(0)
,_unknown(_pool){
assign(v);
}
inline mcp_add_new_user_consume_record_result_params::~mcp_add_new_user_consume_record_result_params(){
}
inline mcp_add_new_user_consume_record_result_params& mcp_add_new_user_consume_record_result_params::operator=(const mcp_add_new_user_consume_record_result_params& v){
assign(v);
return *this;
}
inline void mcp_add_new_user_consume_record_result_params::clear(){
// _m_ret_code=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_new_user_consume_record_result_params::check() const{
// @@int32_t ret_code=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ret_code" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_ret_code;

}

::idl::McpackBean::check();
}
inline void mcp_add_new_user_consume_record_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_new_user_consume_record_result_params& mcp_add_new_user_consume_record_result_params::assign(const mcp_add_new_user_consume_record_result_params& v){
_m_ret_code=v._m_ret_code;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_new_user_consume_record_result_params::has_ret_code() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_add_new_user_consume_record_result_params::ret_code() const{
return _m_ret_code;
}
inline mcp_add_new_user_consume_record_result_params& mcp_add_new_user_consume_record_result_params::set_ret_code(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ret_code=v;
return *this;
}
inline void mcp_add_new_user_consume_record_result_params::clear_ret_code(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ret_code=0;
}
inline ::idl::Unknown* mcp_add_new_user_consume_record_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_new_user_consume_record_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_new_user_consume_record_result_params::unknown(){
return _unknown;
}
inline size_t mcp_add_new_user_consume_record_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_add_new_user_consume_record_response* mcp_add_new_user_consume_record_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_new_user_consume_record_response* tmp=(mcp_add_new_user_consume_record_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_new_user_consume_record_response(pool);
return tmp;
}
inline void mcp_add_new_user_consume_record_response::destroy(mcp_add_new_user_consume_record_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_new_user_consume_record_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_new_user_consume_record_response::mcp_add_new_user_consume_record_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_add_new_user_consume_record_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_new_user_consume_record_response::mcp_add_new_user_consume_record_response(const mcp_add_new_user_consume_record_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_add_new_user_consume_record_result_params::create(_pool);
assign(v);
}
inline mcp_add_new_user_consume_record_response::~mcp_add_new_user_consume_record_response(){
if(_m_result_params){
::idl::mcp_add_new_user_consume_record_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_add_new_user_consume_record_response& mcp_add_new_user_consume_record_response::operator=(const mcp_add_new_user_consume_record_response& v){
assign(v);
return *this;
}
inline void mcp_add_new_user_consume_record_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_new_user_consume_record_response::check() const{
// @@mcp_add_new_user_consume_record_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_add_new_user_consume_record_result_params& item=const_cast< ::idl::mcp_add_new_user_consume_record_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_add_new_user_consume_record_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_new_user_consume_record_response& mcp_add_new_user_consume_record_response::assign(const mcp_add_new_user_consume_record_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_add_new_user_consume_record_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_add_new_user_consume_record_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_new_user_consume_record_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_add_new_user_consume_record_result_params& mcp_add_new_user_consume_record_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_add_new_user_consume_record_result_params* mcp_add_new_user_consume_record_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_add_new_user_consume_record_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_add_new_user_consume_record_result_params* mcp_add_new_user_consume_record_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_add_new_user_consume_record_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_add_new_user_consume_record_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_add_new_user_consume_record_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_new_user_consume_record_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_new_user_consume_record_response::unknown(){
return _unknown;
}
inline size_t mcp_add_new_user_consume_record_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_news_info_list_params* mcp_get_game_news_info_list_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_news_info_list_params* tmp=(mcp_get_game_news_info_list_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_news_info_list_params(pool);
return tmp;
}
inline void mcp_get_game_news_info_list_params::destroy(mcp_get_game_news_info_list_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_news_info_list_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_news_info_list_params::mcp_get_game_news_info_list_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_game_id(_pool)
,_m_ov_id(_pool)
,_m_news_type(_pool)
,_m_date_limit(_pool)
,_m_game_imgtypes(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_news_info_list_params::mcp_get_game_news_info_list_params(const mcp_get_game_news_info_list_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_game_id(_pool)
,_m_ov_id(_pool)
,_m_news_type(_pool)
,_m_date_limit(_pool)
,_m_game_imgtypes(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_news_info_list_params::~mcp_get_game_news_info_list_params(){
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::operator=(const mcp_get_game_news_info_list_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_news_info_list_params::clear(){
_m_game_id.clear();
_m_ov_id.clear();
_m_news_type.clear();
_m_date_limit.clear();
_m_game_imgtypes.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_news_info_list_params::check() const{
// @@string game_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}
// @@string ov_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ov_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ov_id.get();

}
// @@string news_type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "news_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_news_type.get();

}
// @@string date_limit=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "date_limit" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_date_limit.get();

}
// @@string game_imgtypes=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_imgtypes" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_imgtypes.get();

}
// @@uint32_t page=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_game_news_info_list_params::detach(){
_m_game_id.detach();
_m_ov_id.detach();
_m_news_type.detach();
_m_date_limit.detach();
_m_game_imgtypes.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::assign(const mcp_get_game_news_info_list_params& v){
_m_game_id=v._m_game_id;
_m_ov_id=v._m_ov_id;
_m_news_type=v._m_news_type;
_m_date_limit=v._m_date_limit;
_m_game_imgtypes=v._m_game_imgtypes;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_news_info_list_params::has_game_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_news_info_list_params::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::set_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::set_ptr_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_info_list_params::clear_game_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_game_id.clear();
}
inline bool mcp_get_game_news_info_list_params::has_ov_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_game_news_info_list_params::ov_id(unsigned int* size) const{
return _m_ov_id.get(size);
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::set_ov_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_ov_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::set_ptr_ov_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_ov_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_info_list_params::clear_ov_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_ov_id.clear();
}
inline bool mcp_get_game_news_info_list_params::has_news_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_game_news_info_list_params::news_type(unsigned int* size) const{
return _m_news_type.get(size);
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::set_news_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_news_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::set_ptr_news_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_news_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_info_list_params::clear_news_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_news_type.clear();
}
inline bool mcp_get_game_news_info_list_params::has_date_limit() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_game_news_info_list_params::date_limit(unsigned int* size) const{
return _m_date_limit.get(size);
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::set_date_limit(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_date_limit.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::set_ptr_date_limit(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_date_limit.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_info_list_params::clear_date_limit(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_date_limit.clear();
}
inline bool mcp_get_game_news_info_list_params::has_game_imgtypes() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_get_game_news_info_list_params::game_imgtypes(unsigned int* size) const{
return _m_game_imgtypes.get(size);
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::set_game_imgtypes(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_game_imgtypes.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::set_ptr_game_imgtypes(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_game_imgtypes.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_info_list_params::clear_game_imgtypes(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_game_imgtypes.clear();
}
inline bool mcp_get_game_news_info_list_params::has_page() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline uint32_t mcp_get_game_news_info_list_params::page() const{
return _m_page;
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::set_page(uint32_t v){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_game_news_info_list_params::clear_page(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_page=0;
}
inline bool mcp_get_game_news_info_list_params::has_page_size() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline uint32_t mcp_get_game_news_info_list_params::page_size() const{
return _m_page_size;
}
inline mcp_get_game_news_info_list_params& mcp_get_game_news_info_list_params::set_page_size(uint32_t v){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_game_news_info_list_params::clear_page_size(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_game_news_info_list_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_news_info_list_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_news_info_list_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_news_info_list_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_news_info_list_result_params* mcp_get_game_news_info_list_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_news_info_list_result_params* tmp=(mcp_get_game_news_info_list_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_news_info_list_result_params(pool);
return tmp;
}
inline void mcp_get_game_news_info_list_result_params::destroy(mcp_get_game_news_info_list_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_news_info_list_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_news_info_list_result_params::mcp_get_game_news_info_list_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_game_news_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_news_info_list_result_params::mcp_get_game_news_info_list_result_params(const mcp_get_game_news_info_list_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_game_news_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_news_info_list_result_params::~mcp_get_game_news_info_list_result_params(){
}
inline mcp_get_game_news_info_list_result_params& mcp_get_game_news_info_list_result_params::operator=(const mcp_get_game_news_info_list_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_news_info_list_result_params::clear(){
// _m_count=0;
_m_game_news_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_news_info_list_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@game_news_info_t game_news_info_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_news_info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_game_news_info_list)& lr0=(_m_game_news_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_news_info_t& item=const_cast< ::idl::game_news_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_game_news_info_list_result_params::detach(){
_m_game_news_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_news_info_list_result_params& mcp_get_game_news_info_list_result_params::assign(const mcp_get_game_news_info_list_result_params& v){
_m_count=v._m_count;
_m_game_news_info_list=v._m_game_news_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_news_info_list_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_game_news_info_list_result_params::count() const{
return _m_count;
}
inline mcp_get_game_news_info_list_result_params& mcp_get_game_news_info_list_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_game_news_info_list_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_game_news_info_list_result_params::has_game_news_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_news_info_t >& mcp_get_game_news_info_list_result_params::game_news_info_list() const{
 return _m_game_news_info_list;
}
inline void mcp_get_game_news_info_list_result_params::clear_game_news_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_news_info_list.clear();
}
inline ::idl::vector< ::idl::game_news_info_t >* mcp_get_game_news_info_list_result_params::mutable_game_news_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_news_info_list);
}
inline ::idl::vector< ::idl::game_news_info_t >* mcp_get_game_news_info_list_result_params::m_game_news_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_news_info_list);
}
inline size_t mcp_get_game_news_info_list_result_params::game_news_info_list_size() const{
/*  */ return _m_game_news_info_list.size();
}
inline const ::idl::game_news_info_t& mcp_get_game_news_info_list_result_params::game_news_info_list(size_t i0) const{
 return _m_game_news_info_list.get(i0);
}
inline ::idl::game_news_info_t* mcp_get_game_news_info_list_result_params::mutable_game_news_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_news_info_list.mutable_get(i0);
}
inline ::idl::game_news_info_t* mcp_get_game_news_info_list_result_params::m_game_news_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_news_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_game_news_info_list_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_news_info_list_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_news_info_list_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_news_info_list_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_news_info_list_response* mcp_get_game_news_info_list_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_news_info_list_response* tmp=(mcp_get_game_news_info_list_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_news_info_list_response(pool);
return tmp;
}
inline void mcp_get_game_news_info_list_response::destroy(mcp_get_game_news_info_list_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_news_info_list_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_news_info_list_response::mcp_get_game_news_info_list_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_news_info_list_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_news_info_list_response::mcp_get_game_news_info_list_response(const mcp_get_game_news_info_list_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_news_info_list_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_news_info_list_response::~mcp_get_game_news_info_list_response(){
if(_m_result_params){
::idl::mcp_get_game_news_info_list_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_news_info_list_response& mcp_get_game_news_info_list_response::operator=(const mcp_get_game_news_info_list_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_news_info_list_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_news_info_list_response::check() const{
// @@mcp_get_game_news_info_list_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_news_info_list_result_params& item=const_cast< ::idl::mcp_get_game_news_info_list_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_news_info_list_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_news_info_list_response& mcp_get_game_news_info_list_response::assign(const mcp_get_game_news_info_list_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_news_info_list_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_news_info_list_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_news_info_list_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_news_info_list_result_params& mcp_get_game_news_info_list_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_news_info_list_result_params* mcp_get_game_news_info_list_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_news_info_list_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_news_info_list_result_params* mcp_get_game_news_info_list_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_news_info_list_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_news_info_list_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_news_info_list_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_news_info_list_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_news_info_list_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_news_info_list_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_news_entire_info_params* mcp_get_game_news_entire_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_news_entire_info_params* tmp=(mcp_get_game_news_entire_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_news_entire_info_params(pool);
return tmp;
}
inline void mcp_get_game_news_entire_info_params::destroy(mcp_get_game_news_entire_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_news_entire_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_news_entire_info_params::mcp_get_game_news_entire_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_news_id(_pool)
,_m_game_id(_pool)
,_m_news_type(_pool)
,_m_date_limit(_pool)
,_m_order_type(_pool)
,_m_game_imgtypes(_pool)
,_m_channel_info(_pool)
,_m_channel_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_news_entire_info_params::mcp_get_game_news_entire_info_params(const mcp_get_game_news_entire_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_news_id(_pool)
,_m_game_id(_pool)
,_m_news_type(_pool)
,_m_date_limit(_pool)
,_m_order_type(_pool)
,_m_game_imgtypes(_pool)
,_m_channel_info(_pool)
,_m_channel_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_news_entire_info_params::~mcp_get_game_news_entire_info_params(){
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::operator=(const mcp_get_game_news_entire_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_news_entire_info_params::clear(){
_m_news_id.clear();
_m_game_id.clear();
_m_news_type.clear();
_m_date_limit.clear();
_m_order_type.clear();
_m_game_imgtypes.clear();
_m_channel_info.clear();
_m_channel_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_news_entire_info_params::check() const{
// @@string news_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "news_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_news_id.get();

}
// @@string game_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}
// @@string news_type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "news_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_news_type.get();

}
// @@string date_limit=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "date_limit" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_date_limit.get();

}
// @@string order_type=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "order_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_order_type.get();

}
// @@string game_imgtypes=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_imgtypes" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_imgtypes.get();

}
// @@string channel_info=in();
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "channel_info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_channel_info.get();

}
// @@string channel_id=in();
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "channel_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_channel_id.get();

}
// @@uint32_t page=in();
if(!(_flag[8 >> 3] & (1 << (8 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[9 >> 3] & (1 << (9 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_game_news_entire_info_params::detach(){
_m_news_id.detach();
_m_game_id.detach();
_m_news_type.detach();
_m_date_limit.detach();
_m_order_type.detach();
_m_game_imgtypes.detach();
_m_channel_info.detach();
_m_channel_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::assign(const mcp_get_game_news_entire_info_params& v){
_m_news_id=v._m_news_id;
_m_game_id=v._m_game_id;
_m_news_type=v._m_news_type;
_m_date_limit=v._m_date_limit;
_m_order_type=v._m_order_type;
_m_game_imgtypes=v._m_game_imgtypes;
_m_channel_info=v._m_channel_info;
_m_channel_id=v._m_channel_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_news_entire_info_params::has_news_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_news_entire_info_params::news_id(unsigned int* size) const{
return _m_news_id.get(size);
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_news_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_news_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_ptr_news_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_news_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_entire_info_params::clear_news_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_news_id.clear();
}
inline bool mcp_get_game_news_entire_info_params::has_game_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_game_news_entire_info_params::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_game_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_ptr_game_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_entire_info_params::clear_game_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_id.clear();
}
inline bool mcp_get_game_news_entire_info_params::has_news_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_game_news_entire_info_params::news_type(unsigned int* size) const{
return _m_news_type.get(size);
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_news_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_news_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_ptr_news_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_news_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_entire_info_params::clear_news_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_news_type.clear();
}
inline bool mcp_get_game_news_entire_info_params::has_date_limit() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_game_news_entire_info_params::date_limit(unsigned int* size) const{
return _m_date_limit.get(size);
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_date_limit(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_date_limit.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_ptr_date_limit(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_date_limit.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_entire_info_params::clear_date_limit(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_date_limit.clear();
}
inline bool mcp_get_game_news_entire_info_params::has_order_type() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_get_game_news_entire_info_params::order_type(unsigned int* size) const{
return _m_order_type.get(size);
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_order_type(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_order_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_ptr_order_type(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_order_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_entire_info_params::clear_order_type(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_order_type.clear();
}
inline bool mcp_get_game_news_entire_info_params::has_game_imgtypes() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* mcp_get_game_news_entire_info_params::game_imgtypes(unsigned int* size) const{
return _m_game_imgtypes.get(size);
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_game_imgtypes(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_game_imgtypes.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_ptr_game_imgtypes(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_game_imgtypes.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_entire_info_params::clear_game_imgtypes(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_game_imgtypes.clear();
}
inline bool mcp_get_game_news_entire_info_params::has_channel_info() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* mcp_get_game_news_entire_info_params::channel_info(unsigned int* size) const{
return _m_channel_info.get(size);
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_channel_info(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_channel_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_ptr_channel_info(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_channel_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_entire_info_params::clear_channel_info(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_channel_info.clear();
}
inline bool mcp_get_game_news_entire_info_params::has_channel_id() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* mcp_get_game_news_entire_info_params::channel_id(unsigned int* size) const{
return _m_channel_id.get(size);
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_channel_id(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_channel_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_ptr_channel_id(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_channel_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_entire_info_params::clear_channel_id(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_channel_id.clear();
}
inline bool mcp_get_game_news_entire_info_params::has_page() const{
return (_flag[8 >> 3] & (1 << (8 & 0x7)));
}
inline uint32_t mcp_get_game_news_entire_info_params::page() const{
return _m_page;
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_page(uint32_t v){
_flag[8 >> 3] |= (1 << (8 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_game_news_entire_info_params::clear_page(){
_flag[8 >> 3] &= ~(1 << (8 & 0x7));
 _m_page=0;
}
inline bool mcp_get_game_news_entire_info_params::has_page_size() const{
return (_flag[9 >> 3] & (1 << (9 & 0x7)));
}
inline uint32_t mcp_get_game_news_entire_info_params::page_size() const{
return _m_page_size;
}
inline mcp_get_game_news_entire_info_params& mcp_get_game_news_entire_info_params::set_page_size(uint32_t v){
_flag[9 >> 3] |= (1 << (9 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_game_news_entire_info_params::clear_page_size(){
_flag[9 >> 3] &= ~(1 << (9 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_game_news_entire_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_news_entire_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_news_entire_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_news_entire_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_news_entire_info_result_params* mcp_get_game_news_entire_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_news_entire_info_result_params* tmp=(mcp_get_game_news_entire_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_news_entire_info_result_params(pool);
return tmp;
}
inline void mcp_get_game_news_entire_info_result_params::destroy(mcp_get_game_news_entire_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_news_entire_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_news_entire_info_result_params::mcp_get_game_news_entire_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_game_news_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_news_entire_info_result_params::mcp_get_game_news_entire_info_result_params(const mcp_get_game_news_entire_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_game_news_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_news_entire_info_result_params::~mcp_get_game_news_entire_info_result_params(){
}
inline mcp_get_game_news_entire_info_result_params& mcp_get_game_news_entire_info_result_params::operator=(const mcp_get_game_news_entire_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_news_entire_info_result_params::clear(){
// _m_count=0;
_m_game_news_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_news_entire_info_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@game_news_entire_info_t game_news_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_news_list" << "' not found";
}
{
// level 0 begin
typeof(_m_game_news_list)& lr0=(_m_game_news_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_news_entire_info_t& item=const_cast< ::idl::game_news_entire_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_game_news_entire_info_result_params::detach(){
_m_game_news_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_news_entire_info_result_params& mcp_get_game_news_entire_info_result_params::assign(const mcp_get_game_news_entire_info_result_params& v){
_m_count=v._m_count;
_m_game_news_list=v._m_game_news_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_news_entire_info_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_game_news_entire_info_result_params::count() const{
return _m_count;
}
inline mcp_get_game_news_entire_info_result_params& mcp_get_game_news_entire_info_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_game_news_entire_info_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_game_news_entire_info_result_params::has_game_news_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_news_entire_info_t >& mcp_get_game_news_entire_info_result_params::game_news_list() const{
 return _m_game_news_list;
}
inline void mcp_get_game_news_entire_info_result_params::clear_game_news_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_news_list.clear();
}
inline ::idl::vector< ::idl::game_news_entire_info_t >* mcp_get_game_news_entire_info_result_params::mutable_game_news_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_news_list);
}
inline ::idl::vector< ::idl::game_news_entire_info_t >* mcp_get_game_news_entire_info_result_params::m_game_news_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_news_list);
}
inline size_t mcp_get_game_news_entire_info_result_params::game_news_list_size() const{
/*  */ return _m_game_news_list.size();
}
inline const ::idl::game_news_entire_info_t& mcp_get_game_news_entire_info_result_params::game_news_list(size_t i0) const{
 return _m_game_news_list.get(i0);
}
inline ::idl::game_news_entire_info_t* mcp_get_game_news_entire_info_result_params::mutable_game_news_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_news_list.mutable_get(i0);
}
inline ::idl::game_news_entire_info_t* mcp_get_game_news_entire_info_result_params::m_game_news_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_news_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_game_news_entire_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_news_entire_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_news_entire_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_news_entire_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_news_entire_info_response* mcp_get_game_news_entire_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_news_entire_info_response* tmp=(mcp_get_game_news_entire_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_news_entire_info_response(pool);
return tmp;
}
inline void mcp_get_game_news_entire_info_response::destroy(mcp_get_game_news_entire_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_news_entire_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_news_entire_info_response::mcp_get_game_news_entire_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_news_entire_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_news_entire_info_response::mcp_get_game_news_entire_info_response(const mcp_get_game_news_entire_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_news_entire_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_news_entire_info_response::~mcp_get_game_news_entire_info_response(){
if(_m_result_params){
::idl::mcp_get_game_news_entire_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_news_entire_info_response& mcp_get_game_news_entire_info_response::operator=(const mcp_get_game_news_entire_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_news_entire_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_news_entire_info_response::check() const{
// @@mcp_get_game_news_entire_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_news_entire_info_result_params& item=const_cast< ::idl::mcp_get_game_news_entire_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_news_entire_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_news_entire_info_response& mcp_get_game_news_entire_info_response::assign(const mcp_get_game_news_entire_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_news_entire_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_news_entire_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_news_entire_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_news_entire_info_result_params& mcp_get_game_news_entire_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_news_entire_info_result_params* mcp_get_game_news_entire_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_news_entire_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_news_entire_info_result_params* mcp_get_game_news_entire_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_news_entire_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_news_entire_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_news_entire_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_news_entire_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_news_entire_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_news_entire_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_netgame_activity_info_params* mcp_get_netgame_activity_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_netgame_activity_info_params* tmp=(mcp_get_netgame_activity_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_netgame_activity_info_params(pool);
return tmp;
}
inline void mcp_get_netgame_activity_info_params::destroy(mcp_get_netgame_activity_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_netgame_activity_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_netgame_activity_info_params::mcp_get_netgame_activity_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_game_id(_pool)
,_m_act_id(_pool)
,_m_date_limit(_pool)
,_m_channel(_pool)
,_m_game_img_type(_pool)
,_m_act_img_type(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_netgame_activity_info_params::mcp_get_netgame_activity_info_params(const mcp_get_netgame_activity_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_game_id(_pool)
,_m_act_id(_pool)
,_m_date_limit(_pool)
,_m_channel(_pool)
,_m_game_img_type(_pool)
,_m_act_img_type(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_netgame_activity_info_params::~mcp_get_netgame_activity_info_params(){
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::operator=(const mcp_get_netgame_activity_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_netgame_activity_info_params::clear(){
_m_game_id.clear();
_m_act_id.clear();
_m_date_limit.clear();
_m_channel.clear();
_m_game_img_type.clear();
_m_act_img_type.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_netgame_activity_info_params::check() const{
// @@string game_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}
// @@string act_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "act_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_act_id.get();

}
// @@string date_limit=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "date_limit" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_date_limit.get();

}
// @@string channel=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "channel" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_channel.get();

}
// @@string game_img_type=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_img_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_img_type.get();

}
// @@string act_img_type=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "act_img_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_act_img_type.get();

}
// @@uint32_t page=in();
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_netgame_activity_info_params::detach(){
_m_game_id.detach();
_m_act_id.detach();
_m_date_limit.detach();
_m_channel.detach();
_m_game_img_type.detach();
_m_act_img_type.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::assign(const mcp_get_netgame_activity_info_params& v){
_m_game_id=v._m_game_id;
_m_act_id=v._m_act_id;
_m_date_limit=v._m_date_limit;
_m_channel=v._m_channel;
_m_game_img_type=v._m_game_img_type;
_m_act_img_type=v._m_act_img_type;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_netgame_activity_info_params::has_game_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_netgame_activity_info_params::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_ptr_game_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_netgame_activity_info_params::clear_game_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_game_id.clear();
}
inline bool mcp_get_netgame_activity_info_params::has_act_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_netgame_activity_info_params::act_id(unsigned int* size) const{
return _m_act_id.get(size);
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_act_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_act_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_ptr_act_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_act_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_netgame_activity_info_params::clear_act_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_act_id.clear();
}
inline bool mcp_get_netgame_activity_info_params::has_date_limit() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_netgame_activity_info_params::date_limit(unsigned int* size) const{
return _m_date_limit.get(size);
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_date_limit(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_date_limit.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_ptr_date_limit(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_date_limit.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_netgame_activity_info_params::clear_date_limit(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_date_limit.clear();
}
inline bool mcp_get_netgame_activity_info_params::has_channel() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_netgame_activity_info_params::channel(unsigned int* size) const{
return _m_channel.get(size);
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_channel(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_channel.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_ptr_channel(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_channel.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_netgame_activity_info_params::clear_channel(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_channel.clear();
}
inline bool mcp_get_netgame_activity_info_params::has_game_img_type() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_get_netgame_activity_info_params::game_img_type(unsigned int* size) const{
return _m_game_img_type.get(size);
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_game_img_type(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_game_img_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_ptr_game_img_type(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_game_img_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_netgame_activity_info_params::clear_game_img_type(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_game_img_type.clear();
}
inline bool mcp_get_netgame_activity_info_params::has_act_img_type() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* mcp_get_netgame_activity_info_params::act_img_type(unsigned int* size) const{
return _m_act_img_type.get(size);
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_act_img_type(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_act_img_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_ptr_act_img_type(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_act_img_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_netgame_activity_info_params::clear_act_img_type(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_act_img_type.clear();
}
inline bool mcp_get_netgame_activity_info_params::has_page() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline uint32_t mcp_get_netgame_activity_info_params::page() const{
return _m_page;
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_page(uint32_t v){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_netgame_activity_info_params::clear_page(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_page=0;
}
inline bool mcp_get_netgame_activity_info_params::has_page_size() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline uint32_t mcp_get_netgame_activity_info_params::page_size() const{
return _m_page_size;
}
inline mcp_get_netgame_activity_info_params& mcp_get_netgame_activity_info_params::set_page_size(uint32_t v){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_netgame_activity_info_params::clear_page_size(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_netgame_activity_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_netgame_activity_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_netgame_activity_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_netgame_activity_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_netgame_activity_info_result_params* mcp_get_netgame_activity_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_netgame_activity_info_result_params* tmp=(mcp_get_netgame_activity_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_netgame_activity_info_result_params(pool);
return tmp;
}
inline void mcp_get_netgame_activity_info_result_params::destroy(mcp_get_netgame_activity_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_netgame_activity_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_netgame_activity_info_result_params::mcp_get_netgame_activity_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_netgame_activity_info_result_params::mcp_get_netgame_activity_info_result_params(const mcp_get_netgame_activity_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_netgame_activity_info_result_params::~mcp_get_netgame_activity_info_result_params(){
}
inline mcp_get_netgame_activity_info_result_params& mcp_get_netgame_activity_info_result_params::operator=(const mcp_get_netgame_activity_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_netgame_activity_info_result_params::clear(){
// _m_count=0;
_m_result_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_netgame_activity_info_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@netgame_activity_info_t result_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_list" << "' not found";
}
{
// level 0 begin
typeof(_m_result_list)& lr0=(_m_result_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::netgame_activity_info_t& item=const_cast< ::idl::netgame_activity_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_netgame_activity_info_result_params::detach(){
_m_result_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_netgame_activity_info_result_params& mcp_get_netgame_activity_info_result_params::assign(const mcp_get_netgame_activity_info_result_params& v){
_m_count=v._m_count;
_m_result_list=v._m_result_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_netgame_activity_info_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_netgame_activity_info_result_params::count() const{
return _m_count;
}
inline mcp_get_netgame_activity_info_result_params& mcp_get_netgame_activity_info_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_netgame_activity_info_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_netgame_activity_info_result_params::has_result_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::netgame_activity_info_t >& mcp_get_netgame_activity_info_result_params::result_list() const{
 return _m_result_list;
}
inline void mcp_get_netgame_activity_info_result_params::clear_result_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_result_list.clear();
}
inline ::idl::vector< ::idl::netgame_activity_info_t >* mcp_get_netgame_activity_info_result_params::mutable_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline ::idl::vector< ::idl::netgame_activity_info_t >* mcp_get_netgame_activity_info_result_params::m_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline size_t mcp_get_netgame_activity_info_result_params::result_list_size() const{
/*  */ return _m_result_list.size();
}
inline const ::idl::netgame_activity_info_t& mcp_get_netgame_activity_info_result_params::result_list(size_t i0) const{
 return _m_result_list.get(i0);
}
inline ::idl::netgame_activity_info_t* mcp_get_netgame_activity_info_result_params::mutable_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::netgame_activity_info_t* mcp_get_netgame_activity_info_result_params::m_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_netgame_activity_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_netgame_activity_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_netgame_activity_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_netgame_activity_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_netgame_activity_info_response* mcp_get_netgame_activity_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_netgame_activity_info_response* tmp=(mcp_get_netgame_activity_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_netgame_activity_info_response(pool);
return tmp;
}
inline void mcp_get_netgame_activity_info_response::destroy(mcp_get_netgame_activity_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_netgame_activity_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_netgame_activity_info_response::mcp_get_netgame_activity_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_netgame_activity_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_netgame_activity_info_response::mcp_get_netgame_activity_info_response(const mcp_get_netgame_activity_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_netgame_activity_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_netgame_activity_info_response::~mcp_get_netgame_activity_info_response(){
if(_m_result_params){
::idl::mcp_get_netgame_activity_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_netgame_activity_info_response& mcp_get_netgame_activity_info_response::operator=(const mcp_get_netgame_activity_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_netgame_activity_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_netgame_activity_info_response::check() const{
// @@mcp_get_netgame_activity_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_netgame_activity_info_result_params& item=const_cast< ::idl::mcp_get_netgame_activity_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_netgame_activity_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_netgame_activity_info_response& mcp_get_netgame_activity_info_response::assign(const mcp_get_netgame_activity_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_netgame_activity_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_netgame_activity_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_netgame_activity_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_netgame_activity_info_result_params& mcp_get_netgame_activity_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_netgame_activity_info_result_params* mcp_get_netgame_activity_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_netgame_activity_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_netgame_activity_info_result_params* mcp_get_netgame_activity_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_netgame_activity_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_netgame_activity_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_netgame_activity_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_netgame_activity_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_netgame_activity_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_netgame_activity_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_download_app_info_params* mcp_get_game_download_app_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_download_app_info_params* tmp=(mcp_get_game_download_app_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_download_app_info_params(pool);
return tmp;
}
inline void mcp_get_game_download_app_info_params::destroy(mcp_get_game_download_app_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_download_app_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_download_app_info_params::mcp_get_game_download_app_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_c_id(_pool)
,_m_package_name(_pool)
,_m_dev_version_code(_pool)
,_m_dev_version(_pool)
,_m_apk_md5(_pool)
,_m_file_md5(_pool)
,_m_game_img(_pool)
,_m_filter(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_download_app_info_params::mcp_get_game_download_app_info_params(const mcp_get_game_download_app_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_c_id(_pool)
,_m_package_name(_pool)
,_m_dev_version_code(_pool)
,_m_dev_version(_pool)
,_m_apk_md5(_pool)
,_m_file_md5(_pool)
,_m_game_img(_pool)
,_m_filter(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_download_app_info_params::~mcp_get_game_download_app_info_params(){
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::operator=(const mcp_get_game_download_app_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_download_app_info_params::clear(){
_m_c_id.clear();
_m_package_name.clear();
_m_dev_version_code.clear();
_m_dev_version.clear();
_m_apk_md5.clear();
_m_file_md5.clear();
_m_game_img.clear();
_m_filter.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_download_app_info_params::check() const{
// @@string c_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string package_name=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "package_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_package_name.get();

}
// @@string dev_version_code=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "dev_version_code" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_dev_version_code.get();

}
// @@string dev_version=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "dev_version" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_dev_version.get();

}
// @@string apk_md5=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "apk_md5" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_apk_md5.get();

}
// @@string file_md5=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "file_md5" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_file_md5.get();

}
// @@string game_img=in();
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_img" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_img.get();

}
// @@string filter=in();
if(!(_flag[7 >> 3] & (1 << (7 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "filter" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_filter.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_download_app_info_params::detach(){
_m_c_id.detach();
_m_package_name.detach();
_m_dev_version_code.detach();
_m_dev_version.detach();
_m_apk_md5.detach();
_m_file_md5.detach();
_m_game_img.detach();
_m_filter.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::assign(const mcp_get_game_download_app_info_params& v){
_m_c_id=v._m_c_id;
_m_package_name=v._m_package_name;
_m_dev_version_code=v._m_dev_version_code;
_m_dev_version=v._m_dev_version;
_m_apk_md5=v._m_apk_md5;
_m_file_md5=v._m_file_md5;
_m_game_img=v._m_game_img;
_m_filter=v._m_filter;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_download_app_info_params::has_c_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_download_app_info_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_download_app_info_params::clear_c_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_c_id.clear();
}
inline bool mcp_get_game_download_app_info_params::has_package_name() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_game_download_app_info_params::package_name(unsigned int* size) const{
return _m_package_name.get(size);
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_package_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_package_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_ptr_package_name(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_package_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_download_app_info_params::clear_package_name(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_package_name.clear();
}
inline bool mcp_get_game_download_app_info_params::has_dev_version_code() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_game_download_app_info_params::dev_version_code(unsigned int* size) const{
return _m_dev_version_code.get(size);
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_dev_version_code(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_dev_version_code.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_ptr_dev_version_code(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_dev_version_code.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_download_app_info_params::clear_dev_version_code(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_dev_version_code.clear();
}
inline bool mcp_get_game_download_app_info_params::has_dev_version() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_game_download_app_info_params::dev_version(unsigned int* size) const{
return _m_dev_version.get(size);
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_dev_version(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_dev_version.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_ptr_dev_version(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_dev_version.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_download_app_info_params::clear_dev_version(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_dev_version.clear();
}
inline bool mcp_get_game_download_app_info_params::has_apk_md5() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_get_game_download_app_info_params::apk_md5(unsigned int* size) const{
return _m_apk_md5.get(size);
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_apk_md5(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_apk_md5.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_ptr_apk_md5(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_apk_md5.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_download_app_info_params::clear_apk_md5(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_apk_md5.clear();
}
inline bool mcp_get_game_download_app_info_params::has_file_md5() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline const char* mcp_get_game_download_app_info_params::file_md5(unsigned int* size) const{
return _m_file_md5.get(size);
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_file_md5(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_file_md5.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_ptr_file_md5(const char* s,ssize_t size){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_file_md5.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_download_app_info_params::clear_file_md5(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_file_md5.clear();
}
inline bool mcp_get_game_download_app_info_params::has_game_img() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline const char* mcp_get_game_download_app_info_params::game_img(unsigned int* size) const{
return _m_game_img.get(size);
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_game_img(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_game_img.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_ptr_game_img(const char* s,ssize_t size){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_game_img.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_download_app_info_params::clear_game_img(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_game_img.clear();
}
inline bool mcp_get_game_download_app_info_params::has_filter() const{
return (_flag[7 >> 3] & (1 << (7 & 0x7)));
}
inline const char* mcp_get_game_download_app_info_params::filter(unsigned int* size) const{
return _m_filter.get(size);
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_filter(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_filter.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_download_app_info_params& mcp_get_game_download_app_info_params::set_ptr_filter(const char* s,ssize_t size){
_flag[7 >> 3] |= (1 << (7 & 0x7));
 _m_filter.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_download_app_info_params::clear_filter(){
_flag[7 >> 3] &= ~(1 << (7 & 0x7));
 _m_filter.clear();
}
inline ::idl::Unknown* mcp_get_game_download_app_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_download_app_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_download_app_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_download_app_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_download_app_info_result_params* mcp_get_game_download_app_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_download_app_info_result_params* tmp=(mcp_get_game_download_app_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_download_app_info_result_params(pool);
return tmp;
}
inline void mcp_get_game_download_app_info_result_params::destroy(mcp_get_game_download_app_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_download_app_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_download_app_info_result_params::mcp_get_game_download_app_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_download_app_info_result_params::mcp_get_game_download_app_info_result_params(const mcp_get_game_download_app_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_download_app_info_result_params::~mcp_get_game_download_app_info_result_params(){
}
inline mcp_get_game_download_app_info_result_params& mcp_get_game_download_app_info_result_params::operator=(const mcp_get_game_download_app_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_download_app_info_result_params::clear(){
// _m_count=0;
_m_result_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_download_app_info_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@game_update_download_info result_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_list" << "' not found";
}
{
// level 0 begin
typeof(_m_result_list)& lr0=(_m_result_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_update_download_info& item=const_cast< ::idl::game_update_download_info& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_game_download_app_info_result_params::detach(){
_m_result_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_download_app_info_result_params& mcp_get_game_download_app_info_result_params::assign(const mcp_get_game_download_app_info_result_params& v){
_m_count=v._m_count;
_m_result_list=v._m_result_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_download_app_info_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_game_download_app_info_result_params::count() const{
return _m_count;
}
inline mcp_get_game_download_app_info_result_params& mcp_get_game_download_app_info_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_game_download_app_info_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_game_download_app_info_result_params::has_result_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_update_download_info >& mcp_get_game_download_app_info_result_params::result_list() const{
 return _m_result_list;
}
inline void mcp_get_game_download_app_info_result_params::clear_result_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_result_list.clear();
}
inline ::idl::vector< ::idl::game_update_download_info >* mcp_get_game_download_app_info_result_params::mutable_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline ::idl::vector< ::idl::game_update_download_info >* mcp_get_game_download_app_info_result_params::m_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline size_t mcp_get_game_download_app_info_result_params::result_list_size() const{
/*  */ return _m_result_list.size();
}
inline const ::idl::game_update_download_info& mcp_get_game_download_app_info_result_params::result_list(size_t i0) const{
 return _m_result_list.get(i0);
}
inline ::idl::game_update_download_info* mcp_get_game_download_app_info_result_params::mutable_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::game_update_download_info* mcp_get_game_download_app_info_result_params::m_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_game_download_app_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_download_app_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_download_app_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_download_app_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_download_app_info_response* mcp_get_game_download_app_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_download_app_info_response* tmp=(mcp_get_game_download_app_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_download_app_info_response(pool);
return tmp;
}
inline void mcp_get_game_download_app_info_response::destroy(mcp_get_game_download_app_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_download_app_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_download_app_info_response::mcp_get_game_download_app_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_download_app_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_download_app_info_response::mcp_get_game_download_app_info_response(const mcp_get_game_download_app_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_download_app_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_download_app_info_response::~mcp_get_game_download_app_info_response(){
if(_m_result_params){
::idl::mcp_get_game_download_app_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_download_app_info_response& mcp_get_game_download_app_info_response::operator=(const mcp_get_game_download_app_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_download_app_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_download_app_info_response::check() const{
// @@mcp_get_game_download_app_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_download_app_info_result_params& item=const_cast< ::idl::mcp_get_game_download_app_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_download_app_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_download_app_info_response& mcp_get_game_download_app_info_response::assign(const mcp_get_game_download_app_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_download_app_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_download_app_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_download_app_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_download_app_info_result_params& mcp_get_game_download_app_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_download_app_info_result_params* mcp_get_game_download_app_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_download_app_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_download_app_info_result_params* mcp_get_game_download_app_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_download_app_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_download_app_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_download_app_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_download_app_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_download_app_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_download_app_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_dbapp_detail_info_params* mcp_get_game_dbapp_detail_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_dbapp_detail_info_params* tmp=(mcp_get_game_dbapp_detail_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_dbapp_detail_info_params(pool);
return tmp;
}
inline void mcp_get_game_dbapp_detail_info_params::destroy(mcp_get_game_dbapp_detail_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_dbapp_detail_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_dbapp_detail_info_params::mcp_get_game_dbapp_detail_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_package_name(_pool)
,_m_game_img(_pool)
,_m_filter(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_dbapp_detail_info_params::mcp_get_game_dbapp_detail_info_params(const mcp_get_game_dbapp_detail_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_package_name(_pool)
,_m_game_img(_pool)
,_m_filter(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_dbapp_detail_info_params::~mcp_get_game_dbapp_detail_info_params(){
}
inline mcp_get_game_dbapp_detail_info_params& mcp_get_game_dbapp_detail_info_params::operator=(const mcp_get_game_dbapp_detail_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_dbapp_detail_info_params::clear(){
_m_package_name.clear();
_m_game_img.clear();
_m_filter.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_dbapp_detail_info_params::check() const{
// @@string package_name=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "package_name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_package_name.get();

}
// @@string game_img=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_img" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_img.get();

}
// @@string filter=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "filter" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_filter.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_dbapp_detail_info_params::detach(){
_m_package_name.detach();
_m_game_img.detach();
_m_filter.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_dbapp_detail_info_params& mcp_get_game_dbapp_detail_info_params::assign(const mcp_get_game_dbapp_detail_info_params& v){
_m_package_name=v._m_package_name;
_m_game_img=v._m_game_img;
_m_filter=v._m_filter;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_dbapp_detail_info_params::has_package_name() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_dbapp_detail_info_params::package_name(unsigned int* size) const{
return _m_package_name.get(size);
}
inline mcp_get_game_dbapp_detail_info_params& mcp_get_game_dbapp_detail_info_params::set_package_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_package_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_dbapp_detail_info_params& mcp_get_game_dbapp_detail_info_params::set_ptr_package_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_package_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_dbapp_detail_info_params::clear_package_name(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_package_name.clear();
}
inline bool mcp_get_game_dbapp_detail_info_params::has_game_img() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_game_dbapp_detail_info_params::game_img(unsigned int* size) const{
return _m_game_img.get(size);
}
inline mcp_get_game_dbapp_detail_info_params& mcp_get_game_dbapp_detail_info_params::set_game_img(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_img.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_dbapp_detail_info_params& mcp_get_game_dbapp_detail_info_params::set_ptr_game_img(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_img.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_dbapp_detail_info_params::clear_game_img(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_img.clear();
}
inline bool mcp_get_game_dbapp_detail_info_params::has_filter() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_game_dbapp_detail_info_params::filter(unsigned int* size) const{
return _m_filter.get(size);
}
inline mcp_get_game_dbapp_detail_info_params& mcp_get_game_dbapp_detail_info_params::set_filter(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_filter.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_dbapp_detail_info_params& mcp_get_game_dbapp_detail_info_params::set_ptr_filter(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_filter.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_dbapp_detail_info_params::clear_filter(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_filter.clear();
}
inline ::idl::Unknown* mcp_get_game_dbapp_detail_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_dbapp_detail_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_dbapp_detail_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_dbapp_detail_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_dbapp_detail_info_result_params* mcp_get_game_dbapp_detail_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_dbapp_detail_info_result_params* tmp=(mcp_get_game_dbapp_detail_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_dbapp_detail_info_result_params(pool);
return tmp;
}
inline void mcp_get_game_dbapp_detail_info_result_params::destroy(mcp_get_game_dbapp_detail_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_dbapp_detail_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_dbapp_detail_info_result_params::mcp_get_game_dbapp_detail_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_dbapp_detail_info_result_params::mcp_get_game_dbapp_detail_info_result_params(const mcp_get_game_dbapp_detail_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_dbapp_detail_info_result_params::~mcp_get_game_dbapp_detail_info_result_params(){
}
inline mcp_get_game_dbapp_detail_info_result_params& mcp_get_game_dbapp_detail_info_result_params::operator=(const mcp_get_game_dbapp_detail_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_dbapp_detail_info_result_params::clear(){
// _m_count=0;
_m_result_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_dbapp_detail_info_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@game_update_download_info result_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_list" << "' not found";
}
{
// level 0 begin
typeof(_m_result_list)& lr0=(_m_result_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_update_download_info& item=const_cast< ::idl::game_update_download_info& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_game_dbapp_detail_info_result_params::detach(){
_m_result_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_dbapp_detail_info_result_params& mcp_get_game_dbapp_detail_info_result_params::assign(const mcp_get_game_dbapp_detail_info_result_params& v){
_m_count=v._m_count;
_m_result_list=v._m_result_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_dbapp_detail_info_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_game_dbapp_detail_info_result_params::count() const{
return _m_count;
}
inline mcp_get_game_dbapp_detail_info_result_params& mcp_get_game_dbapp_detail_info_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_game_dbapp_detail_info_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_game_dbapp_detail_info_result_params::has_result_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_update_download_info >& mcp_get_game_dbapp_detail_info_result_params::result_list() const{
 return _m_result_list;
}
inline void mcp_get_game_dbapp_detail_info_result_params::clear_result_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_result_list.clear();
}
inline ::idl::vector< ::idl::game_update_download_info >* mcp_get_game_dbapp_detail_info_result_params::mutable_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline ::idl::vector< ::idl::game_update_download_info >* mcp_get_game_dbapp_detail_info_result_params::m_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline size_t mcp_get_game_dbapp_detail_info_result_params::result_list_size() const{
/*  */ return _m_result_list.size();
}
inline const ::idl::game_update_download_info& mcp_get_game_dbapp_detail_info_result_params::result_list(size_t i0) const{
 return _m_result_list.get(i0);
}
inline ::idl::game_update_download_info* mcp_get_game_dbapp_detail_info_result_params::mutable_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::game_update_download_info* mcp_get_game_dbapp_detail_info_result_params::m_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_game_dbapp_detail_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_dbapp_detail_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_dbapp_detail_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_dbapp_detail_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_dbapp_detail_info_response* mcp_get_game_dbapp_detail_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_dbapp_detail_info_response* tmp=(mcp_get_game_dbapp_detail_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_dbapp_detail_info_response(pool);
return tmp;
}
inline void mcp_get_game_dbapp_detail_info_response::destroy(mcp_get_game_dbapp_detail_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_dbapp_detail_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_dbapp_detail_info_response::mcp_get_game_dbapp_detail_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_dbapp_detail_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_dbapp_detail_info_response::mcp_get_game_dbapp_detail_info_response(const mcp_get_game_dbapp_detail_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_dbapp_detail_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_dbapp_detail_info_response::~mcp_get_game_dbapp_detail_info_response(){
if(_m_result_params){
::idl::mcp_get_game_dbapp_detail_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_dbapp_detail_info_response& mcp_get_game_dbapp_detail_info_response::operator=(const mcp_get_game_dbapp_detail_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_dbapp_detail_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_dbapp_detail_info_response::check() const{
// @@mcp_get_game_dbapp_detail_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_dbapp_detail_info_result_params& item=const_cast< ::idl::mcp_get_game_dbapp_detail_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_dbapp_detail_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_dbapp_detail_info_response& mcp_get_game_dbapp_detail_info_response::assign(const mcp_get_game_dbapp_detail_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_dbapp_detail_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_dbapp_detail_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_dbapp_detail_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_dbapp_detail_info_result_params& mcp_get_game_dbapp_detail_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_dbapp_detail_info_result_params* mcp_get_game_dbapp_detail_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_dbapp_detail_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_dbapp_detail_info_result_params* mcp_get_game_dbapp_detail_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_dbapp_detail_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_dbapp_detail_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_dbapp_detail_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_dbapp_detail_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_dbapp_detail_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_dbapp_detail_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_device_download_games_info_by_udid_params* mcp_get_device_download_games_info_by_udid_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_device_download_games_info_by_udid_params* tmp=(mcp_get_device_download_games_info_by_udid_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_device_download_games_info_by_udid_params(pool);
return tmp;
}
inline void mcp_get_device_download_games_info_by_udid_params::destroy(mcp_get_device_download_games_info_by_udid_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_device_download_games_info_by_udid_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_device_download_games_info_by_udid_params::mcp_get_device_download_games_info_by_udid_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_udid(_pool)
,_m_img_types(_pool)
,_m_filter(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_device_download_games_info_by_udid_params::mcp_get_device_download_games_info_by_udid_params(const mcp_get_device_download_games_info_by_udid_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_udid(_pool)
,_m_img_types(_pool)
,_m_filter(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_device_download_games_info_by_udid_params::~mcp_get_device_download_games_info_by_udid_params(){
}
inline mcp_get_device_download_games_info_by_udid_params& mcp_get_device_download_games_info_by_udid_params::operator=(const mcp_get_device_download_games_info_by_udid_params& v){
assign(v);
return *this;
}
inline void mcp_get_device_download_games_info_by_udid_params::clear(){
_m_udid.clear();
_m_img_types.clear();
_m_filter.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_device_download_games_info_by_udid_params::check() const{
// @@string udid=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "udid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_udid.get();

}
// @@string img_types=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "img_types" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_img_types.get();

}
// @@string filter=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "filter" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_filter.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_device_download_games_info_by_udid_params::detach(){
_m_udid.detach();
_m_img_types.detach();
_m_filter.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_device_download_games_info_by_udid_params& mcp_get_device_download_games_info_by_udid_params::assign(const mcp_get_device_download_games_info_by_udid_params& v){
_m_udid=v._m_udid;
_m_img_types=v._m_img_types;
_m_filter=v._m_filter;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_device_download_games_info_by_udid_params::has_udid() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_device_download_games_info_by_udid_params::udid(unsigned int* size) const{
return _m_udid.get(size);
}
inline mcp_get_device_download_games_info_by_udid_params& mcp_get_device_download_games_info_by_udid_params::set_udid(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_udid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_device_download_games_info_by_udid_params& mcp_get_device_download_games_info_by_udid_params::set_ptr_udid(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_udid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_device_download_games_info_by_udid_params::clear_udid(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_udid.clear();
}
inline bool mcp_get_device_download_games_info_by_udid_params::has_img_types() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_device_download_games_info_by_udid_params::img_types(unsigned int* size) const{
return _m_img_types.get(size);
}
inline mcp_get_device_download_games_info_by_udid_params& mcp_get_device_download_games_info_by_udid_params::set_img_types(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_img_types.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_device_download_games_info_by_udid_params& mcp_get_device_download_games_info_by_udid_params::set_ptr_img_types(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_img_types.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_device_download_games_info_by_udid_params::clear_img_types(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_img_types.clear();
}
inline bool mcp_get_device_download_games_info_by_udid_params::has_filter() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_device_download_games_info_by_udid_params::filter(unsigned int* size) const{
return _m_filter.get(size);
}
inline mcp_get_device_download_games_info_by_udid_params& mcp_get_device_download_games_info_by_udid_params::set_filter(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_filter.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_device_download_games_info_by_udid_params& mcp_get_device_download_games_info_by_udid_params::set_ptr_filter(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_filter.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_device_download_games_info_by_udid_params::clear_filter(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_filter.clear();
}
inline ::idl::Unknown* mcp_get_device_download_games_info_by_udid_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_device_download_games_info_by_udid_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_device_download_games_info_by_udid_params::unknown(){
return _unknown;
}
inline size_t mcp_get_device_download_games_info_by_udid_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_device_download_games_info_by_udid_result_params* mcp_get_device_download_games_info_by_udid_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_device_download_games_info_by_udid_result_params* tmp=(mcp_get_device_download_games_info_by_udid_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_device_download_games_info_by_udid_result_params(pool);
return tmp;
}
inline void mcp_get_device_download_games_info_by_udid_result_params::destroy(mcp_get_device_download_games_info_by_udid_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_device_download_games_info_by_udid_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_device_download_games_info_by_udid_result_params::mcp_get_device_download_games_info_by_udid_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_device_download_games_info_by_udid_result_params::mcp_get_device_download_games_info_by_udid_result_params(const mcp_get_device_download_games_info_by_udid_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_device_download_games_info_by_udid_result_params::~mcp_get_device_download_games_info_by_udid_result_params(){
}
inline mcp_get_device_download_games_info_by_udid_result_params& mcp_get_device_download_games_info_by_udid_result_params::operator=(const mcp_get_device_download_games_info_by_udid_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_device_download_games_info_by_udid_result_params::clear(){
// _m_count=0;
_m_result_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_device_download_games_info_by_udid_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@game_content_download_info_t result_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_list" << "' not found";
}
{
// level 0 begin
typeof(_m_result_list)& lr0=(_m_result_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_content_download_info_t& item=const_cast< ::idl::game_content_download_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_device_download_games_info_by_udid_result_params::detach(){
_m_result_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_device_download_games_info_by_udid_result_params& mcp_get_device_download_games_info_by_udid_result_params::assign(const mcp_get_device_download_games_info_by_udid_result_params& v){
_m_count=v._m_count;
_m_result_list=v._m_result_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_device_download_games_info_by_udid_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_device_download_games_info_by_udid_result_params::count() const{
return _m_count;
}
inline mcp_get_device_download_games_info_by_udid_result_params& mcp_get_device_download_games_info_by_udid_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_device_download_games_info_by_udid_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_device_download_games_info_by_udid_result_params::has_result_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_content_download_info_t >& mcp_get_device_download_games_info_by_udid_result_params::result_list() const{
 return _m_result_list;
}
inline void mcp_get_device_download_games_info_by_udid_result_params::clear_result_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_result_list.clear();
}
inline ::idl::vector< ::idl::game_content_download_info_t >* mcp_get_device_download_games_info_by_udid_result_params::mutable_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline ::idl::vector< ::idl::game_content_download_info_t >* mcp_get_device_download_games_info_by_udid_result_params::m_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline size_t mcp_get_device_download_games_info_by_udid_result_params::result_list_size() const{
/*  */ return _m_result_list.size();
}
inline const ::idl::game_content_download_info_t& mcp_get_device_download_games_info_by_udid_result_params::result_list(size_t i0) const{
 return _m_result_list.get(i0);
}
inline ::idl::game_content_download_info_t* mcp_get_device_download_games_info_by_udid_result_params::mutable_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::game_content_download_info_t* mcp_get_device_download_games_info_by_udid_result_params::m_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_device_download_games_info_by_udid_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_device_download_games_info_by_udid_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_device_download_games_info_by_udid_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_device_download_games_info_by_udid_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_device_download_games_info_by_udid_response* mcp_get_device_download_games_info_by_udid_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_device_download_games_info_by_udid_response* tmp=(mcp_get_device_download_games_info_by_udid_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_device_download_games_info_by_udid_response(pool);
return tmp;
}
inline void mcp_get_device_download_games_info_by_udid_response::destroy(mcp_get_device_download_games_info_by_udid_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_device_download_games_info_by_udid_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_device_download_games_info_by_udid_response::mcp_get_device_download_games_info_by_udid_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_device_download_games_info_by_udid_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_device_download_games_info_by_udid_response::mcp_get_device_download_games_info_by_udid_response(const mcp_get_device_download_games_info_by_udid_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_device_download_games_info_by_udid_result_params::create(_pool);
assign(v);
}
inline mcp_get_device_download_games_info_by_udid_response::~mcp_get_device_download_games_info_by_udid_response(){
if(_m_result_params){
::idl::mcp_get_device_download_games_info_by_udid_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_device_download_games_info_by_udid_response& mcp_get_device_download_games_info_by_udid_response::operator=(const mcp_get_device_download_games_info_by_udid_response& v){
assign(v);
return *this;
}
inline void mcp_get_device_download_games_info_by_udid_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_device_download_games_info_by_udid_response::check() const{
// @@mcp_get_device_download_games_info_by_udid_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_device_download_games_info_by_udid_result_params& item=const_cast< ::idl::mcp_get_device_download_games_info_by_udid_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_device_download_games_info_by_udid_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_device_download_games_info_by_udid_response& mcp_get_device_download_games_info_by_udid_response::assign(const mcp_get_device_download_games_info_by_udid_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_device_download_games_info_by_udid_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_device_download_games_info_by_udid_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_device_download_games_info_by_udid_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_device_download_games_info_by_udid_result_params& mcp_get_device_download_games_info_by_udid_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_device_download_games_info_by_udid_result_params* mcp_get_device_download_games_info_by_udid_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_device_download_games_info_by_udid_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_device_download_games_info_by_udid_result_params* mcp_get_device_download_games_info_by_udid_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_device_download_games_info_by_udid_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_device_download_games_info_by_udid_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_device_download_games_info_by_udid_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_device_download_games_info_by_udid_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_device_download_games_info_by_udid_response::unknown(){
return _unknown;
}
inline size_t mcp_get_device_download_games_info_by_udid_response::unknown_size() const{
return _unknown.size();
}
inline mcp_add_device_download_game_params* mcp_add_device_download_game_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_device_download_game_params* tmp=(mcp_add_device_download_game_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_device_download_game_params(pool);
return tmp;
}
inline void mcp_add_device_download_game_params::destroy(mcp_add_device_download_game_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_device_download_game_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_device_download_game_params::mcp_add_device_download_game_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_udid(_pool)
,_m_game_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_device_download_game_params::mcp_add_device_download_game_params(const mcp_add_device_download_game_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_udid(_pool)
,_m_game_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_add_device_download_game_params::~mcp_add_device_download_game_params(){
}
inline mcp_add_device_download_game_params& mcp_add_device_download_game_params::operator=(const mcp_add_device_download_game_params& v){
assign(v);
return *this;
}
inline void mcp_add_device_download_game_params::clear(){
_m_udid.clear();
_m_game_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_device_download_game_params::check() const{
// @@string udid=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "udid" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_udid.get();

}
// @@string game_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_add_device_download_game_params::detach(){
_m_udid.detach();
_m_game_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_device_download_game_params& mcp_add_device_download_game_params::assign(const mcp_add_device_download_game_params& v){
_m_udid=v._m_udid;
_m_game_id=v._m_game_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_device_download_game_params::has_udid() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_add_device_download_game_params::udid(unsigned int* size) const{
return _m_udid.get(size);
}
inline mcp_add_device_download_game_params& mcp_add_device_download_game_params::set_udid(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_udid.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_device_download_game_params& mcp_add_device_download_game_params::set_ptr_udid(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_udid.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_device_download_game_params::clear_udid(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_udid.clear();
}
inline bool mcp_add_device_download_game_params::has_game_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_add_device_download_game_params::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline mcp_add_device_download_game_params& mcp_add_device_download_game_params::set_game_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_add_device_download_game_params& mcp_add_device_download_game_params::set_ptr_game_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_add_device_download_game_params::clear_game_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_id.clear();
}
inline ::idl::Unknown* mcp_add_device_download_game_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_device_download_game_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_device_download_game_params::unknown(){
return _unknown;
}
inline size_t mcp_add_device_download_game_params::unknown_size() const{
return _unknown.size();
}
inline mcp_add_device_download_game_result_params* mcp_add_device_download_game_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_device_download_game_result_params* tmp=(mcp_add_device_download_game_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_device_download_game_result_params(pool);
return tmp;
}
inline void mcp_add_device_download_game_result_params::destroy(mcp_add_device_download_game_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_device_download_game_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_device_download_game_result_params::mcp_add_device_download_game_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ret_code(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_device_download_game_result_params::mcp_add_device_download_game_result_params(const mcp_add_device_download_game_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ret_code(0)
,_unknown(_pool){
assign(v);
}
inline mcp_add_device_download_game_result_params::~mcp_add_device_download_game_result_params(){
}
inline mcp_add_device_download_game_result_params& mcp_add_device_download_game_result_params::operator=(const mcp_add_device_download_game_result_params& v){
assign(v);
return *this;
}
inline void mcp_add_device_download_game_result_params::clear(){
// _m_ret_code=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_device_download_game_result_params::check() const{
// @@int32_t ret_code=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ret_code" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_ret_code;

}

::idl::McpackBean::check();
}
inline void mcp_add_device_download_game_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_device_download_game_result_params& mcp_add_device_download_game_result_params::assign(const mcp_add_device_download_game_result_params& v){
_m_ret_code=v._m_ret_code;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_device_download_game_result_params::has_ret_code() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_add_device_download_game_result_params::ret_code() const{
return _m_ret_code;
}
inline mcp_add_device_download_game_result_params& mcp_add_device_download_game_result_params::set_ret_code(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ret_code=v;
return *this;
}
inline void mcp_add_device_download_game_result_params::clear_ret_code(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ret_code=0;
}
inline ::idl::Unknown* mcp_add_device_download_game_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_device_download_game_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_device_download_game_result_params::unknown(){
return _unknown;
}
inline size_t mcp_add_device_download_game_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_add_device_download_game_response* mcp_add_device_download_game_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_add_device_download_game_response* tmp=(mcp_add_device_download_game_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_add_device_download_game_response(pool);
return tmp;
}
inline void mcp_add_device_download_game_response::destroy(mcp_add_device_download_game_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_add_device_download_game_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_add_device_download_game_response::mcp_add_device_download_game_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_add_device_download_game_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_add_device_download_game_response::mcp_add_device_download_game_response(const mcp_add_device_download_game_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_add_device_download_game_result_params::create(_pool);
assign(v);
}
inline mcp_add_device_download_game_response::~mcp_add_device_download_game_response(){
if(_m_result_params){
::idl::mcp_add_device_download_game_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_add_device_download_game_response& mcp_add_device_download_game_response::operator=(const mcp_add_device_download_game_response& v){
assign(v);
return *this;
}
inline void mcp_add_device_download_game_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_add_device_download_game_response::check() const{
// @@mcp_add_device_download_game_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_add_device_download_game_result_params& item=const_cast< ::idl::mcp_add_device_download_game_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_add_device_download_game_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_add_device_download_game_response& mcp_add_device_download_game_response::assign(const mcp_add_device_download_game_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_add_device_download_game_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_add_device_download_game_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_add_device_download_game_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_add_device_download_game_result_params& mcp_add_device_download_game_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_add_device_download_game_result_params* mcp_add_device_download_game_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_add_device_download_game_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_add_device_download_game_result_params* mcp_add_device_download_game_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_add_device_download_game_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_add_device_download_game_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_add_device_download_game_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_add_device_download_game_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_add_device_download_game_response::unknown(){
return _unknown;
}
inline size_t mcp_add_device_download_game_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_content_info_list_ext_params* mcp_get_game_content_info_list_ext_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_content_info_list_ext_params* tmp=(mcp_get_game_content_info_list_ext_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_content_info_list_ext_params(pool);
return tmp;
}
inline void mcp_get_game_content_info_list_ext_params::destroy(mcp_get_game_content_info_list_ext_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_content_info_list_ext_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_content_info_list_ext_params::mcp_get_game_content_info_list_ext_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_input(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_content_info_list_ext_params::mcp_get_game_content_info_list_ext_params(const mcp_get_game_content_info_list_ext_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_input(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_content_info_list_ext_params::~mcp_get_game_content_info_list_ext_params(){
}
inline mcp_get_game_content_info_list_ext_params& mcp_get_game_content_info_list_ext_params::operator=(const mcp_get_game_content_info_list_ext_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_content_info_list_ext_params::clear(){
_m_input.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_content_info_list_ext_params::check() const{
// @@string input=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "input" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_input.get();

}
// @@uint32_t page=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_game_content_info_list_ext_params::detach(){
_m_input.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_content_info_list_ext_params& mcp_get_game_content_info_list_ext_params::assign(const mcp_get_game_content_info_list_ext_params& v){
_m_input=v._m_input;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_content_info_list_ext_params::has_input() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_content_info_list_ext_params::input(unsigned int* size) const{
return _m_input.get(size);
}
inline mcp_get_game_content_info_list_ext_params& mcp_get_game_content_info_list_ext_params::set_input(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_input.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_content_info_list_ext_params& mcp_get_game_content_info_list_ext_params::set_ptr_input(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_input.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_content_info_list_ext_params::clear_input(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_input.clear();
}
inline bool mcp_get_game_content_info_list_ext_params::has_page() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_game_content_info_list_ext_params::page() const{
return _m_page;
}
inline mcp_get_game_content_info_list_ext_params& mcp_get_game_content_info_list_ext_params::set_page(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_game_content_info_list_ext_params::clear_page(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page=0;
}
inline bool mcp_get_game_content_info_list_ext_params::has_page_size() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_game_content_info_list_ext_params::page_size() const{
return _m_page_size;
}
inline mcp_get_game_content_info_list_ext_params& mcp_get_game_content_info_list_ext_params::set_page_size(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_game_content_info_list_ext_params::clear_page_size(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_game_content_info_list_ext_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_content_info_list_ext_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_content_info_list_ext_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_content_info_list_ext_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_content_info_list_ext_result_params* mcp_get_game_content_info_list_ext_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_content_info_list_ext_result_params* tmp=(mcp_get_game_content_info_list_ext_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_content_info_list_ext_result_params(pool);
return tmp;
}
inline void mcp_get_game_content_info_list_ext_result_params::destroy(mcp_get_game_content_info_list_ext_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_content_info_list_ext_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_content_info_list_ext_result_params::mcp_get_game_content_info_list_ext_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_content_info_list_ext_result_params::mcp_get_game_content_info_list_ext_result_params(const mcp_get_game_content_info_list_ext_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_result_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_content_info_list_ext_result_params::~mcp_get_game_content_info_list_ext_result_params(){
}
inline mcp_get_game_content_info_list_ext_result_params& mcp_get_game_content_info_list_ext_result_params::operator=(const mcp_get_game_content_info_list_ext_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_content_info_list_ext_result_params::clear(){
// _m_count=0;
_m_result_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_content_info_list_ext_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@game_content_download_info_t result_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_list" << "' not found";
}
{
// level 0 begin
typeof(_m_result_list)& lr0=(_m_result_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_content_download_info_t& item=const_cast< ::idl::game_content_download_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_game_content_info_list_ext_result_params::detach(){
_m_result_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_content_info_list_ext_result_params& mcp_get_game_content_info_list_ext_result_params::assign(const mcp_get_game_content_info_list_ext_result_params& v){
_m_count=v._m_count;
_m_result_list=v._m_result_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_content_info_list_ext_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_game_content_info_list_ext_result_params::count() const{
return _m_count;
}
inline mcp_get_game_content_info_list_ext_result_params& mcp_get_game_content_info_list_ext_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_game_content_info_list_ext_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_game_content_info_list_ext_result_params::has_result_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_content_download_info_t >& mcp_get_game_content_info_list_ext_result_params::result_list() const{
 return _m_result_list;
}
inline void mcp_get_game_content_info_list_ext_result_params::clear_result_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_result_list.clear();
}
inline ::idl::vector< ::idl::game_content_download_info_t >* mcp_get_game_content_info_list_ext_result_params::mutable_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline ::idl::vector< ::idl::game_content_download_info_t >* mcp_get_game_content_info_list_ext_result_params::m_result_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_result_list);
}
inline size_t mcp_get_game_content_info_list_ext_result_params::result_list_size() const{
/*  */ return _m_result_list.size();
}
inline const ::idl::game_content_download_info_t& mcp_get_game_content_info_list_ext_result_params::result_list(size_t i0) const{
 return _m_result_list.get(i0);
}
inline ::idl::game_content_download_info_t* mcp_get_game_content_info_list_ext_result_params::mutable_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::game_content_download_info_t* mcp_get_game_content_info_list_ext_result_params::m_result_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_result_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_game_content_info_list_ext_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_content_info_list_ext_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_content_info_list_ext_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_content_info_list_ext_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_content_info_list_ext_response* mcp_get_game_content_info_list_ext_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_content_info_list_ext_response* tmp=(mcp_get_game_content_info_list_ext_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_content_info_list_ext_response(pool);
return tmp;
}
inline void mcp_get_game_content_info_list_ext_response::destroy(mcp_get_game_content_info_list_ext_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_content_info_list_ext_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_content_info_list_ext_response::mcp_get_game_content_info_list_ext_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_content_info_list_ext_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_content_info_list_ext_response::mcp_get_game_content_info_list_ext_response(const mcp_get_game_content_info_list_ext_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_content_info_list_ext_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_content_info_list_ext_response::~mcp_get_game_content_info_list_ext_response(){
if(_m_result_params){
::idl::mcp_get_game_content_info_list_ext_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_content_info_list_ext_response& mcp_get_game_content_info_list_ext_response::operator=(const mcp_get_game_content_info_list_ext_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_content_info_list_ext_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_content_info_list_ext_response::check() const{
// @@mcp_get_game_content_info_list_ext_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_content_info_list_ext_result_params& item=const_cast< ::idl::mcp_get_game_content_info_list_ext_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_content_info_list_ext_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_content_info_list_ext_response& mcp_get_game_content_info_list_ext_response::assign(const mcp_get_game_content_info_list_ext_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_content_info_list_ext_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_content_info_list_ext_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_content_info_list_ext_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_content_info_list_ext_result_params& mcp_get_game_content_info_list_ext_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_content_info_list_ext_result_params* mcp_get_game_content_info_list_ext_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_content_info_list_ext_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_content_info_list_ext_result_params* mcp_get_game_content_info_list_ext_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_content_info_list_ext_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_content_info_list_ext_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_content_info_list_ext_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_content_info_list_ext_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_content_info_list_ext_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_content_info_list_ext_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_currency_rate_params* mcp_get_game_currency_rate_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_currency_rate_params* tmp=(mcp_get_game_currency_rate_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_currency_rate_params(pool);
return tmp;
}
inline void mcp_get_game_currency_rate_params::destroy(mcp_get_game_currency_rate_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_currency_rate_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_currency_rate_params::mcp_get_game_currency_rate_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_input(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_currency_rate_params::mcp_get_game_currency_rate_params(const mcp_get_game_currency_rate_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_input(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_currency_rate_params::~mcp_get_game_currency_rate_params(){
}
inline mcp_get_game_currency_rate_params& mcp_get_game_currency_rate_params::operator=(const mcp_get_game_currency_rate_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_currency_rate_params::clear(){
_m_input.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_currency_rate_params::check() const{
// @@string input=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "input" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_input.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_currency_rate_params::detach(){
_m_input.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_currency_rate_params& mcp_get_game_currency_rate_params::assign(const mcp_get_game_currency_rate_params& v){
_m_input=v._m_input;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_currency_rate_params::has_input() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_currency_rate_params::input(unsigned int* size) const{
return _m_input.get(size);
}
inline mcp_get_game_currency_rate_params& mcp_get_game_currency_rate_params::set_input(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_input.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_currency_rate_params& mcp_get_game_currency_rate_params::set_ptr_input(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_input.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_currency_rate_params::clear_input(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_input.clear();
}
inline ::idl::Unknown* mcp_get_game_currency_rate_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_currency_rate_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_currency_rate_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_currency_rate_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_currency_rate_result_params* mcp_get_game_currency_rate_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_currency_rate_result_params* tmp=(mcp_get_game_currency_rate_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_currency_rate_result_params(pool);
return tmp;
}
inline void mcp_get_game_currency_rate_result_params::destroy(mcp_get_game_currency_rate_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_currency_rate_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_currency_rate_result_params::mcp_get_game_currency_rate_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_currency_info(0)
,_unknown(_pool){
_m_currency_info=::idl::game_dev_vir_currency_info::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_currency_rate_result_params::mcp_get_game_currency_rate_result_params(const mcp_get_game_currency_rate_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_currency_info(0)
,_unknown(_pool){
_m_currency_info=::idl::game_dev_vir_currency_info::create(_pool);
assign(v);
}
inline mcp_get_game_currency_rate_result_params::~mcp_get_game_currency_rate_result_params(){
if(_m_currency_info){
::idl::game_dev_vir_currency_info::destroy(_m_currency_info);
_m_currency_info=0;
}
}
inline mcp_get_game_currency_rate_result_params& mcp_get_game_currency_rate_result_params::operator=(const mcp_get_game_currency_rate_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_currency_rate_result_params::clear(){
if(_m_currency_info){
_m_currency_info->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_currency_rate_result_params::check() const{
// @@game_dev_vir_currency_info currency_info=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "currency_info" << "' not found";
}
{
::idl::game_dev_vir_currency_info& item=const_cast< ::idl::game_dev_vir_currency_info& >(*_m_currency_info);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_currency_rate_result_params::detach(){
if(_m_currency_info){
_m_currency_info->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_currency_rate_result_params& mcp_get_game_currency_rate_result_params::assign(const mcp_get_game_currency_rate_result_params& v){
if(!v._m_currency_info){
if(_m_currency_info){
::idl::game_dev_vir_currency_info::destroy(_m_currency_info);
}
_m_currency_info=0;
}else{
if(!_m_currency_info){
_m_currency_info=::idl::game_dev_vir_currency_info::create(_pool);
}
*_m_currency_info=*v._m_currency_info;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_currency_rate_result_params::has_currency_info() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::game_dev_vir_currency_info& mcp_get_game_currency_rate_result_params::currency_info() const{
 return *_m_currency_info;
}
inline ::idl::game_dev_vir_currency_info* mcp_get_game_currency_rate_result_params::mutable_currency_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_currency_info){
_m_currency_info=::idl::game_dev_vir_currency_info::create(_pool);
}
return _m_currency_info;
}
inline ::idl::game_dev_vir_currency_info* mcp_get_game_currency_rate_result_params::m_currency_info(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_currency_info){
_m_currency_info=::idl::game_dev_vir_currency_info::create(_pool);
}
return _m_currency_info;
}
inline void mcp_get_game_currency_rate_result_params::clear_currency_info(){
if(_m_currency_info){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_currency_info->clear();
}
}
inline ::idl::Unknown* mcp_get_game_currency_rate_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_currency_rate_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_currency_rate_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_currency_rate_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_currency_rate_response* mcp_get_game_currency_rate_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_currency_rate_response* tmp=(mcp_get_game_currency_rate_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_currency_rate_response(pool);
return tmp;
}
inline void mcp_get_game_currency_rate_response::destroy(mcp_get_game_currency_rate_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_currency_rate_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_currency_rate_response::mcp_get_game_currency_rate_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_currency_rate_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_currency_rate_response::mcp_get_game_currency_rate_response(const mcp_get_game_currency_rate_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_currency_rate_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_currency_rate_response::~mcp_get_game_currency_rate_response(){
if(_m_result_params){
::idl::mcp_get_game_currency_rate_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_currency_rate_response& mcp_get_game_currency_rate_response::operator=(const mcp_get_game_currency_rate_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_currency_rate_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_currency_rate_response::check() const{
// @@mcp_get_game_currency_rate_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_currency_rate_result_params& item=const_cast< ::idl::mcp_get_game_currency_rate_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_currency_rate_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_currency_rate_response& mcp_get_game_currency_rate_response::assign(const mcp_get_game_currency_rate_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_currency_rate_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_currency_rate_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_currency_rate_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_currency_rate_result_params& mcp_get_game_currency_rate_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_currency_rate_result_params* mcp_get_game_currency_rate_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_currency_rate_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_currency_rate_result_params* mcp_get_game_currency_rate_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_currency_rate_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_currency_rate_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_currency_rate_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_currency_rate_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_currency_rate_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_currency_rate_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_download_info_params* mcp_get_game_download_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_download_info_params* tmp=(mcp_get_game_download_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_download_info_params(pool);
return tmp;
}
inline void mcp_get_game_download_info_params::destroy(mcp_get_game_download_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_download_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_download_info_params::mcp_get_game_download_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_c_id(_pool)
,_m_channel_info(_pool)
,_m_channel_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_download_info_params::mcp_get_game_download_info_params(const mcp_get_game_download_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_c_id(_pool)
,_m_channel_info(_pool)
,_m_channel_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_download_info_params::~mcp_get_game_download_info_params(){
}
inline mcp_get_game_download_info_params& mcp_get_game_download_info_params::operator=(const mcp_get_game_download_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_download_info_params::clear(){
_m_c_id.clear();
_m_channel_info.clear();
_m_channel_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_download_info_params::check() const{
// @@string c_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string channel_info=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "channel_info" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_channel_info.get();

}
// @@string channel_id=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "channel_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_channel_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_download_info_params::detach(){
_m_c_id.detach();
_m_channel_info.detach();
_m_channel_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_download_info_params& mcp_get_game_download_info_params::assign(const mcp_get_game_download_info_params& v){
_m_c_id=v._m_c_id;
_m_channel_info=v._m_channel_info;
_m_channel_id=v._m_channel_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_download_info_params::has_c_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_download_info_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_get_game_download_info_params& mcp_get_game_download_info_params::set_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_download_info_params& mcp_get_game_download_info_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_download_info_params::clear_c_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_c_id.clear();
}
inline bool mcp_get_game_download_info_params::has_channel_info() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_game_download_info_params::channel_info(unsigned int* size) const{
return _m_channel_info.get(size);
}
inline mcp_get_game_download_info_params& mcp_get_game_download_info_params::set_channel_info(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_channel_info.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_download_info_params& mcp_get_game_download_info_params::set_ptr_channel_info(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_channel_info.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_download_info_params::clear_channel_info(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_channel_info.clear();
}
inline bool mcp_get_game_download_info_params::has_channel_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_game_download_info_params::channel_id(unsigned int* size) const{
return _m_channel_id.get(size);
}
inline mcp_get_game_download_info_params& mcp_get_game_download_info_params::set_channel_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_channel_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_download_info_params& mcp_get_game_download_info_params::set_ptr_channel_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_channel_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_download_info_params::clear_channel_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_channel_id.clear();
}
inline ::idl::Unknown* mcp_get_game_download_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_download_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_download_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_download_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_download_info_result_params* mcp_get_game_download_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_download_info_result_params* tmp=(mcp_get_game_download_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_download_info_result_params(pool);
return tmp;
}
inline void mcp_get_game_download_info_result_params::destroy(mcp_get_game_download_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_download_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_download_info_result_params::mcp_get_game_download_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_download_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_download_info_result_params::mcp_get_game_download_info_result_params(const mcp_get_game_download_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_download_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_download_info_result_params::~mcp_get_game_download_info_result_params(){
}
inline mcp_get_game_download_info_result_params& mcp_get_game_download_info_result_params::operator=(const mcp_get_game_download_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_download_info_result_params::clear(){
// _m_count=0;
_m_download_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_download_info_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@download_detail_t download_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "download_list" << "' not found";
}
{
// level 0 begin
typeof(_m_download_list)& lr0=(_m_download_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::download_detail_t& item=const_cast< ::idl::download_detail_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_game_download_info_result_params::detach(){
_m_download_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_download_info_result_params& mcp_get_game_download_info_result_params::assign(const mcp_get_game_download_info_result_params& v){
_m_count=v._m_count;
_m_download_list=v._m_download_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_download_info_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_game_download_info_result_params::count() const{
return _m_count;
}
inline mcp_get_game_download_info_result_params& mcp_get_game_download_info_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_game_download_info_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_game_download_info_result_params::has_download_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::download_detail_t >& mcp_get_game_download_info_result_params::download_list() const{
 return _m_download_list;
}
inline void mcp_get_game_download_info_result_params::clear_download_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_download_list.clear();
}
inline ::idl::vector< ::idl::download_detail_t >* mcp_get_game_download_info_result_params::mutable_download_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_download_list);
}
inline ::idl::vector< ::idl::download_detail_t >* mcp_get_game_download_info_result_params::m_download_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_download_list);
}
inline size_t mcp_get_game_download_info_result_params::download_list_size() const{
/*  */ return _m_download_list.size();
}
inline const ::idl::download_detail_t& mcp_get_game_download_info_result_params::download_list(size_t i0) const{
 return _m_download_list.get(i0);
}
inline ::idl::download_detail_t* mcp_get_game_download_info_result_params::mutable_download_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_download_list.mutable_get(i0);
}
inline ::idl::download_detail_t* mcp_get_game_download_info_result_params::m_download_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_download_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_game_download_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_download_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_download_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_download_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_download_info_response* mcp_get_game_download_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_download_info_response* tmp=(mcp_get_game_download_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_download_info_response(pool);
return tmp;
}
inline void mcp_get_game_download_info_response::destroy(mcp_get_game_download_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_download_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_download_info_response::mcp_get_game_download_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_download_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_download_info_response::mcp_get_game_download_info_response(const mcp_get_game_download_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_download_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_download_info_response::~mcp_get_game_download_info_response(){
if(_m_result_params){
::idl::mcp_get_game_download_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_download_info_response& mcp_get_game_download_info_response::operator=(const mcp_get_game_download_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_download_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_download_info_response::check() const{
// @@mcp_get_game_download_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_download_info_result_params& item=const_cast< ::idl::mcp_get_game_download_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_download_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_download_info_response& mcp_get_game_download_info_response::assign(const mcp_get_game_download_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_download_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_download_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_download_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_download_info_result_params& mcp_get_game_download_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_download_info_result_params* mcp_get_game_download_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_download_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_download_info_result_params* mcp_get_game_download_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_download_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_download_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_download_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_download_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_download_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_download_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_news_without_pbus_params* mcp_get_game_news_without_pbus_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_news_without_pbus_params* tmp=(mcp_get_game_news_without_pbus_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_news_without_pbus_params(pool);
return tmp;
}
inline void mcp_get_game_news_without_pbus_params::destroy(mcp_get_game_news_without_pbus_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_news_without_pbus_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_news_without_pbus_params::mcp_get_game_news_without_pbus_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_id(_pool)
,_m_c_id(_pool)
,_m_info_type(_pool)
,_m_game_type(_pool)
,_m_date_limit(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_news_without_pbus_params::mcp_get_game_news_without_pbus_params(const mcp_get_game_news_without_pbus_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_id(_pool)
,_m_c_id(_pool)
,_m_info_type(_pool)
,_m_game_type(_pool)
,_m_date_limit(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_news_without_pbus_params::~mcp_get_game_news_without_pbus_params(){
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::operator=(const mcp_get_game_news_without_pbus_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_news_without_pbus_params::clear(){
_m_info_id.clear();
_m_c_id.clear();
_m_info_type.clear();
_m_game_type.clear();
_m_date_limit.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_news_without_pbus_params::check() const{
// @@string info_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@string c_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string info_type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_type.get();

}
// @@string game_type=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_type.get();

}
// @@string date_limit=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "date_limit" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_date_limit.get();

}
// @@uint32_t page=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_game_news_without_pbus_params::detach(){
_m_info_id.detach();
_m_c_id.detach();
_m_info_type.detach();
_m_game_type.detach();
_m_date_limit.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::assign(const mcp_get_game_news_without_pbus_params& v){
_m_info_id=v._m_info_id;
_m_c_id=v._m_c_id;
_m_info_type=v._m_info_type;
_m_game_type=v._m_game_type;
_m_date_limit=v._m_date_limit;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_news_without_pbus_params::has_info_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_news_without_pbus_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::set_info_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_without_pbus_params::clear_info_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_game_news_without_pbus_params::has_c_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_game_news_without_pbus_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::set_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_without_pbus_params::clear_c_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_c_id.clear();
}
inline bool mcp_get_game_news_without_pbus_params::has_info_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_game_news_without_pbus_params::info_type(unsigned int* size) const{
return _m_info_type.get(size);
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::set_info_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::set_ptr_info_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_without_pbus_params::clear_info_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_type.clear();
}
inline bool mcp_get_game_news_without_pbus_params::has_game_type() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_game_news_without_pbus_params::game_type(unsigned int* size) const{
return _m_game_type.get(size);
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::set_game_type(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_game_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::set_ptr_game_type(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_game_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_without_pbus_params::clear_game_type(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_game_type.clear();
}
inline bool mcp_get_game_news_without_pbus_params::has_date_limit() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_get_game_news_without_pbus_params::date_limit(unsigned int* size) const{
return _m_date_limit.get(size);
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::set_date_limit(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_date_limit.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::set_ptr_date_limit(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_date_limit.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_without_pbus_params::clear_date_limit(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_date_limit.clear();
}
inline bool mcp_get_game_news_without_pbus_params::has_page() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline uint32_t mcp_get_game_news_without_pbus_params::page() const{
return _m_page;
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::set_page(uint32_t v){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_game_news_without_pbus_params::clear_page(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_page=0;
}
inline bool mcp_get_game_news_without_pbus_params::has_page_size() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline uint32_t mcp_get_game_news_without_pbus_params::page_size() const{
return _m_page_size;
}
inline mcp_get_game_news_without_pbus_params& mcp_get_game_news_without_pbus_params::set_page_size(uint32_t v){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_game_news_without_pbus_params::clear_page_size(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_game_news_without_pbus_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_news_without_pbus_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_news_without_pbus_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_news_without_pbus_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_news_without_pbus_result_params* mcp_get_game_news_without_pbus_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_news_without_pbus_result_params* tmp=(mcp_get_game_news_without_pbus_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_news_without_pbus_result_params(pool);
return tmp;
}
inline void mcp_get_game_news_without_pbus_result_params::destroy(mcp_get_game_news_without_pbus_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_news_without_pbus_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_news_without_pbus_result_params::mcp_get_game_news_without_pbus_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_game_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_news_without_pbus_result_params::mcp_get_game_news_without_pbus_result_params(const mcp_get_game_news_without_pbus_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_game_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_news_without_pbus_result_params::~mcp_get_game_news_without_pbus_result_params(){
}
inline mcp_get_game_news_without_pbus_result_params& mcp_get_game_news_without_pbus_result_params::operator=(const mcp_get_game_news_without_pbus_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_news_without_pbus_result_params::clear(){
// _m_count=0;
_m_game_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_news_without_pbus_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@game_info_t game_info_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_game_info_list)& lr0=(_m_game_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_info_t& item=const_cast< ::idl::game_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_game_news_without_pbus_result_params::detach(){
_m_game_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_news_without_pbus_result_params& mcp_get_game_news_without_pbus_result_params::assign(const mcp_get_game_news_without_pbus_result_params& v){
_m_count=v._m_count;
_m_game_info_list=v._m_game_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_news_without_pbus_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_game_news_without_pbus_result_params::count() const{
return _m_count;
}
inline mcp_get_game_news_without_pbus_result_params& mcp_get_game_news_without_pbus_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_game_news_without_pbus_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_game_news_without_pbus_result_params::has_game_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_info_t >& mcp_get_game_news_without_pbus_result_params::game_info_list() const{
 return _m_game_info_list;
}
inline void mcp_get_game_news_without_pbus_result_params::clear_game_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_info_list.clear();
}
inline ::idl::vector< ::idl::game_info_t >* mcp_get_game_news_without_pbus_result_params::mutable_game_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_info_list);
}
inline ::idl::vector< ::idl::game_info_t >* mcp_get_game_news_without_pbus_result_params::m_game_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_info_list);
}
inline size_t mcp_get_game_news_without_pbus_result_params::game_info_list_size() const{
/*  */ return _m_game_info_list.size();
}
inline const ::idl::game_info_t& mcp_get_game_news_without_pbus_result_params::game_info_list(size_t i0) const{
 return _m_game_info_list.get(i0);
}
inline ::idl::game_info_t* mcp_get_game_news_without_pbus_result_params::mutable_game_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_info_list.mutable_get(i0);
}
inline ::idl::game_info_t* mcp_get_game_news_without_pbus_result_params::m_game_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_game_news_without_pbus_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_news_without_pbus_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_news_without_pbus_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_news_without_pbus_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_news_without_pbus_response* mcp_get_game_news_without_pbus_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_news_without_pbus_response* tmp=(mcp_get_game_news_without_pbus_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_news_without_pbus_response(pool);
return tmp;
}
inline void mcp_get_game_news_without_pbus_response::destroy(mcp_get_game_news_without_pbus_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_news_without_pbus_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_news_without_pbus_response::mcp_get_game_news_without_pbus_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_news_without_pbus_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_news_without_pbus_response::mcp_get_game_news_without_pbus_response(const mcp_get_game_news_without_pbus_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_news_without_pbus_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_news_without_pbus_response::~mcp_get_game_news_without_pbus_response(){
if(_m_result_params){
::idl::mcp_get_game_news_without_pbus_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_news_without_pbus_response& mcp_get_game_news_without_pbus_response::operator=(const mcp_get_game_news_without_pbus_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_news_without_pbus_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_news_without_pbus_response::check() const{
// @@mcp_get_game_news_without_pbus_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_news_without_pbus_result_params& item=const_cast< ::idl::mcp_get_game_news_without_pbus_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_news_without_pbus_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_news_without_pbus_response& mcp_get_game_news_without_pbus_response::assign(const mcp_get_game_news_without_pbus_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_news_without_pbus_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_news_without_pbus_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_news_without_pbus_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_news_without_pbus_result_params& mcp_get_game_news_without_pbus_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_news_without_pbus_result_params* mcp_get_game_news_without_pbus_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_news_without_pbus_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_news_without_pbus_result_params* mcp_get_game_news_without_pbus_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_news_without_pbus_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_news_without_pbus_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_news_without_pbus_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_news_without_pbus_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_news_without_pbus_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_news_without_pbus_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_mobile_music_info_params* mcp_get_mobile_music_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_mobile_music_info_params* tmp=(mcp_get_mobile_music_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_mobile_music_info_params(pool);
return tmp;
}
inline void mcp_get_mobile_music_info_params::destroy(mcp_get_mobile_music_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_mobile_music_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_mobile_music_info_params::mcp_get_mobile_music_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_name(_pool)
,_m_singer(_pool)
,_m_ring_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_mobile_music_info_params::mcp_get_mobile_music_info_params(const mcp_get_mobile_music_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_name(_pool)
,_m_singer(_pool)
,_m_ring_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_mobile_music_info_params::~mcp_get_mobile_music_info_params(){
}
inline mcp_get_mobile_music_info_params& mcp_get_mobile_music_info_params::operator=(const mcp_get_mobile_music_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_mobile_music_info_params::clear(){
_m_name.clear();
_m_singer.clear();
_m_ring_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_mobile_music_info_params::check() const{
// @@string name=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "name" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_name.get();

}
// @@string singer=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "singer" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_singer.get();

}
// @@string ring_id=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ring_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ring_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_mobile_music_info_params::detach(){
_m_name.detach();
_m_singer.detach();
_m_ring_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_mobile_music_info_params& mcp_get_mobile_music_info_params::assign(const mcp_get_mobile_music_info_params& v){
_m_name=v._m_name;
_m_singer=v._m_singer;
_m_ring_id=v._m_ring_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_mobile_music_info_params::has_name() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_mobile_music_info_params::name(unsigned int* size) const{
return _m_name.get(size);
}
inline mcp_get_mobile_music_info_params& mcp_get_mobile_music_info_params::set_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_name.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_mobile_music_info_params& mcp_get_mobile_music_info_params::set_ptr_name(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_name.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_mobile_music_info_params::clear_name(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_name.clear();
}
inline bool mcp_get_mobile_music_info_params::has_singer() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_mobile_music_info_params::singer(unsigned int* size) const{
return _m_singer.get(size);
}
inline mcp_get_mobile_music_info_params& mcp_get_mobile_music_info_params::set_singer(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_singer.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_mobile_music_info_params& mcp_get_mobile_music_info_params::set_ptr_singer(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_singer.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_mobile_music_info_params::clear_singer(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_singer.clear();
}
inline bool mcp_get_mobile_music_info_params::has_ring_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_mobile_music_info_params::ring_id(unsigned int* size) const{
return _m_ring_id.get(size);
}
inline mcp_get_mobile_music_info_params& mcp_get_mobile_music_info_params::set_ring_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_ring_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_mobile_music_info_params& mcp_get_mobile_music_info_params::set_ptr_ring_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_ring_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_mobile_music_info_params::clear_ring_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_ring_id.clear();
}
inline ::idl::Unknown* mcp_get_mobile_music_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_mobile_music_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_mobile_music_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_mobile_music_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_mobile_music_info_result_params* mcp_get_mobile_music_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_mobile_music_info_result_params* tmp=(mcp_get_mobile_music_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_mobile_music_info_result_params(pool);
return tmp;
}
inline void mcp_get_mobile_music_info_result_params::destroy(mcp_get_mobile_music_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_mobile_music_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_mobile_music_info_result_params::mcp_get_mobile_music_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_music_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_mobile_music_info_result_params::mcp_get_mobile_music_info_result_params(const mcp_get_mobile_music_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_music_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_mobile_music_info_result_params::~mcp_get_mobile_music_info_result_params(){
}
inline mcp_get_mobile_music_info_result_params& mcp_get_mobile_music_info_result_params::operator=(const mcp_get_mobile_music_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_mobile_music_info_result_params::clear(){
// _m_count=0;
_m_music_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_mobile_music_info_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@mobile_music_info_t music_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "music_list" << "' not found";
}
{
// level 0 begin
typeof(_m_music_list)& lr0=(_m_music_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::mobile_music_info_t& item=const_cast< ::idl::mobile_music_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_mobile_music_info_result_params::detach(){
_m_music_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_mobile_music_info_result_params& mcp_get_mobile_music_info_result_params::assign(const mcp_get_mobile_music_info_result_params& v){
_m_count=v._m_count;
_m_music_list=v._m_music_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_mobile_music_info_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_mobile_music_info_result_params::count() const{
return _m_count;
}
inline mcp_get_mobile_music_info_result_params& mcp_get_mobile_music_info_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_mobile_music_info_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_mobile_music_info_result_params::has_music_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::mobile_music_info_t >& mcp_get_mobile_music_info_result_params::music_list() const{
 return _m_music_list;
}
inline void mcp_get_mobile_music_info_result_params::clear_music_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_music_list.clear();
}
inline ::idl::vector< ::idl::mobile_music_info_t >* mcp_get_mobile_music_info_result_params::mutable_music_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_music_list);
}
inline ::idl::vector< ::idl::mobile_music_info_t >* mcp_get_mobile_music_info_result_params::m_music_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_music_list);
}
inline size_t mcp_get_mobile_music_info_result_params::music_list_size() const{
/*  */ return _m_music_list.size();
}
inline const ::idl::mobile_music_info_t& mcp_get_mobile_music_info_result_params::music_list(size_t i0) const{
 return _m_music_list.get(i0);
}
inline ::idl::mobile_music_info_t* mcp_get_mobile_music_info_result_params::mutable_music_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_music_list.mutable_get(i0);
}
inline ::idl::mobile_music_info_t* mcp_get_mobile_music_info_result_params::m_music_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_music_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_mobile_music_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_mobile_music_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_mobile_music_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_mobile_music_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_mobile_music_info_response* mcp_get_mobile_music_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_mobile_music_info_response* tmp=(mcp_get_mobile_music_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_mobile_music_info_response(pool);
return tmp;
}
inline void mcp_get_mobile_music_info_response::destroy(mcp_get_mobile_music_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_mobile_music_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_mobile_music_info_response::mcp_get_mobile_music_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_mobile_music_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_mobile_music_info_response::mcp_get_mobile_music_info_response(const mcp_get_mobile_music_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_mobile_music_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_mobile_music_info_response::~mcp_get_mobile_music_info_response(){
if(_m_result_params){
::idl::mcp_get_mobile_music_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_mobile_music_info_response& mcp_get_mobile_music_info_response::operator=(const mcp_get_mobile_music_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_mobile_music_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_mobile_music_info_response::check() const{
// @@mcp_get_mobile_music_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_mobile_music_info_result_params& item=const_cast< ::idl::mcp_get_mobile_music_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_mobile_music_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_mobile_music_info_response& mcp_get_mobile_music_info_response::assign(const mcp_get_mobile_music_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_mobile_music_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_mobile_music_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_mobile_music_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_mobile_music_info_result_params& mcp_get_mobile_music_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_mobile_music_info_result_params* mcp_get_mobile_music_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_mobile_music_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_mobile_music_info_result_params* mcp_get_mobile_music_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_mobile_music_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_mobile_music_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_mobile_music_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_mobile_music_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_mobile_music_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_mobile_music_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_set_mobile_music_ptag_by_ring_id_params* mcp_set_mobile_music_ptag_by_ring_id_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_set_mobile_music_ptag_by_ring_id_params* tmp=(mcp_set_mobile_music_ptag_by_ring_id_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_set_mobile_music_ptag_by_ring_id_params(pool);
return tmp;
}
inline void mcp_set_mobile_music_ptag_by_ring_id_params::destroy(mcp_set_mobile_music_ptag_by_ring_id_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_set_mobile_music_ptag_by_ring_id_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_set_mobile_music_ptag_by_ring_id_params::mcp_set_mobile_music_ptag_by_ring_id_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ring_id(_pool)
,_m_ptag(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_set_mobile_music_ptag_by_ring_id_params::mcp_set_mobile_music_ptag_by_ring_id_params(const mcp_set_mobile_music_ptag_by_ring_id_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ring_id(_pool)
,_m_ptag(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_set_mobile_music_ptag_by_ring_id_params::~mcp_set_mobile_music_ptag_by_ring_id_params(){
}
inline mcp_set_mobile_music_ptag_by_ring_id_params& mcp_set_mobile_music_ptag_by_ring_id_params::operator=(const mcp_set_mobile_music_ptag_by_ring_id_params& v){
assign(v);
return *this;
}
inline void mcp_set_mobile_music_ptag_by_ring_id_params::clear(){
_m_ring_id.clear();
_m_ptag.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_set_mobile_music_ptag_by_ring_id_params::check() const{
// @@string ring_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ring_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ring_id.get();

}
// @@string ptag=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ptag" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ptag.get();

}

::idl::McpackBean::check();
}
inline void mcp_set_mobile_music_ptag_by_ring_id_params::detach(){
_m_ring_id.detach();
_m_ptag.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_set_mobile_music_ptag_by_ring_id_params& mcp_set_mobile_music_ptag_by_ring_id_params::assign(const mcp_set_mobile_music_ptag_by_ring_id_params& v){
_m_ring_id=v._m_ring_id;
_m_ptag=v._m_ptag;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_set_mobile_music_ptag_by_ring_id_params::has_ring_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_set_mobile_music_ptag_by_ring_id_params::ring_id(unsigned int* size) const{
return _m_ring_id.get(size);
}
inline mcp_set_mobile_music_ptag_by_ring_id_params& mcp_set_mobile_music_ptag_by_ring_id_params::set_ring_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ring_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_set_mobile_music_ptag_by_ring_id_params& mcp_set_mobile_music_ptag_by_ring_id_params::set_ptr_ring_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ring_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_set_mobile_music_ptag_by_ring_id_params::clear_ring_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ring_id.clear();
}
inline bool mcp_set_mobile_music_ptag_by_ring_id_params::has_ptag() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_set_mobile_music_ptag_by_ring_id_params::ptag(unsigned int* size) const{
return _m_ptag.get(size);
}
inline mcp_set_mobile_music_ptag_by_ring_id_params& mcp_set_mobile_music_ptag_by_ring_id_params::set_ptag(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_ptag.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_set_mobile_music_ptag_by_ring_id_params& mcp_set_mobile_music_ptag_by_ring_id_params::set_ptr_ptag(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_ptag.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_set_mobile_music_ptag_by_ring_id_params::clear_ptag(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_ptag.clear();
}
inline ::idl::Unknown* mcp_set_mobile_music_ptag_by_ring_id_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_set_mobile_music_ptag_by_ring_id_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_set_mobile_music_ptag_by_ring_id_params::unknown(){
return _unknown;
}
inline size_t mcp_set_mobile_music_ptag_by_ring_id_params::unknown_size() const{
return _unknown.size();
}
inline mcp_set_mobile_music_ptag_by_ring_id_result_params* mcp_set_mobile_music_ptag_by_ring_id_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_set_mobile_music_ptag_by_ring_id_result_params* tmp=(mcp_set_mobile_music_ptag_by_ring_id_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_set_mobile_music_ptag_by_ring_id_result_params(pool);
return tmp;
}
inline void mcp_set_mobile_music_ptag_by_ring_id_result_params::destroy(mcp_set_mobile_music_ptag_by_ring_id_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_set_mobile_music_ptag_by_ring_id_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_set_mobile_music_ptag_by_ring_id_result_params::mcp_set_mobile_music_ptag_by_ring_id_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_set_mobile_music_ptag_by_ring_id_result_params::mcp_set_mobile_music_ptag_by_ring_id_result_params(const mcp_set_mobile_music_ptag_by_ring_id_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_unknown(_pool){
assign(v);
}
inline mcp_set_mobile_music_ptag_by_ring_id_result_params::~mcp_set_mobile_music_ptag_by_ring_id_result_params(){
}
inline mcp_set_mobile_music_ptag_by_ring_id_result_params& mcp_set_mobile_music_ptag_by_ring_id_result_params::operator=(const mcp_set_mobile_music_ptag_by_ring_id_result_params& v){
assign(v);
return *this;
}
inline void mcp_set_mobile_music_ptag_by_ring_id_result_params::clear(){
// _m_result=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_set_mobile_music_ptag_by_ring_id_result_params::check() const{
// @@uint32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_result;

}

::idl::McpackBean::check();
}
inline void mcp_set_mobile_music_ptag_by_ring_id_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_set_mobile_music_ptag_by_ring_id_result_params& mcp_set_mobile_music_ptag_by_ring_id_result_params::assign(const mcp_set_mobile_music_ptag_by_ring_id_result_params& v){
_m_result=v._m_result;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_set_mobile_music_ptag_by_ring_id_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_set_mobile_music_ptag_by_ring_id_result_params::result() const{
return _m_result;
}
inline mcp_set_mobile_music_ptag_by_ring_id_result_params& mcp_set_mobile_music_ptag_by_ring_id_result_params::set_result(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_set_mobile_music_ptag_by_ring_id_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline ::idl::Unknown* mcp_set_mobile_music_ptag_by_ring_id_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_set_mobile_music_ptag_by_ring_id_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_set_mobile_music_ptag_by_ring_id_result_params::unknown(){
return _unknown;
}
inline size_t mcp_set_mobile_music_ptag_by_ring_id_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_set_mobile_music_ptag_by_ring_id_response* mcp_set_mobile_music_ptag_by_ring_id_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_set_mobile_music_ptag_by_ring_id_response* tmp=(mcp_set_mobile_music_ptag_by_ring_id_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_set_mobile_music_ptag_by_ring_id_response(pool);
return tmp;
}
inline void mcp_set_mobile_music_ptag_by_ring_id_response::destroy(mcp_set_mobile_music_ptag_by_ring_id_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_set_mobile_music_ptag_by_ring_id_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_set_mobile_music_ptag_by_ring_id_response::mcp_set_mobile_music_ptag_by_ring_id_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_set_mobile_music_ptag_by_ring_id_response::mcp_set_mobile_music_ptag_by_ring_id_response(const mcp_set_mobile_music_ptag_by_ring_id_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params::create(_pool);
assign(v);
}
inline mcp_set_mobile_music_ptag_by_ring_id_response::~mcp_set_mobile_music_ptag_by_ring_id_response(){
if(_m_result_params){
::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_set_mobile_music_ptag_by_ring_id_response& mcp_set_mobile_music_ptag_by_ring_id_response::operator=(const mcp_set_mobile_music_ptag_by_ring_id_response& v){
assign(v);
return *this;
}
inline void mcp_set_mobile_music_ptag_by_ring_id_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_set_mobile_music_ptag_by_ring_id_response::check() const{
// @@mcp_set_mobile_music_ptag_by_ring_id_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params& item=const_cast< ::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_set_mobile_music_ptag_by_ring_id_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_set_mobile_music_ptag_by_ring_id_response& mcp_set_mobile_music_ptag_by_ring_id_response::assign(const mcp_set_mobile_music_ptag_by_ring_id_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_set_mobile_music_ptag_by_ring_id_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params& mcp_set_mobile_music_ptag_by_ring_id_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params* mcp_set_mobile_music_ptag_by_ring_id_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params* mcp_set_mobile_music_ptag_by_ring_id_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_set_mobile_music_ptag_by_ring_id_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_set_mobile_music_ptag_by_ring_id_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_set_mobile_music_ptag_by_ring_id_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_set_mobile_music_ptag_by_ring_id_response::unknown(){
return _unknown;
}
inline size_t mcp_set_mobile_music_ptag_by_ring_id_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_mobile_music_ring_id_by_ptag_params* mcp_get_mobile_music_ring_id_by_ptag_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_mobile_music_ring_id_by_ptag_params* tmp=(mcp_get_mobile_music_ring_id_by_ptag_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_mobile_music_ring_id_by_ptag_params(pool);
return tmp;
}
inline void mcp_get_mobile_music_ring_id_by_ptag_params::destroy(mcp_get_mobile_music_ring_id_by_ptag_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_mobile_music_ring_id_by_ptag_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_mobile_music_ring_id_by_ptag_params::mcp_get_mobile_music_ring_id_by_ptag_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ptag(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_mobile_music_ring_id_by_ptag_params::mcp_get_mobile_music_ring_id_by_ptag_params(const mcp_get_mobile_music_ring_id_by_ptag_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ptag(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_mobile_music_ring_id_by_ptag_params::~mcp_get_mobile_music_ring_id_by_ptag_params(){
}
inline mcp_get_mobile_music_ring_id_by_ptag_params& mcp_get_mobile_music_ring_id_by_ptag_params::operator=(const mcp_get_mobile_music_ring_id_by_ptag_params& v){
assign(v);
return *this;
}
inline void mcp_get_mobile_music_ring_id_by_ptag_params::clear(){
_m_ptag.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_mobile_music_ring_id_by_ptag_params::check() const{
// @@string ptag=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ptag" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ptag.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_mobile_music_ring_id_by_ptag_params::detach(){
_m_ptag.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_mobile_music_ring_id_by_ptag_params& mcp_get_mobile_music_ring_id_by_ptag_params::assign(const mcp_get_mobile_music_ring_id_by_ptag_params& v){
_m_ptag=v._m_ptag;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_mobile_music_ring_id_by_ptag_params::has_ptag() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_mobile_music_ring_id_by_ptag_params::ptag(unsigned int* size) const{
return _m_ptag.get(size);
}
inline mcp_get_mobile_music_ring_id_by_ptag_params& mcp_get_mobile_music_ring_id_by_ptag_params::set_ptag(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ptag.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_mobile_music_ring_id_by_ptag_params& mcp_get_mobile_music_ring_id_by_ptag_params::set_ptr_ptag(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ptag.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_mobile_music_ring_id_by_ptag_params::clear_ptag(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ptag.clear();
}
inline ::idl::Unknown* mcp_get_mobile_music_ring_id_by_ptag_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_mobile_music_ring_id_by_ptag_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_mobile_music_ring_id_by_ptag_params::unknown(){
return _unknown;
}
inline size_t mcp_get_mobile_music_ring_id_by_ptag_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_mobile_music_ring_id_by_ptag_result_params* mcp_get_mobile_music_ring_id_by_ptag_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_mobile_music_ring_id_by_ptag_result_params* tmp=(mcp_get_mobile_music_ring_id_by_ptag_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_mobile_music_ring_id_by_ptag_result_params(pool);
return tmp;
}
inline void mcp_get_mobile_music_ring_id_by_ptag_result_params::destroy(mcp_get_mobile_music_ring_id_by_ptag_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_mobile_music_ring_id_by_ptag_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_mobile_music_ring_id_by_ptag_result_params::mcp_get_mobile_music_ring_id_by_ptag_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ring_id(_pool)
,_m_result(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_mobile_music_ring_id_by_ptag_result_params::mcp_get_mobile_music_ring_id_by_ptag_result_params(const mcp_get_mobile_music_ring_id_by_ptag_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ring_id(_pool)
,_m_result(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_mobile_music_ring_id_by_ptag_result_params::~mcp_get_mobile_music_ring_id_by_ptag_result_params(){
}
inline mcp_get_mobile_music_ring_id_by_ptag_result_params& mcp_get_mobile_music_ring_id_by_ptag_result_params::operator=(const mcp_get_mobile_music_ring_id_by_ptag_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_mobile_music_ring_id_by_ptag_result_params::clear(){
_m_ring_id.clear();
// _m_result=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_mobile_music_ring_id_by_ptag_result_params::check() const{
// @@string ring_id=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ring_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ring_id.get();

}
// @@uint32_t result=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_result;

}

::idl::McpackBean::check();
}
inline void mcp_get_mobile_music_ring_id_by_ptag_result_params::detach(){
_m_ring_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_mobile_music_ring_id_by_ptag_result_params& mcp_get_mobile_music_ring_id_by_ptag_result_params::assign(const mcp_get_mobile_music_ring_id_by_ptag_result_params& v){
_m_ring_id=v._m_ring_id;
_m_result=v._m_result;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_mobile_music_ring_id_by_ptag_result_params::has_ring_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_mobile_music_ring_id_by_ptag_result_params::ring_id(unsigned int* size) const{
return _m_ring_id.get(size);
}
inline mcp_get_mobile_music_ring_id_by_ptag_result_params& mcp_get_mobile_music_ring_id_by_ptag_result_params::set_ring_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ring_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_mobile_music_ring_id_by_ptag_result_params& mcp_get_mobile_music_ring_id_by_ptag_result_params::set_ptr_ring_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ring_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_mobile_music_ring_id_by_ptag_result_params::clear_ring_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ring_id.clear();
}
inline bool mcp_get_mobile_music_ring_id_by_ptag_result_params::has_result() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_mobile_music_ring_id_by_ptag_result_params::result() const{
return _m_result;
}
inline mcp_get_mobile_music_ring_id_by_ptag_result_params& mcp_get_mobile_music_ring_id_by_ptag_result_params::set_result(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_get_mobile_music_ring_id_by_ptag_result_params::clear_result(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_result=0;
}
inline ::idl::Unknown* mcp_get_mobile_music_ring_id_by_ptag_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_mobile_music_ring_id_by_ptag_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_mobile_music_ring_id_by_ptag_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_mobile_music_ring_id_by_ptag_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_mobile_music_ring_id_by_ptag_response* mcp_get_mobile_music_ring_id_by_ptag_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_mobile_music_ring_id_by_ptag_response* tmp=(mcp_get_mobile_music_ring_id_by_ptag_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_mobile_music_ring_id_by_ptag_response(pool);
return tmp;
}
inline void mcp_get_mobile_music_ring_id_by_ptag_response::destroy(mcp_get_mobile_music_ring_id_by_ptag_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_mobile_music_ring_id_by_ptag_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_mobile_music_ring_id_by_ptag_response::mcp_get_mobile_music_ring_id_by_ptag_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_mobile_music_ring_id_by_ptag_response::mcp_get_mobile_music_ring_id_by_ptag_response(const mcp_get_mobile_music_ring_id_by_ptag_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params::create(_pool);
assign(v);
}
inline mcp_get_mobile_music_ring_id_by_ptag_response::~mcp_get_mobile_music_ring_id_by_ptag_response(){
if(_m_result_params){
::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_mobile_music_ring_id_by_ptag_response& mcp_get_mobile_music_ring_id_by_ptag_response::operator=(const mcp_get_mobile_music_ring_id_by_ptag_response& v){
assign(v);
return *this;
}
inline void mcp_get_mobile_music_ring_id_by_ptag_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_mobile_music_ring_id_by_ptag_response::check() const{
// @@mcp_get_mobile_music_ring_id_by_ptag_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params& item=const_cast< ::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_mobile_music_ring_id_by_ptag_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_mobile_music_ring_id_by_ptag_response& mcp_get_mobile_music_ring_id_by_ptag_response::assign(const mcp_get_mobile_music_ring_id_by_ptag_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_mobile_music_ring_id_by_ptag_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params& mcp_get_mobile_music_ring_id_by_ptag_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params* mcp_get_mobile_music_ring_id_by_ptag_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params* mcp_get_mobile_music_ring_id_by_ptag_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_mobile_music_ring_id_by_ptag_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_mobile_music_ring_id_by_ptag_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_mobile_music_ring_id_by_ptag_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_mobile_music_ring_id_by_ptag_response::unknown(){
return _unknown;
}
inline size_t mcp_get_mobile_music_ring_id_by_ptag_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_championship_info_params* mcp_get_championship_info_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_championship_info_params* tmp=(mcp_get_championship_info_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_championship_info_params(pool);
return tmp;
}
inline void mcp_get_championship_info_params::destroy(mcp_get_championship_info_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_championship_info_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_championship_info_params::mcp_get_championship_info_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_championship_info_params::mcp_get_championship_info_params(const mcp_get_championship_info_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_championship_info_params::~mcp_get_championship_info_params(){
}
inline mcp_get_championship_info_params& mcp_get_championship_info_params::operator=(const mcp_get_championship_info_params& v){
assign(v);
return *this;
}
inline void mcp_get_championship_info_params::clear(){
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_championship_info_params::check() const{
// @@uint32_t page=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_championship_info_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_championship_info_params& mcp_get_championship_info_params::assign(const mcp_get_championship_info_params& v){
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_championship_info_params::has_page() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_championship_info_params::page() const{
return _m_page;
}
inline mcp_get_championship_info_params& mcp_get_championship_info_params::set_page(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_championship_info_params::clear_page(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_page=0;
}
inline bool mcp_get_championship_info_params::has_page_size() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_championship_info_params::page_size() const{
return _m_page_size;
}
inline mcp_get_championship_info_params& mcp_get_championship_info_params::set_page_size(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_championship_info_params::clear_page_size(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_championship_info_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_championship_info_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_championship_info_params::unknown(){
return _unknown;
}
inline size_t mcp_get_championship_info_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_championship_info_result_params* mcp_get_championship_info_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_championship_info_result_params* tmp=(mcp_get_championship_info_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_championship_info_result_params(pool);
return tmp;
}
inline void mcp_get_championship_info_result_params::destroy(mcp_get_championship_info_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_championship_info_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_championship_info_result_params::mcp_get_championship_info_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_championship_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_championship_info_result_params::mcp_get_championship_info_result_params(const mcp_get_championship_info_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_championship_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_championship_info_result_params::~mcp_get_championship_info_result_params(){
}
inline mcp_get_championship_info_result_params& mcp_get_championship_info_result_params::operator=(const mcp_get_championship_info_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_championship_info_result_params::clear(){
// _m_count=0;
_m_championship_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_championship_info_result_params::check() const{
// @@uint32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_count;

}
// @@championship_info_t championship_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "championship_list" << "' not found";
}
{
// level 0 begin
typeof(_m_championship_list)& lr0=(_m_championship_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::championship_info_t& item=const_cast< ::idl::championship_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_championship_info_result_params::detach(){
_m_championship_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_championship_info_result_params& mcp_get_championship_info_result_params::assign(const mcp_get_championship_info_result_params& v){
_m_count=v._m_count;
_m_championship_list=v._m_championship_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_championship_info_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_championship_info_result_params::count() const{
return _m_count;
}
inline mcp_get_championship_info_result_params& mcp_get_championship_info_result_params::set_count(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_championship_info_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_championship_info_result_params::has_championship_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::championship_info_t >& mcp_get_championship_info_result_params::championship_list() const{
 return _m_championship_list;
}
inline void mcp_get_championship_info_result_params::clear_championship_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_championship_list.clear();
}
inline ::idl::vector< ::idl::championship_info_t >* mcp_get_championship_info_result_params::mutable_championship_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_championship_list);
}
inline ::idl::vector< ::idl::championship_info_t >* mcp_get_championship_info_result_params::m_championship_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_championship_list);
}
inline size_t mcp_get_championship_info_result_params::championship_list_size() const{
/*  */ return _m_championship_list.size();
}
inline const ::idl::championship_info_t& mcp_get_championship_info_result_params::championship_list(size_t i0) const{
 return _m_championship_list.get(i0);
}
inline ::idl::championship_info_t* mcp_get_championship_info_result_params::mutable_championship_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_championship_list.mutable_get(i0);
}
inline ::idl::championship_info_t* mcp_get_championship_info_result_params::m_championship_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_championship_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_championship_info_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_championship_info_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_championship_info_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_championship_info_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_championship_info_response* mcp_get_championship_info_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_championship_info_response* tmp=(mcp_get_championship_info_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_championship_info_response(pool);
return tmp;
}
inline void mcp_get_championship_info_response::destroy(mcp_get_championship_info_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_championship_info_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_championship_info_response::mcp_get_championship_info_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_championship_info_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_championship_info_response::mcp_get_championship_info_response(const mcp_get_championship_info_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_championship_info_result_params::create(_pool);
assign(v);
}
inline mcp_get_championship_info_response::~mcp_get_championship_info_response(){
if(_m_result_params){
::idl::mcp_get_championship_info_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_championship_info_response& mcp_get_championship_info_response::operator=(const mcp_get_championship_info_response& v){
assign(v);
return *this;
}
inline void mcp_get_championship_info_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_championship_info_response::check() const{
// @@mcp_get_championship_info_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_championship_info_result_params& item=const_cast< ::idl::mcp_get_championship_info_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_championship_info_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_championship_info_response& mcp_get_championship_info_response::assign(const mcp_get_championship_info_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_championship_info_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_championship_info_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_championship_info_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_championship_info_result_params& mcp_get_championship_info_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_championship_info_result_params* mcp_get_championship_info_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_championship_info_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_championship_info_result_params* mcp_get_championship_info_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_championship_info_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_championship_info_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_championship_info_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_championship_info_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_championship_info_response::unknown(){
return _unknown;
}
inline size_t mcp_get_championship_info_response::unknown_size() const{
return _unknown.size();
}
inline mcp_user_add_coins_params* mcp_user_add_coins_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_user_add_coins_params* tmp=(mcp_user_add_coins_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_user_add_coins_params(pool);
return tmp;
}
inline void mcp_user_add_coins_params::destroy(mcp_user_add_coins_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_user_add_coins_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_user_add_coins_params::mcp_user_add_coins_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_user_id(_pool)
,_m_game_id(_pool)
,_m_opt(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_user_add_coins_params::mcp_user_add_coins_params(const mcp_user_add_coins_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_user_id(_pool)
,_m_game_id(_pool)
,_m_opt(0)
,_unknown(_pool){
assign(v);
}
inline mcp_user_add_coins_params::~mcp_user_add_coins_params(){
}
inline mcp_user_add_coins_params& mcp_user_add_coins_params::operator=(const mcp_user_add_coins_params& v){
assign(v);
return *this;
}
inline void mcp_user_add_coins_params::clear(){
_m_user_id.clear();
_m_game_id.clear();
// _m_opt=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_user_add_coins_params::check() const{
// @@string user_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}
// @@string game_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_id.get();

}
// @@uint32_t opt=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "opt" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_opt;

}

::idl::McpackBean::check();
}
inline void mcp_user_add_coins_params::detach(){
_m_user_id.detach();
_m_game_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_user_add_coins_params& mcp_user_add_coins_params::assign(const mcp_user_add_coins_params& v){
_m_user_id=v._m_user_id;
_m_game_id=v._m_game_id;
_m_opt=v._m_opt;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_user_add_coins_params::has_user_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_user_add_coins_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_user_add_coins_params& mcp_user_add_coins_params::set_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_user_add_coins_params& mcp_user_add_coins_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_user_add_coins_params::clear_user_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_user_id.clear();
}
inline bool mcp_user_add_coins_params::has_game_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_user_add_coins_params::game_id(unsigned int* size) const{
return _m_game_id.get(size);
}
inline mcp_user_add_coins_params& mcp_user_add_coins_params::set_game_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_user_add_coins_params& mcp_user_add_coins_params::set_ptr_game_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_game_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_user_add_coins_params::clear_game_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_id.clear();
}
inline bool mcp_user_add_coins_params::has_opt() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_user_add_coins_params::opt() const{
return _m_opt;
}
inline mcp_user_add_coins_params& mcp_user_add_coins_params::set_opt(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_opt=v;
return *this;
}
inline void mcp_user_add_coins_params::clear_opt(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_opt=0;
}
inline ::idl::Unknown* mcp_user_add_coins_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_user_add_coins_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_user_add_coins_params::unknown(){
return _unknown;
}
inline size_t mcp_user_add_coins_params::unknown_size() const{
return _unknown.size();
}
inline mcp_user_add_coins_result_params* mcp_user_add_coins_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_user_add_coins_result_params* tmp=(mcp_user_add_coins_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_user_add_coins_result_params(pool);
return tmp;
}
inline void mcp_user_add_coins_result_params::destroy(mcp_user_add_coins_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_user_add_coins_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_user_add_coins_result_params::mcp_user_add_coins_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result(0)
,_m_errorcode(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_user_add_coins_result_params::mcp_user_add_coins_result_params(const mcp_user_add_coins_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result(0)
,_m_errorcode(0)
,_unknown(_pool){
assign(v);
}
inline mcp_user_add_coins_result_params::~mcp_user_add_coins_result_params(){
}
inline mcp_user_add_coins_result_params& mcp_user_add_coins_result_params::operator=(const mcp_user_add_coins_result_params& v){
assign(v);
return *this;
}
inline void mcp_user_add_coins_result_params::clear(){
// _m_result=0;
// _m_errorcode=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_user_add_coins_result_params::check() const{
// @@uint32_t result=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_result;

}
// @@uint32_t errorcode=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "errorcode" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_errorcode;

}

::idl::McpackBean::check();
}
inline void mcp_user_add_coins_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_user_add_coins_result_params& mcp_user_add_coins_result_params::assign(const mcp_user_add_coins_result_params& v){
_m_result=v._m_result;
_m_errorcode=v._m_errorcode;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_user_add_coins_result_params::has_result() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_user_add_coins_result_params::result() const{
return _m_result;
}
inline mcp_user_add_coins_result_params& mcp_user_add_coins_result_params::set_result(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_result=v;
return *this;
}
inline void mcp_user_add_coins_result_params::clear_result(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result=0;
}
inline bool mcp_user_add_coins_result_params::has_errorcode() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_user_add_coins_result_params::errorcode() const{
return _m_errorcode;
}
inline mcp_user_add_coins_result_params& mcp_user_add_coins_result_params::set_errorcode(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_errorcode=v;
return *this;
}
inline void mcp_user_add_coins_result_params::clear_errorcode(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_errorcode=0;
}
inline ::idl::Unknown* mcp_user_add_coins_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_user_add_coins_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_user_add_coins_result_params::unknown(){
return _unknown;
}
inline size_t mcp_user_add_coins_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_user_add_coins_response* mcp_user_add_coins_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_user_add_coins_response* tmp=(mcp_user_add_coins_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_user_add_coins_response(pool);
return tmp;
}
inline void mcp_user_add_coins_response::destroy(mcp_user_add_coins_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_user_add_coins_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_user_add_coins_response::mcp_user_add_coins_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_user_add_coins_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_user_add_coins_response::mcp_user_add_coins_response(const mcp_user_add_coins_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_user_add_coins_result_params::create(_pool);
assign(v);
}
inline mcp_user_add_coins_response::~mcp_user_add_coins_response(){
if(_m_result_params){
::idl::mcp_user_add_coins_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_user_add_coins_response& mcp_user_add_coins_response::operator=(const mcp_user_add_coins_response& v){
assign(v);
return *this;
}
inline void mcp_user_add_coins_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_user_add_coins_response::check() const{
// @@mcp_user_add_coins_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_user_add_coins_result_params& item=const_cast< ::idl::mcp_user_add_coins_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_user_add_coins_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_user_add_coins_response& mcp_user_add_coins_response::assign(const mcp_user_add_coins_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_user_add_coins_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_user_add_coins_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_user_add_coins_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_user_add_coins_result_params& mcp_user_add_coins_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_user_add_coins_result_params* mcp_user_add_coins_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_user_add_coins_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_user_add_coins_result_params* mcp_user_add_coins_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_user_add_coins_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_user_add_coins_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_user_add_coins_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_user_add_coins_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_user_add_coins_response::unknown(){
return _unknown;
}
inline size_t mcp_user_add_coins_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_news_params* mcp_get_game_news_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_news_params* tmp=(mcp_get_game_news_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_news_params(pool);
return tmp;
}
inline void mcp_get_game_news_params::destroy(mcp_get_game_news_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_news_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_news_params::mcp_get_game_news_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_info_id(_pool)
,_m_c_id(_pool)
,_m_info_type(_pool)
,_m_game_type(_pool)
,_m_date_limit(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_news_params::mcp_get_game_news_params(const mcp_get_game_news_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_info_id(_pool)
,_m_c_id(_pool)
,_m_info_type(_pool)
,_m_game_type(_pool)
,_m_date_limit(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_news_params::~mcp_get_game_news_params(){
}
inline mcp_get_game_news_params& mcp_get_game_news_params::operator=(const mcp_get_game_news_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_news_params::clear(){
_m_info_id.clear();
_m_c_id.clear();
_m_info_type.clear();
_m_game_type.clear();
_m_date_limit.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_news_params::check() const{
// @@string info_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_id.get();

}
// @@string c_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string info_type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "info_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_info_type.get();

}
// @@string game_type=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_game_type.get();

}
// @@string date_limit=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "date_limit" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_date_limit.get();

}
// @@uint32_t page=in();
if(!(_flag[5 >> 3] & (1 << (5 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[6 >> 3] & (1 << (6 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_game_news_params::detach(){
_m_info_id.detach();
_m_c_id.detach();
_m_info_type.detach();
_m_game_type.detach();
_m_date_limit.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_news_params& mcp_get_game_news_params::assign(const mcp_get_game_news_params& v){
_m_info_id=v._m_info_id;
_m_c_id=v._m_c_id;
_m_info_type=v._m_info_type;
_m_game_type=v._m_game_type;
_m_date_limit=v._m_date_limit;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_news_params::has_info_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_game_news_params::info_id(unsigned int* size) const{
return _m_info_id.get(size);
}
inline mcp_get_game_news_params& mcp_get_game_news_params::set_info_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_params& mcp_get_game_news_params::set_ptr_info_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_info_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_params::clear_info_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_info_id.clear();
}
inline bool mcp_get_game_news_params::has_c_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_get_game_news_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_get_game_news_params& mcp_get_game_news_params::set_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_params& mcp_get_game_news_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_params::clear_c_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_c_id.clear();
}
inline bool mcp_get_game_news_params::has_info_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_game_news_params::info_type(unsigned int* size) const{
return _m_info_type.get(size);
}
inline mcp_get_game_news_params& mcp_get_game_news_params::set_info_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_params& mcp_get_game_news_params::set_ptr_info_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_info_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_params::clear_info_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_info_type.clear();
}
inline bool mcp_get_game_news_params::has_game_type() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_get_game_news_params::game_type(unsigned int* size) const{
return _m_game_type.get(size);
}
inline mcp_get_game_news_params& mcp_get_game_news_params::set_game_type(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_game_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_params& mcp_get_game_news_params::set_ptr_game_type(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_game_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_params::clear_game_type(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_game_type.clear();
}
inline bool mcp_get_game_news_params::has_date_limit() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_get_game_news_params::date_limit(unsigned int* size) const{
return _m_date_limit.get(size);
}
inline mcp_get_game_news_params& mcp_get_game_news_params::set_date_limit(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_date_limit.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_game_news_params& mcp_get_game_news_params::set_ptr_date_limit(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_date_limit.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_game_news_params::clear_date_limit(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_date_limit.clear();
}
inline bool mcp_get_game_news_params::has_page() const{
return (_flag[5 >> 3] & (1 << (5 & 0x7)));
}
inline uint32_t mcp_get_game_news_params::page() const{
return _m_page;
}
inline mcp_get_game_news_params& mcp_get_game_news_params::set_page(uint32_t v){
_flag[5 >> 3] |= (1 << (5 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_game_news_params::clear_page(){
_flag[5 >> 3] &= ~(1 << (5 & 0x7));
 _m_page=0;
}
inline bool mcp_get_game_news_params::has_page_size() const{
return (_flag[6 >> 3] & (1 << (6 & 0x7)));
}
inline uint32_t mcp_get_game_news_params::page_size() const{
return _m_page_size;
}
inline mcp_get_game_news_params& mcp_get_game_news_params::set_page_size(uint32_t v){
_flag[6 >> 3] |= (1 << (6 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_game_news_params::clear_page_size(){
_flag[6 >> 3] &= ~(1 << (6 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_game_news_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_news_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_news_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_news_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_news_result_params* mcp_get_game_news_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_news_result_params* tmp=(mcp_get_game_news_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_news_result_params(pool);
return tmp;
}
inline void mcp_get_game_news_result_params::destroy(mcp_get_game_news_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_news_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_news_result_params::mcp_get_game_news_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_game_info_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_news_result_params::mcp_get_game_news_result_params(const mcp_get_game_news_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_game_info_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_game_news_result_params::~mcp_get_game_news_result_params(){
}
inline mcp_get_game_news_result_params& mcp_get_game_news_result_params::operator=(const mcp_get_game_news_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_game_news_result_params::clear(){
// _m_count=0;
_m_game_info_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_news_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@game_info_t_hall game_info_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "game_info_list" << "' not found";
}
{
// level 0 begin
typeof(_m_game_info_list)& lr0=(_m_game_info_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::game_info_t_hall& item=const_cast< ::idl::game_info_t_hall& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_game_news_result_params::detach(){
_m_game_info_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_news_result_params& mcp_get_game_news_result_params::assign(const mcp_get_game_news_result_params& v){
_m_count=v._m_count;
_m_game_info_list=v._m_game_info_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_news_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_game_news_result_params::count() const{
return _m_count;
}
inline mcp_get_game_news_result_params& mcp_get_game_news_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_game_news_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_game_news_result_params::has_game_info_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::game_info_t_hall >& mcp_get_game_news_result_params::game_info_list() const{
 return _m_game_info_list;
}
inline void mcp_get_game_news_result_params::clear_game_info_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_game_info_list.clear();
}
inline ::idl::vector< ::idl::game_info_t_hall >* mcp_get_game_news_result_params::mutable_game_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_info_list);
}
inline ::idl::vector< ::idl::game_info_t_hall >* mcp_get_game_news_result_params::m_game_info_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_game_info_list);
}
inline size_t mcp_get_game_news_result_params::game_info_list_size() const{
/*  */ return _m_game_info_list.size();
}
inline const ::idl::game_info_t_hall& mcp_get_game_news_result_params::game_info_list(size_t i0) const{
 return _m_game_info_list.get(i0);
}
inline ::idl::game_info_t_hall* mcp_get_game_news_result_params::mutable_game_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_info_list.mutable_get(i0);
}
inline ::idl::game_info_t_hall* mcp_get_game_news_result_params::m_game_info_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_game_info_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_game_news_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_news_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_news_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_game_news_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_game_news_response* mcp_get_game_news_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_game_news_response* tmp=(mcp_get_game_news_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_game_news_response(pool);
return tmp;
}
inline void mcp_get_game_news_response::destroy(mcp_get_game_news_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_game_news_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_game_news_response::mcp_get_game_news_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_news_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_game_news_response::mcp_get_game_news_response(const mcp_get_game_news_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_game_news_result_params::create(_pool);
assign(v);
}
inline mcp_get_game_news_response::~mcp_get_game_news_response(){
if(_m_result_params){
::idl::mcp_get_game_news_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_game_news_response& mcp_get_game_news_response::operator=(const mcp_get_game_news_response& v){
assign(v);
return *this;
}
inline void mcp_get_game_news_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_game_news_response::check() const{
// @@mcp_get_game_news_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_game_news_result_params& item=const_cast< ::idl::mcp_get_game_news_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_game_news_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_game_news_response& mcp_get_game_news_response::assign(const mcp_get_game_news_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_game_news_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_news_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_game_news_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_game_news_result_params& mcp_get_game_news_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_game_news_result_params* mcp_get_game_news_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_news_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_game_news_result_params* mcp_get_game_news_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_game_news_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_game_news_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_game_news_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_game_news_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_game_news_response::unknown(){
return _unknown;
}
inline size_t mcp_get_game_news_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ip_province_params* mcp_get_ip_province_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ip_province_params* tmp=(mcp_get_ip_province_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ip_province_params(pool);
return tmp;
}
inline void mcp_get_ip_province_params::destroy(mcp_get_ip_province_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ip_province_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ip_province_params::mcp_get_ip_province_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ip(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ip_province_params::mcp_get_ip_province_params(const mcp_get_ip_province_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ip(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_ip_province_params::~mcp_get_ip_province_params(){
}
inline mcp_get_ip_province_params& mcp_get_ip_province_params::operator=(const mcp_get_ip_province_params& v){
assign(v);
return *this;
}
inline void mcp_get_ip_province_params::clear(){
_m_ip.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ip_province_params::check() const{
// @@string ip=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ip" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ip.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_ip_province_params::detach(){
_m_ip.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ip_province_params& mcp_get_ip_province_params::assign(const mcp_get_ip_province_params& v){
_m_ip=v._m_ip;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ip_province_params::has_ip() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_ip_province_params::ip(unsigned int* size) const{
return _m_ip.get(size);
}
inline mcp_get_ip_province_params& mcp_get_ip_province_params::set_ip(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ip.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_ip_province_params& mcp_get_ip_province_params::set_ptr_ip(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ip.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_ip_province_params::clear_ip(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ip.clear();
}
inline ::idl::Unknown* mcp_get_ip_province_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ip_province_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ip_province_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ip_province_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ip_province_result_params* mcp_get_ip_province_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ip_province_result_params* tmp=(mcp_get_ip_province_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ip_province_result_params(pool);
return tmp;
}
inline void mcp_get_ip_province_result_params::destroy(mcp_get_ip_province_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ip_province_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ip_province_result_params::mcp_get_ip_province_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_ip_scope(_pool)
,_m_province(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ip_province_result_params::mcp_get_ip_province_result_params(const mcp_get_ip_province_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_ip_scope(_pool)
,_m_province(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_ip_province_result_params::~mcp_get_ip_province_result_params(){
}
inline mcp_get_ip_province_result_params& mcp_get_ip_province_result_params::operator=(const mcp_get_ip_province_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_ip_province_result_params::clear(){
_m_ip_scope.clear();
// _m_province=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ip_province_result_params::check() const{
// @@string ip_scope=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "ip_scope" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_ip_scope.get();

}
// @@int32_t province=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "province" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_province;

}

::idl::McpackBean::check();
}
inline void mcp_get_ip_province_result_params::detach(){
_m_ip_scope.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ip_province_result_params& mcp_get_ip_province_result_params::assign(const mcp_get_ip_province_result_params& v){
_m_ip_scope=v._m_ip_scope;
_m_province=v._m_province;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ip_province_result_params::has_ip_scope() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_ip_province_result_params::ip_scope(unsigned int* size) const{
return _m_ip_scope.get(size);
}
inline mcp_get_ip_province_result_params& mcp_get_ip_province_result_params::set_ip_scope(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ip_scope.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_ip_province_result_params& mcp_get_ip_province_result_params::set_ptr_ip_scope(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_ip_scope.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_ip_province_result_params::clear_ip_scope(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_ip_scope.clear();
}
inline bool mcp_get_ip_province_result_params::has_province() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline int32_t mcp_get_ip_province_result_params::province() const{
return _m_province;
}
inline mcp_get_ip_province_result_params& mcp_get_ip_province_result_params::set_province(int32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_province=v;
return *this;
}
inline void mcp_get_ip_province_result_params::clear_province(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_province=0;
}
inline ::idl::Unknown* mcp_get_ip_province_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ip_province_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ip_province_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_ip_province_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_ip_province_response* mcp_get_ip_province_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_ip_province_response* tmp=(mcp_get_ip_province_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_ip_province_response(pool);
return tmp;
}
inline void mcp_get_ip_province_response::destroy(mcp_get_ip_province_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_ip_province_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_ip_province_response::mcp_get_ip_province_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ip_province_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_ip_province_response::mcp_get_ip_province_response(const mcp_get_ip_province_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_ip_province_result_params::create(_pool);
assign(v);
}
inline mcp_get_ip_province_response::~mcp_get_ip_province_response(){
if(_m_result_params){
::idl::mcp_get_ip_province_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_ip_province_response& mcp_get_ip_province_response::operator=(const mcp_get_ip_province_response& v){
assign(v);
return *this;
}
inline void mcp_get_ip_province_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_ip_province_response::check() const{
// @@mcp_get_ip_province_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_ip_province_result_params& item=const_cast< ::idl::mcp_get_ip_province_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_ip_province_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_ip_province_response& mcp_get_ip_province_response::assign(const mcp_get_ip_province_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_ip_province_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_ip_province_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_ip_province_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_ip_province_result_params& mcp_get_ip_province_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_ip_province_result_params* mcp_get_ip_province_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ip_province_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_ip_province_result_params* mcp_get_ip_province_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_ip_province_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_ip_province_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_ip_province_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_ip_province_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_ip_province_response::unknown(){
return _unknown;
}
inline size_t mcp_get_ip_province_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_question_type_name_params* mcp_get_question_type_name_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_question_type_name_params* tmp=(mcp_get_question_type_name_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_question_type_name_params(pool);
return tmp;
}
inline void mcp_get_question_type_name_params::destroy(mcp_get_question_type_name_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_question_type_name_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_question_type_name_params::mcp_get_question_type_name_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_question_type_name_params::mcp_get_question_type_name_params(const mcp_get_question_type_name_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_question_type_name_params::~mcp_get_question_type_name_params(){
}
inline mcp_get_question_type_name_params& mcp_get_question_type_name_params::operator=(const mcp_get_question_type_name_params& v){
assign(v);
return *this;
}
inline void mcp_get_question_type_name_params::clear(){
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_question_type_name_params::check() const{
// @@uint32_t page=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_question_type_name_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_question_type_name_params& mcp_get_question_type_name_params::assign(const mcp_get_question_type_name_params& v){
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_question_type_name_params::has_page() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_question_type_name_params::page() const{
return _m_page;
}
inline mcp_get_question_type_name_params& mcp_get_question_type_name_params::set_page(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_question_type_name_params::clear_page(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_page=0;
}
inline bool mcp_get_question_type_name_params::has_page_size() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_question_type_name_params::page_size() const{
return _m_page_size;
}
inline mcp_get_question_type_name_params& mcp_get_question_type_name_params::set_page_size(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_question_type_name_params::clear_page_size(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_question_type_name_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_question_type_name_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_question_type_name_params::unknown(){
return _unknown;
}
inline size_t mcp_get_question_type_name_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_question_type_name_result_params* mcp_get_question_type_name_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_question_type_name_result_params* tmp=(mcp_get_question_type_name_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_question_type_name_result_params(pool);
return tmp;
}
inline void mcp_get_question_type_name_result_params::destroy(mcp_get_question_type_name_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_question_type_name_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_question_type_name_result_params::mcp_get_question_type_name_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_question_type_name_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_question_type_name_result_params::mcp_get_question_type_name_result_params(const mcp_get_question_type_name_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_question_type_name_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_question_type_name_result_params::~mcp_get_question_type_name_result_params(){
}
inline mcp_get_question_type_name_result_params& mcp_get_question_type_name_result_params::operator=(const mcp_get_question_type_name_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_question_type_name_result_params::clear(){
// _m_count=0;
_m_question_type_name_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_question_type_name_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@question_type_name_t question_type_name_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "question_type_name_list" << "' not found";
}
{
// level 0 begin
typeof(_m_question_type_name_list)& lr0=(_m_question_type_name_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::question_type_name_t& item=const_cast< ::idl::question_type_name_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_question_type_name_result_params::detach(){
_m_question_type_name_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_question_type_name_result_params& mcp_get_question_type_name_result_params::assign(const mcp_get_question_type_name_result_params& v){
_m_count=v._m_count;
_m_question_type_name_list=v._m_question_type_name_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_question_type_name_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_question_type_name_result_params::count() const{
return _m_count;
}
inline mcp_get_question_type_name_result_params& mcp_get_question_type_name_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_question_type_name_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_question_type_name_result_params::has_question_type_name_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::question_type_name_t >& mcp_get_question_type_name_result_params::question_type_name_list() const{
 return _m_question_type_name_list;
}
inline void mcp_get_question_type_name_result_params::clear_question_type_name_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_question_type_name_list.clear();
}
inline ::idl::vector< ::idl::question_type_name_t >* mcp_get_question_type_name_result_params::mutable_question_type_name_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_question_type_name_list);
}
inline ::idl::vector< ::idl::question_type_name_t >* mcp_get_question_type_name_result_params::m_question_type_name_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_question_type_name_list);
}
inline size_t mcp_get_question_type_name_result_params::question_type_name_list_size() const{
/*  */ return _m_question_type_name_list.size();
}
inline const ::idl::question_type_name_t& mcp_get_question_type_name_result_params::question_type_name_list(size_t i0) const{
 return _m_question_type_name_list.get(i0);
}
inline ::idl::question_type_name_t* mcp_get_question_type_name_result_params::mutable_question_type_name_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_question_type_name_list.mutable_get(i0);
}
inline ::idl::question_type_name_t* mcp_get_question_type_name_result_params::m_question_type_name_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_question_type_name_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_question_type_name_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_question_type_name_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_question_type_name_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_question_type_name_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_question_type_name_response* mcp_get_question_type_name_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_question_type_name_response* tmp=(mcp_get_question_type_name_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_question_type_name_response(pool);
return tmp;
}
inline void mcp_get_question_type_name_response::destroy(mcp_get_question_type_name_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_question_type_name_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_question_type_name_response::mcp_get_question_type_name_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_question_type_name_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_question_type_name_response::mcp_get_question_type_name_response(const mcp_get_question_type_name_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_question_type_name_result_params::create(_pool);
assign(v);
}
inline mcp_get_question_type_name_response::~mcp_get_question_type_name_response(){
if(_m_result_params){
::idl::mcp_get_question_type_name_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_question_type_name_response& mcp_get_question_type_name_response::operator=(const mcp_get_question_type_name_response& v){
assign(v);
return *this;
}
inline void mcp_get_question_type_name_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_question_type_name_response::check() const{
// @@mcp_get_question_type_name_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_question_type_name_result_params& item=const_cast< ::idl::mcp_get_question_type_name_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_question_type_name_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_question_type_name_response& mcp_get_question_type_name_response::assign(const mcp_get_question_type_name_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_question_type_name_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_question_type_name_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_question_type_name_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_question_type_name_result_params& mcp_get_question_type_name_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_question_type_name_result_params* mcp_get_question_type_name_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_question_type_name_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_question_type_name_result_params* mcp_get_question_type_name_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_question_type_name_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_question_type_name_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_question_type_name_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_question_type_name_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_question_type_name_response::unknown(){
return _unknown;
}
inline size_t mcp_get_question_type_name_response::unknown_size() const{
return _unknown.size();
}
inline mcp_submit_question_params* mcp_submit_question_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_submit_question_params* tmp=(mcp_submit_question_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_submit_question_params(pool);
return tmp;
}
inline void mcp_submit_question_params::destroy(mcp_submit_question_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_submit_question_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_submit_question_params::mcp_submit_question_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_user_id(_pool)
,_m_c_id(_pool)
,_m_question_type(_pool)
,_m_question(_pool)
,_m_phone(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_submit_question_params::mcp_submit_question_params(const mcp_submit_question_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_user_id(_pool)
,_m_c_id(_pool)
,_m_question_type(_pool)
,_m_question(_pool)
,_m_phone(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_submit_question_params::~mcp_submit_question_params(){
}
inline mcp_submit_question_params& mcp_submit_question_params::operator=(const mcp_submit_question_params& v){
assign(v);
return *this;
}
inline void mcp_submit_question_params::clear(){
_m_user_id.clear();
_m_c_id.clear();
_m_question_type.clear();
_m_question.clear();
_m_phone.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_submit_question_params::check() const{
// @@string user_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}
// @@string c_id=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_id.get();

}
// @@string question_type=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "question_type" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_question_type.get();

}
// @@string question=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "question" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_question.get();

}
// @@string phone=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "phone" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_phone.get();

}

::idl::McpackBean::check();
}
inline void mcp_submit_question_params::detach(){
_m_user_id.detach();
_m_c_id.detach();
_m_question_type.detach();
_m_question.detach();
_m_phone.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_submit_question_params& mcp_submit_question_params::assign(const mcp_submit_question_params& v){
_m_user_id=v._m_user_id;
_m_c_id=v._m_c_id;
_m_question_type=v._m_question_type;
_m_question=v._m_question;
_m_phone=v._m_phone;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_submit_question_params::has_user_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_submit_question_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_submit_question_params& mcp_submit_question_params::set_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_submit_question_params& mcp_submit_question_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_submit_question_params::clear_user_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_user_id.clear();
}
inline bool mcp_submit_question_params::has_c_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_submit_question_params::c_id(unsigned int* size) const{
return _m_c_id.get(size);
}
inline mcp_submit_question_params& mcp_submit_question_params::set_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_submit_question_params& mcp_submit_question_params::set_ptr_c_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_c_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_submit_question_params::clear_c_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_c_id.clear();
}
inline bool mcp_submit_question_params::has_question_type() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_submit_question_params::question_type(unsigned int* size) const{
return _m_question_type.get(size);
}
inline mcp_submit_question_params& mcp_submit_question_params::set_question_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_question_type.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_submit_question_params& mcp_submit_question_params::set_ptr_question_type(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_question_type.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_submit_question_params::clear_question_type(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_question_type.clear();
}
inline bool mcp_submit_question_params::has_question() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* mcp_submit_question_params::question(unsigned int* size) const{
return _m_question.get(size);
}
inline mcp_submit_question_params& mcp_submit_question_params::set_question(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_question.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_submit_question_params& mcp_submit_question_params::set_ptr_question(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_question.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_submit_question_params::clear_question(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_question.clear();
}
inline bool mcp_submit_question_params::has_phone() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline const char* mcp_submit_question_params::phone(unsigned int* size) const{
return _m_phone.get(size);
}
inline mcp_submit_question_params& mcp_submit_question_params::set_phone(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_phone.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_submit_question_params& mcp_submit_question_params::set_ptr_phone(const char* s,ssize_t size){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_phone.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_submit_question_params::clear_phone(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_phone.clear();
}
inline ::idl::Unknown* mcp_submit_question_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_submit_question_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_submit_question_params::unknown(){
return _unknown;
}
inline size_t mcp_submit_question_params::unknown_size() const{
return _unknown.size();
}
inline mcp_submit_question_result_params* mcp_submit_question_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_submit_question_result_params* tmp=(mcp_submit_question_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_submit_question_result_params(pool);
return tmp;
}
inline void mcp_submit_question_result_params::destroy(mcp_submit_question_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_submit_question_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_submit_question_result_params::mcp_submit_question_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_res(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_submit_question_result_params::mcp_submit_question_result_params(const mcp_submit_question_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_res(0)
,_unknown(_pool){
assign(v);
}
inline mcp_submit_question_result_params::~mcp_submit_question_result_params(){
}
inline mcp_submit_question_result_params& mcp_submit_question_result_params::operator=(const mcp_submit_question_result_params& v){
assign(v);
return *this;
}
inline void mcp_submit_question_result_params::clear(){
// _m_res=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_submit_question_result_params::check() const{
// @@int32_t res=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "res" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_res;

}

::idl::McpackBean::check();
}
inline void mcp_submit_question_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_submit_question_result_params& mcp_submit_question_result_params::assign(const mcp_submit_question_result_params& v){
_m_res=v._m_res;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_submit_question_result_params::has_res() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_submit_question_result_params::res() const{
return _m_res;
}
inline mcp_submit_question_result_params& mcp_submit_question_result_params::set_res(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_res=v;
return *this;
}
inline void mcp_submit_question_result_params::clear_res(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_res=0;
}
inline ::idl::Unknown* mcp_submit_question_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_submit_question_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_submit_question_result_params::unknown(){
return _unknown;
}
inline size_t mcp_submit_question_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_submit_question_response* mcp_submit_question_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_submit_question_response* tmp=(mcp_submit_question_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_submit_question_response(pool);
return tmp;
}
inline void mcp_submit_question_response::destroy(mcp_submit_question_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_submit_question_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_submit_question_response::mcp_submit_question_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_submit_question_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_submit_question_response::mcp_submit_question_response(const mcp_submit_question_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_submit_question_result_params::create(_pool);
assign(v);
}
inline mcp_submit_question_response::~mcp_submit_question_response(){
if(_m_result_params){
::idl::mcp_submit_question_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_submit_question_response& mcp_submit_question_response::operator=(const mcp_submit_question_response& v){
assign(v);
return *this;
}
inline void mcp_submit_question_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_submit_question_response::check() const{
// @@mcp_submit_question_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_submit_question_result_params& item=const_cast< ::idl::mcp_submit_question_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_submit_question_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_submit_question_response& mcp_submit_question_response::assign(const mcp_submit_question_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_submit_question_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_submit_question_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_submit_question_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_submit_question_result_params& mcp_submit_question_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_submit_question_result_params* mcp_submit_question_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_submit_question_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_submit_question_result_params* mcp_submit_question_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_submit_question_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_submit_question_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_submit_question_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_submit_question_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_submit_question_response::unknown(){
return _unknown;
}
inline size_t mcp_submit_question_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_user_question_params* mcp_get_user_question_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_user_question_params* tmp=(mcp_get_user_question_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_user_question_params(pool);
return tmp;
}
inline void mcp_get_user_question_params::destroy(mcp_get_user_question_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_user_question_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_user_question_params::mcp_get_user_question_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_user_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_user_question_params::mcp_get_user_question_params(const mcp_get_user_question_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_user_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_user_question_params::~mcp_get_user_question_params(){
}
inline mcp_get_user_question_params& mcp_get_user_question_params::operator=(const mcp_get_user_question_params& v){
assign(v);
return *this;
}
inline void mcp_get_user_question_params::clear(){
_m_user_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_user_question_params::check() const{
// @@string user_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_user_question_params::detach(){
_m_user_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_user_question_params& mcp_get_user_question_params::assign(const mcp_get_user_question_params& v){
_m_user_id=v._m_user_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_user_question_params::has_user_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_user_question_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_get_user_question_params& mcp_get_user_question_params::set_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_user_question_params& mcp_get_user_question_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_user_question_params::clear_user_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_user_id.clear();
}
inline ::idl::Unknown* mcp_get_user_question_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_user_question_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_user_question_params::unknown(){
return _unknown;
}
inline size_t mcp_get_user_question_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_user_question_result_params* mcp_get_user_question_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_user_question_result_params* tmp=(mcp_get_user_question_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_user_question_result_params(pool);
return tmp;
}
inline void mcp_get_user_question_result_params::destroy(mcp_get_user_question_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_user_question_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_user_question_result_params::mcp_get_user_question_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_user_question_answer_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_user_question_result_params::mcp_get_user_question_result_params(const mcp_get_user_question_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_user_question_answer_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_user_question_result_params::~mcp_get_user_question_result_params(){
}
inline mcp_get_user_question_result_params& mcp_get_user_question_result_params::operator=(const mcp_get_user_question_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_user_question_result_params::clear(){
// _m_count=0;
_m_user_question_answer_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_user_question_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@user_question_answer_t user_question_answer_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_question_answer_list" << "' not found";
}
{
// level 0 begin
typeof(_m_user_question_answer_list)& lr0=(_m_user_question_answer_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::user_question_answer_t& item=const_cast< ::idl::user_question_answer_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_user_question_result_params::detach(){
_m_user_question_answer_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_user_question_result_params& mcp_get_user_question_result_params::assign(const mcp_get_user_question_result_params& v){
_m_count=v._m_count;
_m_user_question_answer_list=v._m_user_question_answer_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_user_question_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_user_question_result_params::count() const{
return _m_count;
}
inline mcp_get_user_question_result_params& mcp_get_user_question_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_user_question_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_user_question_result_params::has_user_question_answer_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::user_question_answer_t >& mcp_get_user_question_result_params::user_question_answer_list() const{
 return _m_user_question_answer_list;
}
inline void mcp_get_user_question_result_params::clear_user_question_answer_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_user_question_answer_list.clear();
}
inline ::idl::vector< ::idl::user_question_answer_t >* mcp_get_user_question_result_params::mutable_user_question_answer_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_user_question_answer_list);
}
inline ::idl::vector< ::idl::user_question_answer_t >* mcp_get_user_question_result_params::m_user_question_answer_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_user_question_answer_list);
}
inline size_t mcp_get_user_question_result_params::user_question_answer_list_size() const{
/*  */ return _m_user_question_answer_list.size();
}
inline const ::idl::user_question_answer_t& mcp_get_user_question_result_params::user_question_answer_list(size_t i0) const{
 return _m_user_question_answer_list.get(i0);
}
inline ::idl::user_question_answer_t* mcp_get_user_question_result_params::mutable_user_question_answer_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_user_question_answer_list.mutable_get(i0);
}
inline ::idl::user_question_answer_t* mcp_get_user_question_result_params::m_user_question_answer_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_user_question_answer_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_user_question_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_user_question_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_user_question_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_user_question_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_user_question_response* mcp_get_user_question_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_user_question_response* tmp=(mcp_get_user_question_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_user_question_response(pool);
return tmp;
}
inline void mcp_get_user_question_response::destroy(mcp_get_user_question_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_user_question_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_user_question_response::mcp_get_user_question_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_user_question_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_user_question_response::mcp_get_user_question_response(const mcp_get_user_question_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_user_question_result_params::create(_pool);
assign(v);
}
inline mcp_get_user_question_response::~mcp_get_user_question_response(){
if(_m_result_params){
::idl::mcp_get_user_question_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_user_question_response& mcp_get_user_question_response::operator=(const mcp_get_user_question_response& v){
assign(v);
return *this;
}
inline void mcp_get_user_question_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_user_question_response::check() const{
// @@mcp_get_user_question_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_user_question_result_params& item=const_cast< ::idl::mcp_get_user_question_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_user_question_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_user_question_response& mcp_get_user_question_response::assign(const mcp_get_user_question_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_user_question_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_user_question_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_user_question_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_user_question_result_params& mcp_get_user_question_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_user_question_result_params* mcp_get_user_question_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_user_question_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_user_question_result_params* mcp_get_user_question_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_user_question_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_user_question_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_user_question_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_user_question_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_user_question_response::unknown(){
return _unknown;
}
inline size_t mcp_get_user_question_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_qp_activity_params* mcp_get_qp_activity_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_qp_activity_params* tmp=(mcp_get_qp_activity_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_qp_activity_params(pool);
return tmp;
}
inline void mcp_get_qp_activity_params::destroy(mcp_get_qp_activity_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_qp_activity_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_qp_activity_params::mcp_get_qp_activity_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_qp_activity_params::mcp_get_qp_activity_params(const mcp_get_qp_activity_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_id(_pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_qp_activity_params::~mcp_get_qp_activity_params(){
}
inline mcp_get_qp_activity_params& mcp_get_qp_activity_params::operator=(const mcp_get_qp_activity_params& v){
assign(v);
return *this;
}
inline void mcp_get_qp_activity_params::clear(){
_m_id.clear();
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_qp_activity_params::check() const{
// @@string id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_id.get();

}
// @@uint32_t page=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_qp_activity_params::detach(){
_m_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_qp_activity_params& mcp_get_qp_activity_params::assign(const mcp_get_qp_activity_params& v){
_m_id=v._m_id;
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_qp_activity_params::has_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_qp_activity_params::id(unsigned int* size) const{
return _m_id.get(size);
}
inline mcp_get_qp_activity_params& mcp_get_qp_activity_params::set_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_qp_activity_params& mcp_get_qp_activity_params::set_ptr_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_qp_activity_params::clear_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_id.clear();
}
inline bool mcp_get_qp_activity_params::has_page() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_qp_activity_params::page() const{
return _m_page;
}
inline mcp_get_qp_activity_params& mcp_get_qp_activity_params::set_page(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_qp_activity_params::clear_page(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page=0;
}
inline bool mcp_get_qp_activity_params::has_page_size() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline uint32_t mcp_get_qp_activity_params::page_size() const{
return _m_page_size;
}
inline mcp_get_qp_activity_params& mcp_get_qp_activity_params::set_page_size(uint32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_qp_activity_params::clear_page_size(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_qp_activity_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_qp_activity_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_qp_activity_params::unknown(){
return _unknown;
}
inline size_t mcp_get_qp_activity_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_qp_activity_result_params* mcp_get_qp_activity_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_qp_activity_result_params* tmp=(mcp_get_qp_activity_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_qp_activity_result_params(pool);
return tmp;
}
inline void mcp_get_qp_activity_result_params::destroy(mcp_get_qp_activity_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_qp_activity_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_qp_activity_result_params::mcp_get_qp_activity_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_qp_activity_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_qp_activity_result_params::mcp_get_qp_activity_result_params(const mcp_get_qp_activity_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_qp_activity_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_qp_activity_result_params::~mcp_get_qp_activity_result_params(){
}
inline mcp_get_qp_activity_result_params& mcp_get_qp_activity_result_params::operator=(const mcp_get_qp_activity_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_qp_activity_result_params::clear(){
// _m_count=0;
_m_qp_activity_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_qp_activity_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@qp_activity_t qp_activity_list=out(),array(0);
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "qp_activity_list" << "' not found";
}
{
// level 0 begin
typeof(_m_qp_activity_list)& lr0=(_m_qp_activity_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::qp_activity_t& item=const_cast< ::idl::qp_activity_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_qp_activity_result_params::detach(){
_m_qp_activity_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_qp_activity_result_params& mcp_get_qp_activity_result_params::assign(const mcp_get_qp_activity_result_params& v){
_m_count=v._m_count;
_m_qp_activity_list=v._m_qp_activity_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_qp_activity_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_qp_activity_result_params::count() const{
return _m_count;
}
inline mcp_get_qp_activity_result_params& mcp_get_qp_activity_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_qp_activity_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_qp_activity_result_params::has_qp_activity_list() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const ::idl::vector< ::idl::qp_activity_t >& mcp_get_qp_activity_result_params::qp_activity_list() const{
 return _m_qp_activity_list;
}
inline void mcp_get_qp_activity_result_params::clear_qp_activity_list(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_qp_activity_list.clear();
}
inline ::idl::vector< ::idl::qp_activity_t >* mcp_get_qp_activity_result_params::mutable_qp_activity_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_qp_activity_list);
}
inline ::idl::vector< ::idl::qp_activity_t >* mcp_get_qp_activity_result_params::m_qp_activity_list(){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return &(_m_qp_activity_list);
}
inline size_t mcp_get_qp_activity_result_params::qp_activity_list_size() const{
/*  */ return _m_qp_activity_list.size();
}
inline const ::idl::qp_activity_t& mcp_get_qp_activity_result_params::qp_activity_list(size_t i0) const{
 return _m_qp_activity_list.get(i0);
}
inline ::idl::qp_activity_t* mcp_get_qp_activity_result_params::mutable_qp_activity_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_qp_activity_list.mutable_get(i0);
}
inline ::idl::qp_activity_t* mcp_get_qp_activity_result_params::m_qp_activity_list(size_t i0){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 return _m_qp_activity_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_qp_activity_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_qp_activity_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_qp_activity_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_qp_activity_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_qp_activity_response* mcp_get_qp_activity_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_qp_activity_response* tmp=(mcp_get_qp_activity_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_qp_activity_response(pool);
return tmp;
}
inline void mcp_get_qp_activity_response::destroy(mcp_get_qp_activity_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_qp_activity_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_qp_activity_response::mcp_get_qp_activity_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_qp_activity_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_qp_activity_response::mcp_get_qp_activity_response(const mcp_get_qp_activity_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_qp_activity_result_params::create(_pool);
assign(v);
}
inline mcp_get_qp_activity_response::~mcp_get_qp_activity_response(){
if(_m_result_params){
::idl::mcp_get_qp_activity_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_qp_activity_response& mcp_get_qp_activity_response::operator=(const mcp_get_qp_activity_response& v){
assign(v);
return *this;
}
inline void mcp_get_qp_activity_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_qp_activity_response::check() const{
// @@mcp_get_qp_activity_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_qp_activity_result_params& item=const_cast< ::idl::mcp_get_qp_activity_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_qp_activity_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_qp_activity_response& mcp_get_qp_activity_response::assign(const mcp_get_qp_activity_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_qp_activity_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_qp_activity_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_qp_activity_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_qp_activity_result_params& mcp_get_qp_activity_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_qp_activity_result_params* mcp_get_qp_activity_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_qp_activity_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_qp_activity_result_params* mcp_get_qp_activity_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_qp_activity_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_qp_activity_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_qp_activity_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_qp_activity_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_qp_activity_response::unknown(){
return _unknown;
}
inline size_t mcp_get_qp_activity_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_qp_activity_person_params* mcp_get_qp_activity_person_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_qp_activity_person_params* tmp=(mcp_get_qp_activity_person_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_qp_activity_person_params(pool);
return tmp;
}
inline void mcp_get_qp_activity_person_params::destroy(mcp_get_qp_activity_person_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_qp_activity_person_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_qp_activity_person_params::mcp_get_qp_activity_person_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_c_ids(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_qp_activity_person_params::mcp_get_qp_activity_person_params(const mcp_get_qp_activity_person_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_c_ids(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_qp_activity_person_params::~mcp_get_qp_activity_person_params(){
}
inline mcp_get_qp_activity_person_params& mcp_get_qp_activity_person_params::operator=(const mcp_get_qp_activity_person_params& v){
assign(v);
return *this;
}
inline void mcp_get_qp_activity_person_params::clear(){
_m_c_ids.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_qp_activity_person_params::check() const{
// @@string c_ids=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "c_ids" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_c_ids.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_qp_activity_person_params::detach(){
_m_c_ids.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_qp_activity_person_params& mcp_get_qp_activity_person_params::assign(const mcp_get_qp_activity_person_params& v){
_m_c_ids=v._m_c_ids;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_qp_activity_person_params::has_c_ids() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_qp_activity_person_params::c_ids(unsigned int* size) const{
return _m_c_ids.get(size);
}
inline mcp_get_qp_activity_person_params& mcp_get_qp_activity_person_params::set_c_ids(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_ids.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_qp_activity_person_params& mcp_get_qp_activity_person_params::set_ptr_c_ids(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_c_ids.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_qp_activity_person_params::clear_c_ids(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_c_ids.clear();
}
inline ::idl::Unknown* mcp_get_qp_activity_person_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_qp_activity_person_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_qp_activity_person_params::unknown(){
return _unknown;
}
inline size_t mcp_get_qp_activity_person_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_qp_activity_person_result_params* mcp_get_qp_activity_person_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_qp_activity_person_result_params* tmp=(mcp_get_qp_activity_person_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_qp_activity_person_result_params(pool);
return tmp;
}
inline void mcp_get_qp_activity_person_result_params::destroy(mcp_get_qp_activity_person_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_qp_activity_person_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_qp_activity_person_result_params::mcp_get_qp_activity_person_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_res(0)
,_m_total_person_num(0)
,_m_qp_activity_person_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_qp_activity_person_result_params::mcp_get_qp_activity_person_result_params(const mcp_get_qp_activity_person_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_res(0)
,_m_total_person_num(0)
,_m_qp_activity_person_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_qp_activity_person_result_params::~mcp_get_qp_activity_person_result_params(){
}
inline mcp_get_qp_activity_person_result_params& mcp_get_qp_activity_person_result_params::operator=(const mcp_get_qp_activity_person_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_qp_activity_person_result_params::clear(){
// _m_res=0;
// _m_total_person_num=0;
_m_qp_activity_person_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_qp_activity_person_result_params::check() const{
// @@int32_t res=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "res" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_res;

}
// @@int32_t total_person_num=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "total_person_num" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_total_person_num;

}
// @@qp_activity_person_t qp_activity_person_list=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "qp_activity_person_list" << "' not found";
}
{
// level 0 begin
typeof(_m_qp_activity_person_list)& lr0=(_m_qp_activity_person_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::qp_activity_person_t& item=const_cast< ::idl::qp_activity_person_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_qp_activity_person_result_params::detach(){
_m_qp_activity_person_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_qp_activity_person_result_params& mcp_get_qp_activity_person_result_params::assign(const mcp_get_qp_activity_person_result_params& v){
_m_res=v._m_res;
_m_total_person_num=v._m_total_person_num;
_m_qp_activity_person_list=v._m_qp_activity_person_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_qp_activity_person_result_params::has_res() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_qp_activity_person_result_params::res() const{
return _m_res;
}
inline mcp_get_qp_activity_person_result_params& mcp_get_qp_activity_person_result_params::set_res(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_res=v;
return *this;
}
inline void mcp_get_qp_activity_person_result_params::clear_res(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_res=0;
}
inline bool mcp_get_qp_activity_person_result_params::has_total_person_num() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline int32_t mcp_get_qp_activity_person_result_params::total_person_num() const{
return _m_total_person_num;
}
inline mcp_get_qp_activity_person_result_params& mcp_get_qp_activity_person_result_params::set_total_person_num(int32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_total_person_num=v;
return *this;
}
inline void mcp_get_qp_activity_person_result_params::clear_total_person_num(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_total_person_num=0;
}
inline bool mcp_get_qp_activity_person_result_params::has_qp_activity_person_list() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::qp_activity_person_t >& mcp_get_qp_activity_person_result_params::qp_activity_person_list() const{
 return _m_qp_activity_person_list;
}
inline void mcp_get_qp_activity_person_result_params::clear_qp_activity_person_list(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_qp_activity_person_list.clear();
}
inline ::idl::vector< ::idl::qp_activity_person_t >* mcp_get_qp_activity_person_result_params::mutable_qp_activity_person_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_qp_activity_person_list);
}
inline ::idl::vector< ::idl::qp_activity_person_t >* mcp_get_qp_activity_person_result_params::m_qp_activity_person_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_qp_activity_person_list);
}
inline size_t mcp_get_qp_activity_person_result_params::qp_activity_person_list_size() const{
/*  */ return _m_qp_activity_person_list.size();
}
inline const ::idl::qp_activity_person_t& mcp_get_qp_activity_person_result_params::qp_activity_person_list(size_t i0) const{
 return _m_qp_activity_person_list.get(i0);
}
inline ::idl::qp_activity_person_t* mcp_get_qp_activity_person_result_params::mutable_qp_activity_person_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_qp_activity_person_list.mutable_get(i0);
}
inline ::idl::qp_activity_person_t* mcp_get_qp_activity_person_result_params::m_qp_activity_person_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_qp_activity_person_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_qp_activity_person_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_qp_activity_person_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_qp_activity_person_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_qp_activity_person_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_qp_activity_person_response* mcp_get_qp_activity_person_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_qp_activity_person_response* tmp=(mcp_get_qp_activity_person_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_qp_activity_person_response(pool);
return tmp;
}
inline void mcp_get_qp_activity_person_response::destroy(mcp_get_qp_activity_person_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_qp_activity_person_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_qp_activity_person_response::mcp_get_qp_activity_person_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_qp_activity_person_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_qp_activity_person_response::mcp_get_qp_activity_person_response(const mcp_get_qp_activity_person_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_qp_activity_person_result_params::create(_pool);
assign(v);
}
inline mcp_get_qp_activity_person_response::~mcp_get_qp_activity_person_response(){
if(_m_result_params){
::idl::mcp_get_qp_activity_person_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_qp_activity_person_response& mcp_get_qp_activity_person_response::operator=(const mcp_get_qp_activity_person_response& v){
assign(v);
return *this;
}
inline void mcp_get_qp_activity_person_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_qp_activity_person_response::check() const{
// @@mcp_get_qp_activity_person_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_qp_activity_person_result_params& item=const_cast< ::idl::mcp_get_qp_activity_person_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_qp_activity_person_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_qp_activity_person_response& mcp_get_qp_activity_person_response::assign(const mcp_get_qp_activity_person_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_qp_activity_person_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_qp_activity_person_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_qp_activity_person_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_qp_activity_person_result_params& mcp_get_qp_activity_person_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_qp_activity_person_result_params* mcp_get_qp_activity_person_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_qp_activity_person_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_qp_activity_person_result_params* mcp_get_qp_activity_person_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_qp_activity_person_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_qp_activity_person_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_qp_activity_person_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_qp_activity_person_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_qp_activity_person_response::unknown(){
return _unknown;
}
inline size_t mcp_get_qp_activity_person_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_person_award_list_params* mcp_get_person_award_list_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_person_award_list_params* tmp=(mcp_get_person_award_list_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_person_award_list_params(pool);
return tmp;
}
inline void mcp_get_person_award_list_params::destroy(mcp_get_person_award_list_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_person_award_list_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_person_award_list_params::mcp_get_person_award_list_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_person_award_list_params::mcp_get_person_award_list_params(const mcp_get_person_award_list_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_page(0)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_person_award_list_params::~mcp_get_person_award_list_params(){
}
inline mcp_get_person_award_list_params& mcp_get_person_award_list_params::operator=(const mcp_get_person_award_list_params& v){
assign(v);
return *this;
}
inline void mcp_get_person_award_list_params::clear(){
// _m_page=0;
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_person_award_list_params::check() const{
// @@uint32_t page=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_person_award_list_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_person_award_list_params& mcp_get_person_award_list_params::assign(const mcp_get_person_award_list_params& v){
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_person_award_list_params::has_page() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_person_award_list_params::page() const{
return _m_page;
}
inline mcp_get_person_award_list_params& mcp_get_person_award_list_params::set_page(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_person_award_list_params::clear_page(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_page=0;
}
inline bool mcp_get_person_award_list_params::has_page_size() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_person_award_list_params::page_size() const{
return _m_page_size;
}
inline mcp_get_person_award_list_params& mcp_get_person_award_list_params::set_page_size(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_person_award_list_params::clear_page_size(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_person_award_list_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_person_award_list_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_person_award_list_params::unknown(){
return _unknown;
}
inline size_t mcp_get_person_award_list_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_person_award_list_result_params* mcp_get_person_award_list_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_person_award_list_result_params* tmp=(mcp_get_person_award_list_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_person_award_list_result_params(pool);
return tmp;
}
inline void mcp_get_person_award_list_result_params::destroy(mcp_get_person_award_list_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_person_award_list_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_person_award_list_result_params::mcp_get_person_award_list_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_res(0)
,_m_count(0)
,_m_person_award_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_person_award_list_result_params::mcp_get_person_award_list_result_params(const mcp_get_person_award_list_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_res(0)
,_m_count(0)
,_m_person_award_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_person_award_list_result_params::~mcp_get_person_award_list_result_params(){
}
inline mcp_get_person_award_list_result_params& mcp_get_person_award_list_result_params::operator=(const mcp_get_person_award_list_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_person_award_list_result_params::clear(){
// _m_res=0;
// _m_count=0;
_m_person_award_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_person_award_list_result_params::check() const{
// @@int32_t res=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "res" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_res;

}
// @@int32_t count=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@person_award_info_t person_award_list=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "person_award_list" << "' not found";
}
{
// level 0 begin
typeof(_m_person_award_list)& lr0=(_m_person_award_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::person_award_info_t& item=const_cast< ::idl::person_award_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_person_award_list_result_params::detach(){
_m_person_award_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_person_award_list_result_params& mcp_get_person_award_list_result_params::assign(const mcp_get_person_award_list_result_params& v){
_m_res=v._m_res;
_m_count=v._m_count;
_m_person_award_list=v._m_person_award_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_person_award_list_result_params::has_res() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_person_award_list_result_params::res() const{
return _m_res;
}
inline mcp_get_person_award_list_result_params& mcp_get_person_award_list_result_params::set_res(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_res=v;
return *this;
}
inline void mcp_get_person_award_list_result_params::clear_res(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_res=0;
}
inline bool mcp_get_person_award_list_result_params::has_count() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline int32_t mcp_get_person_award_list_result_params::count() const{
return _m_count;
}
inline mcp_get_person_award_list_result_params& mcp_get_person_award_list_result_params::set_count(int32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_person_award_list_result_params::clear_count(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_count=0;
}
inline bool mcp_get_person_award_list_result_params::has_person_award_list() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::person_award_info_t >& mcp_get_person_award_list_result_params::person_award_list() const{
 return _m_person_award_list;
}
inline void mcp_get_person_award_list_result_params::clear_person_award_list(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_person_award_list.clear();
}
inline ::idl::vector< ::idl::person_award_info_t >* mcp_get_person_award_list_result_params::mutable_person_award_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_person_award_list);
}
inline ::idl::vector< ::idl::person_award_info_t >* mcp_get_person_award_list_result_params::m_person_award_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_person_award_list);
}
inline size_t mcp_get_person_award_list_result_params::person_award_list_size() const{
/*  */ return _m_person_award_list.size();
}
inline const ::idl::person_award_info_t& mcp_get_person_award_list_result_params::person_award_list(size_t i0) const{
 return _m_person_award_list.get(i0);
}
inline ::idl::person_award_info_t* mcp_get_person_award_list_result_params::mutable_person_award_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_person_award_list.mutable_get(i0);
}
inline ::idl::person_award_info_t* mcp_get_person_award_list_result_params::m_person_award_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_person_award_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_person_award_list_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_person_award_list_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_person_award_list_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_person_award_list_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_person_award_list_response* mcp_get_person_award_list_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_person_award_list_response* tmp=(mcp_get_person_award_list_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_person_award_list_response(pool);
return tmp;
}
inline void mcp_get_person_award_list_response::destroy(mcp_get_person_award_list_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_person_award_list_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_person_award_list_response::mcp_get_person_award_list_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_person_award_list_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_person_award_list_response::mcp_get_person_award_list_response(const mcp_get_person_award_list_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_person_award_list_result_params::create(_pool);
assign(v);
}
inline mcp_get_person_award_list_response::~mcp_get_person_award_list_response(){
if(_m_result_params){
::idl::mcp_get_person_award_list_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_person_award_list_response& mcp_get_person_award_list_response::operator=(const mcp_get_person_award_list_response& v){
assign(v);
return *this;
}
inline void mcp_get_person_award_list_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_person_award_list_response::check() const{
// @@mcp_get_person_award_list_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_person_award_list_result_params& item=const_cast< ::idl::mcp_get_person_award_list_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_person_award_list_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_person_award_list_response& mcp_get_person_award_list_response::assign(const mcp_get_person_award_list_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_person_award_list_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_person_award_list_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_person_award_list_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_person_award_list_result_params& mcp_get_person_award_list_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_person_award_list_result_params* mcp_get_person_award_list_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_person_award_list_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_person_award_list_result_params* mcp_get_person_award_list_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_person_award_list_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_person_award_list_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_person_award_list_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_person_award_list_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_person_award_list_response::unknown(){
return _unknown;
}
inline size_t mcp_get_person_award_list_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_person_all_awards_params* mcp_get_person_all_awards_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_person_all_awards_params* tmp=(mcp_get_person_all_awards_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_person_all_awards_params(pool);
return tmp;
}
inline void mcp_get_person_all_awards_params::destroy(mcp_get_person_all_awards_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_person_all_awards_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_person_all_awards_params::mcp_get_person_all_awards_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_page(0)
,_m_page_size(0)
,_m_user_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_person_all_awards_params::mcp_get_person_all_awards_params(const mcp_get_person_all_awards_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_page(0)
,_m_page_size(0)
,_m_user_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_person_all_awards_params::~mcp_get_person_all_awards_params(){
}
inline mcp_get_person_all_awards_params& mcp_get_person_all_awards_params::operator=(const mcp_get_person_all_awards_params& v){
assign(v);
return *this;
}
inline void mcp_get_person_all_awards_params::clear(){
// _m_page=0;
// _m_page_size=0;
_m_user_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_person_all_awards_params::check() const{
// @@uint32_t page=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page;

}
// @@uint32_t page_size=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}
// @@string user_id=in();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_person_all_awards_params::detach(){
_m_user_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_person_all_awards_params& mcp_get_person_all_awards_params::assign(const mcp_get_person_all_awards_params& v){
_m_page=v._m_page;
_m_page_size=v._m_page_size;
_m_user_id=v._m_user_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_person_all_awards_params::has_page() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline uint32_t mcp_get_person_all_awards_params::page() const{
return _m_page;
}
inline mcp_get_person_all_awards_params& mcp_get_person_all_awards_params::set_page(uint32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_page=v;
return *this;
}
inline void mcp_get_person_all_awards_params::clear_page(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_page=0;
}
inline bool mcp_get_person_all_awards_params::has_page_size() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_person_all_awards_params::page_size() const{
return _m_page_size;
}
inline mcp_get_person_all_awards_params& mcp_get_person_all_awards_params::set_page_size(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_person_all_awards_params::clear_page_size(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page_size=0;
}
inline bool mcp_get_person_all_awards_params::has_user_id() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const char* mcp_get_person_all_awards_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_get_person_all_awards_params& mcp_get_person_all_awards_params::set_user_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_person_all_awards_params& mcp_get_person_all_awards_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_person_all_awards_params::clear_user_id(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_user_id.clear();
}
inline ::idl::Unknown* mcp_get_person_all_awards_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_person_all_awards_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_person_all_awards_params::unknown(){
return _unknown;
}
inline size_t mcp_get_person_all_awards_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_person_all_awards_result_params* mcp_get_person_all_awards_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_person_all_awards_result_params* tmp=(mcp_get_person_all_awards_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_person_all_awards_result_params(pool);
return tmp;
}
inline void mcp_get_person_all_awards_result_params::destroy(mcp_get_person_all_awards_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_person_all_awards_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_person_all_awards_result_params::mcp_get_person_all_awards_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_res(0)
,_m_person_all_award_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_person_all_awards_result_params::mcp_get_person_all_awards_result_params(const mcp_get_person_all_awards_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_res(0)
,_m_person_all_award_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_person_all_awards_result_params::~mcp_get_person_all_awards_result_params(){
}
inline mcp_get_person_all_awards_result_params& mcp_get_person_all_awards_result_params::operator=(const mcp_get_person_all_awards_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_person_all_awards_result_params::clear(){
// _m_count=0;
// _m_res=0;
_m_person_all_award_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_person_all_awards_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@int32_t res=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "res" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_res;

}
// @@person_all_award_info_t person_all_award_list=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "person_all_award_list" << "' not found";
}
{
// level 0 begin
typeof(_m_person_all_award_list)& lr0=(_m_person_all_award_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::person_all_award_info_t& item=const_cast< ::idl::person_all_award_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_person_all_awards_result_params::detach(){
_m_person_all_award_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_person_all_awards_result_params& mcp_get_person_all_awards_result_params::assign(const mcp_get_person_all_awards_result_params& v){
_m_count=v._m_count;
_m_res=v._m_res;
_m_person_all_award_list=v._m_person_all_award_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_person_all_awards_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_person_all_awards_result_params::count() const{
return _m_count;
}
inline mcp_get_person_all_awards_result_params& mcp_get_person_all_awards_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_person_all_awards_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_person_all_awards_result_params::has_res() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline int32_t mcp_get_person_all_awards_result_params::res() const{
return _m_res;
}
inline mcp_get_person_all_awards_result_params& mcp_get_person_all_awards_result_params::set_res(int32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_res=v;
return *this;
}
inline void mcp_get_person_all_awards_result_params::clear_res(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_res=0;
}
inline bool mcp_get_person_all_awards_result_params::has_person_all_award_list() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::person_all_award_info_t >& mcp_get_person_all_awards_result_params::person_all_award_list() const{
 return _m_person_all_award_list;
}
inline void mcp_get_person_all_awards_result_params::clear_person_all_award_list(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_person_all_award_list.clear();
}
inline ::idl::vector< ::idl::person_all_award_info_t >* mcp_get_person_all_awards_result_params::mutable_person_all_award_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_person_all_award_list);
}
inline ::idl::vector< ::idl::person_all_award_info_t >* mcp_get_person_all_awards_result_params::m_person_all_award_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_person_all_award_list);
}
inline size_t mcp_get_person_all_awards_result_params::person_all_award_list_size() const{
/*  */ return _m_person_all_award_list.size();
}
inline const ::idl::person_all_award_info_t& mcp_get_person_all_awards_result_params::person_all_award_list(size_t i0) const{
 return _m_person_all_award_list.get(i0);
}
inline ::idl::person_all_award_info_t* mcp_get_person_all_awards_result_params::mutable_person_all_award_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_person_all_award_list.mutable_get(i0);
}
inline ::idl::person_all_award_info_t* mcp_get_person_all_awards_result_params::m_person_all_award_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_person_all_award_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_person_all_awards_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_person_all_awards_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_person_all_awards_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_person_all_awards_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_person_all_awards_response* mcp_get_person_all_awards_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_person_all_awards_response* tmp=(mcp_get_person_all_awards_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_person_all_awards_response(pool);
return tmp;
}
inline void mcp_get_person_all_awards_response::destroy(mcp_get_person_all_awards_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_person_all_awards_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_person_all_awards_response::mcp_get_person_all_awards_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_person_all_awards_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_person_all_awards_response::mcp_get_person_all_awards_response(const mcp_get_person_all_awards_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_person_all_awards_result_params::create(_pool);
assign(v);
}
inline mcp_get_person_all_awards_response::~mcp_get_person_all_awards_response(){
if(_m_result_params){
::idl::mcp_get_person_all_awards_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_person_all_awards_response& mcp_get_person_all_awards_response::operator=(const mcp_get_person_all_awards_response& v){
assign(v);
return *this;
}
inline void mcp_get_person_all_awards_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_person_all_awards_response::check() const{
// @@mcp_get_person_all_awards_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_person_all_awards_result_params& item=const_cast< ::idl::mcp_get_person_all_awards_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_person_all_awards_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_person_all_awards_response& mcp_get_person_all_awards_response::assign(const mcp_get_person_all_awards_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_person_all_awards_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_person_all_awards_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_person_all_awards_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_person_all_awards_result_params& mcp_get_person_all_awards_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_person_all_awards_result_params* mcp_get_person_all_awards_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_person_all_awards_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_person_all_awards_result_params* mcp_get_person_all_awards_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_person_all_awards_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_person_all_awards_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_person_all_awards_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_person_all_awards_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_person_all_awards_response::unknown(){
return _unknown;
}
inline size_t mcp_get_person_all_awards_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_person_award_params* mcp_get_person_award_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_person_award_params* tmp=(mcp_get_person_award_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_person_award_params(pool);
return tmp;
}
inline void mcp_get_person_award_params::destroy(mcp_get_person_award_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_person_award_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_person_award_params::mcp_get_person_award_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_user_id(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_person_award_params::mcp_get_person_award_params(const mcp_get_person_award_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_user_id(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_person_award_params::~mcp_get_person_award_params(){
}
inline mcp_get_person_award_params& mcp_get_person_award_params::operator=(const mcp_get_person_award_params& v){
assign(v);
return *this;
}
inline void mcp_get_person_award_params::clear(){
_m_user_id.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_person_award_params::check() const{
// @@string user_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}

::idl::McpackBean::check();
}
inline void mcp_get_person_award_params::detach(){
_m_user_id.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_person_award_params& mcp_get_person_award_params::assign(const mcp_get_person_award_params& v){
_m_user_id=v._m_user_id;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_person_award_params::has_user_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_person_award_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_get_person_award_params& mcp_get_person_award_params::set_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_person_award_params& mcp_get_person_award_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_person_award_params::clear_user_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_user_id.clear();
}
inline ::idl::Unknown* mcp_get_person_award_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_person_award_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_person_award_params::unknown(){
return _unknown;
}
inline size_t mcp_get_person_award_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_person_award_result_params* mcp_get_person_award_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_person_award_result_params* tmp=(mcp_get_person_award_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_person_award_result_params(pool);
return tmp;
}
inline void mcp_get_person_award_result_params::destroy(mcp_get_person_award_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_person_award_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_person_award_result_params::mcp_get_person_award_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_rank(0)
,_m_count(0)
,_m_res(0)
,_m_person_award_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_person_award_result_params::mcp_get_person_award_result_params(const mcp_get_person_award_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_rank(0)
,_m_count(0)
,_m_res(0)
,_m_person_award_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_person_award_result_params::~mcp_get_person_award_result_params(){
}
inline mcp_get_person_award_result_params& mcp_get_person_award_result_params::operator=(const mcp_get_person_award_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_person_award_result_params::clear(){
// _m_rank=0;
// _m_count=0;
// _m_res=0;
_m_person_award_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_person_award_result_params::check() const{
// @@int32_t rank=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "rank" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_rank;

}
// @@int32_t count=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@int32_t res=out();
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "res" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_res;

}
// @@person_award_info_t person_award_list=out(),array(0);
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "person_award_list" << "' not found";
}
{
// level 0 begin
typeof(_m_person_award_list)& lr0=(_m_person_award_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::person_award_info_t& item=const_cast< ::idl::person_award_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_person_award_result_params::detach(){
_m_person_award_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_person_award_result_params& mcp_get_person_award_result_params::assign(const mcp_get_person_award_result_params& v){
_m_rank=v._m_rank;
_m_count=v._m_count;
_m_res=v._m_res;
_m_person_award_list=v._m_person_award_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_person_award_result_params::has_rank() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_person_award_result_params::rank() const{
return _m_rank;
}
inline mcp_get_person_award_result_params& mcp_get_person_award_result_params::set_rank(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_rank=v;
return *this;
}
inline void mcp_get_person_award_result_params::clear_rank(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_rank=0;
}
inline bool mcp_get_person_award_result_params::has_count() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline int32_t mcp_get_person_award_result_params::count() const{
return _m_count;
}
inline mcp_get_person_award_result_params& mcp_get_person_award_result_params::set_count(int32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_person_award_result_params::clear_count(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_count=0;
}
inline bool mcp_get_person_award_result_params::has_res() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline int32_t mcp_get_person_award_result_params::res() const{
return _m_res;
}
inline mcp_get_person_award_result_params& mcp_get_person_award_result_params::set_res(int32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 _m_res=v;
return *this;
}
inline void mcp_get_person_award_result_params::clear_res(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_res=0;
}
inline bool mcp_get_person_award_result_params::has_person_award_list() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const ::idl::vector< ::idl::person_award_info_t >& mcp_get_person_award_result_params::person_award_list() const{
 return _m_person_award_list;
}
inline void mcp_get_person_award_result_params::clear_person_award_list(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_person_award_list.clear();
}
inline ::idl::vector< ::idl::person_award_info_t >* mcp_get_person_award_result_params::mutable_person_award_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_person_award_list);
}
inline ::idl::vector< ::idl::person_award_info_t >* mcp_get_person_award_result_params::m_person_award_list(){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return &(_m_person_award_list);
}
inline size_t mcp_get_person_award_result_params::person_award_list_size() const{
/*  */ return _m_person_award_list.size();
}
inline const ::idl::person_award_info_t& mcp_get_person_award_result_params::person_award_list(size_t i0) const{
 return _m_person_award_list.get(i0);
}
inline ::idl::person_award_info_t* mcp_get_person_award_result_params::mutable_person_award_list(size_t i0){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return _m_person_award_list.mutable_get(i0);
}
inline ::idl::person_award_info_t* mcp_get_person_award_result_params::m_person_award_list(size_t i0){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 return _m_person_award_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_person_award_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_person_award_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_person_award_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_person_award_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_person_award_response* mcp_get_person_award_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_person_award_response* tmp=(mcp_get_person_award_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_person_award_response(pool);
return tmp;
}
inline void mcp_get_person_award_response::destroy(mcp_get_person_award_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_person_award_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_person_award_response::mcp_get_person_award_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_person_award_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_person_award_response::mcp_get_person_award_response(const mcp_get_person_award_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_person_award_result_params::create(_pool);
assign(v);
}
inline mcp_get_person_award_response::~mcp_get_person_award_response(){
if(_m_result_params){
::idl::mcp_get_person_award_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_person_award_response& mcp_get_person_award_response::operator=(const mcp_get_person_award_response& v){
assign(v);
return *this;
}
inline void mcp_get_person_award_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_person_award_response::check() const{
// @@mcp_get_person_award_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_person_award_result_params& item=const_cast< ::idl::mcp_get_person_award_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_person_award_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_person_award_response& mcp_get_person_award_response::assign(const mcp_get_person_award_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_person_award_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_person_award_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_person_award_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_person_award_result_params& mcp_get_person_award_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_person_award_result_params* mcp_get_person_award_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_person_award_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_person_award_result_params* mcp_get_person_award_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_person_award_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_person_award_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_person_award_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_person_award_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_person_award_response::unknown(){
return _unknown;
}
inline size_t mcp_get_person_award_response::unknown_size() const{
return _unknown.size();
}
inline mcp_get_award_list_params* mcp_get_award_list_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_award_list_params* tmp=(mcp_get_award_list_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_award_list_params(pool);
return tmp;
}
inline void mcp_get_award_list_params::destroy(mcp_get_award_list_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_award_list_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_award_list_params::mcp_get_award_list_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_award_channel(_pool)
,_m_page_size(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_award_list_params::mcp_get_award_list_params(const mcp_get_award_list_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_award_channel(_pool)
,_m_page_size(0)
,_unknown(_pool){
assign(v);
}
inline mcp_get_award_list_params::~mcp_get_award_list_params(){
}
inline mcp_get_award_list_params& mcp_get_award_list_params::operator=(const mcp_get_award_list_params& v){
assign(v);
return *this;
}
inline void mcp_get_award_list_params::clear(){
_m_award_channel.clear();
// _m_page_size=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_award_list_params::check() const{
// @@string award_channel=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "award_channel" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_award_channel.get();

}
// @@uint32_t page_size=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "page_size" << "' not found";
}
{
__attribute__((unused)) uint32_t item=_m_page_size;

}

::idl::McpackBean::check();
}
inline void mcp_get_award_list_params::detach(){
_m_award_channel.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_award_list_params& mcp_get_award_list_params::assign(const mcp_get_award_list_params& v){
_m_award_channel=v._m_award_channel;
_m_page_size=v._m_page_size;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_award_list_params::has_award_channel() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_get_award_list_params::award_channel(unsigned int* size) const{
return _m_award_channel.get(size);
}
inline mcp_get_award_list_params& mcp_get_award_list_params::set_award_channel(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_award_channel.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_get_award_list_params& mcp_get_award_list_params::set_ptr_award_channel(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_award_channel.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_get_award_list_params::clear_award_channel(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_award_channel.clear();
}
inline bool mcp_get_award_list_params::has_page_size() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline uint32_t mcp_get_award_list_params::page_size() const{
return _m_page_size;
}
inline mcp_get_award_list_params& mcp_get_award_list_params::set_page_size(uint32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_page_size=v;
return *this;
}
inline void mcp_get_award_list_params::clear_page_size(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_page_size=0;
}
inline ::idl::Unknown* mcp_get_award_list_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_award_list_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_award_list_params::unknown(){
return _unknown;
}
inline size_t mcp_get_award_list_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_award_list_result_params* mcp_get_award_list_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_award_list_result_params* tmp=(mcp_get_award_list_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_award_list_result_params(pool);
return tmp;
}
inline void mcp_get_award_list_result_params::destroy(mcp_get_award_list_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_award_list_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_award_list_result_params::mcp_get_award_list_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_count(0)
,_m_res(0)
,_m_award_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_award_list_result_params::mcp_get_award_list_result_params(const mcp_get_award_list_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_count(0)
,_m_res(0)
,_m_award_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_get_award_list_result_params::~mcp_get_award_list_result_params(){
}
inline mcp_get_award_list_result_params& mcp_get_award_list_result_params::operator=(const mcp_get_award_list_result_params& v){
assign(v);
return *this;
}
inline void mcp_get_award_list_result_params::clear(){
// _m_count=0;
// _m_res=0;
_m_award_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_award_list_result_params::check() const{
// @@int32_t count=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "count" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_count;

}
// @@int32_t res=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "res" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_res;

}
// @@award_info_t award_list=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "award_list" << "' not found";
}
{
// level 0 begin
typeof(_m_award_list)& lr0=(_m_award_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::award_info_t& item=const_cast< ::idl::award_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_get_award_list_result_params::detach(){
_m_award_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_award_list_result_params& mcp_get_award_list_result_params::assign(const mcp_get_award_list_result_params& v){
_m_count=v._m_count;
_m_res=v._m_res;
_m_award_list=v._m_award_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_award_list_result_params::has_count() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_get_award_list_result_params::count() const{
return _m_count;
}
inline mcp_get_award_list_result_params& mcp_get_award_list_result_params::set_count(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_count=v;
return *this;
}
inline void mcp_get_award_list_result_params::clear_count(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_count=0;
}
inline bool mcp_get_award_list_result_params::has_res() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline int32_t mcp_get_award_list_result_params::res() const{
return _m_res;
}
inline mcp_get_award_list_result_params& mcp_get_award_list_result_params::set_res(int32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_res=v;
return *this;
}
inline void mcp_get_award_list_result_params::clear_res(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_res=0;
}
inline bool mcp_get_award_list_result_params::has_award_list() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::award_info_t >& mcp_get_award_list_result_params::award_list() const{
 return _m_award_list;
}
inline void mcp_get_award_list_result_params::clear_award_list(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_award_list.clear();
}
inline ::idl::vector< ::idl::award_info_t >* mcp_get_award_list_result_params::mutable_award_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_award_list);
}
inline ::idl::vector< ::idl::award_info_t >* mcp_get_award_list_result_params::m_award_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_award_list);
}
inline size_t mcp_get_award_list_result_params::award_list_size() const{
/*  */ return _m_award_list.size();
}
inline const ::idl::award_info_t& mcp_get_award_list_result_params::award_list(size_t i0) const{
 return _m_award_list.get(i0);
}
inline ::idl::award_info_t* mcp_get_award_list_result_params::mutable_award_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_award_list.mutable_get(i0);
}
inline ::idl::award_info_t* mcp_get_award_list_result_params::m_award_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_award_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_get_award_list_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_award_list_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_award_list_result_params::unknown(){
return _unknown;
}
inline size_t mcp_get_award_list_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_get_award_list_response* mcp_get_award_list_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_get_award_list_response* tmp=(mcp_get_award_list_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_get_award_list_response(pool);
return tmp;
}
inline void mcp_get_award_list_response::destroy(mcp_get_award_list_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_get_award_list_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_get_award_list_response::mcp_get_award_list_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_award_list_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_get_award_list_response::mcp_get_award_list_response(const mcp_get_award_list_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_get_award_list_result_params::create(_pool);
assign(v);
}
inline mcp_get_award_list_response::~mcp_get_award_list_response(){
if(_m_result_params){
::idl::mcp_get_award_list_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_get_award_list_response& mcp_get_award_list_response::operator=(const mcp_get_award_list_response& v){
assign(v);
return *this;
}
inline void mcp_get_award_list_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_get_award_list_response::check() const{
// @@mcp_get_award_list_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_get_award_list_result_params& item=const_cast< ::idl::mcp_get_award_list_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_get_award_list_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_get_award_list_response& mcp_get_award_list_response::assign(const mcp_get_award_list_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_get_award_list_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_get_award_list_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_get_award_list_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_get_award_list_result_params& mcp_get_award_list_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_get_award_list_result_params* mcp_get_award_list_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_award_list_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_get_award_list_result_params* mcp_get_award_list_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_get_award_list_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_get_award_list_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_get_award_list_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_get_award_list_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_get_award_list_response::unknown(){
return _unknown;
}
inline size_t mcp_get_award_list_response::unknown_size() const{
return _unknown.size();
}
inline mcp_grab_award_params* mcp_grab_award_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_grab_award_params* tmp=(mcp_grab_award_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_grab_award_params(pool);
return tmp;
}
inline void mcp_grab_award_params::destroy(mcp_grab_award_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_grab_award_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_grab_award_params::mcp_grab_award_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_user_id(_pool)
,_m_award_channel(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_grab_award_params::mcp_grab_award_params(const mcp_grab_award_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_user_id(_pool)
,_m_award_channel(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_grab_award_params::~mcp_grab_award_params(){
}
inline mcp_grab_award_params& mcp_grab_award_params::operator=(const mcp_grab_award_params& v){
assign(v);
return *this;
}
inline void mcp_grab_award_params::clear(){
_m_user_id.clear();
_m_award_channel.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_grab_award_params::check() const{
// @@string user_id=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}
// @@string award_channel=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "award_channel" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_award_channel.get();

}

::idl::McpackBean::check();
}
inline void mcp_grab_award_params::detach(){
_m_user_id.detach();
_m_award_channel.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_grab_award_params& mcp_grab_award_params::assign(const mcp_grab_award_params& v){
_m_user_id=v._m_user_id;
_m_award_channel=v._m_award_channel;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_grab_award_params::has_user_id() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* mcp_grab_award_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_grab_award_params& mcp_grab_award_params::set_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_grab_award_params& mcp_grab_award_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_grab_award_params::clear_user_id(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_user_id.clear();
}
inline bool mcp_grab_award_params::has_award_channel() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_grab_award_params::award_channel(unsigned int* size) const{
return _m_award_channel.get(size);
}
inline mcp_grab_award_params& mcp_grab_award_params::set_award_channel(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_award_channel.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_grab_award_params& mcp_grab_award_params::set_ptr_award_channel(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_award_channel.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_grab_award_params::clear_award_channel(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_award_channel.clear();
}
inline ::idl::Unknown* mcp_grab_award_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_grab_award_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_grab_award_params::unknown(){
return _unknown;
}
inline size_t mcp_grab_award_params::unknown_size() const{
return _unknown.size();
}
inline mcp_grab_award_result_params* mcp_grab_award_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_grab_award_result_params* tmp=(mcp_grab_award_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_grab_award_result_params(pool);
return tmp;
}
inline void mcp_grab_award_result_params::destroy(mcp_grab_award_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_grab_award_result_params();
pool->free(v,sizeof(*v));
}
}
inline mcp_grab_award_result_params::mcp_grab_award_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_res(0)
,_m_user_id(_pool)
,_m_award_list(_pool)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline mcp_grab_award_result_params::mcp_grab_award_result_params(const mcp_grab_award_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_res(0)
,_m_user_id(_pool)
,_m_award_list(_pool)
,_unknown(_pool){
assign(v);
}
inline mcp_grab_award_result_params::~mcp_grab_award_result_params(){
}
inline mcp_grab_award_result_params& mcp_grab_award_result_params::operator=(const mcp_grab_award_result_params& v){
assign(v);
return *this;
}
inline void mcp_grab_award_result_params::clear(){
// _m_res=0;
_m_user_id.clear();
_m_award_list.clear();
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_grab_award_result_params::check() const{
// @@int32_t res=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "res" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_res;

}
// @@string user_id=out();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "user_id" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_user_id.get();

}
// @@award_info_t award_list=out(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "award_list" << "' not found";
}
{
// level 0 begin
typeof(_m_award_list)& lr0=(_m_award_list);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
::idl::award_info_t& item=const_cast< ::idl::award_info_t& >(lr0.GetWithoutCheck(i0));
item.check();

}

}

::idl::McpackBean::check();
}
inline void mcp_grab_award_result_params::detach(){
_m_user_id.detach();
_m_award_list.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_grab_award_result_params& mcp_grab_award_result_params::assign(const mcp_grab_award_result_params& v){
_m_res=v._m_res;
_m_user_id=v._m_user_id;
_m_award_list=v._m_award_list;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_grab_award_result_params::has_res() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t mcp_grab_award_result_params::res() const{
return _m_res;
}
inline mcp_grab_award_result_params& mcp_grab_award_result_params::set_res(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_res=v;
return *this;
}
inline void mcp_grab_award_result_params::clear_res(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_res=0;
}
inline bool mcp_grab_award_result_params::has_user_id() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* mcp_grab_award_result_params::user_id(unsigned int* size) const{
return _m_user_id.get(size);
}
inline mcp_grab_award_result_params& mcp_grab_award_result_params::set_user_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_user_id.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline mcp_grab_award_result_params& mcp_grab_award_result_params::set_ptr_user_id(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_user_id.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void mcp_grab_award_result_params::clear_user_id(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_user_id.clear();
}
inline bool mcp_grab_award_result_params::has_award_list() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< ::idl::award_info_t >& mcp_grab_award_result_params::award_list() const{
 return _m_award_list;
}
inline void mcp_grab_award_result_params::clear_award_list(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_award_list.clear();
}
inline ::idl::vector< ::idl::award_info_t >* mcp_grab_award_result_params::mutable_award_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_award_list);
}
inline ::idl::vector< ::idl::award_info_t >* mcp_grab_award_result_params::m_award_list(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_award_list);
}
inline size_t mcp_grab_award_result_params::award_list_size() const{
/*  */ return _m_award_list.size();
}
inline const ::idl::award_info_t& mcp_grab_award_result_params::award_list(size_t i0) const{
 return _m_award_list.get(i0);
}
inline ::idl::award_info_t* mcp_grab_award_result_params::mutable_award_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_award_list.mutable_get(i0);
}
inline ::idl::award_info_t* mcp_grab_award_result_params::m_award_list(size_t i0){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return _m_award_list.mutable_get(i0);
}
inline ::idl::Unknown* mcp_grab_award_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_grab_award_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_grab_award_result_params::unknown(){
return _unknown;
}
inline size_t mcp_grab_award_result_params::unknown_size() const{
return _unknown.size();
}
inline mcp_grab_award_response* mcp_grab_award_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
mcp_grab_award_response* tmp=(mcp_grab_award_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)mcp_grab_award_response(pool);
return tmp;
}
inline void mcp_grab_award_response::destroy(mcp_grab_award_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~mcp_grab_award_response();
pool->free(v,sizeof(*v));
}
}
inline mcp_grab_award_response::mcp_grab_award_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_grab_award_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline mcp_grab_award_response::mcp_grab_award_response(const mcp_grab_award_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::mcp_grab_award_result_params::create(_pool);
assign(v);
}
inline mcp_grab_award_response::~mcp_grab_award_response(){
if(_m_result_params){
::idl::mcp_grab_award_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline mcp_grab_award_response& mcp_grab_award_response::operator=(const mcp_grab_award_response& v){
assign(v);
return *this;
}
inline void mcp_grab_award_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void mcp_grab_award_response::check() const{
// @@mcp_grab_award_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::mcp_grab_award_result_params& item=const_cast< ::idl::mcp_grab_award_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void mcp_grab_award_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline mcp_grab_award_response& mcp_grab_award_response::assign(const mcp_grab_award_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::mcp_grab_award_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::mcp_grab_award_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool mcp_grab_award_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::mcp_grab_award_result_params& mcp_grab_award_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::mcp_grab_award_result_params* mcp_grab_award_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_grab_award_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::mcp_grab_award_result_params* mcp_grab_award_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::mcp_grab_award_result_params::create(_pool);
}
return _m_result_params;
}
inline void mcp_grab_award_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* mcp_grab_award_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& mcp_grab_award_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& mcp_grab_award_response::unknown(){
return _unknown;
}
inline size_t mcp_grab_award_response::unknown_size() const{
return _unknown.size();
}
inline Notify_addSystemNotify_params* Notify_addSystemNotify_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
Notify_addSystemNotify_params* tmp=(Notify_addSystemNotify_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)Notify_addSystemNotify_params(pool);
return tmp;
}
inline void Notify_addSystemNotify_params::destroy(Notify_addSystemNotify_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~Notify_addSystemNotify_params();
pool->free(v,sizeof(*v));
}
}
inline Notify_addSystemNotify_params::Notify_addSystemNotify_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_sourceId(_pool)
,_m_titleId(_pool)
,_m_targetUid(_pool)
,_m_messageContent(_pool)
,_m_bussiness(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline Notify_addSystemNotify_params::Notify_addSystemNotify_params(const Notify_addSystemNotify_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_sourceId(_pool)
,_m_titleId(_pool)
,_m_targetUid(_pool)
,_m_messageContent(_pool)
,_m_bussiness(0)
,_unknown(_pool){
assign(v);
}
inline Notify_addSystemNotify_params::~Notify_addSystemNotify_params(){
}
inline Notify_addSystemNotify_params& Notify_addSystemNotify_params::operator=(const Notify_addSystemNotify_params& v){
assign(v);
return *this;
}
inline void Notify_addSystemNotify_params::clear(){
_m_sourceId.clear();
_m_titleId.clear();
_m_targetUid.clear();
_m_messageContent.clear();
// _m_bussiness=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void Notify_addSystemNotify_params::check() const{
// @@string sourceId=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "sourceId" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_sourceId.get();

}
// @@string titleId=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "titleId" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_titleId.get();

}
// @@int32_t targetUid=in(),array(0);
if(!(_flag[2 >> 3] & (1 << (2 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "targetUid" << "' not found";
}
{
// level 0 begin
typeof(_m_targetUid)& lr0=(_m_targetUid);
__attribute__((unused)) size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
__attribute__((unused)) int32_t item=lr0.GetWithoutCheck(i0);

}

}
// @@string messageContent=in();
if(!(_flag[3 >> 3] & (1 << (3 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "messageContent" << "' not found";
}
{
__attribute__((unused)) const char* item=_m_messageContent.get();

}
// @@int32_t bussiness=in();
if(!(_flag[4 >> 3] & (1 << (4 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "bussiness" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_bussiness;

}

::idl::McpackBean::check();
}
inline void Notify_addSystemNotify_params::detach(){
_m_sourceId.detach();
_m_titleId.detach();
_m_targetUid.detach();
_m_messageContent.detach();
_unknown.clear();

::idl::McpackBean::detach();
}
inline Notify_addSystemNotify_params& Notify_addSystemNotify_params::assign(const Notify_addSystemNotify_params& v){
_m_sourceId=v._m_sourceId;
_m_titleId=v._m_titleId;
_m_targetUid=v._m_targetUid;
_m_messageContent=v._m_messageContent;
_m_bussiness=v._m_bussiness;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool Notify_addSystemNotify_params::has_sourceId() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const char* Notify_addSystemNotify_params::sourceId(unsigned int* size) const{
return _m_sourceId.get(size);
}
inline Notify_addSystemNotify_params& Notify_addSystemNotify_params::set_sourceId(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_sourceId.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline Notify_addSystemNotify_params& Notify_addSystemNotify_params::set_ptr_sourceId(const char* s,ssize_t size){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_sourceId.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void Notify_addSystemNotify_params::clear_sourceId(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_sourceId.clear();
}
inline bool Notify_addSystemNotify_params::has_titleId() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline const char* Notify_addSystemNotify_params::titleId(unsigned int* size) const{
return _m_titleId.get(size);
}
inline Notify_addSystemNotify_params& Notify_addSystemNotify_params::set_titleId(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_titleId.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline Notify_addSystemNotify_params& Notify_addSystemNotify_params::set_ptr_titleId(const char* s,ssize_t size){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_titleId.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void Notify_addSystemNotify_params::clear_titleId(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_titleId.clear();
}
inline bool Notify_addSystemNotify_params::has_targetUid() const{
return (_flag[2 >> 3] & (1 << (2 & 0x7)));
}
inline const ::idl::vector< int32_t >& Notify_addSystemNotify_params::targetUid() const{
 return _m_targetUid;
}
inline void Notify_addSystemNotify_params::clear_targetUid(){
_flag[2 >> 3] &= ~(1 << (2 & 0x7));
 _m_targetUid.clear();
}
inline ::idl::vector< int32_t >* Notify_addSystemNotify_params::mutable_targetUid(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_targetUid);
}
inline ::idl::vector< int32_t >* Notify_addSystemNotify_params::m_targetUid(){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 return &(_m_targetUid);
}
inline size_t Notify_addSystemNotify_params::targetUid_size() const{
/*  */ return _m_targetUid.size();
}
inline int32_t Notify_addSystemNotify_params::targetUid(size_t i0) const{
 return _m_targetUid.get(i0);
}
inline Notify_addSystemNotify_params& Notify_addSystemNotify_params::set_targetUid(size_t i0,int32_t v){
_flag[2 >> 3] |= (1 << (2 & 0x7));
 *(_m_targetUid.mutable_get(i0))=v;
return *this;
}
inline bool Notify_addSystemNotify_params::has_messageContent() const{
return (_flag[3 >> 3] & (1 << (3 & 0x7)));
}
inline const char* Notify_addSystemNotify_params::messageContent(unsigned int* size) const{
return _m_messageContent.get(size);
}
inline Notify_addSystemNotify_params& Notify_addSystemNotify_params::set_messageContent(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_messageContent.set(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline Notify_addSystemNotify_params& Notify_addSystemNotify_params::set_ptr_messageContent(const char* s,ssize_t size){
_flag[3 >> 3] |= (1 << (3 & 0x7));
 _m_messageContent.set_ptr(s,(size==-1)?strlen(s):(size_t)size);
return *this;
}
inline void Notify_addSystemNotify_params::clear_messageContent(){
_flag[3 >> 3] &= ~(1 << (3 & 0x7));
 _m_messageContent.clear();
}
inline bool Notify_addSystemNotify_params::has_bussiness() const{
return (_flag[4 >> 3] & (1 << (4 & 0x7)));
}
inline int32_t Notify_addSystemNotify_params::bussiness() const{
return _m_bussiness;
}
inline Notify_addSystemNotify_params& Notify_addSystemNotify_params::set_bussiness(int32_t v){
_flag[4 >> 3] |= (1 << (4 & 0x7));
 _m_bussiness=v;
return *this;
}
inline void Notify_addSystemNotify_params::clear_bussiness(){
_flag[4 >> 3] &= ~(1 << (4 & 0x7));
 _m_bussiness=0;
}
inline ::idl::Unknown* Notify_addSystemNotify_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& Notify_addSystemNotify_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& Notify_addSystemNotify_params::unknown(){
return _unknown;
}
inline size_t Notify_addSystemNotify_params::unknown_size() const{
return _unknown.size();
}
inline Notify_addSystemNotify_result_params* Notify_addSystemNotify_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
Notify_addSystemNotify_result_params* tmp=(Notify_addSystemNotify_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)Notify_addSystemNotify_result_params(pool);
return tmp;
}
inline void Notify_addSystemNotify_result_params::destroy(Notify_addSystemNotify_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~Notify_addSystemNotify_result_params();
pool->free(v,sizeof(*v));
}
}
inline Notify_addSystemNotify_result_params::Notify_addSystemNotify_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_resault(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline Notify_addSystemNotify_result_params::Notify_addSystemNotify_result_params(const Notify_addSystemNotify_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_resault(0)
,_unknown(_pool){
assign(v);
}
inline Notify_addSystemNotify_result_params::~Notify_addSystemNotify_result_params(){
}
inline Notify_addSystemNotify_result_params& Notify_addSystemNotify_result_params::operator=(const Notify_addSystemNotify_result_params& v){
assign(v);
return *this;
}
inline void Notify_addSystemNotify_result_params::clear(){
// _m_resault=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void Notify_addSystemNotify_result_params::check() const{
// @@bool resault=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "resault" << "' not found";
}
{
__attribute__((unused)) bool item=_m_resault;

}

::idl::McpackBean::check();
}
inline void Notify_addSystemNotify_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline Notify_addSystemNotify_result_params& Notify_addSystemNotify_result_params::assign(const Notify_addSystemNotify_result_params& v){
_m_resault=v._m_resault;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool Notify_addSystemNotify_result_params::has_resault() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline bool Notify_addSystemNotify_result_params::resault() const{
return _m_resault;
}
inline Notify_addSystemNotify_result_params& Notify_addSystemNotify_result_params::set_resault(bool v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_resault=v;
return *this;
}
inline void Notify_addSystemNotify_result_params::clear_resault(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_resault=0;
}
inline ::idl::Unknown* Notify_addSystemNotify_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& Notify_addSystemNotify_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& Notify_addSystemNotify_result_params::unknown(){
return _unknown;
}
inline size_t Notify_addSystemNotify_result_params::unknown_size() const{
return _unknown.size();
}
inline Notify_addSystemNotify_response* Notify_addSystemNotify_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
Notify_addSystemNotify_response* tmp=(Notify_addSystemNotify_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)Notify_addSystemNotify_response(pool);
return tmp;
}
inline void Notify_addSystemNotify_response::destroy(Notify_addSystemNotify_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~Notify_addSystemNotify_response();
pool->free(v,sizeof(*v));
}
}
inline Notify_addSystemNotify_response::Notify_addSystemNotify_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::Notify_addSystemNotify_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline Notify_addSystemNotify_response::Notify_addSystemNotify_response(const Notify_addSystemNotify_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::Notify_addSystemNotify_result_params::create(_pool);
assign(v);
}
inline Notify_addSystemNotify_response::~Notify_addSystemNotify_response(){
if(_m_result_params){
::idl::Notify_addSystemNotify_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline Notify_addSystemNotify_response& Notify_addSystemNotify_response::operator=(const Notify_addSystemNotify_response& v){
assign(v);
return *this;
}
inline void Notify_addSystemNotify_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void Notify_addSystemNotify_response::check() const{
// @@Notify_addSystemNotify_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::Notify_addSystemNotify_result_params& item=const_cast< ::idl::Notify_addSystemNotify_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void Notify_addSystemNotify_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline Notify_addSystemNotify_response& Notify_addSystemNotify_response::assign(const Notify_addSystemNotify_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::Notify_addSystemNotify_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::Notify_addSystemNotify_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool Notify_addSystemNotify_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::Notify_addSystemNotify_result_params& Notify_addSystemNotify_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::Notify_addSystemNotify_result_params* Notify_addSystemNotify_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::Notify_addSystemNotify_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::Notify_addSystemNotify_result_params* Notify_addSystemNotify_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::Notify_addSystemNotify_result_params::create(_pool);
}
return _m_result_params;
}
inline void Notify_addSystemNotify_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* Notify_addSystemNotify_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& Notify_addSystemNotify_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& Notify_addSystemNotify_response::unknown(){
return _unknown;
}
inline size_t Notify_addSystemNotify_response::unknown_size() const{
return _unknown.size();
}
inline GameHallPoint_addGameHallScore_params* GameHallPoint_addGameHallScore_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
GameHallPoint_addGameHallScore_params* tmp=(GameHallPoint_addGameHallScore_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)GameHallPoint_addGameHallScore_params(pool);
return tmp;
}
inline void GameHallPoint_addGameHallScore_params::destroy(GameHallPoint_addGameHallScore_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~GameHallPoint_addGameHallScore_params();
pool->free(v,sizeof(*v));
}
}
inline GameHallPoint_addGameHallScore_params::GameHallPoint_addGameHallScore_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_userId(0)
,_m_opId(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline GameHallPoint_addGameHallScore_params::GameHallPoint_addGameHallScore_params(const GameHallPoint_addGameHallScore_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_userId(0)
,_m_opId(0)
,_unknown(_pool){
assign(v);
}
inline GameHallPoint_addGameHallScore_params::~GameHallPoint_addGameHallScore_params(){
}
inline GameHallPoint_addGameHallScore_params& GameHallPoint_addGameHallScore_params::operator=(const GameHallPoint_addGameHallScore_params& v){
assign(v);
return *this;
}
inline void GameHallPoint_addGameHallScore_params::clear(){
// _m_userId=0;
// _m_opId=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void GameHallPoint_addGameHallScore_params::check() const{
// @@int32_t userId=in();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "userId" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_userId;

}
// @@int32_t opId=in();
if(!(_flag[1 >> 3] & (1 << (1 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "opId" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_opId;

}

::idl::McpackBean::check();
}
inline void GameHallPoint_addGameHallScore_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline GameHallPoint_addGameHallScore_params& GameHallPoint_addGameHallScore_params::assign(const GameHallPoint_addGameHallScore_params& v){
_m_userId=v._m_userId;
_m_opId=v._m_opId;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool GameHallPoint_addGameHallScore_params::has_userId() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t GameHallPoint_addGameHallScore_params::userId() const{
return _m_userId;
}
inline GameHallPoint_addGameHallScore_params& GameHallPoint_addGameHallScore_params::set_userId(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_userId=v;
return *this;
}
inline void GameHallPoint_addGameHallScore_params::clear_userId(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_userId=0;
}
inline bool GameHallPoint_addGameHallScore_params::has_opId() const{
return (_flag[1 >> 3] & (1 << (1 & 0x7)));
}
inline int32_t GameHallPoint_addGameHallScore_params::opId() const{
return _m_opId;
}
inline GameHallPoint_addGameHallScore_params& GameHallPoint_addGameHallScore_params::set_opId(int32_t v){
_flag[1 >> 3] |= (1 << (1 & 0x7));
 _m_opId=v;
return *this;
}
inline void GameHallPoint_addGameHallScore_params::clear_opId(){
_flag[1 >> 3] &= ~(1 << (1 & 0x7));
 _m_opId=0;
}
inline ::idl::Unknown* GameHallPoint_addGameHallScore_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& GameHallPoint_addGameHallScore_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& GameHallPoint_addGameHallScore_params::unknown(){
return _unknown;
}
inline size_t GameHallPoint_addGameHallScore_params::unknown_size() const{
return _unknown.size();
}
inline GameHallPoint_addGameHallScore_result_params* GameHallPoint_addGameHallScore_result_params::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
GameHallPoint_addGameHallScore_result_params* tmp=(GameHallPoint_addGameHallScore_result_params*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)GameHallPoint_addGameHallScore_result_params(pool);
return tmp;
}
inline void GameHallPoint_addGameHallScore_result_params::destroy(GameHallPoint_addGameHallScore_result_params* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~GameHallPoint_addGameHallScore_result_params();
pool->free(v,sizeof(*v));
}
}
inline GameHallPoint_addGameHallScore_result_params::GameHallPoint_addGameHallScore_result_params(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_score(0)
,_unknown(_pool){
memset(_flag,0,sizeof(_flag));
}
inline GameHallPoint_addGameHallScore_result_params::GameHallPoint_addGameHallScore_result_params(const GameHallPoint_addGameHallScore_result_params& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_score(0)
,_unknown(_pool){
assign(v);
}
inline GameHallPoint_addGameHallScore_result_params::~GameHallPoint_addGameHallScore_result_params(){
}
inline GameHallPoint_addGameHallScore_result_params& GameHallPoint_addGameHallScore_result_params::operator=(const GameHallPoint_addGameHallScore_result_params& v){
assign(v);
return *this;
}
inline void GameHallPoint_addGameHallScore_result_params::clear(){
// _m_score=0;
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void GameHallPoint_addGameHallScore_result_params::check() const{
// @@int32_t score=out();
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "score" << "' not found";
}
{
__attribute__((unused)) int32_t item=_m_score;

}

::idl::McpackBean::check();
}
inline void GameHallPoint_addGameHallScore_result_params::detach(){
_unknown.clear();

::idl::McpackBean::detach();
}
inline GameHallPoint_addGameHallScore_result_params& GameHallPoint_addGameHallScore_result_params::assign(const GameHallPoint_addGameHallScore_result_params& v){
_m_score=v._m_score;
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool GameHallPoint_addGameHallScore_result_params::has_score() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline int32_t GameHallPoint_addGameHallScore_result_params::score() const{
return _m_score;
}
inline GameHallPoint_addGameHallScore_result_params& GameHallPoint_addGameHallScore_result_params::set_score(int32_t v){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 _m_score=v;
return *this;
}
inline void GameHallPoint_addGameHallScore_result_params::clear_score(){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_score=0;
}
inline ::idl::Unknown* GameHallPoint_addGameHallScore_result_params::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& GameHallPoint_addGameHallScore_result_params::unknown() const{
return _unknown;
}
inline ::idl::Unknown& GameHallPoint_addGameHallScore_result_params::unknown(){
return _unknown;
}
inline size_t GameHallPoint_addGameHallScore_result_params::unknown_size() const{
return _unknown.size();
}
inline GameHallPoint_addGameHallScore_response* GameHallPoint_addGameHallScore_response::create(bsl::mempool* pool){
if(!pool){
throw bsl::NullPointerException() << BSL_EARG;
}
GameHallPoint_addGameHallScore_response* tmp=(GameHallPoint_addGameHallScore_response*)pool->malloc(sizeof(*tmp));
if(!tmp){
throw bsl::BadAllocException() << BSL_EARG;
}
new(tmp)GameHallPoint_addGameHallScore_response(pool);
return tmp;
}
inline void GameHallPoint_addGameHallScore_response::destroy(GameHallPoint_addGameHallScore_response* v){
if(v){
bsl::mempool *pool=v->_pool;
v->~GameHallPoint_addGameHallScore_response();
pool->free(v,sizeof(*v));
}
}
inline GameHallPoint_addGameHallScore_response::GameHallPoint_addGameHallScore_response(bsl::mempool *pool): 
::idl::McpackBean(pool),
_pool(pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::GameHallPoint_addGameHallScore_result_params::create(_pool);
memset(_flag,0,sizeof(_flag));
}
inline GameHallPoint_addGameHallScore_response::GameHallPoint_addGameHallScore_response(const GameHallPoint_addGameHallScore_response& v): 
::idl::McpackBean(v._pool),
_pool(v._pool)
,_m_result_params(0)
,_unknown(_pool){
_m_result_params=::idl::GameHallPoint_addGameHallScore_result_params::create(_pool);
assign(v);
}
inline GameHallPoint_addGameHallScore_response::~GameHallPoint_addGameHallScore_response(){
if(_m_result_params){
::idl::GameHallPoint_addGameHallScore_result_params::destroy(_m_result_params);
_m_result_params=0;
}
}
inline GameHallPoint_addGameHallScore_response& GameHallPoint_addGameHallScore_response::operator=(const GameHallPoint_addGameHallScore_response& v){
assign(v);
return *this;
}
inline void GameHallPoint_addGameHallScore_response::clear(){
if(_m_result_params){
_m_result_params->clear();
}
memset(_flag,0,sizeof(_flag));
_unknown.clear(); 
::idl::McpackBean::clear();
}
// @@CF(constraint functions).
inline void GameHallPoint_addGameHallScore_response::check() const{
// @@GameHallPoint_addGameHallScore_result_params result_params;
if(!(_flag[0 >> 3] & (1 << (0 & 0x7)))){
throw bsl::KeyNotFoundException() << BSL_EARG << "key '" << "result_params" << "' not found";
}
{
::idl::GameHallPoint_addGameHallScore_result_params& item=const_cast< ::idl::GameHallPoint_addGameHallScore_result_params& >(*_m_result_params);
item.check();

}

::idl::McpackBean::check();
}
inline void GameHallPoint_addGameHallScore_response::detach(){
if(_m_result_params){
_m_result_params->detach();
}
_unknown.clear();

::idl::McpackBean::detach();
}
inline GameHallPoint_addGameHallScore_response& GameHallPoint_addGameHallScore_response::assign(const GameHallPoint_addGameHallScore_response& v){
if(!v._m_result_params){
if(_m_result_params){
::idl::GameHallPoint_addGameHallScore_result_params::destroy(_m_result_params);
}
_m_result_params=0;
}else{
if(!_m_result_params){
_m_result_params=::idl::GameHallPoint_addGameHallScore_result_params::create(_pool);
}
*_m_result_params=*v._m_result_params;
}
_unknown=v._unknown;
bsl::xmemcpy(_flag,v._flag,sizeof(v._flag));
return *this;
}
inline bool GameHallPoint_addGameHallScore_response::has_result_params() const{
return (_flag[0 >> 3] & (1 << (0 & 0x7)));
}
inline const ::idl::GameHallPoint_addGameHallScore_result_params& GameHallPoint_addGameHallScore_response::result_params() const{
 return *_m_result_params;
}
inline ::idl::GameHallPoint_addGameHallScore_result_params* GameHallPoint_addGameHallScore_response::mutable_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::GameHallPoint_addGameHallScore_result_params::create(_pool);
}
return _m_result_params;
}
inline ::idl::GameHallPoint_addGameHallScore_result_params* GameHallPoint_addGameHallScore_response::m_result_params(){
_flag[0 >> 3] |= (1 << (0 & 0x7));
 if(!_m_result_params){
_m_result_params=::idl::GameHallPoint_addGameHallScore_result_params::create(_pool);
}
return _m_result_params;
}
inline void GameHallPoint_addGameHallScore_response::clear_result_params(){
if(_m_result_params){
_flag[0 >> 3] &= ~(1 << (0 & 0x7));
 _m_result_params->clear();
}
}
inline ::idl::Unknown* GameHallPoint_addGameHallScore_response::mutable_unknown(){
return &_unknown;
}
inline const ::idl::Unknown& GameHallPoint_addGameHallScore_response::unknown() const{
return _unknown;
}
inline ::idl::Unknown& GameHallPoint_addGameHallScore_response::unknown(){
return _unknown;
}
inline size_t GameHallPoint_addGameHallScore_response::unknown_size() const{
return _unknown.size();
}
} // namespace idl
#endif // IDL_GENERATED_FILE_MCP_IDL_H_
