#include "mcp.idl.h"
__attribute__((unused)) extern bsl::syspool _common_pool;
namespace idl {
// @@class sub_class_t
static void _mcpack2_load_sub_class_t_id(const mc_pack_item_t*,sub_class_t*);
static void _mcpack2_load_sub_class_t_name(const mc_pack_item_t*,sub_class_t*);
static void _mcpack2_load_sub_class_t_icon(const mc_pack_item_t*,sub_class_t*);
static void _mcpack2_load_sub_class_t_content_list(const mc_pack_item_t*,sub_class_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,sub_class_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_sub_class_t_readmap;
// static initialization.
static bool _mcpack2_load_sub_class_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,sub_class_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,sub_class_t*)>("id",_mcpack2_load_sub_class_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,sub_class_t*)>("name",_mcpack2_load_sub_class_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,sub_class_t*)>("icon",_mcpack2_load_sub_class_t_icon));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,sub_class_t*)>("content_list",_mcpack2_load_sub_class_t_content_list));
_mcpack2_load_sub_class_t_readmap.create(16*4);
_mcpack2_load_sub_class_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_sub_class_t_static_inited=_mcpack2_load_sub_class_t_static_init();
// @@string id;
static void _mcpack2_load_sub_class_t_id(__attribute__((unused)) const mc_pack_item_t* item,sub_class_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_sub_class_t_name(__attribute__((unused)) const mc_pack_item_t* item,sub_class_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string icon;
static void _mcpack2_load_sub_class_t_icon(__attribute__((unused)) const mc_pack_item_t* item,sub_class_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "icon";
}
self->_m_icon.set_ptr(item->value,item->value_size-1);
}
// @@string content_list=array(0,0);
static void _mcpack2_load_sub_class_t_content_list(__attribute__((unused)) const mc_pack_item_t* item,sub_class_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_content_list)) lp0=&(self->_m_content_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void sub_class_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,sub_class_t*)=0;
do{
if(_mcpack2_load_sub_class_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int sub_class_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,sub_class_t*)=0;
if(_mcpack2_load_sub_class_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void sub_class_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t sub_class_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string icon;
{
int res=mc_pack_put_str(pack,"icon",_m_icon.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_list=array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"content_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_content_list)& lr0=(_m_content_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class class_info_t
static void _mcpack2_load_class_info_t_id(const mc_pack_item_t*,class_info_t*);
static void _mcpack2_load_class_info_t_name(const mc_pack_item_t*,class_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,class_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_class_info_t_readmap;
// static initialization.
static bool _mcpack2_load_class_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,class_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,class_info_t*)>("id",_mcpack2_load_class_info_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,class_info_t*)>("name",_mcpack2_load_class_info_t_name));
_mcpack2_load_class_info_t_readmap.create(16*2);
_mcpack2_load_class_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_class_info_t_static_inited=_mcpack2_load_class_info_t_static_init();
// @@string id;
static void _mcpack2_load_class_info_t_id(__attribute__((unused)) const mc_pack_item_t* item,class_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_class_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,class_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
void class_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,class_info_t*)=0;
do{
if(_mcpack2_load_class_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int class_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,class_info_t*)=0;
if(_mcpack2_load_class_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void class_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t class_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class class_detail_count_t
static void _mcpack2_load_class_detail_count_t_id(const mc_pack_item_t*,class_detail_count_t*);
static void _mcpack2_load_class_detail_count_t_name(const mc_pack_item_t*,class_detail_count_t*);
static void _mcpack2_load_class_detail_count_t_icon(const mc_pack_item_t*,class_detail_count_t*);
static void _mcpack2_load_class_detail_count_t_count(const mc_pack_item_t*,class_detail_count_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,class_detail_count_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_class_detail_count_t_readmap;
// static initialization.
static bool _mcpack2_load_class_detail_count_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,class_detail_count_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,class_detail_count_t*)>("id",_mcpack2_load_class_detail_count_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,class_detail_count_t*)>("name",_mcpack2_load_class_detail_count_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,class_detail_count_t*)>("icon",_mcpack2_load_class_detail_count_t_icon));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,class_detail_count_t*)>("count",_mcpack2_load_class_detail_count_t_count));
_mcpack2_load_class_detail_count_t_readmap.create(16*4);
_mcpack2_load_class_detail_count_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_class_detail_count_t_static_inited=_mcpack2_load_class_detail_count_t_static_init();
// @@string id;
static void _mcpack2_load_class_detail_count_t_id(__attribute__((unused)) const mc_pack_item_t* item,class_detail_count_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_class_detail_count_t_name(__attribute__((unused)) const mc_pack_item_t* item,class_detail_count_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string icon;
static void _mcpack2_load_class_detail_count_t_icon(__attribute__((unused)) const mc_pack_item_t* item,class_detail_count_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "icon";
}
self->_m_icon.set_ptr(item->value,item->value_size-1);
}
// @@string count;
static void _mcpack2_load_class_detail_count_t_count(__attribute__((unused)) const mc_pack_item_t* item,class_detail_count_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
self->_m_count.set_ptr(item->value,item->value_size-1);
}
void class_detail_count_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,class_detail_count_t*)=0;
do{
if(_mcpack2_load_class_detail_count_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int class_detail_count_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,class_detail_count_t*)=0;
if(_mcpack2_load_class_detail_count_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void class_detail_count_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t class_detail_count_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string icon;
{
int res=mc_pack_put_str(pack,"icon",_m_icon.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string count;
{
int res=mc_pack_put_str(pack,"count",_m_count.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class img_info_t
static void _mcpack2_load_img_info_t_type(const mc_pack_item_t*,img_info_t*);
static void _mcpack2_load_img_info_t_url(const mc_pack_item_t*,img_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,img_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_img_info_t_readmap;
// static initialization.
static bool _mcpack2_load_img_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,img_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,img_info_t*)>("type",_mcpack2_load_img_info_t_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,img_info_t*)>("url",_mcpack2_load_img_info_t_url));
_mcpack2_load_img_info_t_readmap.create(16*2);
_mcpack2_load_img_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_img_info_t_static_inited=_mcpack2_load_img_info_t_static_init();
// @@string type;
static void _mcpack2_load_img_info_t_type(__attribute__((unused)) const mc_pack_item_t* item,img_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type";
}
self->_m_type.set_ptr(item->value,item->value_size-1);
}
// @@string url;
static void _mcpack2_load_img_info_t_url(__attribute__((unused)) const mc_pack_item_t* item,img_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "url";
}
self->_m_url.set_ptr(item->value,item->value_size-1);
}
void img_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,img_info_t*)=0;
do{
if(_mcpack2_load_img_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int img_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,img_info_t*)=0;
if(_mcpack2_load_img_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void img_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t img_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string type;
{
int res=mc_pack_put_str(pack,"type",_m_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string url;
{
int res=mc_pack_put_str(pack,"url",_m_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class attribute_info_t
static void _mcpack2_load_attribute_info_t_name(const mc_pack_item_t*,attribute_info_t*);
static void _mcpack2_load_attribute_info_t_content(const mc_pack_item_t*,attribute_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,attribute_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_attribute_info_t_readmap;
// static initialization.
static bool _mcpack2_load_attribute_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,attribute_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,attribute_info_t*)>("name",_mcpack2_load_attribute_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,attribute_info_t*)>("content",_mcpack2_load_attribute_info_t_content));
_mcpack2_load_attribute_info_t_readmap.create(16*2);
_mcpack2_load_attribute_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_attribute_info_t_static_inited=_mcpack2_load_attribute_info_t_static_init();
// @@string name;
static void _mcpack2_load_attribute_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,attribute_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string content;
static void _mcpack2_load_attribute_info_t_content(__attribute__((unused)) const mc_pack_item_t* item,attribute_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content";
}
self->_m_content.set_ptr(item->value,item->value_size-1);
}
void attribute_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,attribute_info_t*)=0;
do{
if(_mcpack2_load_attribute_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int attribute_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,attribute_info_t*)=0;
if(_mcpack2_load_attribute_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void attribute_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t attribute_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content;
{
int res=mc_pack_put_str(pack,"content",_m_content.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class ios_content_info_t
static void _mcpack2_load_ios_content_info_t_id(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_name(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_icon(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_type(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_itunes_id(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_info(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_version(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_cp_id(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_cp_name(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_star(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_gdate(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_mdate(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_adapt(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_url(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_jump_url(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_size(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_now_price(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_original_price(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_rating(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_count(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_crt_rating(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_crt_count(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_language(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_img_list(const mc_pack_item_t*,ios_content_info_t*);
static void _mcpack2_load_ios_content_info_t_class_info(const mc_pack_item_t*,ios_content_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_ios_content_info_t_readmap;
// static initialization.
static bool _mcpack2_load_ios_content_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,ios_content_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("id",_mcpack2_load_ios_content_info_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("name",_mcpack2_load_ios_content_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("icon",_mcpack2_load_ios_content_info_t_icon));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("type",_mcpack2_load_ios_content_info_t_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("itunes_id",_mcpack2_load_ios_content_info_t_itunes_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("info",_mcpack2_load_ios_content_info_t_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("version",_mcpack2_load_ios_content_info_t_version));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("cp_id",_mcpack2_load_ios_content_info_t_cp_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("cp_name",_mcpack2_load_ios_content_info_t_cp_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("star",_mcpack2_load_ios_content_info_t_star));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("gdate",_mcpack2_load_ios_content_info_t_gdate));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("mdate",_mcpack2_load_ios_content_info_t_mdate));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("adapt",_mcpack2_load_ios_content_info_t_adapt));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("url",_mcpack2_load_ios_content_info_t_url));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("jump_url",_mcpack2_load_ios_content_info_t_jump_url));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("size",_mcpack2_load_ios_content_info_t_size));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("now_price",_mcpack2_load_ios_content_info_t_now_price));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("original_price",_mcpack2_load_ios_content_info_t_original_price));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("rating",_mcpack2_load_ios_content_info_t_rating));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("count",_mcpack2_load_ios_content_info_t_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("crt_rating",_mcpack2_load_ios_content_info_t_crt_rating));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("crt_count",_mcpack2_load_ios_content_info_t_crt_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("language",_mcpack2_load_ios_content_info_t_language));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("img_list",_mcpack2_load_ios_content_info_t_img_list));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,ios_content_info_t*)>("class_info",_mcpack2_load_ios_content_info_t_class_info));
_mcpack2_load_ios_content_info_t_readmap.create(16*25);
_mcpack2_load_ios_content_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_ios_content_info_t_static_inited=_mcpack2_load_ios_content_info_t_static_init();
// @@string id;
static void _mcpack2_load_ios_content_info_t_id(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_ios_content_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string icon;
static void _mcpack2_load_ios_content_info_t_icon(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "icon";
}
self->_m_icon.set_ptr(item->value,item->value_size-1);
}
// @@string type;
static void _mcpack2_load_ios_content_info_t_type(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type";
}
self->_m_type.set_ptr(item->value,item->value_size-1);
}
// @@string itunes_id;
static void _mcpack2_load_ios_content_info_t_itunes_id(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "itunes_id";
}
self->_m_itunes_id.set_ptr(item->value,item->value_size-1);
}
// @@string info;
static void _mcpack2_load_ios_content_info_t_info(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info";
}
self->_m_info.set_ptr(item->value,item->value_size-1);
}
// @@string version;
static void _mcpack2_load_ios_content_info_t_version(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "version";
}
self->_m_version.set_ptr(item->value,item->value_size-1);
}
// @@string cp_id;
static void _mcpack2_load_ios_content_info_t_cp_id(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "cp_id";
}
self->_m_cp_id.set_ptr(item->value,item->value_size-1);
}
// @@string cp_name;
static void _mcpack2_load_ios_content_info_t_cp_name(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "cp_name";
}
self->_m_cp_name.set_ptr(item->value,item->value_size-1);
}
// @@string star;
static void _mcpack2_load_ios_content_info_t_star(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "star";
}
self->_m_star.set_ptr(item->value,item->value_size-1);
}
// @@string gdate;
static void _mcpack2_load_ios_content_info_t_gdate(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[10 >> 3] |= (1 << (10 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "gdate";
}
self->_m_gdate.set_ptr(item->value,item->value_size-1);
}
// @@string mdate;
static void _mcpack2_load_ios_content_info_t_mdate(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[11 >> 3] |= (1 << (11 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "mdate";
}
self->_m_mdate.set_ptr(item->value,item->value_size-1);
}
// @@string adapt;
static void _mcpack2_load_ios_content_info_t_adapt(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[12 >> 3] |= (1 << (12 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "adapt";
}
self->_m_adapt.set_ptr(item->value,item->value_size-1);
}
// @@string url;
static void _mcpack2_load_ios_content_info_t_url(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[13 >> 3] |= (1 << (13 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "url";
}
self->_m_url.set_ptr(item->value,item->value_size-1);
}
// @@string jump_url;
static void _mcpack2_load_ios_content_info_t_jump_url(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[14 >> 3] |= (1 << (14 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "jump_url";
}
self->_m_jump_url.set_ptr(item->value,item->value_size-1);
}
// @@string size;
static void _mcpack2_load_ios_content_info_t_size(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[15 >> 3] |= (1 << (15 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "size";
}
self->_m_size.set_ptr(item->value,item->value_size-1);
}
// @@string now_price;
static void _mcpack2_load_ios_content_info_t_now_price(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[16 >> 3] |= (1 << (16 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "now_price";
}
self->_m_now_price.set_ptr(item->value,item->value_size-1);
}
// @@string original_price;
static void _mcpack2_load_ios_content_info_t_original_price(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[17 >> 3] |= (1 << (17 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "original_price";
}
self->_m_original_price.set_ptr(item->value,item->value_size-1);
}
// @@string rating;
static void _mcpack2_load_ios_content_info_t_rating(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[18 >> 3] |= (1 << (18 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "rating";
}
self->_m_rating.set_ptr(item->value,item->value_size-1);
}
// @@string count;
static void _mcpack2_load_ios_content_info_t_count(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[19 >> 3] |= (1 << (19 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
self->_m_count.set_ptr(item->value,item->value_size-1);
}
// @@string crt_rating;
static void _mcpack2_load_ios_content_info_t_crt_rating(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[20 >> 3] |= (1 << (20 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "crt_rating";
}
self->_m_crt_rating.set_ptr(item->value,item->value_size-1);
}
// @@string crt_count;
static void _mcpack2_load_ios_content_info_t_crt_count(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[21 >> 3] |= (1 << (21 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "crt_count";
}
self->_m_crt_count.set_ptr(item->value,item->value_size-1);
}
// @@string language;
static void _mcpack2_load_ios_content_info_t_language(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[22 >> 3] |= (1 << (22 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "language";
}
self->_m_language.set_ptr(item->value,item->value_size-1);
}
// @@string img_list=array(0);
static void _mcpack2_load_ios_content_info_t_img_list(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[23 >> 3] |= (1 << (23 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_img_list)) lp0=&(self->_m_img_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_list";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "img_list";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@class_info_t class_info=array(0);
static void _mcpack2_load_ios_content_info_t_class_info(__attribute__((unused)) const mc_pack_item_t* item,ios_content_info_t* self){
self->_flag[24 >> 3] |= (1 << (24 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_class_info)) lp0=&(self->_m_class_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void ios_content_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,ios_content_info_t*)=0;
do{
if(_mcpack2_load_ios_content_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int ios_content_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,ios_content_info_t*)=0;
if(_mcpack2_load_ios_content_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void ios_content_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t ios_content_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string icon;
{
int res=mc_pack_put_str(pack,"icon",_m_icon.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type;
{
int res=mc_pack_put_str(pack,"type",_m_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string itunes_id;
{
int res=mc_pack_put_str(pack,"itunes_id",_m_itunes_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info;
{
int res=mc_pack_put_str(pack,"info",_m_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string version;
{
int res=mc_pack_put_str(pack,"version",_m_version.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string cp_id;
{
int res=mc_pack_put_str(pack,"cp_id",_m_cp_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string cp_name;
{
int res=mc_pack_put_str(pack,"cp_name",_m_cp_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string star;
{
int res=mc_pack_put_str(pack,"star",_m_star.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string gdate;
{
int res=mc_pack_put_str(pack,"gdate",_m_gdate.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string mdate;
{
int res=mc_pack_put_str(pack,"mdate",_m_mdate.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string adapt;
{
int res=mc_pack_put_str(pack,"adapt",_m_adapt.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string url;
{
int res=mc_pack_put_str(pack,"url",_m_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string jump_url;
{
int res=mc_pack_put_str(pack,"jump_url",_m_jump_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string size;
{
int res=mc_pack_put_str(pack,"size",_m_size.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string now_price;
{
int res=mc_pack_put_str(pack,"now_price",_m_now_price.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string original_price;
{
int res=mc_pack_put_str(pack,"original_price",_m_original_price.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string rating;
{
int res=mc_pack_put_str(pack,"rating",_m_rating.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string count;
{
int res=mc_pack_put_str(pack,"count",_m_count.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string crt_rating;
{
int res=mc_pack_put_str(pack,"crt_rating",_m_crt_rating.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string crt_count;
{
int res=mc_pack_put_str(pack,"crt_count",_m_crt_count.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string language;
{
int res=mc_pack_put_str(pack,"language",_m_language.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string img_list=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"img_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_img_list)& lr0=(_m_img_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@class_info_t class_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"class_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_class_info)& lr0=(_m_class_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class game_brief_info_t
static void _mcpack2_load_game_brief_info_t_info_type(const mc_pack_item_t*,game_brief_info_t*);
static void _mcpack2_load_game_brief_info_t_info_id(const mc_pack_item_t*,game_brief_info_t*);
static void _mcpack2_load_game_brief_info_t_info_title(const mc_pack_item_t*,game_brief_info_t*);
static void _mcpack2_load_game_brief_info_t_info_datetime(const mc_pack_item_t*,game_brief_info_t*);
static void _mcpack2_load_game_brief_info_t_type_name(const mc_pack_item_t*,game_brief_info_t*);
static void _mcpack2_load_game_brief_info_t_game_type(const mc_pack_item_t*,game_brief_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,game_brief_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_game_brief_info_t_readmap;
// static initialization.
static bool _mcpack2_load_game_brief_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,game_brief_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_brief_info_t*)>("info_type",_mcpack2_load_game_brief_info_t_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_brief_info_t*)>("info_id",_mcpack2_load_game_brief_info_t_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_brief_info_t*)>("info_title",_mcpack2_load_game_brief_info_t_info_title));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_brief_info_t*)>("info_datetime",_mcpack2_load_game_brief_info_t_info_datetime));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_brief_info_t*)>("type_name",_mcpack2_load_game_brief_info_t_type_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_brief_info_t*)>("game_type",_mcpack2_load_game_brief_info_t_game_type));
_mcpack2_load_game_brief_info_t_readmap.create(16*6);
_mcpack2_load_game_brief_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_game_brief_info_t_static_inited=_mcpack2_load_game_brief_info_t_static_init();
// @@string info_type;
static void _mcpack2_load_game_brief_info_t_info_type(__attribute__((unused)) const mc_pack_item_t* item,game_brief_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
self->_m_info_type.set_ptr(item->value,item->value_size-1);
}
// @@string info_id;
static void _mcpack2_load_game_brief_info_t_info_id(__attribute__((unused)) const mc_pack_item_t* item,game_brief_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@string info_title;
static void _mcpack2_load_game_brief_info_t_info_title(__attribute__((unused)) const mc_pack_item_t* item,game_brief_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_title";
}
self->_m_info_title.set_ptr(item->value,item->value_size-1);
}
// @@string info_datetime;
static void _mcpack2_load_game_brief_info_t_info_datetime(__attribute__((unused)) const mc_pack_item_t* item,game_brief_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_datetime";
}
self->_m_info_datetime.set_ptr(item->value,item->value_size-1);
}
// @@string type_name;
static void _mcpack2_load_game_brief_info_t_type_name(__attribute__((unused)) const mc_pack_item_t* item,game_brief_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_name";
}
self->_m_type_name.set_ptr(item->value,item->value_size-1);
}
// @@string game_type;
static void _mcpack2_load_game_brief_info_t_game_type(__attribute__((unused)) const mc_pack_item_t* item,game_brief_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_type";
}
self->_m_game_type.set_ptr(item->value,item->value_size-1);
}
void game_brief_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,game_brief_info_t*)=0;
do{
if(_mcpack2_load_game_brief_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int game_brief_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,game_brief_info_t*)=0;
if(_mcpack2_load_game_brief_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void game_brief_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t game_brief_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string info_type;
{
int res=mc_pack_put_str(pack,"info_type",_m_info_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id;
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_title;
{
int res=mc_pack_put_str(pack,"info_title",_m_info_title.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_datetime;
{
int res=mc_pack_put_str(pack,"info_datetime",_m_info_datetime.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_name;
{
int res=mc_pack_put_str(pack,"type_name",_m_type_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_type;
{
int res=mc_pack_put_str(pack,"game_type",_m_game_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class game_info_t
static void _mcpack2_load_game_info_t_info_type(const mc_pack_item_t*,game_info_t*);
static void _mcpack2_load_game_info_t_info_id(const mc_pack_item_t*,game_info_t*);
static void _mcpack2_load_game_info_t_c_id(const mc_pack_item_t*,game_info_t*);
static void _mcpack2_load_game_info_t_info_title(const mc_pack_item_t*,game_info_t*);
static void _mcpack2_load_game_info_t_info_content(const mc_pack_item_t*,game_info_t*);
static void _mcpack2_load_game_info_t_info_date(const mc_pack_item_t*,game_info_t*);
static void _mcpack2_load_game_info_t_type_name(const mc_pack_item_t*,game_info_t*);
static void _mcpack2_load_game_info_t_game_type(const mc_pack_item_t*,game_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,game_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_game_info_t_readmap;
// static initialization.
static bool _mcpack2_load_game_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,game_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t*)>("info_type",_mcpack2_load_game_info_t_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t*)>("info_id",_mcpack2_load_game_info_t_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t*)>("c_id",_mcpack2_load_game_info_t_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t*)>("info_title",_mcpack2_load_game_info_t_info_title));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t*)>("info_content",_mcpack2_load_game_info_t_info_content));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t*)>("info_date",_mcpack2_load_game_info_t_info_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t*)>("type_name",_mcpack2_load_game_info_t_type_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t*)>("game_type",_mcpack2_load_game_info_t_game_type));
_mcpack2_load_game_info_t_readmap.create(16*8);
_mcpack2_load_game_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_game_info_t_static_inited=_mcpack2_load_game_info_t_static_init();
// @@string info_type;
static void _mcpack2_load_game_info_t_info_type(__attribute__((unused)) const mc_pack_item_t* item,game_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
self->_m_info_type.set_ptr(item->value,item->value_size-1);
}
// @@string info_id;
static void _mcpack2_load_game_info_t_info_id(__attribute__((unused)) const mc_pack_item_t* item,game_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id;
static void _mcpack2_load_game_info_t_c_id(__attribute__((unused)) const mc_pack_item_t* item,game_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string info_title;
static void _mcpack2_load_game_info_t_info_title(__attribute__((unused)) const mc_pack_item_t* item,game_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_title";
}
self->_m_info_title.set_ptr(item->value,item->value_size-1);
}
// @@string info_content;
static void _mcpack2_load_game_info_t_info_content(__attribute__((unused)) const mc_pack_item_t* item,game_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_content";
}
self->_m_info_content.set_ptr(item->value,item->value_size-1);
}
// @@string info_date;
static void _mcpack2_load_game_info_t_info_date(__attribute__((unused)) const mc_pack_item_t* item,game_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_date";
}
self->_m_info_date.set_ptr(item->value,item->value_size-1);
}
// @@string type_name;
static void _mcpack2_load_game_info_t_type_name(__attribute__((unused)) const mc_pack_item_t* item,game_info_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_name";
}
self->_m_type_name.set_ptr(item->value,item->value_size-1);
}
// @@string game_type;
static void _mcpack2_load_game_info_t_game_type(__attribute__((unused)) const mc_pack_item_t* item,game_info_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_type";
}
self->_m_game_type.set_ptr(item->value,item->value_size-1);
}
void game_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,game_info_t*)=0;
do{
if(_mcpack2_load_game_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int game_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,game_info_t*)=0;
if(_mcpack2_load_game_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void game_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t game_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string info_type;
{
int res=mc_pack_put_str(pack,"info_type",_m_info_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id;
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id;
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_title;
{
int res=mc_pack_put_str(pack,"info_title",_m_info_title.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_content;
{
int res=mc_pack_put_str(pack,"info_content",_m_info_content.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_date;
{
int res=mc_pack_put_str(pack,"info_date",_m_info_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_name;
{
int res=mc_pack_put_str(pack,"type_name",_m_type_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_type;
{
int res=mc_pack_put_str(pack,"game_type",_m_game_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class pub_prop_info_t
static void _mcpack2_load_pub_prop_info_t_prop_url(const mc_pack_item_t*,pub_prop_info_t*);
static void _mcpack2_load_pub_prop_info_t_name(const mc_pack_item_t*,pub_prop_info_t*);
static void _mcpack2_load_pub_prop_info_t_color(const mc_pack_item_t*,pub_prop_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,pub_prop_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_pub_prop_info_t_readmap;
// static initialization.
static bool _mcpack2_load_pub_prop_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,pub_prop_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,pub_prop_info_t*)>("prop_url",_mcpack2_load_pub_prop_info_t_prop_url));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,pub_prop_info_t*)>("name",_mcpack2_load_pub_prop_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,pub_prop_info_t*)>("color",_mcpack2_load_pub_prop_info_t_color));
_mcpack2_load_pub_prop_info_t_readmap.create(16*3);
_mcpack2_load_pub_prop_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_pub_prop_info_t_static_inited=_mcpack2_load_pub_prop_info_t_static_init();
// @@string prop_url;
static void _mcpack2_load_pub_prop_info_t_prop_url(__attribute__((unused)) const mc_pack_item_t* item,pub_prop_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "prop_url";
}
self->_m_prop_url.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_pub_prop_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,pub_prop_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string color;
static void _mcpack2_load_pub_prop_info_t_color(__attribute__((unused)) const mc_pack_item_t* item,pub_prop_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "color";
}
self->_m_color.set_ptr(item->value,item->value_size-1);
}
void pub_prop_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,pub_prop_info_t*)=0;
do{
if(_mcpack2_load_pub_prop_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int pub_prop_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,pub_prop_info_t*)=0;
if(_mcpack2_load_pub_prop_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void pub_prop_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t pub_prop_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string prop_url;
{
int res=mc_pack_put_str(pack,"prop_url",_m_prop_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string color;
{
int res=mc_pack_put_str(pack,"color",_m_color.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class game_info_t_hall
static void _mcpack2_load_game_info_t_hall_info_type(const mc_pack_item_t*,game_info_t_hall*);
static void _mcpack2_load_game_info_t_hall_info_id(const mc_pack_item_t*,game_info_t_hall*);
static void _mcpack2_load_game_info_t_hall_c_id(const mc_pack_item_t*,game_info_t_hall*);
static void _mcpack2_load_game_info_t_hall_info_title(const mc_pack_item_t*,game_info_t_hall*);
static void _mcpack2_load_game_info_t_hall_info_content(const mc_pack_item_t*,game_info_t_hall*);
static void _mcpack2_load_game_info_t_hall_info_date(const mc_pack_item_t*,game_info_t_hall*);
static void _mcpack2_load_game_info_t_hall_type_name(const mc_pack_item_t*,game_info_t_hall*);
static void _mcpack2_load_game_info_t_hall_game_type(const mc_pack_item_t*,game_info_t_hall*);
static void _mcpack2_load_game_info_t_hall_news_source(const mc_pack_item_t*,game_info_t_hall*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,game_info_t_hall*),::idl::string_hash,::idl::string_equal> _mcpack2_load_game_info_t_hall_readmap;
// static initialization.
static bool _mcpack2_load_game_info_t_hall_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,game_info_t_hall*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t_hall*)>("info_type",_mcpack2_load_game_info_t_hall_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t_hall*)>("info_id",_mcpack2_load_game_info_t_hall_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t_hall*)>("c_id",_mcpack2_load_game_info_t_hall_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t_hall*)>("info_title",_mcpack2_load_game_info_t_hall_info_title));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t_hall*)>("info_content",_mcpack2_load_game_info_t_hall_info_content));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t_hall*)>("info_date",_mcpack2_load_game_info_t_hall_info_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t_hall*)>("type_name",_mcpack2_load_game_info_t_hall_type_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t_hall*)>("game_type",_mcpack2_load_game_info_t_hall_game_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_info_t_hall*)>("news_source",_mcpack2_load_game_info_t_hall_news_source));
_mcpack2_load_game_info_t_hall_readmap.create(16*9);
_mcpack2_load_game_info_t_hall_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_game_info_t_hall_static_inited=_mcpack2_load_game_info_t_hall_static_init();
// @@string info_type;
static void _mcpack2_load_game_info_t_hall_info_type(__attribute__((unused)) const mc_pack_item_t* item,game_info_t_hall* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
self->_m_info_type.set_ptr(item->value,item->value_size-1);
}
// @@string info_id;
static void _mcpack2_load_game_info_t_hall_info_id(__attribute__((unused)) const mc_pack_item_t* item,game_info_t_hall* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id;
static void _mcpack2_load_game_info_t_hall_c_id(__attribute__((unused)) const mc_pack_item_t* item,game_info_t_hall* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string info_title;
static void _mcpack2_load_game_info_t_hall_info_title(__attribute__((unused)) const mc_pack_item_t* item,game_info_t_hall* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_title";
}
self->_m_info_title.set_ptr(item->value,item->value_size-1);
}
// @@string info_content;
static void _mcpack2_load_game_info_t_hall_info_content(__attribute__((unused)) const mc_pack_item_t* item,game_info_t_hall* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_content";
}
self->_m_info_content.set_ptr(item->value,item->value_size-1);
}
// @@string info_date;
static void _mcpack2_load_game_info_t_hall_info_date(__attribute__((unused)) const mc_pack_item_t* item,game_info_t_hall* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_date";
}
self->_m_info_date.set_ptr(item->value,item->value_size-1);
}
// @@string type_name;
static void _mcpack2_load_game_info_t_hall_type_name(__attribute__((unused)) const mc_pack_item_t* item,game_info_t_hall* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_name";
}
self->_m_type_name.set_ptr(item->value,item->value_size-1);
}
// @@string game_type;
static void _mcpack2_load_game_info_t_hall_game_type(__attribute__((unused)) const mc_pack_item_t* item,game_info_t_hall* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_type";
}
self->_m_game_type.set_ptr(item->value,item->value_size-1);
}
// @@string news_source;
static void _mcpack2_load_game_info_t_hall_news_source(__attribute__((unused)) const mc_pack_item_t* item,game_info_t_hall* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "news_source";
}
self->_m_news_source.set_ptr(item->value,item->value_size-1);
}
void game_info_t_hall::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,game_info_t_hall*)=0;
do{
if(_mcpack2_load_game_info_t_hall_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int game_info_t_hall::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,game_info_t_hall*)=0;
if(_mcpack2_load_game_info_t_hall_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void game_info_t_hall::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t game_info_t_hall::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string info_type;
{
int res=mc_pack_put_str(pack,"info_type",_m_info_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id;
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id;
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_title;
{
int res=mc_pack_put_str(pack,"info_title",_m_info_title.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_content;
{
int res=mc_pack_put_str(pack,"info_content",_m_info_content.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_date;
{
int res=mc_pack_put_str(pack,"info_date",_m_info_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_name;
{
int res=mc_pack_put_str(pack,"type_name",_m_type_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_type;
{
int res=mc_pack_put_str(pack,"game_type",_m_game_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string news_source;
{
int res=mc_pack_put_str(pack,"news_source",_m_news_source.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class online_game_info_t
static void _mcpack2_load_online_game_info_t_id(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_name(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_icon(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_thumb(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_type(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_info(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_version(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_system_req(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_cp_id(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_cp_name(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_star(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_popularity(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_language(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_gdate(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_mdate(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_ldate(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_url(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_size(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_label_list(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_img_list(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_apk_flag(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_editor_recom(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_class_info(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_attribute_list(const mc_pack_item_t*,online_game_info_t*);
static void _mcpack2_load_online_game_info_t_pub_prop_ids(const mc_pack_item_t*,online_game_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_online_game_info_t_readmap;
// static initialization.
static bool _mcpack2_load_online_game_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,online_game_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("id",_mcpack2_load_online_game_info_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("name",_mcpack2_load_online_game_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("icon",_mcpack2_load_online_game_info_t_icon));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("thumb",_mcpack2_load_online_game_info_t_thumb));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("type",_mcpack2_load_online_game_info_t_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("info",_mcpack2_load_online_game_info_t_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("version",_mcpack2_load_online_game_info_t_version));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("system_req",_mcpack2_load_online_game_info_t_system_req));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("cp_id",_mcpack2_load_online_game_info_t_cp_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("cp_name",_mcpack2_load_online_game_info_t_cp_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("star",_mcpack2_load_online_game_info_t_star));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("popularity",_mcpack2_load_online_game_info_t_popularity));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("language",_mcpack2_load_online_game_info_t_language));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("gdate",_mcpack2_load_online_game_info_t_gdate));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("mdate",_mcpack2_load_online_game_info_t_mdate));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("ldate",_mcpack2_load_online_game_info_t_ldate));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("url",_mcpack2_load_online_game_info_t_url));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("size",_mcpack2_load_online_game_info_t_size));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("label_list",_mcpack2_load_online_game_info_t_label_list));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("img_list",_mcpack2_load_online_game_info_t_img_list));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("apk_flag",_mcpack2_load_online_game_info_t_apk_flag));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("editor_recom",_mcpack2_load_online_game_info_t_editor_recom));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("class_info",_mcpack2_load_online_game_info_t_class_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("attribute_list",_mcpack2_load_online_game_info_t_attribute_list));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,online_game_info_t*)>("pub_prop_ids",_mcpack2_load_online_game_info_t_pub_prop_ids));
_mcpack2_load_online_game_info_t_readmap.create(16*25);
_mcpack2_load_online_game_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_online_game_info_t_static_inited=_mcpack2_load_online_game_info_t_static_init();
// @@string id;
static void _mcpack2_load_online_game_info_t_id(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_online_game_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string icon;
static void _mcpack2_load_online_game_info_t_icon(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "icon";
}
self->_m_icon.set_ptr(item->value,item->value_size-1);
}
// @@string thumb;
static void _mcpack2_load_online_game_info_t_thumb(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "thumb";
}
self->_m_thumb.set_ptr(item->value,item->value_size-1);
}
// @@string type;
static void _mcpack2_load_online_game_info_t_type(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type";
}
self->_m_type.set_ptr(item->value,item->value_size-1);
}
// @@string info;
static void _mcpack2_load_online_game_info_t_info(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info";
}
self->_m_info.set_ptr(item->value,item->value_size-1);
}
// @@string version;
static void _mcpack2_load_online_game_info_t_version(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "version";
}
self->_m_version.set_ptr(item->value,item->value_size-1);
}
// @@string system_req;
static void _mcpack2_load_online_game_info_t_system_req(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "system_req";
}
self->_m_system_req.set_ptr(item->value,item->value_size-1);
}
// @@string cp_id;
static void _mcpack2_load_online_game_info_t_cp_id(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "cp_id";
}
self->_m_cp_id.set_ptr(item->value,item->value_size-1);
}
// @@string cp_name;
static void _mcpack2_load_online_game_info_t_cp_name(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "cp_name";
}
self->_m_cp_name.set_ptr(item->value,item->value_size-1);
}
// @@string star;
static void _mcpack2_load_online_game_info_t_star(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[10 >> 3] |= (1 << (10 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "star";
}
self->_m_star.set_ptr(item->value,item->value_size-1);
}
// @@string popularity;
static void _mcpack2_load_online_game_info_t_popularity(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[11 >> 3] |= (1 << (11 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "popularity";
}
self->_m_popularity.set_ptr(item->value,item->value_size-1);
}
// @@string language;
static void _mcpack2_load_online_game_info_t_language(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[12 >> 3] |= (1 << (12 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "language";
}
self->_m_language.set_ptr(item->value,item->value_size-1);
}
// @@string gdate;
static void _mcpack2_load_online_game_info_t_gdate(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[13 >> 3] |= (1 << (13 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "gdate";
}
self->_m_gdate.set_ptr(item->value,item->value_size-1);
}
// @@string mdate;
static void _mcpack2_load_online_game_info_t_mdate(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[14 >> 3] |= (1 << (14 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "mdate";
}
self->_m_mdate.set_ptr(item->value,item->value_size-1);
}
// @@string ldate;
static void _mcpack2_load_online_game_info_t_ldate(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[15 >> 3] |= (1 << (15 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ldate";
}
self->_m_ldate.set_ptr(item->value,item->value_size-1);
}
// @@string url;
static void _mcpack2_load_online_game_info_t_url(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[16 >> 3] |= (1 << (16 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "url";
}
self->_m_url.set_ptr(item->value,item->value_size-1);
}
// @@string size;
static void _mcpack2_load_online_game_info_t_size(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[17 >> 3] |= (1 << (17 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "size";
}
self->_m_size.set_ptr(item->value,item->value_size-1);
}
// @@string label_list=array(0);
static void _mcpack2_load_online_game_info_t_label_list(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[18 >> 3] |= (1 << (18 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "label_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_label_list)) lp0=&(self->_m_label_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "label_list";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "label_list";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "label_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string img_list=array(0);
static void _mcpack2_load_online_game_info_t_img_list(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[19 >> 3] |= (1 << (19 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_img_list)) lp0=&(self->_m_img_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_list";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "img_list";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string apk_flag;
static void _mcpack2_load_online_game_info_t_apk_flag(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[20 >> 3] |= (1 << (20 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "apk_flag";
}
self->_m_apk_flag.set_ptr(item->value,item->value_size-1);
}
// @@string editor_recom;
static void _mcpack2_load_online_game_info_t_editor_recom(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[21 >> 3] |= (1 << (21 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "editor_recom";
}
self->_m_editor_recom.set_ptr(item->value,item->value_size-1);
}
// @@class_info_t class_info=array(0);
static void _mcpack2_load_online_game_info_t_class_info(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[22 >> 3] |= (1 << (22 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_class_info)) lp0=&(self->_m_class_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@attribute_info_t attribute_list=array(0);
static void _mcpack2_load_online_game_info_t_attribute_list(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[23 >> 3] |= (1 << (23 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "attribute_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_attribute_list)) lp0=&(self->_m_attribute_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "attribute_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "attribute_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "attribute_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string pub_prop_ids;
static void _mcpack2_load_online_game_info_t_pub_prop_ids(__attribute__((unused)) const mc_pack_item_t* item,online_game_info_t* self){
self->_flag[24 >> 3] |= (1 << (24 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "pub_prop_ids";
}
self->_m_pub_prop_ids.set_ptr(item->value,item->value_size-1);
}
void online_game_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,online_game_info_t*)=0;
do{
if(_mcpack2_load_online_game_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int online_game_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,online_game_info_t*)=0;
if(_mcpack2_load_online_game_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void online_game_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t online_game_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string icon;
{
int res=mc_pack_put_str(pack,"icon",_m_icon.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string thumb;
{
int res=mc_pack_put_str(pack,"thumb",_m_thumb.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type;
{
int res=mc_pack_put_str(pack,"type",_m_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info;
{
int res=mc_pack_put_str(pack,"info",_m_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string version;
{
int res=mc_pack_put_str(pack,"version",_m_version.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string system_req;
{
int res=mc_pack_put_str(pack,"system_req",_m_system_req.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string cp_id;
{
int res=mc_pack_put_str(pack,"cp_id",_m_cp_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string cp_name;
{
int res=mc_pack_put_str(pack,"cp_name",_m_cp_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string star;
{
int res=mc_pack_put_str(pack,"star",_m_star.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string popularity;
{
int res=mc_pack_put_str(pack,"popularity",_m_popularity.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string language;
{
int res=mc_pack_put_str(pack,"language",_m_language.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string gdate;
{
int res=mc_pack_put_str(pack,"gdate",_m_gdate.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string mdate;
{
int res=mc_pack_put_str(pack,"mdate",_m_mdate.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ldate;
{
int res=mc_pack_put_str(pack,"ldate",_m_ldate.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string url;
{
int res=mc_pack_put_str(pack,"url",_m_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string size;
{
int res=mc_pack_put_str(pack,"size",_m_size.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string label_list=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"label_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_label_list)& lr0=(_m_label_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string img_list=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"img_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_img_list)& lr0=(_m_img_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string apk_flag;
{
int res=mc_pack_put_str(pack,"apk_flag",_m_apk_flag.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string editor_recom;
{
int res=mc_pack_put_str(pack,"editor_recom",_m_editor_recom.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@class_info_t class_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"class_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_class_info)& lr0=(_m_class_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@attribute_info_t attribute_list=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"attribute_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_attribute_list)& lr0=(_m_attribute_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string pub_prop_ids;
{
int res=mc_pack_put_str(pack,"pub_prop_ids",_m_pub_prop_ids.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class grab_info_t
static void _mcpack2_load_grab_info_t_id(const mc_pack_item_t*,grab_info_t*);
static void _mcpack2_load_grab_info_t_c_id(const mc_pack_item_t*,grab_info_t*);
static void _mcpack2_load_grab_info_t_name(const mc_pack_item_t*,grab_info_t*);
static void _mcpack2_load_grab_info_t_amount(const mc_pack_item_t*,grab_info_t*);
static void _mcpack2_load_grab_info_t_send_amount(const mc_pack_item_t*,grab_info_t*);
static void _mcpack2_load_grab_info_t_create_time(const mc_pack_item_t*,grab_info_t*);
static void _mcpack2_load_grab_info_t_start_time(const mc_pack_item_t*,grab_info_t*);
static void _mcpack2_load_grab_info_t_end_time(const mc_pack_item_t*,grab_info_t*);
static void _mcpack2_load_grab_info_t_info(const mc_pack_item_t*,grab_info_t*);
static void _mcpack2_load_grab_info_t_num(const mc_pack_item_t*,grab_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,grab_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_grab_info_t_readmap;
// static initialization.
static bool _mcpack2_load_grab_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,grab_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grab_info_t*)>("id",_mcpack2_load_grab_info_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grab_info_t*)>("c_id",_mcpack2_load_grab_info_t_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grab_info_t*)>("name",_mcpack2_load_grab_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grab_info_t*)>("amount",_mcpack2_load_grab_info_t_amount));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grab_info_t*)>("send_amount",_mcpack2_load_grab_info_t_send_amount));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grab_info_t*)>("create_time",_mcpack2_load_grab_info_t_create_time));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grab_info_t*)>("start_time",_mcpack2_load_grab_info_t_start_time));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grab_info_t*)>("end_time",_mcpack2_load_grab_info_t_end_time));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grab_info_t*)>("info",_mcpack2_load_grab_info_t_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grab_info_t*)>("num",_mcpack2_load_grab_info_t_num));
_mcpack2_load_grab_info_t_readmap.create(16*10);
_mcpack2_load_grab_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_grab_info_t_static_inited=_mcpack2_load_grab_info_t_static_init();
// @@uint32_t id;
static void _mcpack2_load_grab_info_t_id(__attribute__((unused)) const mc_pack_item_t* item,grab_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_id));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
}
// @@string c_id;
static void _mcpack2_load_grab_info_t_c_id(__attribute__((unused)) const mc_pack_item_t* item,grab_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_grab_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,grab_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t amount;
static void _mcpack2_load_grab_info_t_amount(__attribute__((unused)) const mc_pack_item_t* item,grab_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_amount));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "amount";
}
}
// @@uint32_t send_amount;
static void _mcpack2_load_grab_info_t_send_amount(__attribute__((unused)) const mc_pack_item_t* item,grab_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_send_amount));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "send_amount";
}
}
// @@string create_time;
static void _mcpack2_load_grab_info_t_create_time(__attribute__((unused)) const mc_pack_item_t* item,grab_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "create_time";
}
self->_m_create_time.set_ptr(item->value,item->value_size-1);
}
// @@string start_time;
static void _mcpack2_load_grab_info_t_start_time(__attribute__((unused)) const mc_pack_item_t* item,grab_info_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "start_time";
}
self->_m_start_time.set_ptr(item->value,item->value_size-1);
}
// @@string end_time;
static void _mcpack2_load_grab_info_t_end_time(__attribute__((unused)) const mc_pack_item_t* item,grab_info_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "end_time";
}
self->_m_end_time.set_ptr(item->value,item->value_size-1);
}
// @@string info;
static void _mcpack2_load_grab_info_t_info(__attribute__((unused)) const mc_pack_item_t* item,grab_info_t* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info";
}
self->_m_info.set_ptr(item->value,item->value_size-1);
}
// @@string num;
static void _mcpack2_load_grab_info_t_num(__attribute__((unused)) const mc_pack_item_t* item,grab_info_t* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "num";
}
self->_m_num.set_ptr(item->value,item->value_size-1);
}
void grab_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,grab_info_t*)=0;
do{
if(_mcpack2_load_grab_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int grab_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,grab_info_t*)=0;
if(_mcpack2_load_grab_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void grab_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t grab_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t id;
{
int res=mc_pack_put_uint32(pack,"id",_m_id);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id;
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t amount;
{
int res=mc_pack_put_uint32(pack,"amount",_m_amount);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t send_amount;
{
int res=mc_pack_put_uint32(pack,"send_amount",_m_send_amount);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string create_time;
{
int res=mc_pack_put_str(pack,"create_time",_m_create_time.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string start_time;
{
int res=mc_pack_put_str(pack,"start_time",_m_start_time.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string end_time;
{
int res=mc_pack_put_str(pack,"end_time",_m_end_time.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info;
{
int res=mc_pack_put_str(pack,"info",_m_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string num;
{
int res=mc_pack_put_str(pack,"num",_m_num.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class user_grab_number_t
static void _mcpack2_load_user_grab_number_t_grab_id(const mc_pack_item_t*,user_grab_number_t*);
static void _mcpack2_load_user_grab_number_t_num(const mc_pack_item_t*,user_grab_number_t*);
static void _mcpack2_load_user_grab_number_t_c_id(const mc_pack_item_t*,user_grab_number_t*);
static void _mcpack2_load_user_grab_number_t_name(const mc_pack_item_t*,user_grab_number_t*);
static void _mcpack2_load_user_grab_number_t_create_time(const mc_pack_item_t*,user_grab_number_t*);
static void _mcpack2_load_user_grab_number_t_start_time(const mc_pack_item_t*,user_grab_number_t*);
static void _mcpack2_load_user_grab_number_t_end_time(const mc_pack_item_t*,user_grab_number_t*);
static void _mcpack2_load_user_grab_number_t_info(const mc_pack_item_t*,user_grab_number_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,user_grab_number_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_user_grab_number_t_readmap;
// static initialization.
static bool _mcpack2_load_user_grab_number_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,user_grab_number_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_grab_number_t*)>("grab_id",_mcpack2_load_user_grab_number_t_grab_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_grab_number_t*)>("num",_mcpack2_load_user_grab_number_t_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_grab_number_t*)>("c_id",_mcpack2_load_user_grab_number_t_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_grab_number_t*)>("name",_mcpack2_load_user_grab_number_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_grab_number_t*)>("create_time",_mcpack2_load_user_grab_number_t_create_time));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_grab_number_t*)>("start_time",_mcpack2_load_user_grab_number_t_start_time));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_grab_number_t*)>("end_time",_mcpack2_load_user_grab_number_t_end_time));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_grab_number_t*)>("info",_mcpack2_load_user_grab_number_t_info));
_mcpack2_load_user_grab_number_t_readmap.create(16*8);
_mcpack2_load_user_grab_number_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_user_grab_number_t_static_inited=_mcpack2_load_user_grab_number_t_static_init();
// @@uint32_t grab_id;
static void _mcpack2_load_user_grab_number_t_grab_id(__attribute__((unused)) const mc_pack_item_t* item,user_grab_number_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_grab_id));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "grab_id";
}
}
// @@string num;
static void _mcpack2_load_user_grab_number_t_num(__attribute__((unused)) const mc_pack_item_t* item,user_grab_number_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "num";
}
self->_m_num.set_ptr(item->value,item->value_size-1);
}
// @@string c_id;
static void _mcpack2_load_user_grab_number_t_c_id(__attribute__((unused)) const mc_pack_item_t* item,user_grab_number_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_user_grab_number_t_name(__attribute__((unused)) const mc_pack_item_t* item,user_grab_number_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string create_time;
static void _mcpack2_load_user_grab_number_t_create_time(__attribute__((unused)) const mc_pack_item_t* item,user_grab_number_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "create_time";
}
self->_m_create_time.set_ptr(item->value,item->value_size-1);
}
// @@string start_time;
static void _mcpack2_load_user_grab_number_t_start_time(__attribute__((unused)) const mc_pack_item_t* item,user_grab_number_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "start_time";
}
self->_m_start_time.set_ptr(item->value,item->value_size-1);
}
// @@string end_time;
static void _mcpack2_load_user_grab_number_t_end_time(__attribute__((unused)) const mc_pack_item_t* item,user_grab_number_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "end_time";
}
self->_m_end_time.set_ptr(item->value,item->value_size-1);
}
// @@string info;
static void _mcpack2_load_user_grab_number_t_info(__attribute__((unused)) const mc_pack_item_t* item,user_grab_number_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info";
}
self->_m_info.set_ptr(item->value,item->value_size-1);
}
void user_grab_number_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,user_grab_number_t*)=0;
do{
if(_mcpack2_load_user_grab_number_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int user_grab_number_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,user_grab_number_t*)=0;
if(_mcpack2_load_user_grab_number_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void user_grab_number_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t user_grab_number_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t grab_id;
{
int res=mc_pack_put_uint32(pack,"grab_id",_m_grab_id);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string num;
{
int res=mc_pack_put_str(pack,"num",_m_num.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id;
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string create_time;
{
int res=mc_pack_put_str(pack,"create_time",_m_create_time.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string start_time;
{
int res=mc_pack_put_str(pack,"start_time",_m_start_time.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string end_time;
{
int res=mc_pack_put_str(pack,"end_time",_m_end_time.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info;
{
int res=mc_pack_put_str(pack,"info",_m_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mobile_music_info_t
static void _mcpack2_load_mobile_music_info_t_ring_id(const mc_pack_item_t*,mobile_music_info_t*);
static void _mcpack2_load_mobile_music_info_t_name(const mc_pack_item_t*,mobile_music_info_t*);
static void _mcpack2_load_mobile_music_info_t_singer(const mc_pack_item_t*,mobile_music_info_t*);
static void _mcpack2_load_mobile_music_info_t_bell_id(const mc_pack_item_t*,mobile_music_info_t*);
static void _mcpack2_load_mobile_music_info_t_song_id(const mc_pack_item_t*,mobile_music_info_t*);
static void _mcpack2_load_mobile_music_info_t_cp_id(const mc_pack_item_t*,mobile_music_info_t*);
static void _mcpack2_load_mobile_music_info_t_date(const mc_pack_item_t*,mobile_music_info_t*);
static void _mcpack2_load_mobile_music_info_t_dolby_flag(const mc_pack_item_t*,mobile_music_info_t*);
static void _mcpack2_load_mobile_music_info_t_status(const mc_pack_item_t*,mobile_music_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mobile_music_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mobile_music_info_t_readmap;
// static initialization.
static bool _mcpack2_load_mobile_music_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mobile_music_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mobile_music_info_t*)>("ring_id",_mcpack2_load_mobile_music_info_t_ring_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mobile_music_info_t*)>("name",_mcpack2_load_mobile_music_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mobile_music_info_t*)>("singer",_mcpack2_load_mobile_music_info_t_singer));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mobile_music_info_t*)>("bell_id",_mcpack2_load_mobile_music_info_t_bell_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mobile_music_info_t*)>("song_id",_mcpack2_load_mobile_music_info_t_song_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mobile_music_info_t*)>("cp_id",_mcpack2_load_mobile_music_info_t_cp_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mobile_music_info_t*)>("date",_mcpack2_load_mobile_music_info_t_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mobile_music_info_t*)>("dolby_flag",_mcpack2_load_mobile_music_info_t_dolby_flag));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mobile_music_info_t*)>("status",_mcpack2_load_mobile_music_info_t_status));
_mcpack2_load_mobile_music_info_t_readmap.create(16*9);
_mcpack2_load_mobile_music_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mobile_music_info_t_static_inited=_mcpack2_load_mobile_music_info_t_static_init();
// @@string ring_id;
static void _mcpack2_load_mobile_music_info_t_ring_id(__attribute__((unused)) const mc_pack_item_t* item,mobile_music_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ring_id";
}
self->_m_ring_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_mobile_music_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,mobile_music_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string singer;
static void _mcpack2_load_mobile_music_info_t_singer(__attribute__((unused)) const mc_pack_item_t* item,mobile_music_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "singer";
}
self->_m_singer.set_ptr(item->value,item->value_size-1);
}
// @@string bell_id;
static void _mcpack2_load_mobile_music_info_t_bell_id(__attribute__((unused)) const mc_pack_item_t* item,mobile_music_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "bell_id";
}
self->_m_bell_id.set_ptr(item->value,item->value_size-1);
}
// @@string song_id;
static void _mcpack2_load_mobile_music_info_t_song_id(__attribute__((unused)) const mc_pack_item_t* item,mobile_music_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "song_id";
}
self->_m_song_id.set_ptr(item->value,item->value_size-1);
}
// @@string cp_id;
static void _mcpack2_load_mobile_music_info_t_cp_id(__attribute__((unused)) const mc_pack_item_t* item,mobile_music_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "cp_id";
}
self->_m_cp_id.set_ptr(item->value,item->value_size-1);
}
// @@string date;
static void _mcpack2_load_mobile_music_info_t_date(__attribute__((unused)) const mc_pack_item_t* item,mobile_music_info_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "date";
}
self->_m_date.set_ptr(item->value,item->value_size-1);
}
// @@string dolby_flag;
static void _mcpack2_load_mobile_music_info_t_dolby_flag(__attribute__((unused)) const mc_pack_item_t* item,mobile_music_info_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "dolby_flag";
}
self->_m_dolby_flag.set_ptr(item->value,item->value_size-1);
}
// @@string status;
static void _mcpack2_load_mobile_music_info_t_status(__attribute__((unused)) const mc_pack_item_t* item,mobile_music_info_t* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "status";
}
self->_m_status.set_ptr(item->value,item->value_size-1);
}
void mobile_music_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mobile_music_info_t*)=0;
do{
if(_mcpack2_load_mobile_music_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mobile_music_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mobile_music_info_t*)=0;
if(_mcpack2_load_mobile_music_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mobile_music_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mobile_music_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string ring_id;
{
int res=mc_pack_put_str(pack,"ring_id",_m_ring_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string singer;
{
int res=mc_pack_put_str(pack,"singer",_m_singer.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string bell_id;
{
int res=mc_pack_put_str(pack,"bell_id",_m_bell_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string song_id;
{
int res=mc_pack_put_str(pack,"song_id",_m_song_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string cp_id;
{
int res=mc_pack_put_str(pack,"cp_id",_m_cp_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string date;
{
int res=mc_pack_put_str(pack,"date",_m_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string dolby_flag;
{
int res=mc_pack_put_str(pack,"dolby_flag",_m_dolby_flag.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string status;
{
int res=mc_pack_put_str(pack,"status",_m_status.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class pt_game_basic_info_t
static void _mcpack2_load_pt_game_basic_info_t_game_id(const mc_pack_item_t*,pt_game_basic_info_t*);
static void _mcpack2_load_pt_game_basic_info_t_name(const mc_pack_item_t*,pt_game_basic_info_t*);
static void _mcpack2_load_pt_game_basic_info_t_app_key(const mc_pack_item_t*,pt_game_basic_info_t*);
static void _mcpack2_load_pt_game_basic_info_t_app_secret(const mc_pack_item_t*,pt_game_basic_info_t*);
static void _mcpack2_load_pt_game_basic_info_t_notify_url(const mc_pack_item_t*,pt_game_basic_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,pt_game_basic_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_pt_game_basic_info_t_readmap;
// static initialization.
static bool _mcpack2_load_pt_game_basic_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,pt_game_basic_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,pt_game_basic_info_t*)>("game_id",_mcpack2_load_pt_game_basic_info_t_game_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,pt_game_basic_info_t*)>("name",_mcpack2_load_pt_game_basic_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,pt_game_basic_info_t*)>("app_key",_mcpack2_load_pt_game_basic_info_t_app_key));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,pt_game_basic_info_t*)>("app_secret",_mcpack2_load_pt_game_basic_info_t_app_secret));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,pt_game_basic_info_t*)>("notify_url",_mcpack2_load_pt_game_basic_info_t_notify_url));
_mcpack2_load_pt_game_basic_info_t_readmap.create(16*5);
_mcpack2_load_pt_game_basic_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_pt_game_basic_info_t_static_inited=_mcpack2_load_pt_game_basic_info_t_static_init();
// @@string game_id;
static void _mcpack2_load_pt_game_basic_info_t_game_id(__attribute__((unused)) const mc_pack_item_t* item,pt_game_basic_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_pt_game_basic_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,pt_game_basic_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string app_key;
static void _mcpack2_load_pt_game_basic_info_t_app_key(__attribute__((unused)) const mc_pack_item_t* item,pt_game_basic_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "app_key";
}
self->_m_app_key.set_ptr(item->value,item->value_size-1);
}
// @@string app_secret;
static void _mcpack2_load_pt_game_basic_info_t_app_secret(__attribute__((unused)) const mc_pack_item_t* item,pt_game_basic_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "app_secret";
}
self->_m_app_secret.set_ptr(item->value,item->value_size-1);
}
// @@string notify_url;
static void _mcpack2_load_pt_game_basic_info_t_notify_url(__attribute__((unused)) const mc_pack_item_t* item,pt_game_basic_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "notify_url";
}
self->_m_notify_url.set_ptr(item->value,item->value_size-1);
}
void pt_game_basic_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,pt_game_basic_info_t*)=0;
do{
if(_mcpack2_load_pt_game_basic_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int pt_game_basic_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,pt_game_basic_info_t*)=0;
if(_mcpack2_load_pt_game_basic_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void pt_game_basic_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t pt_game_basic_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string game_id;
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string app_key;
{
int res=mc_pack_put_str(pack,"app_key",_m_app_key.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string app_secret;
{
int res=mc_pack_put_str(pack,"app_secret",_m_app_secret.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string notify_url;
{
int res=mc_pack_put_str(pack,"notify_url",_m_notify_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class calender_info_t
static void _mcpack2_load_calender_info_t_id(const mc_pack_item_t*,calender_info_t*);
static void _mcpack2_load_calender_info_t_title(const mc_pack_item_t*,calender_info_t*);
static void _mcpack2_load_calender_info_t_type(const mc_pack_item_t*,calender_info_t*);
static void _mcpack2_load_calender_info_t_c_id(const mc_pack_item_t*,calender_info_t*);
static void _mcpack2_load_calender_info_t_date(const mc_pack_item_t*,calender_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,calender_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_calender_info_t_readmap;
// static initialization.
static bool _mcpack2_load_calender_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,calender_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,calender_info_t*)>("id",_mcpack2_load_calender_info_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,calender_info_t*)>("title",_mcpack2_load_calender_info_t_title));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,calender_info_t*)>("type",_mcpack2_load_calender_info_t_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,calender_info_t*)>("c_id",_mcpack2_load_calender_info_t_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,calender_info_t*)>("date",_mcpack2_load_calender_info_t_date));
_mcpack2_load_calender_info_t_readmap.create(16*5);
_mcpack2_load_calender_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_calender_info_t_static_inited=_mcpack2_load_calender_info_t_static_init();
// @@string id;
static void _mcpack2_load_calender_info_t_id(__attribute__((unused)) const mc_pack_item_t* item,calender_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string title;
static void _mcpack2_load_calender_info_t_title(__attribute__((unused)) const mc_pack_item_t* item,calender_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "title";
}
self->_m_title.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t type;
static void _mcpack2_load_calender_info_t_type(__attribute__((unused)) const mc_pack_item_t* item,calender_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type";
}
}
// @@string c_id;
static void _mcpack2_load_calender_info_t_c_id(__attribute__((unused)) const mc_pack_item_t* item,calender_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string date;
static void _mcpack2_load_calender_info_t_date(__attribute__((unused)) const mc_pack_item_t* item,calender_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "date";
}
self->_m_date.set_ptr(item->value,item->value_size-1);
}
void calender_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,calender_info_t*)=0;
do{
if(_mcpack2_load_calender_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int calender_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,calender_info_t*)=0;
if(_mcpack2_load_calender_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void calender_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t calender_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string title;
{
int res=mc_pack_put_str(pack,"title",_m_title.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t type;
{
int res=mc_pack_put_uint32(pack,"type",_m_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id;
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string date;
{
int res=mc_pack_put_str(pack,"date",_m_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class soft_info_t
static void _mcpack2_load_soft_info_t_type_id(const mc_pack_item_t*,soft_info_t*);
static void _mcpack2_load_soft_info_t_id(const mc_pack_item_t*,soft_info_t*);
static void _mcpack2_load_soft_info_t_name(const mc_pack_item_t*,soft_info_t*);
static void _mcpack2_load_soft_info_t_icon(const mc_pack_item_t*,soft_info_t*);
static void _mcpack2_load_soft_info_t_preview(const mc_pack_item_t*,soft_info_t*);
static void _mcpack2_load_soft_info_t_version(const mc_pack_item_t*,soft_info_t*);
static void _mcpack2_load_soft_info_t_size(const mc_pack_item_t*,soft_info_t*);
static void _mcpack2_load_soft_info_t_pop(const mc_pack_item_t*,soft_info_t*);
static void _mcpack2_load_soft_info_t_adapt(const mc_pack_item_t*,soft_info_t*);
static void _mcpack2_load_soft_info_t_date(const mc_pack_item_t*,soft_info_t*);
static void _mcpack2_load_soft_info_t_froms(const mc_pack_item_t*,soft_info_t*);
static void _mcpack2_load_soft_info_t_info(const mc_pack_item_t*,soft_info_t*);
static void _mcpack2_load_soft_info_t_down_url(const mc_pack_item_t*,soft_info_t*);
static void _mcpack2_load_soft_info_t_star(const mc_pack_item_t*,soft_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,soft_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_soft_info_t_readmap;
// static initialization.
static bool _mcpack2_load_soft_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,soft_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("type_id",_mcpack2_load_soft_info_t_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("id",_mcpack2_load_soft_info_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("name",_mcpack2_load_soft_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("icon",_mcpack2_load_soft_info_t_icon));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("preview",_mcpack2_load_soft_info_t_preview));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("version",_mcpack2_load_soft_info_t_version));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("size",_mcpack2_load_soft_info_t_size));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("pop",_mcpack2_load_soft_info_t_pop));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("adapt",_mcpack2_load_soft_info_t_adapt));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("date",_mcpack2_load_soft_info_t_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("froms",_mcpack2_load_soft_info_t_froms));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("info",_mcpack2_load_soft_info_t_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("down_url",_mcpack2_load_soft_info_t_down_url));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,soft_info_t*)>("star",_mcpack2_load_soft_info_t_star));
_mcpack2_load_soft_info_t_readmap.create(16*14);
_mcpack2_load_soft_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_soft_info_t_static_inited=_mcpack2_load_soft_info_t_static_init();
// @@string type_id;
static void _mcpack2_load_soft_info_t_type_id(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@string id;
static void _mcpack2_load_soft_info_t_id(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_soft_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string icon;
static void _mcpack2_load_soft_info_t_icon(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "icon";
}
self->_m_icon.set_ptr(item->value,item->value_size-1);
}
// @@string preview;
static void _mcpack2_load_soft_info_t_preview(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "preview";
}
self->_m_preview.set_ptr(item->value,item->value_size-1);
}
// @@string version;
static void _mcpack2_load_soft_info_t_version(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "version";
}
self->_m_version.set_ptr(item->value,item->value_size-1);
}
// @@string size;
static void _mcpack2_load_soft_info_t_size(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "size";
}
self->_m_size.set_ptr(item->value,item->value_size-1);
}
// @@string pop;
static void _mcpack2_load_soft_info_t_pop(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "pop";
}
self->_m_pop.set_ptr(item->value,item->value_size-1);
}
// @@string adapt;
static void _mcpack2_load_soft_info_t_adapt(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "adapt";
}
self->_m_adapt.set_ptr(item->value,item->value_size-1);
}
// @@string date;
static void _mcpack2_load_soft_info_t_date(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "date";
}
self->_m_date.set_ptr(item->value,item->value_size-1);
}
// @@string froms;
static void _mcpack2_load_soft_info_t_froms(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[10 >> 3] |= (1 << (10 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "froms";
}
self->_m_froms.set_ptr(item->value,item->value_size-1);
}
// @@string info;
static void _mcpack2_load_soft_info_t_info(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[11 >> 3] |= (1 << (11 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info";
}
self->_m_info.set_ptr(item->value,item->value_size-1);
}
// @@string down_url;
static void _mcpack2_load_soft_info_t_down_url(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[12 >> 3] |= (1 << (12 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "down_url";
}
self->_m_down_url.set_ptr(item->value,item->value_size-1);
}
// @@string star;
static void _mcpack2_load_soft_info_t_star(__attribute__((unused)) const mc_pack_item_t* item,soft_info_t* self){
self->_flag[13 >> 3] |= (1 << (13 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "star";
}
self->_m_star.set_ptr(item->value,item->value_size-1);
}
void soft_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,soft_info_t*)=0;
do{
if(_mcpack2_load_soft_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int soft_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,soft_info_t*)=0;
if(_mcpack2_load_soft_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void soft_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t soft_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string type_id;
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string icon;
{
int res=mc_pack_put_str(pack,"icon",_m_icon.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string preview;
{
int res=mc_pack_put_str(pack,"preview",_m_preview.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string version;
{
int res=mc_pack_put_str(pack,"version",_m_version.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string size;
{
int res=mc_pack_put_str(pack,"size",_m_size.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string pop;
{
int res=mc_pack_put_str(pack,"pop",_m_pop.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string adapt;
{
int res=mc_pack_put_str(pack,"adapt",_m_adapt.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string date;
{
int res=mc_pack_put_str(pack,"date",_m_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string froms;
{
int res=mc_pack_put_str(pack,"froms",_m_froms.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info;
{
int res=mc_pack_put_str(pack,"info",_m_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string down_url;
{
int res=mc_pack_put_str(pack,"down_url",_m_down_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string star;
{
int res=mc_pack_put_str(pack,"star",_m_star.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class theme_info_t
static void _mcpack2_load_theme_info_t_type_id(const mc_pack_item_t*,theme_info_t*);
static void _mcpack2_load_theme_info_t_id(const mc_pack_item_t*,theme_info_t*);
static void _mcpack2_load_theme_info_t_name(const mc_pack_item_t*,theme_info_t*);
static void _mcpack2_load_theme_info_t_icon(const mc_pack_item_t*,theme_info_t*);
static void _mcpack2_load_theme_info_t_preview(const mc_pack_item_t*,theme_info_t*);
static void _mcpack2_load_theme_info_t_size(const mc_pack_item_t*,theme_info_t*);
static void _mcpack2_load_theme_info_t_pop(const mc_pack_item_t*,theme_info_t*);
static void _mcpack2_load_theme_info_t_adapt(const mc_pack_item_t*,theme_info_t*);
static void _mcpack2_load_theme_info_t_date(const mc_pack_item_t*,theme_info_t*);
static void _mcpack2_load_theme_info_t_froms(const mc_pack_item_t*,theme_info_t*);
static void _mcpack2_load_theme_info_t_info(const mc_pack_item_t*,theme_info_t*);
static void _mcpack2_load_theme_info_t_down_url(const mc_pack_item_t*,theme_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,theme_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_theme_info_t_readmap;
// static initialization.
static bool _mcpack2_load_theme_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,theme_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,theme_info_t*)>("type_id",_mcpack2_load_theme_info_t_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,theme_info_t*)>("id",_mcpack2_load_theme_info_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,theme_info_t*)>("name",_mcpack2_load_theme_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,theme_info_t*)>("icon",_mcpack2_load_theme_info_t_icon));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,theme_info_t*)>("preview",_mcpack2_load_theme_info_t_preview));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,theme_info_t*)>("size",_mcpack2_load_theme_info_t_size));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,theme_info_t*)>("pop",_mcpack2_load_theme_info_t_pop));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,theme_info_t*)>("adapt",_mcpack2_load_theme_info_t_adapt));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,theme_info_t*)>("date",_mcpack2_load_theme_info_t_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,theme_info_t*)>("froms",_mcpack2_load_theme_info_t_froms));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,theme_info_t*)>("info",_mcpack2_load_theme_info_t_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,theme_info_t*)>("down_url",_mcpack2_load_theme_info_t_down_url));
_mcpack2_load_theme_info_t_readmap.create(16*12);
_mcpack2_load_theme_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_theme_info_t_static_inited=_mcpack2_load_theme_info_t_static_init();
// @@string type_id;
static void _mcpack2_load_theme_info_t_type_id(__attribute__((unused)) const mc_pack_item_t* item,theme_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@string id;
static void _mcpack2_load_theme_info_t_id(__attribute__((unused)) const mc_pack_item_t* item,theme_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_theme_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,theme_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string icon;
static void _mcpack2_load_theme_info_t_icon(__attribute__((unused)) const mc_pack_item_t* item,theme_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "icon";
}
self->_m_icon.set_ptr(item->value,item->value_size-1);
}
// @@string preview;
static void _mcpack2_load_theme_info_t_preview(__attribute__((unused)) const mc_pack_item_t* item,theme_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "preview";
}
self->_m_preview.set_ptr(item->value,item->value_size-1);
}
// @@string size;
static void _mcpack2_load_theme_info_t_size(__attribute__((unused)) const mc_pack_item_t* item,theme_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "size";
}
self->_m_size.set_ptr(item->value,item->value_size-1);
}
// @@string pop;
static void _mcpack2_load_theme_info_t_pop(__attribute__((unused)) const mc_pack_item_t* item,theme_info_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "pop";
}
self->_m_pop.set_ptr(item->value,item->value_size-1);
}
// @@string adapt;
static void _mcpack2_load_theme_info_t_adapt(__attribute__((unused)) const mc_pack_item_t* item,theme_info_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "adapt";
}
self->_m_adapt.set_ptr(item->value,item->value_size-1);
}
// @@string date;
static void _mcpack2_load_theme_info_t_date(__attribute__((unused)) const mc_pack_item_t* item,theme_info_t* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "date";
}
self->_m_date.set_ptr(item->value,item->value_size-1);
}
// @@string froms;
static void _mcpack2_load_theme_info_t_froms(__attribute__((unused)) const mc_pack_item_t* item,theme_info_t* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "froms";
}
self->_m_froms.set_ptr(item->value,item->value_size-1);
}
// @@string info;
static void _mcpack2_load_theme_info_t_info(__attribute__((unused)) const mc_pack_item_t* item,theme_info_t* self){
self->_flag[10 >> 3] |= (1 << (10 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info";
}
self->_m_info.set_ptr(item->value,item->value_size-1);
}
// @@string down_url;
static void _mcpack2_load_theme_info_t_down_url(__attribute__((unused)) const mc_pack_item_t* item,theme_info_t* self){
self->_flag[11 >> 3] |= (1 << (11 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "down_url";
}
self->_m_down_url.set_ptr(item->value,item->value_size-1);
}
void theme_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,theme_info_t*)=0;
do{
if(_mcpack2_load_theme_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int theme_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,theme_info_t*)=0;
if(_mcpack2_load_theme_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void theme_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t theme_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string type_id;
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string icon;
{
int res=mc_pack_put_str(pack,"icon",_m_icon.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string preview;
{
int res=mc_pack_put_str(pack,"preview",_m_preview.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string size;
{
int res=mc_pack_put_str(pack,"size",_m_size.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string pop;
{
int res=mc_pack_put_str(pack,"pop",_m_pop.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string adapt;
{
int res=mc_pack_put_str(pack,"adapt",_m_adapt.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string date;
{
int res=mc_pack_put_str(pack,"date",_m_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string froms;
{
int res=mc_pack_put_str(pack,"froms",_m_froms.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info;
{
int res=mc_pack_put_str(pack,"info",_m_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string down_url;
{
int res=mc_pack_put_str(pack,"down_url",_m_down_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class music_info_t
static void _mcpack2_load_music_info_t_music_id(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_songname(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_area_id(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_area_name(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_cp_id(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_cp_name(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_language_id(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_language(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_publish_date(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_intro(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_lyric_writer(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_composer(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_price(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_discount(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_download_base(const mc_pack_item_t*,music_info_t*);
static void _mcpack2_load_music_info_t_lyric_txt(const mc_pack_item_t*,music_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,music_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_music_info_t_readmap;
// static initialization.
static bool _mcpack2_load_music_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,music_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("music_id",_mcpack2_load_music_info_t_music_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("songname",_mcpack2_load_music_info_t_songname));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("area_id",_mcpack2_load_music_info_t_area_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("area_name",_mcpack2_load_music_info_t_area_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("cp_id",_mcpack2_load_music_info_t_cp_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("cp_name",_mcpack2_load_music_info_t_cp_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("language_id",_mcpack2_load_music_info_t_language_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("language",_mcpack2_load_music_info_t_language));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("publish_date",_mcpack2_load_music_info_t_publish_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("intro",_mcpack2_load_music_info_t_intro));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("lyric_writer",_mcpack2_load_music_info_t_lyric_writer));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("composer",_mcpack2_load_music_info_t_composer));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("price",_mcpack2_load_music_info_t_price));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("discount",_mcpack2_load_music_info_t_discount));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("download_base",_mcpack2_load_music_info_t_download_base));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,music_info_t*)>("lyric_txt",_mcpack2_load_music_info_t_lyric_txt));
_mcpack2_load_music_info_t_readmap.create(16*16);
_mcpack2_load_music_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_music_info_t_static_inited=_mcpack2_load_music_info_t_static_init();
// @@string music_id;
static void _mcpack2_load_music_info_t_music_id(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "music_id";
}
self->_m_music_id.set_ptr(item->value,item->value_size-1);
}
// @@string songname;
static void _mcpack2_load_music_info_t_songname(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "songname";
}
self->_m_songname.set_ptr(item->value,item->value_size-1);
}
// @@string area_id;
static void _mcpack2_load_music_info_t_area_id(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "area_id";
}
self->_m_area_id.set_ptr(item->value,item->value_size-1);
}
// @@string area_name;
static void _mcpack2_load_music_info_t_area_name(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "area_name";
}
self->_m_area_name.set_ptr(item->value,item->value_size-1);
}
// @@string cp_id;
static void _mcpack2_load_music_info_t_cp_id(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "cp_id";
}
self->_m_cp_id.set_ptr(item->value,item->value_size-1);
}
// @@string cp_name;
static void _mcpack2_load_music_info_t_cp_name(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "cp_name";
}
self->_m_cp_name.set_ptr(item->value,item->value_size-1);
}
// @@string language_id;
static void _mcpack2_load_music_info_t_language_id(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "language_id";
}
self->_m_language_id.set_ptr(item->value,item->value_size-1);
}
// @@string language;
static void _mcpack2_load_music_info_t_language(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "language";
}
self->_m_language.set_ptr(item->value,item->value_size-1);
}
// @@string publish_date;
static void _mcpack2_load_music_info_t_publish_date(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "publish_date";
}
self->_m_publish_date.set_ptr(item->value,item->value_size-1);
}
// @@string intro;
static void _mcpack2_load_music_info_t_intro(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "intro";
}
self->_m_intro.set_ptr(item->value,item->value_size-1);
}
// @@string lyric_writer;
static void _mcpack2_load_music_info_t_lyric_writer(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[10 >> 3] |= (1 << (10 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "lyric_writer";
}
self->_m_lyric_writer.set_ptr(item->value,item->value_size-1);
}
// @@string composer;
static void _mcpack2_load_music_info_t_composer(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[11 >> 3] |= (1 << (11 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "composer";
}
self->_m_composer.set_ptr(item->value,item->value_size-1);
}
// @@string price;
static void _mcpack2_load_music_info_t_price(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[12 >> 3] |= (1 << (12 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "price";
}
self->_m_price.set_ptr(item->value,item->value_size-1);
}
// @@string discount;
static void _mcpack2_load_music_info_t_discount(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[13 >> 3] |= (1 << (13 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "discount";
}
self->_m_discount.set_ptr(item->value,item->value_size-1);
}
// @@string download_base;
static void _mcpack2_load_music_info_t_download_base(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[14 >> 3] |= (1 << (14 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "download_base";
}
self->_m_download_base.set_ptr(item->value,item->value_size-1);
}
// @@string lyric_txt;
static void _mcpack2_load_music_info_t_lyric_txt(__attribute__((unused)) const mc_pack_item_t* item,music_info_t* self){
self->_flag[15 >> 3] |= (1 << (15 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "lyric_txt";
}
self->_m_lyric_txt.set_ptr(item->value,item->value_size-1);
}
void music_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,music_info_t*)=0;
do{
if(_mcpack2_load_music_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int music_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,music_info_t*)=0;
if(_mcpack2_load_music_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void music_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t music_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string music_id;
{
int res=mc_pack_put_str(pack,"music_id",_m_music_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string songname;
{
int res=mc_pack_put_str(pack,"songname",_m_songname.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string area_id;
{
int res=mc_pack_put_str(pack,"area_id",_m_area_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string area_name;
{
int res=mc_pack_put_str(pack,"area_name",_m_area_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string cp_id;
{
int res=mc_pack_put_str(pack,"cp_id",_m_cp_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string cp_name;
{
int res=mc_pack_put_str(pack,"cp_name",_m_cp_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string language_id;
{
int res=mc_pack_put_str(pack,"language_id",_m_language_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string language;
{
int res=mc_pack_put_str(pack,"language",_m_language.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string publish_date;
{
int res=mc_pack_put_str(pack,"publish_date",_m_publish_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string intro;
{
int res=mc_pack_put_str(pack,"intro",_m_intro.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string lyric_writer;
{
int res=mc_pack_put_str(pack,"lyric_writer",_m_lyric_writer.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string composer;
{
int res=mc_pack_put_str(pack,"composer",_m_composer.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string price;
{
int res=mc_pack_put_str(pack,"price",_m_price.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string discount;
{
int res=mc_pack_put_str(pack,"discount",_m_discount.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string download_base;
{
int res=mc_pack_put_str(pack,"download_base",_m_download_base.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string lyric_txt;
{
int res=mc_pack_put_str(pack,"lyric_txt",_m_lyric_txt.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class cp_info_t
static void _mcpack2_load_cp_info_t_id(const mc_pack_item_t*,cp_info_t*);
static void _mcpack2_load_cp_info_t_name(const mc_pack_item_t*,cp_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,cp_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_cp_info_t_readmap;
// static initialization.
static bool _mcpack2_load_cp_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,cp_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,cp_info_t*)>("id",_mcpack2_load_cp_info_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,cp_info_t*)>("name",_mcpack2_load_cp_info_t_name));
_mcpack2_load_cp_info_t_readmap.create(16*2);
_mcpack2_load_cp_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_cp_info_t_static_inited=_mcpack2_load_cp_info_t_static_init();
// @@string id;
static void _mcpack2_load_cp_info_t_id(__attribute__((unused)) const mc_pack_item_t* item,cp_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_cp_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,cp_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
void cp_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,cp_info_t*)=0;
do{
if(_mcpack2_load_cp_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int cp_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,cp_info_t*)=0;
if(_mcpack2_load_cp_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void cp_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t cp_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class grant_detail_t
static void _mcpack2_load_grant_detail_t_id(const mc_pack_item_t*,grant_detail_t*);
static void _mcpack2_load_grant_detail_t_grant_time(const mc_pack_item_t*,grant_detail_t*);
static void _mcpack2_load_grant_detail_t_valid_time(const mc_pack_item_t*,grant_detail_t*);
static void _mcpack2_load_grant_detail_t_modify_time(const mc_pack_item_t*,grant_detail_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,grant_detail_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_grant_detail_t_readmap;
// static initialization.
static bool _mcpack2_load_grant_detail_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,grant_detail_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grant_detail_t*)>("id",_mcpack2_load_grant_detail_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grant_detail_t*)>("grant_time",_mcpack2_load_grant_detail_t_grant_time));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grant_detail_t*)>("valid_time",_mcpack2_load_grant_detail_t_valid_time));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,grant_detail_t*)>("modify_time",_mcpack2_load_grant_detail_t_modify_time));
_mcpack2_load_grant_detail_t_readmap.create(16*4);
_mcpack2_load_grant_detail_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_grant_detail_t_static_inited=_mcpack2_load_grant_detail_t_static_init();
// @@string id;
static void _mcpack2_load_grant_detail_t_id(__attribute__((unused)) const mc_pack_item_t* item,grant_detail_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string grant_time;
static void _mcpack2_load_grant_detail_t_grant_time(__attribute__((unused)) const mc_pack_item_t* item,grant_detail_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "grant_time";
}
self->_m_grant_time.set_ptr(item->value,item->value_size-1);
}
// @@string valid_time;
static void _mcpack2_load_grant_detail_t_valid_time(__attribute__((unused)) const mc_pack_item_t* item,grant_detail_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "valid_time";
}
self->_m_valid_time.set_ptr(item->value,item->value_size-1);
}
// @@string modify_time;
static void _mcpack2_load_grant_detail_t_modify_time(__attribute__((unused)) const mc_pack_item_t* item,grant_detail_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "modify_time";
}
self->_m_modify_time.set_ptr(item->value,item->value_size-1);
}
void grant_detail_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,grant_detail_t*)=0;
do{
if(_mcpack2_load_grant_detail_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int grant_detail_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,grant_detail_t*)=0;
if(_mcpack2_load_grant_detail_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void grant_detail_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t grant_detail_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string grant_time;
{
int res=mc_pack_put_str(pack,"grant_time",_m_grant_time.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string valid_time;
{
int res=mc_pack_put_str(pack,"valid_time",_m_valid_time.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string modify_time;
{
int res=mc_pack_put_str(pack,"modify_time",_m_modify_time.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class download_detail_t
static void _mcpack2_load_download_detail_t_id(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_url(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_baidu_url(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_url_type(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_media_format(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_size(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_mtype(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_charge_id(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_charge_value(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_apk_flag(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_channel_info(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_channel_id(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_package_name(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_int_version(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_string_version(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_sdk_version(const mc_pack_item_t*,download_detail_t*);
static void _mcpack2_load_download_detail_t_apk_md5(const mc_pack_item_t*,download_detail_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,download_detail_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_download_detail_t_readmap;
// static initialization.
static bool _mcpack2_load_download_detail_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,download_detail_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("id",_mcpack2_load_download_detail_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("url",_mcpack2_load_download_detail_t_url));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("baidu_url",_mcpack2_load_download_detail_t_baidu_url));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("url_type",_mcpack2_load_download_detail_t_url_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("media_format",_mcpack2_load_download_detail_t_media_format));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("size",_mcpack2_load_download_detail_t_size));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("mtype",_mcpack2_load_download_detail_t_mtype));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("charge_id",_mcpack2_load_download_detail_t_charge_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("charge_value",_mcpack2_load_download_detail_t_charge_value));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("apk_flag",_mcpack2_load_download_detail_t_apk_flag));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("channel_info",_mcpack2_load_download_detail_t_channel_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("channel_id",_mcpack2_load_download_detail_t_channel_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("package_name",_mcpack2_load_download_detail_t_package_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("int_version",_mcpack2_load_download_detail_t_int_version));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("string_version",_mcpack2_load_download_detail_t_string_version));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("sdk_version",_mcpack2_load_download_detail_t_sdk_version));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,download_detail_t*)>("apk_md5",_mcpack2_load_download_detail_t_apk_md5));
_mcpack2_load_download_detail_t_readmap.create(16*17);
_mcpack2_load_download_detail_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_download_detail_t_static_inited=_mcpack2_load_download_detail_t_static_init();
// @@string id;
static void _mcpack2_load_download_detail_t_id(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string url;
static void _mcpack2_load_download_detail_t_url(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "url";
}
self->_m_url.set_ptr(item->value,item->value_size-1);
}
// @@string baidu_url;
static void _mcpack2_load_download_detail_t_baidu_url(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "baidu_url";
}
self->_m_baidu_url.set_ptr(item->value,item->value_size-1);
}
// @@string url_type;
static void _mcpack2_load_download_detail_t_url_type(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "url_type";
}
self->_m_url_type.set_ptr(item->value,item->value_size-1);
}
// @@string media_format;
static void _mcpack2_load_download_detail_t_media_format(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "media_format";
}
self->_m_media_format.set_ptr(item->value,item->value_size-1);
}
// @@string size;
static void _mcpack2_load_download_detail_t_size(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "size";
}
self->_m_size.set_ptr(item->value,item->value_size-1);
}
// @@string mtype;
static void _mcpack2_load_download_detail_t_mtype(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "mtype";
}
self->_m_mtype.set_ptr(item->value,item->value_size-1);
}
// @@string charge_id;
static void _mcpack2_load_download_detail_t_charge_id(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "charge_id";
}
self->_m_charge_id.set_ptr(item->value,item->value_size-1);
}
// @@string charge_value;
static void _mcpack2_load_download_detail_t_charge_value(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "charge_value";
}
self->_m_charge_value.set_ptr(item->value,item->value_size-1);
}
// @@string apk_flag;
static void _mcpack2_load_download_detail_t_apk_flag(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "apk_flag";
}
self->_m_apk_flag.set_ptr(item->value,item->value_size-1);
}
// @@string channel_info;
static void _mcpack2_load_download_detail_t_channel_info(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[10 >> 3] |= (1 << (10 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "channel_info";
}
self->_m_channel_info.set_ptr(item->value,item->value_size-1);
}
// @@string channel_id;
static void _mcpack2_load_download_detail_t_channel_id(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[11 >> 3] |= (1 << (11 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "channel_id";
}
self->_m_channel_id.set_ptr(item->value,item->value_size-1);
}
// @@string package_name;
static void _mcpack2_load_download_detail_t_package_name(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[12 >> 3] |= (1 << (12 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "package_name";
}
self->_m_package_name.set_ptr(item->value,item->value_size-1);
}
// @@string int_version;
static void _mcpack2_load_download_detail_t_int_version(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[13 >> 3] |= (1 << (13 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "int_version";
}
self->_m_int_version.set_ptr(item->value,item->value_size-1);
}
// @@string string_version;
static void _mcpack2_load_download_detail_t_string_version(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[14 >> 3] |= (1 << (14 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "string_version";
}
self->_m_string_version.set_ptr(item->value,item->value_size-1);
}
// @@string sdk_version;
static void _mcpack2_load_download_detail_t_sdk_version(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[15 >> 3] |= (1 << (15 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "sdk_version";
}
self->_m_sdk_version.set_ptr(item->value,item->value_size-1);
}
// @@string apk_md5;
static void _mcpack2_load_download_detail_t_apk_md5(__attribute__((unused)) const mc_pack_item_t* item,download_detail_t* self){
self->_flag[16 >> 3] |= (1 << (16 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "apk_md5";
}
self->_m_apk_md5.set_ptr(item->value,item->value_size-1);
}
void download_detail_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,download_detail_t*)=0;
do{
if(_mcpack2_load_download_detail_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int download_detail_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,download_detail_t*)=0;
if(_mcpack2_load_download_detail_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void download_detail_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t download_detail_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string url;
{
int res=mc_pack_put_str(pack,"url",_m_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string baidu_url;
{
int res=mc_pack_put_str(pack,"baidu_url",_m_baidu_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string url_type;
{
int res=mc_pack_put_str(pack,"url_type",_m_url_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string media_format;
{
int res=mc_pack_put_str(pack,"media_format",_m_media_format.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string size;
{
int res=mc_pack_put_str(pack,"size",_m_size.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string mtype;
{
int res=mc_pack_put_str(pack,"mtype",_m_mtype.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string charge_id;
{
int res=mc_pack_put_str(pack,"charge_id",_m_charge_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string charge_value;
{
int res=mc_pack_put_str(pack,"charge_value",_m_charge_value.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string apk_flag;
{
int res=mc_pack_put_str(pack,"apk_flag",_m_apk_flag.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string channel_info;
{
int res=mc_pack_put_str(pack,"channel_info",_m_channel_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string channel_id;
{
int res=mc_pack_put_str(pack,"channel_id",_m_channel_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string package_name;
{
int res=mc_pack_put_str(pack,"package_name",_m_package_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string int_version;
{
int res=mc_pack_put_str(pack,"int_version",_m_int_version.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string string_version;
{
int res=mc_pack_put_str(pack,"string_version",_m_string_version.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string sdk_version;
{
int res=mc_pack_put_str(pack,"sdk_version",_m_sdk_version.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string apk_md5;
{
int res=mc_pack_put_str(pack,"apk_md5",_m_apk_md5.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class championship_info_t
static void _mcpack2_load_championship_info_t_name(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_game_name(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_union_start_action(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_has_account(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_c_id(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_log_date(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_channel_info(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_start_time(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_end_time(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_join_num(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_award(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_rule(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_total_coins(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_pic_url(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_enable(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_top_award(const mc_pack_item_t*,championship_info_t*);
static void _mcpack2_load_championship_info_t_championship_download_list(const mc_pack_item_t*,championship_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,championship_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_championship_info_t_readmap;
// static initialization.
static bool _mcpack2_load_championship_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,championship_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("name",_mcpack2_load_championship_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("game_name",_mcpack2_load_championship_info_t_game_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("union_start_action",_mcpack2_load_championship_info_t_union_start_action));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("has_account",_mcpack2_load_championship_info_t_has_account));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("c_id",_mcpack2_load_championship_info_t_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("log_date",_mcpack2_load_championship_info_t_log_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("channel_info",_mcpack2_load_championship_info_t_channel_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("start_time",_mcpack2_load_championship_info_t_start_time));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("end_time",_mcpack2_load_championship_info_t_end_time));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("join_num",_mcpack2_load_championship_info_t_join_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("award",_mcpack2_load_championship_info_t_award));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("rule",_mcpack2_load_championship_info_t_rule));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("total_coins",_mcpack2_load_championship_info_t_total_coins));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("pic_url",_mcpack2_load_championship_info_t_pic_url));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("enable",_mcpack2_load_championship_info_t_enable));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("top_award",_mcpack2_load_championship_info_t_top_award));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,championship_info_t*)>("championship_download_list",_mcpack2_load_championship_info_t_championship_download_list));
_mcpack2_load_championship_info_t_readmap.create(16*17);
_mcpack2_load_championship_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_championship_info_t_static_inited=_mcpack2_load_championship_info_t_static_init();
// @@string name;
static void _mcpack2_load_championship_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string game_name;
static void _mcpack2_load_championship_info_t_game_name(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_name";
}
self->_m_game_name.set_ptr(item->value,item->value_size-1);
}
// @@string union_start_action;
static void _mcpack2_load_championship_info_t_union_start_action(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "union_start_action";
}
self->_m_union_start_action.set_ptr(item->value,item->value_size-1);
}
// @@string has_account;
static void _mcpack2_load_championship_info_t_has_account(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "has_account";
}
self->_m_has_account.set_ptr(item->value,item->value_size-1);
}
// @@string c_id;
static void _mcpack2_load_championship_info_t_c_id(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string log_date;
static void _mcpack2_load_championship_info_t_log_date(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "log_date";
}
self->_m_log_date.set_ptr(item->value,item->value_size-1);
}
// @@string channel_info;
static void _mcpack2_load_championship_info_t_channel_info(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "channel_info";
}
self->_m_channel_info.set_ptr(item->value,item->value_size-1);
}
// @@string start_time;
static void _mcpack2_load_championship_info_t_start_time(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "start_time";
}
self->_m_start_time.set_ptr(item->value,item->value_size-1);
}
// @@string end_time;
static void _mcpack2_load_championship_info_t_end_time(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "end_time";
}
self->_m_end_time.set_ptr(item->value,item->value_size-1);
}
// @@string join_num;
static void _mcpack2_load_championship_info_t_join_num(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "join_num";
}
self->_m_join_num.set_ptr(item->value,item->value_size-1);
}
// @@string award;
static void _mcpack2_load_championship_info_t_award(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[10 >> 3] |= (1 << (10 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "award";
}
self->_m_award.set_ptr(item->value,item->value_size-1);
}
// @@string rule;
static void _mcpack2_load_championship_info_t_rule(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[11 >> 3] |= (1 << (11 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "rule";
}
self->_m_rule.set_ptr(item->value,item->value_size-1);
}
// @@string total_coins;
static void _mcpack2_load_championship_info_t_total_coins(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[12 >> 3] |= (1 << (12 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "total_coins";
}
self->_m_total_coins.set_ptr(item->value,item->value_size-1);
}
// @@string pic_url;
static void _mcpack2_load_championship_info_t_pic_url(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[13 >> 3] |= (1 << (13 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "pic_url";
}
self->_m_pic_url.set_ptr(item->value,item->value_size-1);
}
// @@string enable;
static void _mcpack2_load_championship_info_t_enable(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[14 >> 3] |= (1 << (14 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "enable";
}
self->_m_enable.set_ptr(item->value,item->value_size-1);
}
// @@string top_award;
static void _mcpack2_load_championship_info_t_top_award(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[15 >> 3] |= (1 << (15 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "top_award";
}
self->_m_top_award.set_ptr(item->value,item->value_size-1);
}
// @@download_detail_t championship_download_list=array(0);
static void _mcpack2_load_championship_info_t_championship_download_list(__attribute__((unused)) const mc_pack_item_t* item,championship_info_t* self){
self->_flag[16 >> 3] |= (1 << (16 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "championship_download_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_championship_download_list)) lp0=&(self->_m_championship_download_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "championship_download_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "championship_download_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "championship_download_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void championship_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,championship_info_t*)=0;
do{
if(_mcpack2_load_championship_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int championship_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,championship_info_t*)=0;
if(_mcpack2_load_championship_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void championship_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t championship_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_name;
{
int res=mc_pack_put_str(pack,"game_name",_m_game_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string union_start_action;
{
int res=mc_pack_put_str(pack,"union_start_action",_m_union_start_action.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string has_account;
{
int res=mc_pack_put_str(pack,"has_account",_m_has_account.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id;
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string log_date;
{
int res=mc_pack_put_str(pack,"log_date",_m_log_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string channel_info;
{
int res=mc_pack_put_str(pack,"channel_info",_m_channel_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string start_time;
{
int res=mc_pack_put_str(pack,"start_time",_m_start_time.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string end_time;
{
int res=mc_pack_put_str(pack,"end_time",_m_end_time.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string join_num;
{
int res=mc_pack_put_str(pack,"join_num",_m_join_num.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string award;
{
int res=mc_pack_put_str(pack,"award",_m_award.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string rule;
{
int res=mc_pack_put_str(pack,"rule",_m_rule.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string total_coins;
{
int res=mc_pack_put_str(pack,"total_coins",_m_total_coins.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string pic_url;
{
int res=mc_pack_put_str(pack,"pic_url",_m_pic_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string enable;
{
int res=mc_pack_put_str(pack,"enable",_m_enable.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string top_award;
{
int res=mc_pack_put_str(pack,"top_award",_m_top_award.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@download_detail_t championship_download_list=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"championship_download_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_championship_download_list)& lr0=(_m_championship_download_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class content_basic_info_t
static void _mcpack2_load_content_basic_info_t_id(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_name(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_type(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_ext_id(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_abstract_(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_version(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_method(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_star(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_network(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_code(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_log_date(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_mod_date(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_dft_charge_type(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_dft_charge_val(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_enName(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_language(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_adapt(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_package_name(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_version_appinfo(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_sdk_version(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_version_code(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_ptype_0(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_ptype_1(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_ptype_2(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_ptype_3(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_ptype_4(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_pub_props(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_pub_prop_info(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_union_start_action(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_has_account(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_editor_recom(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_show_highspeed(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_bind_resource_id(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_class_info(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_img_info(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_cp_info(const mc_pack_item_t*,content_basic_info_t*);
static void _mcpack2_load_content_basic_info_t_grant_info(const mc_pack_item_t*,content_basic_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_content_basic_info_t_readmap;
// static initialization.
static bool _mcpack2_load_content_basic_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,content_basic_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("id",_mcpack2_load_content_basic_info_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("name",_mcpack2_load_content_basic_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("type",_mcpack2_load_content_basic_info_t_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("ext_id",_mcpack2_load_content_basic_info_t_ext_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("abstract_",_mcpack2_load_content_basic_info_t_abstract_));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("version",_mcpack2_load_content_basic_info_t_version));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("method",_mcpack2_load_content_basic_info_t_method));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("star",_mcpack2_load_content_basic_info_t_star));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("network",_mcpack2_load_content_basic_info_t_network));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("code",_mcpack2_load_content_basic_info_t_code));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("log_date",_mcpack2_load_content_basic_info_t_log_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("mod_date",_mcpack2_load_content_basic_info_t_mod_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("dft_charge_type",_mcpack2_load_content_basic_info_t_dft_charge_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("dft_charge_val",_mcpack2_load_content_basic_info_t_dft_charge_val));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("enName",_mcpack2_load_content_basic_info_t_enName));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("language",_mcpack2_load_content_basic_info_t_language));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("adapt",_mcpack2_load_content_basic_info_t_adapt));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("package_name",_mcpack2_load_content_basic_info_t_package_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("version_appinfo",_mcpack2_load_content_basic_info_t_version_appinfo));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("sdk_version",_mcpack2_load_content_basic_info_t_sdk_version));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("version_code",_mcpack2_load_content_basic_info_t_version_code));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("ptype_0",_mcpack2_load_content_basic_info_t_ptype_0));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("ptype_1",_mcpack2_load_content_basic_info_t_ptype_1));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("ptype_2",_mcpack2_load_content_basic_info_t_ptype_2));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("ptype_3",_mcpack2_load_content_basic_info_t_ptype_3));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("ptype_4",_mcpack2_load_content_basic_info_t_ptype_4));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("pub_props",_mcpack2_load_content_basic_info_t_pub_props));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("pub_prop_info",_mcpack2_load_content_basic_info_t_pub_prop_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("union_start_action",_mcpack2_load_content_basic_info_t_union_start_action));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("has_account",_mcpack2_load_content_basic_info_t_has_account));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("editor_recom",_mcpack2_load_content_basic_info_t_editor_recom));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("show_highspeed",_mcpack2_load_content_basic_info_t_show_highspeed));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("bind_resource_id",_mcpack2_load_content_basic_info_t_bind_resource_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("class_info",_mcpack2_load_content_basic_info_t_class_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("img_info",_mcpack2_load_content_basic_info_t_img_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("cp_info",_mcpack2_load_content_basic_info_t_cp_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_basic_info_t*)>("grant_info",_mcpack2_load_content_basic_info_t_grant_info));
_mcpack2_load_content_basic_info_t_readmap.create(16*37);
_mcpack2_load_content_basic_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_content_basic_info_t_static_inited=_mcpack2_load_content_basic_info_t_static_init();
// @@string id;
static void _mcpack2_load_content_basic_info_t_id(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_content_basic_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string type;
static void _mcpack2_load_content_basic_info_t_type(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type";
}
self->_m_type.set_ptr(item->value,item->value_size-1);
}
// @@string ext_id;
static void _mcpack2_load_content_basic_info_t_ext_id(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ext_id";
}
self->_m_ext_id.set_ptr(item->value,item->value_size-1);
}
// @@string abstract_;
static void _mcpack2_load_content_basic_info_t_abstract_(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "abstract_";
}
self->_m_abstract_.set_ptr(item->value,item->value_size-1);
}
// @@string version;
static void _mcpack2_load_content_basic_info_t_version(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "version";
}
self->_m_version.set_ptr(item->value,item->value_size-1);
}
// @@string method;
static void _mcpack2_load_content_basic_info_t_method(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "method";
}
self->_m_method.set_ptr(item->value,item->value_size-1);
}
// @@string star;
static void _mcpack2_load_content_basic_info_t_star(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "star";
}
self->_m_star.set_ptr(item->value,item->value_size-1);
}
// @@string network;
static void _mcpack2_load_content_basic_info_t_network(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "network";
}
self->_m_network.set_ptr(item->value,item->value_size-1);
}
// @@string code;
static void _mcpack2_load_content_basic_info_t_code(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "code";
}
self->_m_code.set_ptr(item->value,item->value_size-1);
}
// @@string log_date;
static void _mcpack2_load_content_basic_info_t_log_date(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[10 >> 3] |= (1 << (10 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "log_date";
}
self->_m_log_date.set_ptr(item->value,item->value_size-1);
}
// @@string mod_date;
static void _mcpack2_load_content_basic_info_t_mod_date(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[11 >> 3] |= (1 << (11 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "mod_date";
}
self->_m_mod_date.set_ptr(item->value,item->value_size-1);
}
// @@string dft_charge_type;
static void _mcpack2_load_content_basic_info_t_dft_charge_type(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[12 >> 3] |= (1 << (12 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "dft_charge_type";
}
self->_m_dft_charge_type.set_ptr(item->value,item->value_size-1);
}
// @@string dft_charge_val;
static void _mcpack2_load_content_basic_info_t_dft_charge_val(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[13 >> 3] |= (1 << (13 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "dft_charge_val";
}
self->_m_dft_charge_val.set_ptr(item->value,item->value_size-1);
}
// @@string enName;
static void _mcpack2_load_content_basic_info_t_enName(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[14 >> 3] |= (1 << (14 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "enName";
}
self->_m_enName.set_ptr(item->value,item->value_size-1);
}
// @@string language;
static void _mcpack2_load_content_basic_info_t_language(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[15 >> 3] |= (1 << (15 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "language";
}
self->_m_language.set_ptr(item->value,item->value_size-1);
}
// @@string adapt;
static void _mcpack2_load_content_basic_info_t_adapt(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[16 >> 3] |= (1 << (16 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "adapt";
}
self->_m_adapt.set_ptr(item->value,item->value_size-1);
}
// @@string package_name;
static void _mcpack2_load_content_basic_info_t_package_name(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[17 >> 3] |= (1 << (17 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "package_name";
}
self->_m_package_name.set_ptr(item->value,item->value_size-1);
}
// @@string version_appinfo;
static void _mcpack2_load_content_basic_info_t_version_appinfo(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[18 >> 3] |= (1 << (18 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "version_appinfo";
}
self->_m_version_appinfo.set_ptr(item->value,item->value_size-1);
}
// @@string sdk_version;
static void _mcpack2_load_content_basic_info_t_sdk_version(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[19 >> 3] |= (1 << (19 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "sdk_version";
}
self->_m_sdk_version.set_ptr(item->value,item->value_size-1);
}
// @@string version_code;
static void _mcpack2_load_content_basic_info_t_version_code(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[20 >> 3] |= (1 << (20 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "version_code";
}
self->_m_version_code.set_ptr(item->value,item->value_size-1);
}
// @@string ptype_0;
static void _mcpack2_load_content_basic_info_t_ptype_0(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[21 >> 3] |= (1 << (21 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ptype_0";
}
self->_m_ptype_0.set_ptr(item->value,item->value_size-1);
}
// @@string ptype_1;
static void _mcpack2_load_content_basic_info_t_ptype_1(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[22 >> 3] |= (1 << (22 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ptype_1";
}
self->_m_ptype_1.set_ptr(item->value,item->value_size-1);
}
// @@string ptype_2;
static void _mcpack2_load_content_basic_info_t_ptype_2(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[23 >> 3] |= (1 << (23 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ptype_2";
}
self->_m_ptype_2.set_ptr(item->value,item->value_size-1);
}
// @@string ptype_3;
static void _mcpack2_load_content_basic_info_t_ptype_3(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[24 >> 3] |= (1 << (24 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ptype_3";
}
self->_m_ptype_3.set_ptr(item->value,item->value_size-1);
}
// @@string ptype_4;
static void _mcpack2_load_content_basic_info_t_ptype_4(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[25 >> 3] |= (1 << (25 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ptype_4";
}
self->_m_ptype_4.set_ptr(item->value,item->value_size-1);
}
// @@string pub_props=array(0);
static void _mcpack2_load_content_basic_info_t_pub_props(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[26 >> 3] |= (1 << (26 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_props";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_pub_props)) lp0=&(self->_m_pub_props);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_props";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "pub_props";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_props";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@pub_prop_info_t pub_prop_info=array(0);
static void _mcpack2_load_content_basic_info_t_pub_prop_info(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[27 >> 3] |= (1 << (27 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_prop_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_pub_prop_info)) lp0=&(self->_m_pub_prop_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_prop_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_prop_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_prop_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string union_start_action;
static void _mcpack2_load_content_basic_info_t_union_start_action(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[28 >> 3] |= (1 << (28 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "union_start_action";
}
self->_m_union_start_action.set_ptr(item->value,item->value_size-1);
}
// @@string has_account;
static void _mcpack2_load_content_basic_info_t_has_account(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[29 >> 3] |= (1 << (29 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "has_account";
}
self->_m_has_account.set_ptr(item->value,item->value_size-1);
}
// @@string editor_recom;
static void _mcpack2_load_content_basic_info_t_editor_recom(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[30 >> 3] |= (1 << (30 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "editor_recom";
}
self->_m_editor_recom.set_ptr(item->value,item->value_size-1);
}
// @@string show_highspeed;
static void _mcpack2_load_content_basic_info_t_show_highspeed(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[31 >> 3] |= (1 << (31 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "show_highspeed";
}
self->_m_show_highspeed.set_ptr(item->value,item->value_size-1);
}
// @@string bind_resource_id;
static void _mcpack2_load_content_basic_info_t_bind_resource_id(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[32 >> 3] |= (1 << (32 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "bind_resource_id";
}
self->_m_bind_resource_id.set_ptr(item->value,item->value_size-1);
}
// @@class_info_t class_info=array(0);
static void _mcpack2_load_content_basic_info_t_class_info(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[33 >> 3] |= (1 << (33 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_class_info)) lp0=&(self->_m_class_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@img_info_t img_info=array(0);
static void _mcpack2_load_content_basic_info_t_img_info(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[34 >> 3] |= (1 << (34 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_img_info)) lp0=&(self->_m_img_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@cp_info_t cp_info;
static void _mcpack2_load_content_basic_info_t_cp_info(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[35 >> 3] |= (1 << (35 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_cp_info){
self->_m_cp_info=::idl::cp_info_t::create(self->_pool);
}
self->_m_cp_info->LoadWithoutCheck(pack);
}
// @@grant_detail_t grant_info;
static void _mcpack2_load_content_basic_info_t_grant_info(__attribute__((unused)) const mc_pack_item_t* item,content_basic_info_t* self){
self->_flag[36 >> 3] |= (1 << (36 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_grant_info){
self->_m_grant_info=::idl::grant_detail_t::create(self->_pool);
}
self->_m_grant_info->LoadWithoutCheck(pack);
}
void content_basic_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,content_basic_info_t*)=0;
do{
if(_mcpack2_load_content_basic_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int content_basic_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,content_basic_info_t*)=0;
if(_mcpack2_load_content_basic_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void content_basic_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t content_basic_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type;
{
int res=mc_pack_put_str(pack,"type",_m_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ext_id;
{
int res=mc_pack_put_str(pack,"ext_id",_m_ext_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string abstract_;
{
int res=mc_pack_put_str(pack,"abstract_",_m_abstract_.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string version;
{
int res=mc_pack_put_str(pack,"version",_m_version.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string method;
{
int res=mc_pack_put_str(pack,"method",_m_method.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string star;
{
int res=mc_pack_put_str(pack,"star",_m_star.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string network;
{
int res=mc_pack_put_str(pack,"network",_m_network.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string code;
{
int res=mc_pack_put_str(pack,"code",_m_code.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string log_date;
{
int res=mc_pack_put_str(pack,"log_date",_m_log_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string mod_date;
{
int res=mc_pack_put_str(pack,"mod_date",_m_mod_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string dft_charge_type;
{
int res=mc_pack_put_str(pack,"dft_charge_type",_m_dft_charge_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string dft_charge_val;
{
int res=mc_pack_put_str(pack,"dft_charge_val",_m_dft_charge_val.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string enName;
{
int res=mc_pack_put_str(pack,"enName",_m_enName.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string language;
{
int res=mc_pack_put_str(pack,"language",_m_language.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string adapt;
{
int res=mc_pack_put_str(pack,"adapt",_m_adapt.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string package_name;
{
int res=mc_pack_put_str(pack,"package_name",_m_package_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string version_appinfo;
{
int res=mc_pack_put_str(pack,"version_appinfo",_m_version_appinfo.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string sdk_version;
{
int res=mc_pack_put_str(pack,"sdk_version",_m_sdk_version.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string version_code;
{
int res=mc_pack_put_str(pack,"version_code",_m_version_code.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ptype_0;
{
int res=mc_pack_put_str(pack,"ptype_0",_m_ptype_0.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ptype_1;
{
int res=mc_pack_put_str(pack,"ptype_1",_m_ptype_1.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ptype_2;
{
int res=mc_pack_put_str(pack,"ptype_2",_m_ptype_2.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ptype_3;
{
int res=mc_pack_put_str(pack,"ptype_3",_m_ptype_3.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ptype_4;
{
int res=mc_pack_put_str(pack,"ptype_4",_m_ptype_4.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string pub_props=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"pub_props");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_pub_props)& lr0=(_m_pub_props);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@pub_prop_info_t pub_prop_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"pub_prop_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_pub_prop_info)& lr0=(_m_pub_prop_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string union_start_action;
{
int res=mc_pack_put_str(pack,"union_start_action",_m_union_start_action.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string has_account;
{
int res=mc_pack_put_str(pack,"has_account",_m_has_account.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string editor_recom;
{
int res=mc_pack_put_str(pack,"editor_recom",_m_editor_recom.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string show_highspeed;
{
int res=mc_pack_put_str(pack,"show_highspeed",_m_show_highspeed.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string bind_resource_id;
{
int res=mc_pack_put_str(pack,"bind_resource_id",_m_bind_resource_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@class_info_t class_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"class_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_class_info)& lr0=(_m_class_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@img_info_t img_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"img_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_img_info)& lr0=(_m_img_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@cp_info_t cp_info;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"cp_info");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_cp_info->save(subpack);
mc_pack_finish(subpack);
}
// @@grant_detail_t grant_info;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"grant_info");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_grant_info->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class content_detail_t
static void _mcpack2_load_content_detail_t_id(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_name(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_type(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_class_info(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_img_info(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_ext_id(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_abstract_(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_version(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_method(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_star(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_network(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_code(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_log_date(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_mod_date(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_dft_charge_type(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_dft_charge_val(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_enName(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_language(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_adapt(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_package_name(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_version_appinfo(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_sdk_version(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_version_code(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_ptype_0(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_ptype_1(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_ptype_2(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_ptype_3(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_ptype_4(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_pub_props(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_pub_prop_info(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_union_start_action(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_has_account(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_editor_recom(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_show_highspeed(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_cp_info(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_grant_info(const mc_pack_item_t*,content_detail_t*);
static void _mcpack2_load_content_detail_t_download_info(const mc_pack_item_t*,content_detail_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,content_detail_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_content_detail_t_readmap;
// static initialization.
static bool _mcpack2_load_content_detail_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,content_detail_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("id",_mcpack2_load_content_detail_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("name",_mcpack2_load_content_detail_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("type",_mcpack2_load_content_detail_t_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("class_info",_mcpack2_load_content_detail_t_class_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("img_info",_mcpack2_load_content_detail_t_img_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("ext_id",_mcpack2_load_content_detail_t_ext_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("abstract_",_mcpack2_load_content_detail_t_abstract_));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("version",_mcpack2_load_content_detail_t_version));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("method",_mcpack2_load_content_detail_t_method));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("star",_mcpack2_load_content_detail_t_star));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("network",_mcpack2_load_content_detail_t_network));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("code",_mcpack2_load_content_detail_t_code));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("log_date",_mcpack2_load_content_detail_t_log_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("mod_date",_mcpack2_load_content_detail_t_mod_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("dft_charge_type",_mcpack2_load_content_detail_t_dft_charge_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("dft_charge_val",_mcpack2_load_content_detail_t_dft_charge_val));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("enName",_mcpack2_load_content_detail_t_enName));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("language",_mcpack2_load_content_detail_t_language));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("adapt",_mcpack2_load_content_detail_t_adapt));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("package_name",_mcpack2_load_content_detail_t_package_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("version_appinfo",_mcpack2_load_content_detail_t_version_appinfo));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("sdk_version",_mcpack2_load_content_detail_t_sdk_version));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("version_code",_mcpack2_load_content_detail_t_version_code));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("ptype_0",_mcpack2_load_content_detail_t_ptype_0));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("ptype_1",_mcpack2_load_content_detail_t_ptype_1));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("ptype_2",_mcpack2_load_content_detail_t_ptype_2));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("ptype_3",_mcpack2_load_content_detail_t_ptype_3));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("ptype_4",_mcpack2_load_content_detail_t_ptype_4));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("pub_props",_mcpack2_load_content_detail_t_pub_props));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("pub_prop_info",_mcpack2_load_content_detail_t_pub_prop_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("union_start_action",_mcpack2_load_content_detail_t_union_start_action));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("has_account",_mcpack2_load_content_detail_t_has_account));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("editor_recom",_mcpack2_load_content_detail_t_editor_recom));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("show_highspeed",_mcpack2_load_content_detail_t_show_highspeed));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("cp_info",_mcpack2_load_content_detail_t_cp_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("grant_info",_mcpack2_load_content_detail_t_grant_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,content_detail_t*)>("download_info",_mcpack2_load_content_detail_t_download_info));
_mcpack2_load_content_detail_t_readmap.create(16*37);
_mcpack2_load_content_detail_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_content_detail_t_static_inited=_mcpack2_load_content_detail_t_static_init();
// @@string id;
static void _mcpack2_load_content_detail_t_id(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_content_detail_t_name(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string type;
static void _mcpack2_load_content_detail_t_type(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type";
}
self->_m_type.set_ptr(item->value,item->value_size-1);
}
// @@class_info_t class_info=array(0);
static void _mcpack2_load_content_detail_t_class_info(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_class_info)) lp0=&(self->_m_class_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@img_info_t img_info=array(0);
static void _mcpack2_load_content_detail_t_img_info(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_img_info)) lp0=&(self->_m_img_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string ext_id;
static void _mcpack2_load_content_detail_t_ext_id(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ext_id";
}
self->_m_ext_id.set_ptr(item->value,item->value_size-1);
}
// @@string abstract_;
static void _mcpack2_load_content_detail_t_abstract_(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "abstract_";
}
self->_m_abstract_.set_ptr(item->value,item->value_size-1);
}
// @@string version;
static void _mcpack2_load_content_detail_t_version(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "version";
}
self->_m_version.set_ptr(item->value,item->value_size-1);
}
// @@string method;
static void _mcpack2_load_content_detail_t_method(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "method";
}
self->_m_method.set_ptr(item->value,item->value_size-1);
}
// @@string star;
static void _mcpack2_load_content_detail_t_star(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "star";
}
self->_m_star.set_ptr(item->value,item->value_size-1);
}
// @@string network;
static void _mcpack2_load_content_detail_t_network(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[10 >> 3] |= (1 << (10 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "network";
}
self->_m_network.set_ptr(item->value,item->value_size-1);
}
// @@string code;
static void _mcpack2_load_content_detail_t_code(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[11 >> 3] |= (1 << (11 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "code";
}
self->_m_code.set_ptr(item->value,item->value_size-1);
}
// @@string log_date;
static void _mcpack2_load_content_detail_t_log_date(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[12 >> 3] |= (1 << (12 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "log_date";
}
self->_m_log_date.set_ptr(item->value,item->value_size-1);
}
// @@string mod_date;
static void _mcpack2_load_content_detail_t_mod_date(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[13 >> 3] |= (1 << (13 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "mod_date";
}
self->_m_mod_date.set_ptr(item->value,item->value_size-1);
}
// @@string dft_charge_type;
static void _mcpack2_load_content_detail_t_dft_charge_type(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[14 >> 3] |= (1 << (14 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "dft_charge_type";
}
self->_m_dft_charge_type.set_ptr(item->value,item->value_size-1);
}
// @@string dft_charge_val;
static void _mcpack2_load_content_detail_t_dft_charge_val(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[15 >> 3] |= (1 << (15 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "dft_charge_val";
}
self->_m_dft_charge_val.set_ptr(item->value,item->value_size-1);
}
// @@string enName;
static void _mcpack2_load_content_detail_t_enName(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[16 >> 3] |= (1 << (16 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "enName";
}
self->_m_enName.set_ptr(item->value,item->value_size-1);
}
// @@string language;
static void _mcpack2_load_content_detail_t_language(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[17 >> 3] |= (1 << (17 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "language";
}
self->_m_language.set_ptr(item->value,item->value_size-1);
}
// @@string adapt;
static void _mcpack2_load_content_detail_t_adapt(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[18 >> 3] |= (1 << (18 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "adapt";
}
self->_m_adapt.set_ptr(item->value,item->value_size-1);
}
// @@string package_name;
static void _mcpack2_load_content_detail_t_package_name(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[19 >> 3] |= (1 << (19 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "package_name";
}
self->_m_package_name.set_ptr(item->value,item->value_size-1);
}
// @@string version_appinfo;
static void _mcpack2_load_content_detail_t_version_appinfo(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[20 >> 3] |= (1 << (20 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "version_appinfo";
}
self->_m_version_appinfo.set_ptr(item->value,item->value_size-1);
}
// @@string sdk_version;
static void _mcpack2_load_content_detail_t_sdk_version(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[21 >> 3] |= (1 << (21 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "sdk_version";
}
self->_m_sdk_version.set_ptr(item->value,item->value_size-1);
}
// @@string version_code;
static void _mcpack2_load_content_detail_t_version_code(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[22 >> 3] |= (1 << (22 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "version_code";
}
self->_m_version_code.set_ptr(item->value,item->value_size-1);
}
// @@string ptype_0;
static void _mcpack2_load_content_detail_t_ptype_0(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[23 >> 3] |= (1 << (23 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ptype_0";
}
self->_m_ptype_0.set_ptr(item->value,item->value_size-1);
}
// @@string ptype_1;
static void _mcpack2_load_content_detail_t_ptype_1(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[24 >> 3] |= (1 << (24 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ptype_1";
}
self->_m_ptype_1.set_ptr(item->value,item->value_size-1);
}
// @@string ptype_2;
static void _mcpack2_load_content_detail_t_ptype_2(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[25 >> 3] |= (1 << (25 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ptype_2";
}
self->_m_ptype_2.set_ptr(item->value,item->value_size-1);
}
// @@string ptype_3;
static void _mcpack2_load_content_detail_t_ptype_3(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[26 >> 3] |= (1 << (26 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ptype_3";
}
self->_m_ptype_3.set_ptr(item->value,item->value_size-1);
}
// @@string ptype_4;
static void _mcpack2_load_content_detail_t_ptype_4(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[27 >> 3] |= (1 << (27 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ptype_4";
}
self->_m_ptype_4.set_ptr(item->value,item->value_size-1);
}
// @@string pub_props=array(0);
static void _mcpack2_load_content_detail_t_pub_props(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[28 >> 3] |= (1 << (28 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_props";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_pub_props)) lp0=&(self->_m_pub_props);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_props";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "pub_props";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_props";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@pub_prop_info_t pub_prop_info=array(0);
static void _mcpack2_load_content_detail_t_pub_prop_info(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[29 >> 3] |= (1 << (29 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_prop_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_pub_prop_info)) lp0=&(self->_m_pub_prop_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_prop_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_prop_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pub_prop_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string union_start_action;
static void _mcpack2_load_content_detail_t_union_start_action(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[30 >> 3] |= (1 << (30 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "union_start_action";
}
self->_m_union_start_action.set_ptr(item->value,item->value_size-1);
}
// @@string has_account;
static void _mcpack2_load_content_detail_t_has_account(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[31 >> 3] |= (1 << (31 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "has_account";
}
self->_m_has_account.set_ptr(item->value,item->value_size-1);
}
// @@string editor_recom;
static void _mcpack2_load_content_detail_t_editor_recom(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[32 >> 3] |= (1 << (32 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "editor_recom";
}
self->_m_editor_recom.set_ptr(item->value,item->value_size-1);
}
// @@string show_highspeed;
static void _mcpack2_load_content_detail_t_show_highspeed(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[33 >> 3] |= (1 << (33 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "show_highspeed";
}
self->_m_show_highspeed.set_ptr(item->value,item->value_size-1);
}
// @@cp_info_t cp_info;
static void _mcpack2_load_content_detail_t_cp_info(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[34 >> 3] |= (1 << (34 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_cp_info){
self->_m_cp_info=::idl::cp_info_t::create(self->_pool);
}
self->_m_cp_info->LoadWithoutCheck(pack);
}
// @@grant_detail_t grant_info;
static void _mcpack2_load_content_detail_t_grant_info(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[35 >> 3] |= (1 << (35 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_grant_info){
self->_m_grant_info=::idl::grant_detail_t::create(self->_pool);
}
self->_m_grant_info->LoadWithoutCheck(pack);
}
// @@download_detail_t download_info=array(0);
static void _mcpack2_load_content_detail_t_download_info(__attribute__((unused)) const mc_pack_item_t* item,content_detail_t* self){
self->_flag[36 >> 3] |= (1 << (36 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_download_info)) lp0=&(self->_m_download_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void content_detail_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,content_detail_t*)=0;
do{
if(_mcpack2_load_content_detail_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int content_detail_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,content_detail_t*)=0;
if(_mcpack2_load_content_detail_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void content_detail_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t content_detail_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type;
{
int res=mc_pack_put_str(pack,"type",_m_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@class_info_t class_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"class_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_class_info)& lr0=(_m_class_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@img_info_t img_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"img_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_img_info)& lr0=(_m_img_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string ext_id;
{
int res=mc_pack_put_str(pack,"ext_id",_m_ext_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string abstract_;
{
int res=mc_pack_put_str(pack,"abstract_",_m_abstract_.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string version;
{
int res=mc_pack_put_str(pack,"version",_m_version.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string method;
{
int res=mc_pack_put_str(pack,"method",_m_method.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string star;
{
int res=mc_pack_put_str(pack,"star",_m_star.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string network;
{
int res=mc_pack_put_str(pack,"network",_m_network.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string code;
{
int res=mc_pack_put_str(pack,"code",_m_code.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string log_date;
{
int res=mc_pack_put_str(pack,"log_date",_m_log_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string mod_date;
{
int res=mc_pack_put_str(pack,"mod_date",_m_mod_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string dft_charge_type;
{
int res=mc_pack_put_str(pack,"dft_charge_type",_m_dft_charge_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string dft_charge_val;
{
int res=mc_pack_put_str(pack,"dft_charge_val",_m_dft_charge_val.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string enName;
{
int res=mc_pack_put_str(pack,"enName",_m_enName.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string language;
{
int res=mc_pack_put_str(pack,"language",_m_language.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string adapt;
{
int res=mc_pack_put_str(pack,"adapt",_m_adapt.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string package_name;
{
int res=mc_pack_put_str(pack,"package_name",_m_package_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string version_appinfo;
{
int res=mc_pack_put_str(pack,"version_appinfo",_m_version_appinfo.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string sdk_version;
{
int res=mc_pack_put_str(pack,"sdk_version",_m_sdk_version.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string version_code;
{
int res=mc_pack_put_str(pack,"version_code",_m_version_code.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ptype_0;
{
int res=mc_pack_put_str(pack,"ptype_0",_m_ptype_0.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ptype_1;
{
int res=mc_pack_put_str(pack,"ptype_1",_m_ptype_1.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ptype_2;
{
int res=mc_pack_put_str(pack,"ptype_2",_m_ptype_2.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ptype_3;
{
int res=mc_pack_put_str(pack,"ptype_3",_m_ptype_3.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ptype_4;
{
int res=mc_pack_put_str(pack,"ptype_4",_m_ptype_4.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string pub_props=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"pub_props");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_pub_props)& lr0=(_m_pub_props);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@pub_prop_info_t pub_prop_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"pub_prop_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_pub_prop_info)& lr0=(_m_pub_prop_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string union_start_action;
{
int res=mc_pack_put_str(pack,"union_start_action",_m_union_start_action.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string has_account;
{
int res=mc_pack_put_str(pack,"has_account",_m_has_account.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string editor_recom;
{
int res=mc_pack_put_str(pack,"editor_recom",_m_editor_recom.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string show_highspeed;
{
int res=mc_pack_put_str(pack,"show_highspeed",_m_show_highspeed.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@cp_info_t cp_info;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"cp_info");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_cp_info->save(subpack);
mc_pack_finish(subpack);
}
// @@grant_detail_t grant_info;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"grant_info");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_grant_info->save(subpack);
mc_pack_finish(subpack);
}
// @@download_detail_t download_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"download_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_download_info)& lr0=(_m_download_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_content_in_param
static void _mcpack2_load_mcp_content_in_param_type_id(const mc_pack_item_t*,mcp_content_in_param*);
static void _mcpack2_load_mcp_content_in_param_class_id(const mc_pack_item_t*,mcp_content_in_param*);
static void _mcpack2_load_mcp_content_in_param_weight_order(const mc_pack_item_t*,mcp_content_in_param*);
static void _mcpack2_load_mcp_content_in_param_label_id(const mc_pack_item_t*,mcp_content_in_param*);
static void _mcpack2_load_mcp_content_in_param_img_type(const mc_pack_item_t*,mcp_content_in_param*);
static void _mcpack2_load_mcp_content_in_param_column_id(const mc_pack_item_t*,mcp_content_in_param*);
static void _mcpack2_load_mcp_content_in_param_content_id(const mc_pack_item_t*,mcp_content_in_param*);
static void _mcpack2_load_mcp_content_in_param_channel_id(const mc_pack_item_t*,mcp_content_in_param*);
static void _mcpack2_load_mcp_content_in_param_channel_info(const mc_pack_item_t*,mcp_content_in_param*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_content_in_param*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_content_in_param_readmap;
// static initialization.
static bool _mcpack2_load_mcp_content_in_param_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_content_in_param*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_content_in_param*)>("type_id",_mcpack2_load_mcp_content_in_param_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_content_in_param*)>("class_id",_mcpack2_load_mcp_content_in_param_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_content_in_param*)>("weight_order",_mcpack2_load_mcp_content_in_param_weight_order));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_content_in_param*)>("label_id",_mcpack2_load_mcp_content_in_param_label_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_content_in_param*)>("img_type",_mcpack2_load_mcp_content_in_param_img_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_content_in_param*)>("column_id",_mcpack2_load_mcp_content_in_param_column_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_content_in_param*)>("content_id",_mcpack2_load_mcp_content_in_param_content_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_content_in_param*)>("channel_id",_mcpack2_load_mcp_content_in_param_channel_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_content_in_param*)>("channel_info",_mcpack2_load_mcp_content_in_param_channel_info));
_mcpack2_load_mcp_content_in_param_readmap.create(16*9);
_mcpack2_load_mcp_content_in_param_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_content_in_param_static_inited=_mcpack2_load_mcp_content_in_param_static_init();
// @@string type_id;
static void _mcpack2_load_mcp_content_in_param_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_content_in_param* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@string class_id;
static void _mcpack2_load_mcp_content_in_param_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_content_in_param* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
// @@string weight_order;
static void _mcpack2_load_mcp_content_in_param_weight_order(__attribute__((unused)) const mc_pack_item_t* item,mcp_content_in_param* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "weight_order";
}
self->_m_weight_order.set_ptr(item->value,item->value_size-1);
}
// @@string label_id;
static void _mcpack2_load_mcp_content_in_param_label_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_content_in_param* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "label_id";
}
self->_m_label_id.set_ptr(item->value,item->value_size-1);
}
// @@string img_type;
static void _mcpack2_load_mcp_content_in_param_img_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_content_in_param* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "img_type";
}
self->_m_img_type.set_ptr(item->value,item->value_size-1);
}
// @@string column_id;
static void _mcpack2_load_mcp_content_in_param_column_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_content_in_param* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "column_id";
}
self->_m_column_id.set_ptr(item->value,item->value_size-1);
}
// @@string content_id;
static void _mcpack2_load_mcp_content_in_param_content_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_content_in_param* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_id";
}
self->_m_content_id.set_ptr(item->value,item->value_size-1);
}
// @@string channel_id;
static void _mcpack2_load_mcp_content_in_param_channel_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_content_in_param* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "channel_id";
}
self->_m_channel_id.set_ptr(item->value,item->value_size-1);
}
// @@string channel_info;
static void _mcpack2_load_mcp_content_in_param_channel_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_content_in_param* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "channel_info";
}
self->_m_channel_info.set_ptr(item->value,item->value_size-1);
}
void mcp_content_in_param::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_content_in_param*)=0;
do{
if(_mcpack2_load_mcp_content_in_param_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_content_in_param::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_content_in_param*)=0;
if(_mcpack2_load_mcp_content_in_param_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_content_in_param::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_content_in_param::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string type_id;
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string class_id;
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string weight_order;
{
int res=mc_pack_put_str(pack,"weight_order",_m_weight_order.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string label_id;
{
int res=mc_pack_put_str(pack,"label_id",_m_label_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string img_type;
{
int res=mc_pack_put_str(pack,"img_type",_m_img_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string column_id;
{
int res=mc_pack_put_str(pack,"column_id",_m_column_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_id;
{
int res=mc_pack_put_str(pack,"content_id",_m_content_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string channel_id;
{
int res=mc_pack_put_str(pack,"channel_id",_m_channel_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string channel_info;
{
int res=mc_pack_put_str(pack,"channel_info",_m_channel_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class once_consume_goods_t
static void _mcpack2_load_once_consume_goods_t_orderid(const mc_pack_item_t*,once_consume_goods_t*);
static void _mcpack2_load_once_consume_goods_t_itemid(const mc_pack_item_t*,once_consume_goods_t*);
static void _mcpack2_load_once_consume_goods_t_ordertime(const mc_pack_item_t*,once_consume_goods_t*);
static void _mcpack2_load_once_consume_goods_t_udid(const mc_pack_item_t*,once_consume_goods_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,once_consume_goods_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_once_consume_goods_t_readmap;
// static initialization.
static bool _mcpack2_load_once_consume_goods_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,once_consume_goods_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,once_consume_goods_t*)>("orderid",_mcpack2_load_once_consume_goods_t_orderid));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,once_consume_goods_t*)>("itemid",_mcpack2_load_once_consume_goods_t_itemid));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,once_consume_goods_t*)>("ordertime",_mcpack2_load_once_consume_goods_t_ordertime));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,once_consume_goods_t*)>("udid",_mcpack2_load_once_consume_goods_t_udid));
_mcpack2_load_once_consume_goods_t_readmap.create(16*4);
_mcpack2_load_once_consume_goods_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_once_consume_goods_t_static_inited=_mcpack2_load_once_consume_goods_t_static_init();
// @@string orderid;
static void _mcpack2_load_once_consume_goods_t_orderid(__attribute__((unused)) const mc_pack_item_t* item,once_consume_goods_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "orderid";
}
self->_m_orderid.set_ptr(item->value,item->value_size-1);
}
// @@string itemid;
static void _mcpack2_load_once_consume_goods_t_itemid(__attribute__((unused)) const mc_pack_item_t* item,once_consume_goods_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "itemid";
}
self->_m_itemid.set_ptr(item->value,item->value_size-1);
}
// @@string ordertime;
static void _mcpack2_load_once_consume_goods_t_ordertime(__attribute__((unused)) const mc_pack_item_t* item,once_consume_goods_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ordertime";
}
self->_m_ordertime.set_ptr(item->value,item->value_size-1);
}
// @@string udid;
static void _mcpack2_load_once_consume_goods_t_udid(__attribute__((unused)) const mc_pack_item_t* item,once_consume_goods_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "udid";
}
self->_m_udid.set_ptr(item->value,item->value_size-1);
}
void once_consume_goods_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,once_consume_goods_t*)=0;
do{
if(_mcpack2_load_once_consume_goods_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int once_consume_goods_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,once_consume_goods_t*)=0;
if(_mcpack2_load_once_consume_goods_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void once_consume_goods_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t once_consume_goods_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string orderid;
{
int res=mc_pack_put_str(pack,"orderid",_m_orderid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string itemid;
{
int res=mc_pack_put_str(pack,"itemid",_m_itemid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ordertime;
{
int res=mc_pack_put_str(pack,"ordertime",_m_ordertime.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string udid;
{
int res=mc_pack_put_str(pack,"udid",_m_udid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class game_news_entire_info_t
static void _mcpack2_load_game_news_entire_info_t_news_info(const mc_pack_item_t*,game_news_entire_info_t*);
static void _mcpack2_load_game_news_entire_info_t_game_basic_info(const mc_pack_item_t*,game_news_entire_info_t*);
static void _mcpack2_load_game_news_entire_info_t_game_download_list(const mc_pack_item_t*,game_news_entire_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,game_news_entire_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_game_news_entire_info_t_readmap;
// static initialization.
static bool _mcpack2_load_game_news_entire_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,game_news_entire_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_news_entire_info_t*)>("news_info",_mcpack2_load_game_news_entire_info_t_news_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_news_entire_info_t*)>("game_basic_info",_mcpack2_load_game_news_entire_info_t_game_basic_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_news_entire_info_t*)>("game_download_list",_mcpack2_load_game_news_entire_info_t_game_download_list));
_mcpack2_load_game_news_entire_info_t_readmap.create(16*3);
_mcpack2_load_game_news_entire_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_game_news_entire_info_t_static_inited=_mcpack2_load_game_news_entire_info_t_static_init();
// @@game_info_t news_info;
static void _mcpack2_load_game_news_entire_info_t_news_info(__attribute__((unused)) const mc_pack_item_t* item,game_news_entire_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_news_info){
self->_m_news_info=::idl::game_info_t::create(self->_pool);
}
self->_m_news_info->LoadWithoutCheck(pack);
}
// @@content_basic_info_t game_basic_info;
static void _mcpack2_load_game_news_entire_info_t_game_basic_info(__attribute__((unused)) const mc_pack_item_t* item,game_news_entire_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_game_basic_info){
self->_m_game_basic_info=::idl::content_basic_info_t::create(self->_pool);
}
self->_m_game_basic_info->LoadWithoutCheck(pack);
}
// @@download_detail_t game_download_list=array(0);
static void _mcpack2_load_game_news_entire_info_t_game_download_list(__attribute__((unused)) const mc_pack_item_t* item,game_news_entire_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_download_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_game_download_list)) lp0=&(self->_m_game_download_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_download_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_download_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_download_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void game_news_entire_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,game_news_entire_info_t*)=0;
do{
if(_mcpack2_load_game_news_entire_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int game_news_entire_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,game_news_entire_info_t*)=0;
if(_mcpack2_load_game_news_entire_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void game_news_entire_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t game_news_entire_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@game_info_t news_info;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"news_info");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_news_info->save(subpack);
mc_pack_finish(subpack);
}
// @@content_basic_info_t game_basic_info;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"game_basic_info");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_game_basic_info->save(subpack);
mc_pack_finish(subpack);
}
// @@download_detail_t game_download_list=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"game_download_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_game_download_list)& lr0=(_m_game_download_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class game_news_info_t
static void _mcpack2_load_game_news_info_t_news_id(const mc_pack_item_t*,game_news_info_t*);
static void _mcpack2_load_game_news_info_t_news_type(const mc_pack_item_t*,game_news_info_t*);
static void _mcpack2_load_game_news_info_t_news_time(const mc_pack_item_t*,game_news_info_t*);
static void _mcpack2_load_game_news_info_t_news_content(const mc_pack_item_t*,game_news_info_t*);
static void _mcpack2_load_game_news_info_t_news_title(const mc_pack_item_t*,game_news_info_t*);
static void _mcpack2_load_game_news_info_t_news_type_name(const mc_pack_item_t*,game_news_info_t*);
static void _mcpack2_load_game_news_info_t_game_id(const mc_pack_item_t*,game_news_info_t*);
static void _mcpack2_load_game_news_info_t_game_type(const mc_pack_item_t*,game_news_info_t*);
static void _mcpack2_load_game_news_info_t_game_name(const mc_pack_item_t*,game_news_info_t*);
static void _mcpack2_load_game_news_info_t_game_img_info(const mc_pack_item_t*,game_news_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,game_news_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_game_news_info_t_readmap;
// static initialization.
static bool _mcpack2_load_game_news_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,game_news_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_news_info_t*)>("news_id",_mcpack2_load_game_news_info_t_news_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_news_info_t*)>("news_type",_mcpack2_load_game_news_info_t_news_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_news_info_t*)>("news_time",_mcpack2_load_game_news_info_t_news_time));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_news_info_t*)>("news_content",_mcpack2_load_game_news_info_t_news_content));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_news_info_t*)>("news_title",_mcpack2_load_game_news_info_t_news_title));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_news_info_t*)>("news_type_name",_mcpack2_load_game_news_info_t_news_type_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_news_info_t*)>("game_id",_mcpack2_load_game_news_info_t_game_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_news_info_t*)>("game_type",_mcpack2_load_game_news_info_t_game_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_news_info_t*)>("game_name",_mcpack2_load_game_news_info_t_game_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_news_info_t*)>("game_img_info",_mcpack2_load_game_news_info_t_game_img_info));
_mcpack2_load_game_news_info_t_readmap.create(16*10);
_mcpack2_load_game_news_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_game_news_info_t_static_inited=_mcpack2_load_game_news_info_t_static_init();
// @@string news_id;
static void _mcpack2_load_game_news_info_t_news_id(__attribute__((unused)) const mc_pack_item_t* item,game_news_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "news_id";
}
self->_m_news_id.set_ptr(item->value,item->value_size-1);
}
// @@string news_type;
static void _mcpack2_load_game_news_info_t_news_type(__attribute__((unused)) const mc_pack_item_t* item,game_news_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "news_type";
}
self->_m_news_type.set_ptr(item->value,item->value_size-1);
}
// @@string news_time;
static void _mcpack2_load_game_news_info_t_news_time(__attribute__((unused)) const mc_pack_item_t* item,game_news_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "news_time";
}
self->_m_news_time.set_ptr(item->value,item->value_size-1);
}
// @@string news_content;
static void _mcpack2_load_game_news_info_t_news_content(__attribute__((unused)) const mc_pack_item_t* item,game_news_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "news_content";
}
self->_m_news_content.set_ptr(item->value,item->value_size-1);
}
// @@string news_title;
static void _mcpack2_load_game_news_info_t_news_title(__attribute__((unused)) const mc_pack_item_t* item,game_news_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "news_title";
}
self->_m_news_title.set_ptr(item->value,item->value_size-1);
}
// @@string news_type_name;
static void _mcpack2_load_game_news_info_t_news_type_name(__attribute__((unused)) const mc_pack_item_t* item,game_news_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "news_type_name";
}
self->_m_news_type_name.set_ptr(item->value,item->value_size-1);
}
// @@string game_id;
static void _mcpack2_load_game_news_info_t_game_id(__attribute__((unused)) const mc_pack_item_t* item,game_news_info_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
// @@string game_type;
static void _mcpack2_load_game_news_info_t_game_type(__attribute__((unused)) const mc_pack_item_t* item,game_news_info_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_type";
}
self->_m_game_type.set_ptr(item->value,item->value_size-1);
}
// @@string game_name;
static void _mcpack2_load_game_news_info_t_game_name(__attribute__((unused)) const mc_pack_item_t* item,game_news_info_t* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_name";
}
self->_m_game_name.set_ptr(item->value,item->value_size-1);
}
// @@img_info_t game_img_info=array(0);
static void _mcpack2_load_game_news_info_t_game_img_info(__attribute__((unused)) const mc_pack_item_t* item,game_news_info_t* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_img_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_game_img_info)) lp0=&(self->_m_game_img_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_img_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_img_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_img_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void game_news_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,game_news_info_t*)=0;
do{
if(_mcpack2_load_game_news_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int game_news_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,game_news_info_t*)=0;
if(_mcpack2_load_game_news_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void game_news_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t game_news_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string news_id;
{
int res=mc_pack_put_str(pack,"news_id",_m_news_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string news_type;
{
int res=mc_pack_put_str(pack,"news_type",_m_news_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string news_time;
{
int res=mc_pack_put_str(pack,"news_time",_m_news_time.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string news_content;
{
int res=mc_pack_put_str(pack,"news_content",_m_news_content.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string news_title;
{
int res=mc_pack_put_str(pack,"news_title",_m_news_title.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string news_type_name;
{
int res=mc_pack_put_str(pack,"news_type_name",_m_news_type_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_id;
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_type;
{
int res=mc_pack_put_str(pack,"game_type",_m_game_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_name;
{
int res=mc_pack_put_str(pack,"game_name",_m_game_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@img_info_t game_img_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"game_img_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_game_img_info)& lr0=(_m_game_img_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class netgame_activity_info_t
static void _mcpack2_load_netgame_activity_info_t_act_id(const mc_pack_item_t*,netgame_activity_info_t*);
static void _mcpack2_load_netgame_activity_info_t_act_title(const mc_pack_item_t*,netgame_activity_info_t*);
static void _mcpack2_load_netgame_activity_info_t_act_content(const mc_pack_item_t*,netgame_activity_info_t*);
static void _mcpack2_load_netgame_activity_info_t_act_logdate(const mc_pack_item_t*,netgame_activity_info_t*);
static void _mcpack2_load_netgame_activity_info_t_act_img_info(const mc_pack_item_t*,netgame_activity_info_t*);
static void _mcpack2_load_netgame_activity_info_t_game_news_list(const mc_pack_item_t*,netgame_activity_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,netgame_activity_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_netgame_activity_info_t_readmap;
// static initialization.
static bool _mcpack2_load_netgame_activity_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,netgame_activity_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,netgame_activity_info_t*)>("act_id",_mcpack2_load_netgame_activity_info_t_act_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,netgame_activity_info_t*)>("act_title",_mcpack2_load_netgame_activity_info_t_act_title));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,netgame_activity_info_t*)>("act_content",_mcpack2_load_netgame_activity_info_t_act_content));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,netgame_activity_info_t*)>("act_logdate",_mcpack2_load_netgame_activity_info_t_act_logdate));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,netgame_activity_info_t*)>("act_img_info",_mcpack2_load_netgame_activity_info_t_act_img_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,netgame_activity_info_t*)>("game_news_list",_mcpack2_load_netgame_activity_info_t_game_news_list));
_mcpack2_load_netgame_activity_info_t_readmap.create(16*6);
_mcpack2_load_netgame_activity_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_netgame_activity_info_t_static_inited=_mcpack2_load_netgame_activity_info_t_static_init();
// @@string act_id;
static void _mcpack2_load_netgame_activity_info_t_act_id(__attribute__((unused)) const mc_pack_item_t* item,netgame_activity_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "act_id";
}
self->_m_act_id.set_ptr(item->value,item->value_size-1);
}
// @@string act_title;
static void _mcpack2_load_netgame_activity_info_t_act_title(__attribute__((unused)) const mc_pack_item_t* item,netgame_activity_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "act_title";
}
self->_m_act_title.set_ptr(item->value,item->value_size-1);
}
// @@string act_content;
static void _mcpack2_load_netgame_activity_info_t_act_content(__attribute__((unused)) const mc_pack_item_t* item,netgame_activity_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "act_content";
}
self->_m_act_content.set_ptr(item->value,item->value_size-1);
}
// @@string act_logdate;
static void _mcpack2_load_netgame_activity_info_t_act_logdate(__attribute__((unused)) const mc_pack_item_t* item,netgame_activity_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "act_logdate";
}
self->_m_act_logdate.set_ptr(item->value,item->value_size-1);
}
// @@img_info_t act_img_info=array(0);
static void _mcpack2_load_netgame_activity_info_t_act_img_info(__attribute__((unused)) const mc_pack_item_t* item,netgame_activity_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "act_img_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_act_img_info)) lp0=&(self->_m_act_img_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "act_img_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "act_img_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "act_img_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@game_news_info_t game_news_list=array(0);
static void _mcpack2_load_netgame_activity_info_t_game_news_list(__attribute__((unused)) const mc_pack_item_t* item,netgame_activity_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_news_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_game_news_list)) lp0=&(self->_m_game_news_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_news_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_news_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_news_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void netgame_activity_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,netgame_activity_info_t*)=0;
do{
if(_mcpack2_load_netgame_activity_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int netgame_activity_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,netgame_activity_info_t*)=0;
if(_mcpack2_load_netgame_activity_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void netgame_activity_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t netgame_activity_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string act_id;
{
int res=mc_pack_put_str(pack,"act_id",_m_act_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string act_title;
{
int res=mc_pack_put_str(pack,"act_title",_m_act_title.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string act_content;
{
int res=mc_pack_put_str(pack,"act_content",_m_act_content.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string act_logdate;
{
int res=mc_pack_put_str(pack,"act_logdate",_m_act_logdate.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@img_info_t act_img_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"act_img_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_act_img_info)& lr0=(_m_act_img_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@game_news_info_t game_news_list=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"game_news_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_game_news_list)& lr0=(_m_game_news_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class column_info_t
static void _mcpack2_load_column_info_t_id(const mc_pack_item_t*,column_info_t*);
static void _mcpack2_load_column_info_t_name(const mc_pack_item_t*,column_info_t*);
static void _mcpack2_load_column_info_t_type_id(const mc_pack_item_t*,column_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,column_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_column_info_t_readmap;
// static initialization.
static bool _mcpack2_load_column_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,column_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,column_info_t*)>("id",_mcpack2_load_column_info_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,column_info_t*)>("name",_mcpack2_load_column_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,column_info_t*)>("type_id",_mcpack2_load_column_info_t_type_id));
_mcpack2_load_column_info_t_readmap.create(16*3);
_mcpack2_load_column_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_column_info_t_static_inited=_mcpack2_load_column_info_t_static_init();
// @@string id;
static void _mcpack2_load_column_info_t_id(__attribute__((unused)) const mc_pack_item_t* item,column_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_column_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,column_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string type_id;
static void _mcpack2_load_column_info_t_type_id(__attribute__((unused)) const mc_pack_item_t* item,column_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
void column_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,column_info_t*)=0;
do{
if(_mcpack2_load_column_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int column_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,column_info_t*)=0;
if(_mcpack2_load_column_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void column_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t column_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id;
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class game_ext_update_info_t
static void _mcpack2_load_game_ext_update_info_t_c_id(const mc_pack_item_t*,game_ext_update_info_t*);
static void _mcpack2_load_game_ext_update_info_t_update_url(const mc_pack_item_t*,game_ext_update_info_t*);
static void _mcpack2_load_game_ext_update_info_t_diff_pkg_size(const mc_pack_item_t*,game_ext_update_info_t*);
static void _mcpack2_load_game_ext_update_info_t_channel_info(const mc_pack_item_t*,game_ext_update_info_t*);
static void _mcpack2_load_game_ext_update_info_t_channel_id(const mc_pack_item_t*,game_ext_update_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,game_ext_update_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_game_ext_update_info_t_readmap;
// static initialization.
static bool _mcpack2_load_game_ext_update_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,game_ext_update_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_ext_update_info_t*)>("c_id",_mcpack2_load_game_ext_update_info_t_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_ext_update_info_t*)>("update_url",_mcpack2_load_game_ext_update_info_t_update_url));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_ext_update_info_t*)>("diff_pkg_size",_mcpack2_load_game_ext_update_info_t_diff_pkg_size));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_ext_update_info_t*)>("channel_info",_mcpack2_load_game_ext_update_info_t_channel_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_ext_update_info_t*)>("channel_id",_mcpack2_load_game_ext_update_info_t_channel_id));
_mcpack2_load_game_ext_update_info_t_readmap.create(16*5);
_mcpack2_load_game_ext_update_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_game_ext_update_info_t_static_inited=_mcpack2_load_game_ext_update_info_t_static_init();
// @@string c_id;
static void _mcpack2_load_game_ext_update_info_t_c_id(__attribute__((unused)) const mc_pack_item_t* item,game_ext_update_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string update_url;
static void _mcpack2_load_game_ext_update_info_t_update_url(__attribute__((unused)) const mc_pack_item_t* item,game_ext_update_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "update_url";
}
self->_m_update_url.set_ptr(item->value,item->value_size-1);
}
// @@string diff_pkg_size;
static void _mcpack2_load_game_ext_update_info_t_diff_pkg_size(__attribute__((unused)) const mc_pack_item_t* item,game_ext_update_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "diff_pkg_size";
}
self->_m_diff_pkg_size.set_ptr(item->value,item->value_size-1);
}
// @@string channel_info;
static void _mcpack2_load_game_ext_update_info_t_channel_info(__attribute__((unused)) const mc_pack_item_t* item,game_ext_update_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "channel_info";
}
self->_m_channel_info.set_ptr(item->value,item->value_size-1);
}
// @@string channel_id;
static void _mcpack2_load_game_ext_update_info_t_channel_id(__attribute__((unused)) const mc_pack_item_t* item,game_ext_update_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "channel_id";
}
self->_m_channel_id.set_ptr(item->value,item->value_size-1);
}
void game_ext_update_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,game_ext_update_info_t*)=0;
do{
if(_mcpack2_load_game_ext_update_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int game_ext_update_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,game_ext_update_info_t*)=0;
if(_mcpack2_load_game_ext_update_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void game_ext_update_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t game_ext_update_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string c_id;
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string update_url;
{
int res=mc_pack_put_str(pack,"update_url",_m_update_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string diff_pkg_size;
{
int res=mc_pack_put_str(pack,"diff_pkg_size",_m_diff_pkg_size.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string channel_info;
{
int res=mc_pack_put_str(pack,"channel_info",_m_channel_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string channel_id;
{
int res=mc_pack_put_str(pack,"channel_id",_m_channel_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class game_update_download_info
static void _mcpack2_load_game_update_download_info_basic_info(const mc_pack_item_t*,game_update_download_info*);
static void _mcpack2_load_game_update_download_info_download_info(const mc_pack_item_t*,game_update_download_info*);
static void _mcpack2_load_game_update_download_info_update_info(const mc_pack_item_t*,game_update_download_info*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,game_update_download_info*),::idl::string_hash,::idl::string_equal> _mcpack2_load_game_update_download_info_readmap;
// static initialization.
static bool _mcpack2_load_game_update_download_info_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,game_update_download_info*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_update_download_info*)>("basic_info",_mcpack2_load_game_update_download_info_basic_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_update_download_info*)>("download_info",_mcpack2_load_game_update_download_info_download_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_update_download_info*)>("update_info",_mcpack2_load_game_update_download_info_update_info));
_mcpack2_load_game_update_download_info_readmap.create(16*3);
_mcpack2_load_game_update_download_info_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_game_update_download_info_static_inited=_mcpack2_load_game_update_download_info_static_init();
// @@content_basic_info_t basic_info;
static void _mcpack2_load_game_update_download_info_basic_info(__attribute__((unused)) const mc_pack_item_t* item,game_update_download_info* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_basic_info){
self->_m_basic_info=::idl::content_basic_info_t::create(self->_pool);
}
self->_m_basic_info->LoadWithoutCheck(pack);
}
// @@download_detail_t download_info=array(0);
static void _mcpack2_load_game_update_download_info_download_info(__attribute__((unused)) const mc_pack_item_t* item,game_update_download_info* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_download_info)) lp0=&(self->_m_download_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@game_ext_update_info_t update_info=array(0);
static void _mcpack2_load_game_update_download_info_update_info(__attribute__((unused)) const mc_pack_item_t* item,game_update_download_info* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "update_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_update_info)) lp0=&(self->_m_update_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "update_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "update_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "update_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void game_update_download_info::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,game_update_download_info*)=0;
do{
if(_mcpack2_load_game_update_download_info_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int game_update_download_info::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,game_update_download_info*)=0;
if(_mcpack2_load_game_update_download_info_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void game_update_download_info::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t game_update_download_info::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@content_basic_info_t basic_info;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"basic_info");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_basic_info->save(subpack);
mc_pack_finish(subpack);
}
// @@download_detail_t download_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"download_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_download_info)& lr0=(_m_download_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@game_ext_update_info_t update_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"update_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_update_info)& lr0=(_m_update_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class game_content_download_info_t
static void _mcpack2_load_game_content_download_info_t_basic_info(const mc_pack_item_t*,game_content_download_info_t*);
static void _mcpack2_load_game_content_download_info_t_download_info(const mc_pack_item_t*,game_content_download_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,game_content_download_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_game_content_download_info_t_readmap;
// static initialization.
static bool _mcpack2_load_game_content_download_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,game_content_download_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_content_download_info_t*)>("basic_info",_mcpack2_load_game_content_download_info_t_basic_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_content_download_info_t*)>("download_info",_mcpack2_load_game_content_download_info_t_download_info));
_mcpack2_load_game_content_download_info_t_readmap.create(16*2);
_mcpack2_load_game_content_download_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_game_content_download_info_t_static_inited=_mcpack2_load_game_content_download_info_t_static_init();
// @@content_basic_info_t basic_info;
static void _mcpack2_load_game_content_download_info_t_basic_info(__attribute__((unused)) const mc_pack_item_t* item,game_content_download_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_basic_info){
self->_m_basic_info=::idl::content_basic_info_t::create(self->_pool);
}
self->_m_basic_info->LoadWithoutCheck(pack);
}
// @@download_detail_t download_info=array(0);
static void _mcpack2_load_game_content_download_info_t_download_info(__attribute__((unused)) const mc_pack_item_t* item,game_content_download_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_download_info)) lp0=&(self->_m_download_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void game_content_download_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,game_content_download_info_t*)=0;
do{
if(_mcpack2_load_game_content_download_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int game_content_download_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,game_content_download_info_t*)=0;
if(_mcpack2_load_game_content_download_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void game_content_download_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t game_content_download_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@content_basic_info_t basic_info;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"basic_info");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_basic_info->save(subpack);
mc_pack_finish(subpack);
}
// @@download_detail_t download_info=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"download_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_download_info)& lr0=(_m_download_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class game_dev_vir_currency_info
static void _mcpack2_load_game_dev_vir_currency_info_id(const mc_pack_item_t*,game_dev_vir_currency_info*);
static void _mcpack2_load_game_dev_vir_currency_info_name(const mc_pack_item_t*,game_dev_vir_currency_info*);
static void _mcpack2_load_game_dev_vir_currency_info_game_id(const mc_pack_item_t*,game_dev_vir_currency_info*);
static void _mcpack2_load_game_dev_vir_currency_info_exchage_rate(const mc_pack_item_t*,game_dev_vir_currency_info*);
static void _mcpack2_load_game_dev_vir_currency_info_icon(const mc_pack_item_t*,game_dev_vir_currency_info*);
static void _mcpack2_load_game_dev_vir_currency_info_desc(const mc_pack_item_t*,game_dev_vir_currency_info*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,game_dev_vir_currency_info*),::idl::string_hash,::idl::string_equal> _mcpack2_load_game_dev_vir_currency_info_readmap;
// static initialization.
static bool _mcpack2_load_game_dev_vir_currency_info_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,game_dev_vir_currency_info*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_dev_vir_currency_info*)>("id",_mcpack2_load_game_dev_vir_currency_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_dev_vir_currency_info*)>("name",_mcpack2_load_game_dev_vir_currency_info_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_dev_vir_currency_info*)>("game_id",_mcpack2_load_game_dev_vir_currency_info_game_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_dev_vir_currency_info*)>("exchage_rate",_mcpack2_load_game_dev_vir_currency_info_exchage_rate));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_dev_vir_currency_info*)>("icon",_mcpack2_load_game_dev_vir_currency_info_icon));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,game_dev_vir_currency_info*)>("desc",_mcpack2_load_game_dev_vir_currency_info_desc));
_mcpack2_load_game_dev_vir_currency_info_readmap.create(16*6);
_mcpack2_load_game_dev_vir_currency_info_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_game_dev_vir_currency_info_static_inited=_mcpack2_load_game_dev_vir_currency_info_static_init();
// @@string id;
static void _mcpack2_load_game_dev_vir_currency_info_id(__attribute__((unused)) const mc_pack_item_t* item,game_dev_vir_currency_info* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_game_dev_vir_currency_info_name(__attribute__((unused)) const mc_pack_item_t* item,game_dev_vir_currency_info* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string game_id;
static void _mcpack2_load_game_dev_vir_currency_info_game_id(__attribute__((unused)) const mc_pack_item_t* item,game_dev_vir_currency_info* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
// @@string exchage_rate;
static void _mcpack2_load_game_dev_vir_currency_info_exchage_rate(__attribute__((unused)) const mc_pack_item_t* item,game_dev_vir_currency_info* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "exchage_rate";
}
self->_m_exchage_rate.set_ptr(item->value,item->value_size-1);
}
// @@string icon;
static void _mcpack2_load_game_dev_vir_currency_info_icon(__attribute__((unused)) const mc_pack_item_t* item,game_dev_vir_currency_info* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "icon";
}
self->_m_icon.set_ptr(item->value,item->value_size-1);
}
// @@string desc;
static void _mcpack2_load_game_dev_vir_currency_info_desc(__attribute__((unused)) const mc_pack_item_t* item,game_dev_vir_currency_info* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "desc";
}
self->_m_desc.set_ptr(item->value,item->value_size-1);
}
void game_dev_vir_currency_info::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,game_dev_vir_currency_info*)=0;
do{
if(_mcpack2_load_game_dev_vir_currency_info_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int game_dev_vir_currency_info::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,game_dev_vir_currency_info*)=0;
if(_mcpack2_load_game_dev_vir_currency_info_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void game_dev_vir_currency_info::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t game_dev_vir_currency_info::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_id;
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string exchage_rate;
{
int res=mc_pack_put_str(pack,"exchage_rate",_m_exchage_rate.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string icon;
{
int res=mc_pack_put_str(pack,"icon",_m_icon.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string desc;
{
int res=mc_pack_put_str(pack,"desc",_m_desc.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class question_type_name_t
static void _mcpack2_load_question_type_name_t_id(const mc_pack_item_t*,question_type_name_t*);
static void _mcpack2_load_question_type_name_t_name(const mc_pack_item_t*,question_type_name_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,question_type_name_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_question_type_name_t_readmap;
// static initialization.
static bool _mcpack2_load_question_type_name_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,question_type_name_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,question_type_name_t*)>("id",_mcpack2_load_question_type_name_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,question_type_name_t*)>("name",_mcpack2_load_question_type_name_t_name));
_mcpack2_load_question_type_name_t_readmap.create(16*2);
_mcpack2_load_question_type_name_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_question_type_name_t_static_inited=_mcpack2_load_question_type_name_t_static_init();
// @@string id;
static void _mcpack2_load_question_type_name_t_id(__attribute__((unused)) const mc_pack_item_t* item,question_type_name_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_question_type_name_t_name(__attribute__((unused)) const mc_pack_item_t* item,question_type_name_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
void question_type_name_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,question_type_name_t*)=0;
do{
if(_mcpack2_load_question_type_name_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int question_type_name_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,question_type_name_t*)=0;
if(_mcpack2_load_question_type_name_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void question_type_name_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t question_type_name_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class user_question_answer_t
static void _mcpack2_load_user_question_answer_t_id(const mc_pack_item_t*,user_question_answer_t*);
static void _mcpack2_load_user_question_answer_t_app_id(const mc_pack_item_t*,user_question_answer_t*);
static void _mcpack2_load_user_question_answer_t_question(const mc_pack_item_t*,user_question_answer_t*);
static void _mcpack2_load_user_question_answer_t_answer(const mc_pack_item_t*,user_question_answer_t*);
static void _mcpack2_load_user_question_answer_t_status(const mc_pack_item_t*,user_question_answer_t*);
static void _mcpack2_load_user_question_answer_t_date_q(const mc_pack_item_t*,user_question_answer_t*);
static void _mcpack2_load_user_question_answer_t_date_a(const mc_pack_item_t*,user_question_answer_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,user_question_answer_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_user_question_answer_t_readmap;
// static initialization.
static bool _mcpack2_load_user_question_answer_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,user_question_answer_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_question_answer_t*)>("id",_mcpack2_load_user_question_answer_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_question_answer_t*)>("app_id",_mcpack2_load_user_question_answer_t_app_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_question_answer_t*)>("question",_mcpack2_load_user_question_answer_t_question));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_question_answer_t*)>("answer",_mcpack2_load_user_question_answer_t_answer));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_question_answer_t*)>("status",_mcpack2_load_user_question_answer_t_status));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_question_answer_t*)>("date_q",_mcpack2_load_user_question_answer_t_date_q));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,user_question_answer_t*)>("date_a",_mcpack2_load_user_question_answer_t_date_a));
_mcpack2_load_user_question_answer_t_readmap.create(16*7);
_mcpack2_load_user_question_answer_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_user_question_answer_t_static_inited=_mcpack2_load_user_question_answer_t_static_init();
// @@string id;
static void _mcpack2_load_user_question_answer_t_id(__attribute__((unused)) const mc_pack_item_t* item,user_question_answer_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string app_id;
static void _mcpack2_load_user_question_answer_t_app_id(__attribute__((unused)) const mc_pack_item_t* item,user_question_answer_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "app_id";
}
self->_m_app_id.set_ptr(item->value,item->value_size-1);
}
// @@string question;
static void _mcpack2_load_user_question_answer_t_question(__attribute__((unused)) const mc_pack_item_t* item,user_question_answer_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "question";
}
self->_m_question.set_ptr(item->value,item->value_size-1);
}
// @@string answer;
static void _mcpack2_load_user_question_answer_t_answer(__attribute__((unused)) const mc_pack_item_t* item,user_question_answer_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "answer";
}
self->_m_answer.set_ptr(item->value,item->value_size-1);
}
// @@string status;
static void _mcpack2_load_user_question_answer_t_status(__attribute__((unused)) const mc_pack_item_t* item,user_question_answer_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "status";
}
self->_m_status.set_ptr(item->value,item->value_size-1);
}
// @@string date_q;
static void _mcpack2_load_user_question_answer_t_date_q(__attribute__((unused)) const mc_pack_item_t* item,user_question_answer_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "date_q";
}
self->_m_date_q.set_ptr(item->value,item->value_size-1);
}
// @@string date_a;
static void _mcpack2_load_user_question_answer_t_date_a(__attribute__((unused)) const mc_pack_item_t* item,user_question_answer_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "date_a";
}
self->_m_date_a.set_ptr(item->value,item->value_size-1);
}
void user_question_answer_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,user_question_answer_t*)=0;
do{
if(_mcpack2_load_user_question_answer_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int user_question_answer_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,user_question_answer_t*)=0;
if(_mcpack2_load_user_question_answer_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void user_question_answer_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t user_question_answer_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string app_id;
{
int res=mc_pack_put_str(pack,"app_id",_m_app_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string question;
{
int res=mc_pack_put_str(pack,"question",_m_question.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string answer;
{
int res=mc_pack_put_str(pack,"answer",_m_answer.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string status;
{
int res=mc_pack_put_str(pack,"status",_m_status.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string date_q;
{
int res=mc_pack_put_str(pack,"date_q",_m_date_q.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string date_a;
{
int res=mc_pack_put_str(pack,"date_a",_m_date_a.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class qp_activity_award_t
static void _mcpack2_load_qp_activity_award_t_id(const mc_pack_item_t*,qp_activity_award_t*);
static void _mcpack2_load_qp_activity_award_t_name(const mc_pack_item_t*,qp_activity_award_t*);
static void _mcpack2_load_qp_activity_award_t_pic_url(const mc_pack_item_t*,qp_activity_award_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,qp_activity_award_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_qp_activity_award_t_readmap;
// static initialization.
static bool _mcpack2_load_qp_activity_award_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,qp_activity_award_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_award_t*)>("id",_mcpack2_load_qp_activity_award_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_award_t*)>("name",_mcpack2_load_qp_activity_award_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_award_t*)>("pic_url",_mcpack2_load_qp_activity_award_t_pic_url));
_mcpack2_load_qp_activity_award_t_readmap.create(16*3);
_mcpack2_load_qp_activity_award_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_qp_activity_award_t_static_inited=_mcpack2_load_qp_activity_award_t_static_init();
// @@string id;
static void _mcpack2_load_qp_activity_award_t_id(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_award_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_qp_activity_award_t_name(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_award_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string pic_url;
static void _mcpack2_load_qp_activity_award_t_pic_url(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_award_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "pic_url";
}
self->_m_pic_url.set_ptr(item->value,item->value_size-1);
}
void qp_activity_award_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,qp_activity_award_t*)=0;
do{
if(_mcpack2_load_qp_activity_award_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int qp_activity_award_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,qp_activity_award_t*)=0;
if(_mcpack2_load_qp_activity_award_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void qp_activity_award_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t qp_activity_award_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string pic_url;
{
int res=mc_pack_put_str(pack,"pic_url",_m_pic_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class qp_activity_t
static void _mcpack2_load_qp_activity_t_id(const mc_pack_item_t*,qp_activity_t*);
static void _mcpack2_load_qp_activity_t_c_id(const mc_pack_item_t*,qp_activity_t*);
static void _mcpack2_load_qp_activity_t_title(const mc_pack_item_t*,qp_activity_t*);
static void _mcpack2_load_qp_activity_t_info(const mc_pack_item_t*,qp_activity_t*);
static void _mcpack2_load_qp_activity_t_rules(const mc_pack_item_t*,qp_activity_t*);
static void _mcpack2_load_qp_activity_t_start_time(const mc_pack_item_t*,qp_activity_t*);
static void _mcpack2_load_qp_activity_t_end_time(const mc_pack_item_t*,qp_activity_t*);
static void _mcpack2_load_qp_activity_t_icon_url(const mc_pack_item_t*,qp_activity_t*);
static void _mcpack2_load_qp_activity_t_status(const mc_pack_item_t*,qp_activity_t*);
static void _mcpack2_load_qp_activity_t_act_info(const mc_pack_item_t*,qp_activity_t*);
static void _mcpack2_load_qp_activity_t_qp_activity_award_list(const mc_pack_item_t*,qp_activity_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,qp_activity_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_qp_activity_t_readmap;
// static initialization.
static bool _mcpack2_load_qp_activity_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,qp_activity_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_t*)>("id",_mcpack2_load_qp_activity_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_t*)>("c_id",_mcpack2_load_qp_activity_t_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_t*)>("title",_mcpack2_load_qp_activity_t_title));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_t*)>("info",_mcpack2_load_qp_activity_t_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_t*)>("rules",_mcpack2_load_qp_activity_t_rules));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_t*)>("start_time",_mcpack2_load_qp_activity_t_start_time));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_t*)>("end_time",_mcpack2_load_qp_activity_t_end_time));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_t*)>("icon_url",_mcpack2_load_qp_activity_t_icon_url));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_t*)>("status",_mcpack2_load_qp_activity_t_status));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_t*)>("act_info",_mcpack2_load_qp_activity_t_act_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_t*)>("qp_activity_award_list",_mcpack2_load_qp_activity_t_qp_activity_award_list));
_mcpack2_load_qp_activity_t_readmap.create(16*11);
_mcpack2_load_qp_activity_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_qp_activity_t_static_inited=_mcpack2_load_qp_activity_t_static_init();
// @@string id;
static void _mcpack2_load_qp_activity_t_id(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id;
static void _mcpack2_load_qp_activity_t_c_id(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string title;
static void _mcpack2_load_qp_activity_t_title(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "title";
}
self->_m_title.set_ptr(item->value,item->value_size-1);
}
// @@string info;
static void _mcpack2_load_qp_activity_t_info(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info";
}
self->_m_info.set_ptr(item->value,item->value_size-1);
}
// @@string rules;
static void _mcpack2_load_qp_activity_t_rules(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "rules";
}
self->_m_rules.set_ptr(item->value,item->value_size-1);
}
// @@int64_t start_time;
static void _mcpack2_load_qp_activity_t_start_time(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int64_from_item(item,reinterpret_cast<mc_int64_t*>(&(self->_m_start_time)));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "start_time";
}
}
// @@int64_t end_time;
static void _mcpack2_load_qp_activity_t_end_time(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int64_from_item(item,reinterpret_cast<mc_int64_t*>(&(self->_m_end_time)));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "end_time";
}
}
// @@string icon_url;
static void _mcpack2_load_qp_activity_t_icon_url(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "icon_url";
}
self->_m_icon_url.set_ptr(item->value,item->value_size-1);
}
// @@string status;
static void _mcpack2_load_qp_activity_t_status(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_t* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "status";
}
self->_m_status.set_ptr(item->value,item->value_size-1);
}
// @@string act_info;
static void _mcpack2_load_qp_activity_t_act_info(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_t* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "act_info";
}
self->_m_act_info.set_ptr(item->value,item->value_size-1);
}
// @@qp_activity_award_t qp_activity_award_list=array(0);
static void _mcpack2_load_qp_activity_t_qp_activity_award_list(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_t* self){
self->_flag[10 >> 3] |= (1 << (10 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "qp_activity_award_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_qp_activity_award_list)) lp0=&(self->_m_qp_activity_award_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "qp_activity_award_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "qp_activity_award_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "qp_activity_award_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void qp_activity_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,qp_activity_t*)=0;
do{
if(_mcpack2_load_qp_activity_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int qp_activity_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,qp_activity_t*)=0;
if(_mcpack2_load_qp_activity_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void qp_activity_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t qp_activity_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id;
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string title;
{
int res=mc_pack_put_str(pack,"title",_m_title.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info;
{
int res=mc_pack_put_str(pack,"info",_m_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string rules;
{
int res=mc_pack_put_str(pack,"rules",_m_rules.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int64_t start_time;
{
int res=mc_pack_put_int64(pack,"start_time",_m_start_time);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int64_t end_time;
{
int res=mc_pack_put_int64(pack,"end_time",_m_end_time);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string icon_url;
{
int res=mc_pack_put_str(pack,"icon_url",_m_icon_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string status;
{
int res=mc_pack_put_str(pack,"status",_m_status.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string act_info;
{
int res=mc_pack_put_str(pack,"act_info",_m_act_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@qp_activity_award_t qp_activity_award_list=array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"qp_activity_award_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_qp_activity_award_list)& lr0=(_m_qp_activity_award_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class qp_activity_person_t
static void _mcpack2_load_qp_activity_person_t_c_id(const mc_pack_item_t*,qp_activity_person_t*);
static void _mcpack2_load_qp_activity_person_t_person_num(const mc_pack_item_t*,qp_activity_person_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,qp_activity_person_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_qp_activity_person_t_readmap;
// static initialization.
static bool _mcpack2_load_qp_activity_person_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,qp_activity_person_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_person_t*)>("c_id",_mcpack2_load_qp_activity_person_t_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,qp_activity_person_t*)>("person_num",_mcpack2_load_qp_activity_person_t_person_num));
_mcpack2_load_qp_activity_person_t_readmap.create(16*2);
_mcpack2_load_qp_activity_person_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_qp_activity_person_t_static_inited=_mcpack2_load_qp_activity_person_t_static_init();
// @@string c_id;
static void _mcpack2_load_qp_activity_person_t_c_id(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_person_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string person_num;
static void _mcpack2_load_qp_activity_person_t_person_num(__attribute__((unused)) const mc_pack_item_t* item,qp_activity_person_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "person_num";
}
self->_m_person_num.set_ptr(item->value,item->value_size-1);
}
void qp_activity_person_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,qp_activity_person_t*)=0;
do{
if(_mcpack2_load_qp_activity_person_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int qp_activity_person_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,qp_activity_person_t*)=0;
if(_mcpack2_load_qp_activity_person_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void qp_activity_person_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t qp_activity_person_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string c_id;
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string person_num;
{
int res=mc_pack_put_str(pack,"person_num",_m_person_num.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class person_all_award_info_t
static void _mcpack2_load_person_all_award_info_t_id(const mc_pack_item_t*,person_all_award_info_t*);
static void _mcpack2_load_person_all_award_info_t_icon(const mc_pack_item_t*,person_all_award_info_t*);
static void _mcpack2_load_person_all_award_info_t_name(const mc_pack_item_t*,person_all_award_info_t*);
static void _mcpack2_load_person_all_award_info_t_date(const mc_pack_item_t*,person_all_award_info_t*);
static void _mcpack2_load_person_all_award_info_t_type(const mc_pack_item_t*,person_all_award_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,person_all_award_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_person_all_award_info_t_readmap;
// static initialization.
static bool _mcpack2_load_person_all_award_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,person_all_award_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,person_all_award_info_t*)>("id",_mcpack2_load_person_all_award_info_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,person_all_award_info_t*)>("icon",_mcpack2_load_person_all_award_info_t_icon));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,person_all_award_info_t*)>("name",_mcpack2_load_person_all_award_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,person_all_award_info_t*)>("date",_mcpack2_load_person_all_award_info_t_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,person_all_award_info_t*)>("type",_mcpack2_load_person_all_award_info_t_type));
_mcpack2_load_person_all_award_info_t_readmap.create(16*5);
_mcpack2_load_person_all_award_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_person_all_award_info_t_static_inited=_mcpack2_load_person_all_award_info_t_static_init();
// @@string id;
static void _mcpack2_load_person_all_award_info_t_id(__attribute__((unused)) const mc_pack_item_t* item,person_all_award_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string icon;
static void _mcpack2_load_person_all_award_info_t_icon(__attribute__((unused)) const mc_pack_item_t* item,person_all_award_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "icon";
}
self->_m_icon.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_person_all_award_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,person_all_award_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@int64_t date;
static void _mcpack2_load_person_all_award_info_t_date(__attribute__((unused)) const mc_pack_item_t* item,person_all_award_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int64_from_item(item,reinterpret_cast<mc_int64_t*>(&(self->_m_date)));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "date";
}
}
// @@string type;
static void _mcpack2_load_person_all_award_info_t_type(__attribute__((unused)) const mc_pack_item_t* item,person_all_award_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type";
}
self->_m_type.set_ptr(item->value,item->value_size-1);
}
void person_all_award_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,person_all_award_info_t*)=0;
do{
if(_mcpack2_load_person_all_award_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int person_all_award_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,person_all_award_info_t*)=0;
if(_mcpack2_load_person_all_award_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void person_all_award_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t person_all_award_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string icon;
{
int res=mc_pack_put_str(pack,"icon",_m_icon.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int64_t date;
{
int res=mc_pack_put_int64(pack,"date",_m_date);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type;
{
int res=mc_pack_put_str(pack,"type",_m_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class person_award_info_t
static void _mcpack2_load_person_award_info_t_id(const mc_pack_item_t*,person_award_info_t*);
static void _mcpack2_load_person_award_info_t_user_id(const mc_pack_item_t*,person_award_info_t*);
static void _mcpack2_load_person_award_info_t_commodity_id(const mc_pack_item_t*,person_award_info_t*);
static void _mcpack2_load_person_award_info_t_name(const mc_pack_item_t*,person_award_info_t*);
static void _mcpack2_load_person_award_info_t_kudou(const mc_pack_item_t*,person_award_info_t*);
static void _mcpack2_load_person_award_info_t_priority(const mc_pack_item_t*,person_award_info_t*);
static void _mcpack2_load_person_award_info_t_icon(const mc_pack_item_t*,person_award_info_t*);
static void _mcpack2_load_person_award_info_t_rank(const mc_pack_item_t*,person_award_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,person_award_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_person_award_info_t_readmap;
// static initialization.
static bool _mcpack2_load_person_award_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,person_award_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,person_award_info_t*)>("id",_mcpack2_load_person_award_info_t_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,person_award_info_t*)>("user_id",_mcpack2_load_person_award_info_t_user_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,person_award_info_t*)>("commodity_id",_mcpack2_load_person_award_info_t_commodity_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,person_award_info_t*)>("name",_mcpack2_load_person_award_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,person_award_info_t*)>("kudou",_mcpack2_load_person_award_info_t_kudou));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,person_award_info_t*)>("priority",_mcpack2_load_person_award_info_t_priority));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,person_award_info_t*)>("icon",_mcpack2_load_person_award_info_t_icon));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,person_award_info_t*)>("rank",_mcpack2_load_person_award_info_t_rank));
_mcpack2_load_person_award_info_t_readmap.create(16*8);
_mcpack2_load_person_award_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_person_award_info_t_static_inited=_mcpack2_load_person_award_info_t_static_init();
// @@string id;
static void _mcpack2_load_person_award_info_t_id(__attribute__((unused)) const mc_pack_item_t* item,person_award_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string user_id;
static void _mcpack2_load_person_award_info_t_user_id(__attribute__((unused)) const mc_pack_item_t* item,person_award_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
// @@string commodity_id;
static void _mcpack2_load_person_award_info_t_commodity_id(__attribute__((unused)) const mc_pack_item_t* item,person_award_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "commodity_id";
}
self->_m_commodity_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_person_award_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,person_award_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string kudou;
static void _mcpack2_load_person_award_info_t_kudou(__attribute__((unused)) const mc_pack_item_t* item,person_award_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "kudou";
}
self->_m_kudou.set_ptr(item->value,item->value_size-1);
}
// @@string priority;
static void _mcpack2_load_person_award_info_t_priority(__attribute__((unused)) const mc_pack_item_t* item,person_award_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "priority";
}
self->_m_priority.set_ptr(item->value,item->value_size-1);
}
// @@string icon;
static void _mcpack2_load_person_award_info_t_icon(__attribute__((unused)) const mc_pack_item_t* item,person_award_info_t* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "icon";
}
self->_m_icon.set_ptr(item->value,item->value_size-1);
}
// @@int32_t rank;
static void _mcpack2_load_person_award_info_t_rank(__attribute__((unused)) const mc_pack_item_t* item,person_award_info_t* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_rank));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "rank";
}
}
void person_award_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,person_award_info_t*)=0;
do{
if(_mcpack2_load_person_award_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int person_award_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,person_award_info_t*)=0;
if(_mcpack2_load_person_award_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void person_award_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t person_award_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id;
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string user_id;
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string commodity_id;
{
int res=mc_pack_put_str(pack,"commodity_id",_m_commodity_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string kudou;
{
int res=mc_pack_put_str(pack,"kudou",_m_kudou.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string priority;
{
int res=mc_pack_put_str(pack,"priority",_m_priority.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string icon;
{
int res=mc_pack_put_str(pack,"icon",_m_icon.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int32_t rank;
{
int res=mc_pack_put_int32(pack,"rank",_m_rank);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class award_info_t
static void _mcpack2_load_award_info_t_type(const mc_pack_item_t*,award_info_t*);
static void _mcpack2_load_award_info_t_award_id(const mc_pack_item_t*,award_info_t*);
static void _mcpack2_load_award_info_t_name(const mc_pack_item_t*,award_info_t*);
static void _mcpack2_load_award_info_t_prize_name(const mc_pack_item_t*,award_info_t*);
static void _mcpack2_load_award_info_t_icon(const mc_pack_item_t*,award_info_t*);
static void _mcpack2_load_award_info_t_prize_url(const mc_pack_item_t*,award_info_t*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,award_info_t*),::idl::string_hash,::idl::string_equal> _mcpack2_load_award_info_t_readmap;
// static initialization.
static bool _mcpack2_load_award_info_t_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,award_info_t*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,award_info_t*)>("type",_mcpack2_load_award_info_t_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,award_info_t*)>("award_id",_mcpack2_load_award_info_t_award_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,award_info_t*)>("name",_mcpack2_load_award_info_t_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,award_info_t*)>("prize_name",_mcpack2_load_award_info_t_prize_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,award_info_t*)>("icon",_mcpack2_load_award_info_t_icon));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,award_info_t*)>("prize_url",_mcpack2_load_award_info_t_prize_url));
_mcpack2_load_award_info_t_readmap.create(16*6);
_mcpack2_load_award_info_t_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_award_info_t_static_inited=_mcpack2_load_award_info_t_static_init();
// @@string type;
static void _mcpack2_load_award_info_t_type(__attribute__((unused)) const mc_pack_item_t* item,award_info_t* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type";
}
self->_m_type.set_ptr(item->value,item->value_size-1);
}
// @@string award_id;
static void _mcpack2_load_award_info_t_award_id(__attribute__((unused)) const mc_pack_item_t* item,award_info_t* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "award_id";
}
self->_m_award_id.set_ptr(item->value,item->value_size-1);
}
// @@string name;
static void _mcpack2_load_award_info_t_name(__attribute__((unused)) const mc_pack_item_t* item,award_info_t* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string prize_name;
static void _mcpack2_load_award_info_t_prize_name(__attribute__((unused)) const mc_pack_item_t* item,award_info_t* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "prize_name";
}
self->_m_prize_name.set_ptr(item->value,item->value_size-1);
}
// @@string icon;
static void _mcpack2_load_award_info_t_icon(__attribute__((unused)) const mc_pack_item_t* item,award_info_t* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "icon";
}
self->_m_icon.set_ptr(item->value,item->value_size-1);
}
// @@string prize_url;
static void _mcpack2_load_award_info_t_prize_url(__attribute__((unused)) const mc_pack_item_t* item,award_info_t* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "prize_url";
}
self->_m_prize_url.set_ptr(item->value,item->value_size-1);
}
void award_info_t::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,award_info_t*)=0;
do{
if(_mcpack2_load_award_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int award_info_t::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,award_info_t*)=0;
if(_mcpack2_load_award_info_t_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void award_info_t::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t award_info_t::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string type;
{
int res=mc_pack_put_str(pack,"type",_m_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string award_id;
{
int res=mc_pack_put_str(pack,"award_id",_m_award_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name;
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string prize_name;
{
int res=mc_pack_put_str(pack,"prize_name",_m_prize_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string icon;
{
int res=mc_pack_put_str(pack,"icon",_m_icon.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string prize_url;
{
int res=mc_pack_put_str(pack,"prize_url",_m_prize_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_test_params
static void _mcpack2_load_mcp_get_test_params_info_type(const mc_pack_item_t*,mcp_get_test_params*);
static void _mcpack2_load_mcp_get_test_params_unit_num(const mc_pack_item_t*,mcp_get_test_params*);
static void _mcpack2_load_mcp_get_test_params_unit_times(const mc_pack_item_t*,mcp_get_test_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_test_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_test_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_test_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_test_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_test_params*)>("info_type",_mcpack2_load_mcp_get_test_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_test_params*)>("unit_num",_mcpack2_load_mcp_get_test_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_test_params*)>("unit_times",_mcpack2_load_mcp_get_test_params_unit_times));
_mcpack2_load_mcp_get_test_params_readmap.create(16*3);
_mcpack2_load_mcp_get_test_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_test_params_static_inited=_mcpack2_load_mcp_get_test_params_static_init();
// @@uint32_t info_type=in();
static void _mcpack2_load_mcp_get_test_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_test_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_test_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_test_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_test_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_test_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_test_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_test_params*)=0;
do{
if(_mcpack2_load_mcp_get_test_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_test_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_test_params*)=0;
if(_mcpack2_load_mcp_get_test_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_test_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_test_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t info_type=in();
{
int res=mc_pack_put_uint32(pack,"info_type",_m_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_test_result_params
static void _mcpack2_load_mcp_get_test_result_params_info_count(const mc_pack_item_t*,mcp_get_test_result_params*);
static void _mcpack2_load_mcp_get_test_result_params_info_id(const mc_pack_item_t*,mcp_get_test_result_params*);
static void _mcpack2_load_mcp_get_test_result_params_info_name(const mc_pack_item_t*,mcp_get_test_result_params*);
static void _mcpack2_load_mcp_get_test_result_params_phone_count(const mc_pack_item_t*,mcp_get_test_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_test_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_test_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_test_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_test_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_test_result_params*)>("info_count",_mcpack2_load_mcp_get_test_result_params_info_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_test_result_params*)>("info_id",_mcpack2_load_mcp_get_test_result_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_test_result_params*)>("info_name",_mcpack2_load_mcp_get_test_result_params_info_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_test_result_params*)>("phone_count",_mcpack2_load_mcp_get_test_result_params_phone_count));
_mcpack2_load_mcp_get_test_result_params_readmap.create(16*4);
_mcpack2_load_mcp_get_test_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_test_result_params_static_inited=_mcpack2_load_mcp_get_test_result_params_static_init();
// @@uint32_t info_count=out();
static void _mcpack2_load_mcp_get_test_result_params_info_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_test_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_count";
}
}
// @@string info_id=out(),array(0);
static void _mcpack2_load_mcp_get_test_result_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_test_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_id";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_id)) lp0=&(self->_m_info_id);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_id";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_id";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string info_name=out(),array(0);
static void _mcpack2_load_mcp_get_test_result_params_info_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_test_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_name";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_name)) lp0=&(self->_m_info_name);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_name";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_name";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_name";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@uint32_t phone_count=out(),array(0);
static void _mcpack2_load_mcp_get_test_result_params_phone_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_test_result_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_count";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_phone_count)) lp0=&(self->_m_phone_count);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_count";
}
for(int i0=0;i0<size0;i0++){
res0=mc_pack_get_uint32_from_item(&item0,lp0->MutableGetWithoutCheck(i0));
if(res0){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_count";
}
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_count";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_test_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_test_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_test_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_test_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_test_result_params*)=0;
if(_mcpack2_load_mcp_get_test_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_test_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_test_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t info_count=out();
{
int res=mc_pack_put_uint32(pack,"info_count",_m_info_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_id");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_id)& lr0=(_m_info_id);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string info_name=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_name");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_name)& lr0=(_m_info_name);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@uint32_t phone_count=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"phone_count");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_phone_count)& lr0=(_m_phone_count);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_uint32(pack0,0,lr0.GetWithoutCheck(i0));
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_test_response
static void _mcpack2_load_mcp_get_test_response_result_params(const mc_pack_item_t*,mcp_get_test_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_test_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_test_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_test_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_test_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_test_response*)>("result_params",_mcpack2_load_mcp_get_test_response_result_params));
_mcpack2_load_mcp_get_test_response_readmap.create(16*1);
_mcpack2_load_mcp_get_test_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_test_response_static_inited=_mcpack2_load_mcp_get_test_response_static_init();
// @@mcp_get_test_result_params result_params;
static void _mcpack2_load_mcp_get_test_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_test_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_test_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_test_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_test_response*)=0;
do{
if(_mcpack2_load_mcp_get_test_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_test_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_test_response*)=0;
if(_mcpack2_load_mcp_get_test_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_test_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_test_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_test_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_maker_plat_params
static void _mcpack2_load_mcp_get_phone_maker_plat_params_info_type(const mc_pack_item_t*,mcp_get_phone_maker_plat_params*);
static void _mcpack2_load_mcp_get_phone_maker_plat_params_unit_num(const mc_pack_item_t*,mcp_get_phone_maker_plat_params*);
static void _mcpack2_load_mcp_get_phone_maker_plat_params_unit_times(const mc_pack_item_t*,mcp_get_phone_maker_plat_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_maker_plat_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_maker_plat_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_params*)>("info_type",_mcpack2_load_mcp_get_phone_maker_plat_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_params*)>("unit_num",_mcpack2_load_mcp_get_phone_maker_plat_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_params*)>("unit_times",_mcpack2_load_mcp_get_phone_maker_plat_params_unit_times));
_mcpack2_load_mcp_get_phone_maker_plat_params_readmap.create(16*3);
_mcpack2_load_mcp_get_phone_maker_plat_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_maker_plat_params_static_inited=_mcpack2_load_mcp_get_phone_maker_plat_params_static_init();
// @@uint32_t info_type=in();
static void _mcpack2_load_mcp_get_phone_maker_plat_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_maker_plat_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_phone_maker_plat_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_maker_plat_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_phone_maker_plat_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_maker_plat_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_phone_maker_plat_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_maker_plat_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_maker_plat_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_maker_plat_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_maker_plat_params*)=0;
if(_mcpack2_load_mcp_get_phone_maker_plat_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_maker_plat_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_maker_plat_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t info_type=in();
{
int res=mc_pack_put_uint32(pack,"info_type",_m_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_maker_plat_result_params
static void _mcpack2_load_mcp_get_phone_maker_plat_result_params_info_count(const mc_pack_item_t*,mcp_get_phone_maker_plat_result_params*);
static void _mcpack2_load_mcp_get_phone_maker_plat_result_params_info_id(const mc_pack_item_t*,mcp_get_phone_maker_plat_result_params*);
static void _mcpack2_load_mcp_get_phone_maker_plat_result_params_info_name(const mc_pack_item_t*,mcp_get_phone_maker_plat_result_params*);
static void _mcpack2_load_mcp_get_phone_maker_plat_result_params_phone_count(const mc_pack_item_t*,mcp_get_phone_maker_plat_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_maker_plat_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_maker_plat_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_result_params*)>("info_count",_mcpack2_load_mcp_get_phone_maker_plat_result_params_info_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_result_params*)>("info_id",_mcpack2_load_mcp_get_phone_maker_plat_result_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_result_params*)>("info_name",_mcpack2_load_mcp_get_phone_maker_plat_result_params_info_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_result_params*)>("phone_count",_mcpack2_load_mcp_get_phone_maker_plat_result_params_phone_count));
_mcpack2_load_mcp_get_phone_maker_plat_result_params_readmap.create(16*4);
_mcpack2_load_mcp_get_phone_maker_plat_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_maker_plat_result_params_static_inited=_mcpack2_load_mcp_get_phone_maker_plat_result_params_static_init();
// @@uint32_t info_count=out();
static void _mcpack2_load_mcp_get_phone_maker_plat_result_params_info_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_maker_plat_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_count";
}
}
// @@string info_id=out(),array(0);
static void _mcpack2_load_mcp_get_phone_maker_plat_result_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_maker_plat_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_id";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_id)) lp0=&(self->_m_info_id);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_id";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_id";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string info_name=out(),array(0);
static void _mcpack2_load_mcp_get_phone_maker_plat_result_params_info_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_maker_plat_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_name";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_name)) lp0=&(self->_m_info_name);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_name";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_name";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_name";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@uint32_t phone_count=out(),array(0);
static void _mcpack2_load_mcp_get_phone_maker_plat_result_params_phone_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_maker_plat_result_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_count";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_phone_count)) lp0=&(self->_m_phone_count);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_count";
}
for(int i0=0;i0<size0;i0++){
res0=mc_pack_get_uint32_from_item(&item0,lp0->MutableGetWithoutCheck(i0));
if(res0){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_count";
}
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_count";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_phone_maker_plat_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_maker_plat_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_maker_plat_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_maker_plat_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_maker_plat_result_params*)=0;
if(_mcpack2_load_mcp_get_phone_maker_plat_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_maker_plat_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_maker_plat_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t info_count=out();
{
int res=mc_pack_put_uint32(pack,"info_count",_m_info_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_id");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_id)& lr0=(_m_info_id);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string info_name=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_name");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_name)& lr0=(_m_info_name);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@uint32_t phone_count=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"phone_count");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_phone_count)& lr0=(_m_phone_count);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_uint32(pack0,0,lr0.GetWithoutCheck(i0));
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_maker_plat_response
static void _mcpack2_load_mcp_get_phone_maker_plat_response_result_params(const mc_pack_item_t*,mcp_get_phone_maker_plat_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_maker_plat_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_maker_plat_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_maker_plat_response*)>("result_params",_mcpack2_load_mcp_get_phone_maker_plat_response_result_params));
_mcpack2_load_mcp_get_phone_maker_plat_response_readmap.create(16*1);
_mcpack2_load_mcp_get_phone_maker_plat_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_maker_plat_response_static_inited=_mcpack2_load_mcp_get_phone_maker_plat_response_static_init();
// @@mcp_get_phone_maker_plat_result_params result_params;
static void _mcpack2_load_mcp_get_phone_maker_plat_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_maker_plat_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_phone_maker_plat_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_phone_maker_plat_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_maker_plat_response*)=0;
do{
if(_mcpack2_load_mcp_get_phone_maker_plat_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_maker_plat_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_maker_plat_response*)=0;
if(_mcpack2_load_mcp_get_phone_maker_plat_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_maker_plat_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_maker_plat_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_phone_maker_plat_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_classID_params
static void _mcpack2_load_mcp_get_content_list_from_classID_params_class_id(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_params_content_type_id(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_params_priority(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_params_info_id(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_params_info_type(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_params_img_size(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_params_unit_num(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_params_unit_times(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_params_for_adapt(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_classID_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_classID_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*)>("class_id",_mcpack2_load_mcp_get_content_list_from_classID_params_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*)>("content_type_id",_mcpack2_load_mcp_get_content_list_from_classID_params_content_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*)>("priority",_mcpack2_load_mcp_get_content_list_from_classID_params_priority));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*)>("info_id",_mcpack2_load_mcp_get_content_list_from_classID_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*)>("info_type",_mcpack2_load_mcp_get_content_list_from_classID_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*)>("img_size",_mcpack2_load_mcp_get_content_list_from_classID_params_img_size));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*)>("unit_num",_mcpack2_load_mcp_get_content_list_from_classID_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*)>("unit_times",_mcpack2_load_mcp_get_content_list_from_classID_params_unit_times));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*)>("for_adapt",_mcpack2_load_mcp_get_content_list_from_classID_params_for_adapt));
_mcpack2_load_mcp_get_content_list_from_classID_params_readmap.create(16*9);
_mcpack2_load_mcp_get_content_list_from_classID_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_classID_params_static_inited=_mcpack2_load_mcp_get_content_list_from_classID_params_static_init();
// @@string class_id=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_params_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
// @@string content_type_id=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_params_content_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_type_id";
}
self->_m_content_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t priority=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_params_priority(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_priority));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "priority";
}
}
// @@string info_id=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t info_type=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
}
// @@string img_size=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_params_img_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "img_size";
}
self->_m_img_size.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_params* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
// @@uint32_t for_adapt=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_params_for_adapt(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_params* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_for_adapt));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "for_adapt";
}
}
void mcp_get_content_list_from_classID_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_classID_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_classID_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_classID_params*)=0;
if(_mcpack2_load_mcp_get_content_list_from_classID_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_classID_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_classID_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string class_id=in();
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_type_id=in();
{
int res=mc_pack_put_str(pack,"content_type_id",_m_content_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t priority=in();
{
int res=mc_pack_put_uint32(pack,"priority",_m_priority);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t info_type=in();
{
int res=mc_pack_put_uint32(pack,"info_type",_m_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string img_size=in();
{
int res=mc_pack_put_str(pack,"img_size",_m_img_size.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t for_adapt=in();
{
int res=mc_pack_put_uint32(pack,"for_adapt",_m_for_adapt);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_classID_result_params
static void _mcpack2_load_mcp_get_content_list_from_classID_result_params_count(const mc_pack_item_t*,mcp_get_content_list_from_classID_result_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_result_params_content_list(const mc_pack_item_t*,mcp_get_content_list_from_classID_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_classID_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_classID_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_result_params*)>("count",_mcpack2_load_mcp_get_content_list_from_classID_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_result_params*)>("content_list",_mcpack2_load_mcp_get_content_list_from_classID_result_params_content_list));
_mcpack2_load_mcp_get_content_list_from_classID_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_list_from_classID_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_classID_result_params_static_inited=_mcpack2_load_mcp_get_content_list_from_classID_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_content_list_from_classID_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string content_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_content_list_from_classID_result_params_content_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_content_list)) lp0=&(self->_m_content_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_list_from_classID_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_classID_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_classID_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_classID_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_classID_result_params*)=0;
if(_mcpack2_load_mcp_get_content_list_from_classID_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_classID_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_classID_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"content_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_content_list)& lr0=(_m_content_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_classID_response
static void _mcpack2_load_mcp_get_content_list_from_classID_response_result_params(const mc_pack_item_t*,mcp_get_content_list_from_classID_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_classID_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_classID_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_response*)>("result_params",_mcpack2_load_mcp_get_content_list_from_classID_response_result_params));
_mcpack2_load_mcp_get_content_list_from_classID_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_list_from_classID_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_classID_response_static_inited=_mcpack2_load_mcp_get_content_list_from_classID_response_static_init();
// @@mcp_get_content_list_from_classID_result_params result_params;
static void _mcpack2_load_mcp_get_content_list_from_classID_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_list_from_classID_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_list_from_classID_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_classID_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_classID_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_classID_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_classID_response*)=0;
if(_mcpack2_load_mcp_get_content_list_from_classID_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_classID_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_classID_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_list_from_classID_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_typeID_params
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_content_type_id(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*);
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_priority(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*);
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_info_id(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*);
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_info_type(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*);
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_img_size(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*);
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_unit_num(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*);
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_unit_times(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_typeID_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_typeID_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*)>("content_type_id",_mcpack2_load_mcp_get_content_list_from_typeID_params_content_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*)>("priority",_mcpack2_load_mcp_get_content_list_from_typeID_params_priority));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*)>("info_id",_mcpack2_load_mcp_get_content_list_from_typeID_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*)>("info_type",_mcpack2_load_mcp_get_content_list_from_typeID_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*)>("img_size",_mcpack2_load_mcp_get_content_list_from_typeID_params_img_size));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*)>("unit_num",_mcpack2_load_mcp_get_content_list_from_typeID_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*)>("unit_times",_mcpack2_load_mcp_get_content_list_from_typeID_params_unit_times));
_mcpack2_load_mcp_get_content_list_from_typeID_params_readmap.create(16*7);
_mcpack2_load_mcp_get_content_list_from_typeID_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_typeID_params_static_inited=_mcpack2_load_mcp_get_content_list_from_typeID_params_static_init();
// @@string content_type_id=in();
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_content_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_typeID_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_type_id";
}
self->_m_content_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t priority=in();
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_priority(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_typeID_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_priority));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "priority";
}
}
// @@string info_id=in();
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_typeID_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t info_type=in();
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_typeID_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
}
// @@string img_size=in();
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_img_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_typeID_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "img_size";
}
self->_m_img_size.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_typeID_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_content_list_from_typeID_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_typeID_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_content_list_from_typeID_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_typeID_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_typeID_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_params*)=0;
if(_mcpack2_load_mcp_get_content_list_from_typeID_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_typeID_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_typeID_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string content_type_id=in();
{
int res=mc_pack_put_str(pack,"content_type_id",_m_content_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t priority=in();
{
int res=mc_pack_put_uint32(pack,"priority",_m_priority);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t info_type=in();
{
int res=mc_pack_put_uint32(pack,"info_type",_m_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string img_size=in();
{
int res=mc_pack_put_str(pack,"img_size",_m_img_size.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_typeID_result_params
static void _mcpack2_load_mcp_get_content_list_from_typeID_result_params_count(const mc_pack_item_t*,mcp_get_content_list_from_typeID_result_params*);
static void _mcpack2_load_mcp_get_content_list_from_typeID_result_params_content_list(const mc_pack_item_t*,mcp_get_content_list_from_typeID_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_typeID_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_typeID_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_result_params*)>("count",_mcpack2_load_mcp_get_content_list_from_typeID_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_result_params*)>("content_list",_mcpack2_load_mcp_get_content_list_from_typeID_result_params_content_list));
_mcpack2_load_mcp_get_content_list_from_typeID_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_list_from_typeID_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_typeID_result_params_static_inited=_mcpack2_load_mcp_get_content_list_from_typeID_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_content_list_from_typeID_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_typeID_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string content_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_content_list_from_typeID_result_params_content_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_typeID_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_content_list)) lp0=&(self->_m_content_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_list_from_typeID_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_typeID_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_typeID_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_result_params*)=0;
if(_mcpack2_load_mcp_get_content_list_from_typeID_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_typeID_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_typeID_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"content_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_content_list)& lr0=(_m_content_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_typeID_response
static void _mcpack2_load_mcp_get_content_list_from_typeID_response_result_params(const mc_pack_item_t*,mcp_get_content_list_from_typeID_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_typeID_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_typeID_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_response*)>("result_params",_mcpack2_load_mcp_get_content_list_from_typeID_response_result_params));
_mcpack2_load_mcp_get_content_list_from_typeID_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_list_from_typeID_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_typeID_response_static_inited=_mcpack2_load_mcp_get_content_list_from_typeID_response_static_init();
// @@mcp_get_content_list_from_typeID_result_params result_params;
static void _mcpack2_load_mcp_get_content_list_from_typeID_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_typeID_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_list_from_typeID_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_list_from_typeID_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_typeID_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_typeID_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_typeID_response*)=0;
if(_mcpack2_load_mcp_get_content_list_from_typeID_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_typeID_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_typeID_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_list_from_typeID_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_class_params
static void _mcpack2_load_mcp_get_content_class_params_content_type_id(const mc_pack_item_t*,mcp_get_content_class_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_class_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_class_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_class_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_class_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_class_params*)>("content_type_id",_mcpack2_load_mcp_get_content_class_params_content_type_id));
_mcpack2_load_mcp_get_content_class_params_readmap.create(16*1);
_mcpack2_load_mcp_get_content_class_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_class_params_static_inited=_mcpack2_load_mcp_get_content_class_params_static_init();
// @@string content_type_id=in();
static void _mcpack2_load_mcp_get_content_class_params_content_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_class_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_type_id";
}
self->_m_content_type_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_content_class_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_class_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_class_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_class_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_class_params*)=0;
if(_mcpack2_load_mcp_get_content_class_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_class_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_class_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string content_type_id=in();
{
int res=mc_pack_put_str(pack,"content_type_id",_m_content_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_class_result_params
static void _mcpack2_load_mcp_get_content_class_result_params_content_class_id(const mc_pack_item_t*,mcp_get_content_class_result_params*);
static void _mcpack2_load_mcp_get_content_class_result_params_content_class_name(const mc_pack_item_t*,mcp_get_content_class_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_class_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_class_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_class_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_class_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_class_result_params*)>("content_class_id",_mcpack2_load_mcp_get_content_class_result_params_content_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_class_result_params*)>("content_class_name",_mcpack2_load_mcp_get_content_class_result_params_content_class_name));
_mcpack2_load_mcp_get_content_class_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_class_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_class_result_params_static_inited=_mcpack2_load_mcp_get_content_class_result_params_static_init();
// @@string content_class_id=out(),array(0);
static void _mcpack2_load_mcp_get_content_class_result_params_content_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_class_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_class_id";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_content_class_id)) lp0=&(self->_m_content_class_id);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_class_id";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_class_id";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_class_id";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string content_class_name=out(),array(0);
static void _mcpack2_load_mcp_get_content_class_result_params_content_class_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_class_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_class_name";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_content_class_name)) lp0=&(self->_m_content_class_name);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_class_name";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_class_name";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_class_name";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_class_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_class_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_class_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_class_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_class_result_params*)=0;
if(_mcpack2_load_mcp_get_content_class_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_class_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_class_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string content_class_id=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"content_class_id");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_content_class_id)& lr0=(_m_content_class_id);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string content_class_name=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"content_class_name");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_content_class_name)& lr0=(_m_content_class_name);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_class_response
static void _mcpack2_load_mcp_get_content_class_response_result_params(const mc_pack_item_t*,mcp_get_content_class_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_class_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_class_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_class_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_class_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_class_response*)>("result_params",_mcpack2_load_mcp_get_content_class_response_result_params));
_mcpack2_load_mcp_get_content_class_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_class_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_class_response_static_inited=_mcpack2_load_mcp_get_content_class_response_static_init();
// @@mcp_get_content_class_result_params result_params;
static void _mcpack2_load_mcp_get_content_class_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_class_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_class_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_class_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_class_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_class_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_class_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_class_response*)=0;
if(_mcpack2_load_mcp_get_content_class_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_class_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_class_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_class_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_class_name_params
static void _mcpack2_load_mcp_get_content_class_name_params_class_id(const mc_pack_item_t*,mcp_get_content_class_name_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_class_name_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_class_name_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_class_name_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_class_name_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_class_name_params*)>("class_id",_mcpack2_load_mcp_get_content_class_name_params_class_id));
_mcpack2_load_mcp_get_content_class_name_params_readmap.create(16*1);
_mcpack2_load_mcp_get_content_class_name_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_class_name_params_static_inited=_mcpack2_load_mcp_get_content_class_name_params_static_init();
// @@string class_id=in();
static void _mcpack2_load_mcp_get_content_class_name_params_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_class_name_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_content_class_name_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_class_name_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_class_name_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_class_name_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_class_name_params*)=0;
if(_mcpack2_load_mcp_get_content_class_name_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_class_name_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_class_name_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string class_id=in();
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_class_name_result_params
static void _mcpack2_load_mcp_get_content_class_name_result_params_class_name(const mc_pack_item_t*,mcp_get_content_class_name_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_class_name_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_class_name_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_class_name_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_class_name_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_class_name_result_params*)>("class_name",_mcpack2_load_mcp_get_content_class_name_result_params_class_name));
_mcpack2_load_mcp_get_content_class_name_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_content_class_name_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_class_name_result_params_static_inited=_mcpack2_load_mcp_get_content_class_name_result_params_static_init();
// @@string class_name=out();
static void _mcpack2_load_mcp_get_content_class_name_result_params_class_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_class_name_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_name";
}
self->_m_class_name.set_ptr(item->value,item->value_size-1);
}
void mcp_get_content_class_name_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_class_name_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_class_name_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_class_name_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_class_name_result_params*)=0;
if(_mcpack2_load_mcp_get_content_class_name_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_class_name_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_class_name_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string class_name=out();
{
int res=mc_pack_put_str(pack,"class_name",_m_class_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_class_name_response
static void _mcpack2_load_mcp_get_content_class_name_response_result_params(const mc_pack_item_t*,mcp_get_content_class_name_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_class_name_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_class_name_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_class_name_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_class_name_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_class_name_response*)>("result_params",_mcpack2_load_mcp_get_content_class_name_response_result_params));
_mcpack2_load_mcp_get_content_class_name_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_class_name_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_class_name_response_static_inited=_mcpack2_load_mcp_get_content_class_name_response_static_init();
// @@mcp_get_content_class_name_result_params result_params;
static void _mcpack2_load_mcp_get_content_class_name_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_class_name_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_class_name_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_class_name_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_class_name_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_class_name_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_class_name_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_class_name_response*)=0;
if(_mcpack2_load_mcp_get_content_class_name_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_class_name_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_class_name_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_class_name_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_diy_col_name_params
static void _mcpack2_load_mcp_get_content_diy_col_name_params_diycol_id(const mc_pack_item_t*,mcp_get_content_diy_col_name_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_diy_col_name_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_diy_col_name_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_diy_col_name_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_diy_col_name_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_diy_col_name_params*)>("diycol_id",_mcpack2_load_mcp_get_content_diy_col_name_params_diycol_id));
_mcpack2_load_mcp_get_content_diy_col_name_params_readmap.create(16*1);
_mcpack2_load_mcp_get_content_diy_col_name_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_diy_col_name_params_static_inited=_mcpack2_load_mcp_get_content_diy_col_name_params_static_init();
// @@string diycol_id=in();
static void _mcpack2_load_mcp_get_content_diy_col_name_params_diycol_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_diy_col_name_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "diycol_id";
}
self->_m_diycol_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_content_diy_col_name_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_diy_col_name_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_diy_col_name_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_diy_col_name_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_diy_col_name_params*)=0;
if(_mcpack2_load_mcp_get_content_diy_col_name_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_diy_col_name_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_diy_col_name_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string diycol_id=in();
{
int res=mc_pack_put_str(pack,"diycol_id",_m_diycol_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_diy_col_name_result_params
static void _mcpack2_load_mcp_get_content_diy_col_name_result_params_diycol_name(const mc_pack_item_t*,mcp_get_content_diy_col_name_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_diy_col_name_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_diy_col_name_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_diy_col_name_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_diy_col_name_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_diy_col_name_result_params*)>("diycol_name",_mcpack2_load_mcp_get_content_diy_col_name_result_params_diycol_name));
_mcpack2_load_mcp_get_content_diy_col_name_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_content_diy_col_name_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_diy_col_name_result_params_static_inited=_mcpack2_load_mcp_get_content_diy_col_name_result_params_static_init();
// @@string diycol_name=out();
static void _mcpack2_load_mcp_get_content_diy_col_name_result_params_diycol_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_diy_col_name_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "diycol_name";
}
self->_m_diycol_name.set_ptr(item->value,item->value_size-1);
}
void mcp_get_content_diy_col_name_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_diy_col_name_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_diy_col_name_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_diy_col_name_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_diy_col_name_result_params*)=0;
if(_mcpack2_load_mcp_get_content_diy_col_name_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_diy_col_name_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_diy_col_name_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string diycol_name=out();
{
int res=mc_pack_put_str(pack,"diycol_name",_m_diycol_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_diy_col_name_response
static void _mcpack2_load_mcp_get_content_diy_col_name_response_result_params(const mc_pack_item_t*,mcp_get_content_diy_col_name_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_diy_col_name_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_diy_col_name_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_diy_col_name_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_diy_col_name_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_diy_col_name_response*)>("result_params",_mcpack2_load_mcp_get_content_diy_col_name_response_result_params));
_mcpack2_load_mcp_get_content_diy_col_name_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_diy_col_name_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_diy_col_name_response_static_inited=_mcpack2_load_mcp_get_content_diy_col_name_response_static_init();
// @@mcp_get_content_diy_col_name_result_params result_params;
static void _mcpack2_load_mcp_get_content_diy_col_name_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_diy_col_name_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_diy_col_name_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_diy_col_name_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_diy_col_name_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_diy_col_name_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_diy_col_name_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_diy_col_name_response*)=0;
if(_mcpack2_load_mcp_get_content_diy_col_name_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_diy_col_name_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_diy_col_name_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_diy_col_name_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_info_params
static void _mcpack2_load_mcp_get_content_info_params_content_id(const mc_pack_item_t*,mcp_get_content_info_params*);
static void _mcpack2_load_mcp_get_content_info_params_content_ext(const mc_pack_item_t*,mcp_get_content_info_params*);
static void _mcpack2_load_mcp_get_content_info_params_info_id(const mc_pack_item_t*,mcp_get_content_info_params*);
static void _mcpack2_load_mcp_get_content_info_params_info_type(const mc_pack_item_t*,mcp_get_content_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_params*)>("content_id",_mcpack2_load_mcp_get_content_info_params_content_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_params*)>("content_ext",_mcpack2_load_mcp_get_content_info_params_content_ext));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_params*)>("info_id",_mcpack2_load_mcp_get_content_info_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_params*)>("info_type",_mcpack2_load_mcp_get_content_info_params_info_type));
_mcpack2_load_mcp_get_content_info_params_readmap.create(16*4);
_mcpack2_load_mcp_get_content_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_info_params_static_inited=_mcpack2_load_mcp_get_content_info_params_static_init();
// @@string content_id=in();
static void _mcpack2_load_mcp_get_content_info_params_content_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_id";
}
self->_m_content_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t content_ext=in();
static void _mcpack2_load_mcp_get_content_info_params_content_ext(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_content_ext));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_ext";
}
}
// @@string info_id=in();
static void _mcpack2_load_mcp_get_content_info_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_info_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t info_type=in();
static void _mcpack2_load_mcp_get_content_info_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_info_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
}
void mcp_get_content_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_params*)=0;
if(_mcpack2_load_mcp_get_content_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string content_id=in();
{
int res=mc_pack_put_str(pack,"content_id",_m_content_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t content_ext=in();
{
int res=mc_pack_put_uint32(pack,"content_ext",_m_content_ext);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t info_type=in();
{
int res=mc_pack_put_uint32(pack,"info_type",_m_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_info_result_params
static void _mcpack2_load_mcp_get_content_info_result_params_info_list(const mc_pack_item_t*,mcp_get_content_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_result_params*)>("info_list",_mcpack2_load_mcp_get_content_info_result_params_info_list));
_mcpack2_load_mcp_get_content_info_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_content_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_info_result_params_static_inited=_mcpack2_load_mcp_get_content_info_result_params_static_init();
// @@string info_list=out(),array(0);
static void _mcpack2_load_mcp_get_content_info_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_list";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_result_params*)=0;
if(_mcpack2_load_mcp_get_content_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_info_response
static void _mcpack2_load_mcp_get_content_info_response_result_params(const mc_pack_item_t*,mcp_get_content_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_response*)>("result_params",_mcpack2_load_mcp_get_content_info_response_result_params));
_mcpack2_load_mcp_get_content_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_info_response_static_inited=_mcpack2_load_mcp_get_content_info_response_static_init();
// @@mcp_get_content_info_result_params result_params;
static void _mcpack2_load_mcp_get_content_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_response*)=0;
if(_mcpack2_load_mcp_get_content_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_download_info_params
static void _mcpack2_load_mcp_get_download_info_params_content_id(const mc_pack_item_t*,mcp_get_download_info_params*);
static void _mcpack2_load_mcp_get_download_info_params_info_id(const mc_pack_item_t*,mcp_get_download_info_params*);
static void _mcpack2_load_mcp_get_download_info_params_info_type(const mc_pack_item_t*,mcp_get_download_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_download_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_download_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_download_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_info_params*)>("content_id",_mcpack2_load_mcp_get_download_info_params_content_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_info_params*)>("info_id",_mcpack2_load_mcp_get_download_info_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_info_params*)>("info_type",_mcpack2_load_mcp_get_download_info_params_info_type));
_mcpack2_load_mcp_get_download_info_params_readmap.create(16*3);
_mcpack2_load_mcp_get_download_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_download_info_params_static_inited=_mcpack2_load_mcp_get_download_info_params_static_init();
// @@string content_id=in();
static void _mcpack2_load_mcp_get_download_info_params_content_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_id";
}
self->_m_content_id.set_ptr(item->value,item->value_size-1);
}
// @@string info_id=in();
static void _mcpack2_load_mcp_get_download_info_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t info_type=in();
static void _mcpack2_load_mcp_get_download_info_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_info_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
}
void mcp_get_download_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_download_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_download_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_download_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_download_info_params*)=0;
if(_mcpack2_load_mcp_get_download_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_download_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_download_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string content_id=in();
{
int res=mc_pack_put_str(pack,"content_id",_m_content_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t info_type=in();
{
int res=mc_pack_put_uint32(pack,"info_type",_m_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_download_info_result_params
static void _mcpack2_load_mcp_get_download_info_result_params_download_info(const mc_pack_item_t*,mcp_get_download_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_download_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_download_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_download_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_info_result_params*)>("download_info",_mcpack2_load_mcp_get_download_info_result_params_download_info));
_mcpack2_load_mcp_get_download_info_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_download_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_download_info_result_params_static_inited=_mcpack2_load_mcp_get_download_info_result_params_static_init();
// @@string download_info=out(),array(0,0);
static void _mcpack2_load_mcp_get_download_info_result_params_download_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_download_info)) lp0=&(self->_m_download_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "download_info";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_download_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_download_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_download_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_download_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_download_info_result_params*)=0;
if(_mcpack2_load_mcp_get_download_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_download_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_download_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string download_info=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"download_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_download_info)& lr0=(_m_download_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_download_info_response
static void _mcpack2_load_mcp_get_download_info_response_result_params(const mc_pack_item_t*,mcp_get_download_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_download_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_download_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_download_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_info_response*)>("result_params",_mcpack2_load_mcp_get_download_info_response_result_params));
_mcpack2_load_mcp_get_download_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_download_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_download_info_response_static_inited=_mcpack2_load_mcp_get_download_info_response_static_init();
// @@mcp_get_download_info_result_params result_params;
static void _mcpack2_load_mcp_get_download_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_download_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_download_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_download_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_download_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_download_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_download_info_response*)=0;
if(_mcpack2_load_mcp_get_download_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_download_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_download_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_download_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_params
static void _mcpack2_load_mcp_get_content_list_params_priority(const mc_pack_item_t*,mcp_get_content_list_params*);
static void _mcpack2_load_mcp_get_content_list_params_info_id(const mc_pack_item_t*,mcp_get_content_list_params*);
static void _mcpack2_load_mcp_get_content_list_params_info_type(const mc_pack_item_t*,mcp_get_content_list_params*);
static void _mcpack2_load_mcp_get_content_list_params_unit_num(const mc_pack_item_t*,mcp_get_content_list_params*);
static void _mcpack2_load_mcp_get_content_list_params_unit_times(const mc_pack_item_t*,mcp_get_content_list_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_params*)>("priority",_mcpack2_load_mcp_get_content_list_params_priority));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_params*)>("info_id",_mcpack2_load_mcp_get_content_list_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_params*)>("info_type",_mcpack2_load_mcp_get_content_list_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_params*)>("unit_num",_mcpack2_load_mcp_get_content_list_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_params*)>("unit_times",_mcpack2_load_mcp_get_content_list_params_unit_times));
_mcpack2_load_mcp_get_content_list_params_readmap.create(16*5);
_mcpack2_load_mcp_get_content_list_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_params_static_inited=_mcpack2_load_mcp_get_content_list_params_static_init();
// @@uint32_t priority=in();
static void _mcpack2_load_mcp_get_content_list_params_priority(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_priority));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "priority";
}
}
// @@string info_id=in();
static void _mcpack2_load_mcp_get_content_list_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t info_type=in();
static void _mcpack2_load_mcp_get_content_list_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_content_list_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_content_list_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_content_list_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_params*)=0;
if(_mcpack2_load_mcp_get_content_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t priority=in();
{
int res=mc_pack_put_uint32(pack,"priority",_m_priority);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t info_type=in();
{
int res=mc_pack_put_uint32(pack,"info_type",_m_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_result_params
static void _mcpack2_load_mcp_get_content_list_result_params_count(const mc_pack_item_t*,mcp_get_content_list_result_params*);
static void _mcpack2_load_mcp_get_content_list_result_params_content_list(const mc_pack_item_t*,mcp_get_content_list_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_result_params*)>("count",_mcpack2_load_mcp_get_content_list_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_result_params*)>("content_list",_mcpack2_load_mcp_get_content_list_result_params_content_list));
_mcpack2_load_mcp_get_content_list_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_list_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_result_params_static_inited=_mcpack2_load_mcp_get_content_list_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_content_list_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string content_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_content_list_result_params_content_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_content_list)) lp0=&(self->_m_content_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_list_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_result_params*)=0;
if(_mcpack2_load_mcp_get_content_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"content_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_content_list)& lr0=(_m_content_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_response
static void _mcpack2_load_mcp_get_content_list_response_result_params(const mc_pack_item_t*,mcp_get_content_list_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_response*)>("result_params",_mcpack2_load_mcp_get_content_list_response_result_params));
_mcpack2_load_mcp_get_content_list_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_list_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_response_static_inited=_mcpack2_load_mcp_get_content_list_response_static_init();
// @@mcp_get_content_list_result_params result_params;
static void _mcpack2_load_mcp_get_content_list_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_list_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_list_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_response*)=0;
if(_mcpack2_load_mcp_get_content_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_list_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_part_params
static void _mcpack2_load_mcp_get_content_list_from_part_params_part_id(const mc_pack_item_t*,mcp_get_content_list_from_part_params*);
static void _mcpack2_load_mcp_get_content_list_from_part_params_content_type_id(const mc_pack_item_t*,mcp_get_content_list_from_part_params*);
static void _mcpack2_load_mcp_get_content_list_from_part_params_info_id(const mc_pack_item_t*,mcp_get_content_list_from_part_params*);
static void _mcpack2_load_mcp_get_content_list_from_part_params_info_type(const mc_pack_item_t*,mcp_get_content_list_from_part_params*);
static void _mcpack2_load_mcp_get_content_list_from_part_params_unit_num(const mc_pack_item_t*,mcp_get_content_list_from_part_params*);
static void _mcpack2_load_mcp_get_content_list_from_part_params_unit_times(const mc_pack_item_t*,mcp_get_content_list_from_part_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_part_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_part_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_params*)>("part_id",_mcpack2_load_mcp_get_content_list_from_part_params_part_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_params*)>("content_type_id",_mcpack2_load_mcp_get_content_list_from_part_params_content_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_params*)>("info_id",_mcpack2_load_mcp_get_content_list_from_part_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_params*)>("info_type",_mcpack2_load_mcp_get_content_list_from_part_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_params*)>("unit_num",_mcpack2_load_mcp_get_content_list_from_part_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_params*)>("unit_times",_mcpack2_load_mcp_get_content_list_from_part_params_unit_times));
_mcpack2_load_mcp_get_content_list_from_part_params_readmap.create(16*6);
_mcpack2_load_mcp_get_content_list_from_part_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_part_params_static_inited=_mcpack2_load_mcp_get_content_list_from_part_params_static_init();
// @@string part_id=in();
static void _mcpack2_load_mcp_get_content_list_from_part_params_part_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_part_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "part_id";
}
self->_m_part_id.set_ptr(item->value,item->value_size-1);
}
// @@string content_type_id=in();
static void _mcpack2_load_mcp_get_content_list_from_part_params_content_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_part_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_type_id";
}
self->_m_content_type_id.set_ptr(item->value,item->value_size-1);
}
// @@string info_id=in();
static void _mcpack2_load_mcp_get_content_list_from_part_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_part_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t info_type=in();
static void _mcpack2_load_mcp_get_content_list_from_part_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_part_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_content_list_from_part_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_part_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_content_list_from_part_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_part_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_content_list_from_part_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_part_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_part_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_part_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_part_params*)=0;
if(_mcpack2_load_mcp_get_content_list_from_part_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_part_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_part_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string part_id=in();
{
int res=mc_pack_put_str(pack,"part_id",_m_part_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_type_id=in();
{
int res=mc_pack_put_str(pack,"content_type_id",_m_content_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t info_type=in();
{
int res=mc_pack_put_uint32(pack,"info_type",_m_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_part_result_params
static void _mcpack2_load_mcp_get_content_list_from_part_result_params_count(const mc_pack_item_t*,mcp_get_content_list_from_part_result_params*);
static void _mcpack2_load_mcp_get_content_list_from_part_result_params_content_list(const mc_pack_item_t*,mcp_get_content_list_from_part_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_part_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_part_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_result_params*)>("count",_mcpack2_load_mcp_get_content_list_from_part_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_result_params*)>("content_list",_mcpack2_load_mcp_get_content_list_from_part_result_params_content_list));
_mcpack2_load_mcp_get_content_list_from_part_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_list_from_part_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_part_result_params_static_inited=_mcpack2_load_mcp_get_content_list_from_part_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_content_list_from_part_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_part_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string content_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_content_list_from_part_result_params_content_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_part_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_content_list)) lp0=&(self->_m_content_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_list_from_part_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_part_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_part_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_part_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_part_result_params*)=0;
if(_mcpack2_load_mcp_get_content_list_from_part_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_part_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_part_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"content_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_content_list)& lr0=(_m_content_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_part_response
static void _mcpack2_load_mcp_get_content_list_from_part_response_result_params(const mc_pack_item_t*,mcp_get_content_list_from_part_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_part_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_part_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_part_response*)>("result_params",_mcpack2_load_mcp_get_content_list_from_part_response_result_params));
_mcpack2_load_mcp_get_content_list_from_part_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_list_from_part_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_part_response_static_inited=_mcpack2_load_mcp_get_content_list_from_part_response_static_init();
// @@mcp_get_content_list_from_part_result_params result_params;
static void _mcpack2_load_mcp_get_content_list_from_part_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_part_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_list_from_part_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_list_from_part_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_part_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_part_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_part_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_part_response*)=0;
if(_mcpack2_load_mcp_get_content_list_from_part_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_part_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_part_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_list_from_part_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_count_from_class_params
static void _mcpack2_load_mcp_get_content_count_from_class_params_class_id(const mc_pack_item_t*,mcp_get_content_count_from_class_params*);
static void _mcpack2_load_mcp_get_content_count_from_class_params_class_type(const mc_pack_item_t*,mcp_get_content_count_from_class_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_from_class_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_count_from_class_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_count_from_class_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_count_from_class_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_from_class_params*)>("class_id",_mcpack2_load_mcp_get_content_count_from_class_params_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_from_class_params*)>("class_type",_mcpack2_load_mcp_get_content_count_from_class_params_class_type));
_mcpack2_load_mcp_get_content_count_from_class_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_count_from_class_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_count_from_class_params_static_inited=_mcpack2_load_mcp_get_content_count_from_class_params_static_init();
// @@string class_id=in();
static void _mcpack2_load_mcp_get_content_count_from_class_params_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_count_from_class_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t class_type=in();
static void _mcpack2_load_mcp_get_content_count_from_class_params_class_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_count_from_class_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_class_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_type";
}
}
void mcp_get_content_count_from_class_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_count_from_class_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_count_from_class_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_count_from_class_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_count_from_class_params*)=0;
if(_mcpack2_load_mcp_get_content_count_from_class_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_count_from_class_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_count_from_class_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string class_id=in();
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t class_type=in();
{
int res=mc_pack_put_uint32(pack,"class_type",_m_class_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_count_from_class_result_params
static void _mcpack2_load_mcp_get_content_count_from_class_result_params_class_name(const mc_pack_item_t*,mcp_get_content_count_from_class_result_params*);
static void _mcpack2_load_mcp_get_content_count_from_class_result_params_count(const mc_pack_item_t*,mcp_get_content_count_from_class_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_from_class_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_count_from_class_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_count_from_class_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_count_from_class_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_from_class_result_params*)>("class_name",_mcpack2_load_mcp_get_content_count_from_class_result_params_class_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_from_class_result_params*)>("count",_mcpack2_load_mcp_get_content_count_from_class_result_params_count));
_mcpack2_load_mcp_get_content_count_from_class_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_count_from_class_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_count_from_class_result_params_static_inited=_mcpack2_load_mcp_get_content_count_from_class_result_params_static_init();
// @@string class_name=out();
static void _mcpack2_load_mcp_get_content_count_from_class_result_params_class_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_count_from_class_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_name";
}
self->_m_class_name.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_content_count_from_class_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_count_from_class_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
void mcp_get_content_count_from_class_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_count_from_class_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_count_from_class_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_count_from_class_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_count_from_class_result_params*)=0;
if(_mcpack2_load_mcp_get_content_count_from_class_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_count_from_class_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_count_from_class_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string class_name=out();
{
int res=mc_pack_put_str(pack,"class_name",_m_class_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_count_from_class_response
static void _mcpack2_load_mcp_get_content_count_from_class_response_result_params(const mc_pack_item_t*,mcp_get_content_count_from_class_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_from_class_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_count_from_class_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_count_from_class_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_count_from_class_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_from_class_response*)>("result_params",_mcpack2_load_mcp_get_content_count_from_class_response_result_params));
_mcpack2_load_mcp_get_content_count_from_class_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_count_from_class_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_count_from_class_response_static_inited=_mcpack2_load_mcp_get_content_count_from_class_response_static_init();
// @@mcp_get_content_count_from_class_result_params result_params;
static void _mcpack2_load_mcp_get_content_count_from_class_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_count_from_class_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_count_from_class_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_count_from_class_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_count_from_class_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_count_from_class_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_count_from_class_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_count_from_class_response*)=0;
if(_mcpack2_load_mcp_get_content_count_from_class_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_count_from_class_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_count_from_class_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_count_from_class_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_info_params
static void _mcpack2_load_mcp_get_phone_info_params_user_info(const mc_pack_item_t*,mcp_get_phone_info_params*);
static void _mcpack2_load_mcp_get_phone_info_params_user_type(const mc_pack_item_t*,mcp_get_phone_info_params*);
static void _mcpack2_load_mcp_get_phone_info_params_phone_info_type(const mc_pack_item_t*,mcp_get_phone_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_params*)>("user_info",_mcpack2_load_mcp_get_phone_info_params_user_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_params*)>("user_type",_mcpack2_load_mcp_get_phone_info_params_user_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_params*)>("phone_info_type",_mcpack2_load_mcp_get_phone_info_params_phone_info_type));
_mcpack2_load_mcp_get_phone_info_params_readmap.create(16*3);
_mcpack2_load_mcp_get_phone_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_info_params_static_inited=_mcpack2_load_mcp_get_phone_info_params_static_init();
// @@string user_info=in();
static void _mcpack2_load_mcp_get_phone_info_params_user_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_info";
}
self->_m_user_info.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t user_type=in();
static void _mcpack2_load_mcp_get_phone_info_params_user_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_user_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_type";
}
}
// @@uint32_t phone_info_type=in();
static void _mcpack2_load_mcp_get_phone_info_params_phone_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_info_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_phone_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_info_type";
}
}
void mcp_get_phone_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_info_params*)=0;
if(_mcpack2_load_mcp_get_phone_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string user_info=in();
{
int res=mc_pack_put_str(pack,"user_info",_m_user_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t user_type=in();
{
int res=mc_pack_put_uint32(pack,"user_type",_m_user_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t phone_info_type=in();
{
int res=mc_pack_put_uint32(pack,"phone_info_type",_m_phone_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_info_result_params
static void _mcpack2_load_mcp_get_phone_info_result_params_phone_info(const mc_pack_item_t*,mcp_get_phone_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_result_params*)>("phone_info",_mcpack2_load_mcp_get_phone_info_result_params_phone_info));
_mcpack2_load_mcp_get_phone_info_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_phone_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_info_result_params_static_inited=_mcpack2_load_mcp_get_phone_info_result_params_static_init();
// @@string phone_info=out(),array(0,0);
static void _mcpack2_load_mcp_get_phone_info_result_params_phone_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_phone_info)) lp0=&(self->_m_phone_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_info";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_info";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_info";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_info";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_phone_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_info_result_params*)=0;
if(_mcpack2_load_mcp_get_phone_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string phone_info=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"phone_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_phone_info)& lr0=(_m_phone_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_info_response
static void _mcpack2_load_mcp_get_phone_info_response_result_params(const mc_pack_item_t*,mcp_get_phone_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_response*)>("result_params",_mcpack2_load_mcp_get_phone_info_response_result_params));
_mcpack2_load_mcp_get_phone_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_phone_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_info_response_static_inited=_mcpack2_load_mcp_get_phone_info_response_static_init();
// @@mcp_get_phone_info_result_params result_params;
static void _mcpack2_load_mcp_get_phone_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_phone_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_phone_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_phone_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_info_response*)=0;
if(_mcpack2_load_mcp_get_phone_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_phone_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_uaJson_params
static void _mcpack2_load_mcp_get_phone_uaJson_params_ua(const mc_pack_item_t*,mcp_get_phone_uaJson_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_uaJson_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_uaJson_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_uaJson_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_uaJson_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_uaJson_params*)>("ua",_mcpack2_load_mcp_get_phone_uaJson_params_ua));
_mcpack2_load_mcp_get_phone_uaJson_params_readmap.create(16*1);
_mcpack2_load_mcp_get_phone_uaJson_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_uaJson_params_static_inited=_mcpack2_load_mcp_get_phone_uaJson_params_static_init();
// @@string ua=in();
static void _mcpack2_load_mcp_get_phone_uaJson_params_ua(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_uaJson_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ua";
}
self->_m_ua.set_ptr(item->value,item->value_size-1);
}
void mcp_get_phone_uaJson_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_uaJson_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_uaJson_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_uaJson_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_uaJson_params*)=0;
if(_mcpack2_load_mcp_get_phone_uaJson_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_uaJson_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_uaJson_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string ua=in();
{
int res=mc_pack_put_str(pack,"ua",_m_ua.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_uaJson_result_params
static void _mcpack2_load_mcp_get_phone_uaJson_result_params_ua_Json(const mc_pack_item_t*,mcp_get_phone_uaJson_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_uaJson_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_uaJson_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_uaJson_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_uaJson_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_uaJson_result_params*)>("ua_Json",_mcpack2_load_mcp_get_phone_uaJson_result_params_ua_Json));
_mcpack2_load_mcp_get_phone_uaJson_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_phone_uaJson_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_uaJson_result_params_static_inited=_mcpack2_load_mcp_get_phone_uaJson_result_params_static_init();
// @@string ua_Json=out(),array(0);
static void _mcpack2_load_mcp_get_phone_uaJson_result_params_ua_Json(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_uaJson_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "ua_Json";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_ua_Json)) lp0=&(self->_m_ua_Json);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "ua_Json";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ua_Json";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "ua_Json";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_phone_uaJson_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_uaJson_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_uaJson_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_uaJson_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_uaJson_result_params*)=0;
if(_mcpack2_load_mcp_get_phone_uaJson_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_uaJson_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_uaJson_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string ua_Json=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"ua_Json");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_ua_Json)& lr0=(_m_ua_Json);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_uaJson_response
static void _mcpack2_load_mcp_get_phone_uaJson_response_result_params(const mc_pack_item_t*,mcp_get_phone_uaJson_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_uaJson_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_uaJson_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_uaJson_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_uaJson_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_uaJson_response*)>("result_params",_mcpack2_load_mcp_get_phone_uaJson_response_result_params));
_mcpack2_load_mcp_get_phone_uaJson_response_readmap.create(16*1);
_mcpack2_load_mcp_get_phone_uaJson_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_uaJson_response_static_inited=_mcpack2_load_mcp_get_phone_uaJson_response_static_init();
// @@mcp_get_phone_uaJson_result_params result_params;
static void _mcpack2_load_mcp_get_phone_uaJson_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_uaJson_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_phone_uaJson_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_phone_uaJson_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_uaJson_response*)=0;
do{
if(_mcpack2_load_mcp_get_phone_uaJson_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_uaJson_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_uaJson_response*)=0;
if(_mcpack2_load_mcp_get_phone_uaJson_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_uaJson_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_uaJson_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_phone_uaJson_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_init_phone_uaJson_map_params
static void _mcpack2_load_mcp_init_phone_uaJson_map_params_input(const mc_pack_item_t*,mcp_init_phone_uaJson_map_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_init_phone_uaJson_map_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_init_phone_uaJson_map_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_params*)>("input",_mcpack2_load_mcp_init_phone_uaJson_map_params_input));
_mcpack2_load_mcp_init_phone_uaJson_map_params_readmap.create(16*1);
_mcpack2_load_mcp_init_phone_uaJson_map_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_init_phone_uaJson_map_params_static_inited=_mcpack2_load_mcp_init_phone_uaJson_map_params_static_init();
// @@string input=in();
static void _mcpack2_load_mcp_init_phone_uaJson_map_params_input(__attribute__((unused)) const mc_pack_item_t* item,mcp_init_phone_uaJson_map_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "input";
}
self->_m_input.set_ptr(item->value,item->value_size-1);
}
void mcp_init_phone_uaJson_map_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_params*)=0;
do{
if(_mcpack2_load_mcp_init_phone_uaJson_map_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_init_phone_uaJson_map_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_params*)=0;
if(_mcpack2_load_mcp_init_phone_uaJson_map_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_init_phone_uaJson_map_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_init_phone_uaJson_map_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string input=in();
{
int res=mc_pack_put_str(pack,"input",_m_input.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_init_phone_uaJson_map_result_params
static void _mcpack2_load_mcp_init_phone_uaJson_map_result_params_output(const mc_pack_item_t*,mcp_init_phone_uaJson_map_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_init_phone_uaJson_map_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_init_phone_uaJson_map_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_result_params*)>("output",_mcpack2_load_mcp_init_phone_uaJson_map_result_params_output));
_mcpack2_load_mcp_init_phone_uaJson_map_result_params_readmap.create(16*1);
_mcpack2_load_mcp_init_phone_uaJson_map_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_init_phone_uaJson_map_result_params_static_inited=_mcpack2_load_mcp_init_phone_uaJson_map_result_params_static_init();
// @@string output=out(),array(0);
static void _mcpack2_load_mcp_init_phone_uaJson_map_result_params_output(__attribute__((unused)) const mc_pack_item_t* item,mcp_init_phone_uaJson_map_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "output";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_output)) lp0=&(self->_m_output);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "output";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "output";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "output";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_init_phone_uaJson_map_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_result_params*)=0;
do{
if(_mcpack2_load_mcp_init_phone_uaJson_map_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_init_phone_uaJson_map_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_result_params*)=0;
if(_mcpack2_load_mcp_init_phone_uaJson_map_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_init_phone_uaJson_map_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_init_phone_uaJson_map_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string output=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"output");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_output)& lr0=(_m_output);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_init_phone_uaJson_map_response
static void _mcpack2_load_mcp_init_phone_uaJson_map_response_result_params(const mc_pack_item_t*,mcp_init_phone_uaJson_map_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_init_phone_uaJson_map_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_init_phone_uaJson_map_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_response*)>("result_params",_mcpack2_load_mcp_init_phone_uaJson_map_response_result_params));
_mcpack2_load_mcp_init_phone_uaJson_map_response_readmap.create(16*1);
_mcpack2_load_mcp_init_phone_uaJson_map_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_init_phone_uaJson_map_response_static_inited=_mcpack2_load_mcp_init_phone_uaJson_map_response_static_init();
// @@mcp_init_phone_uaJson_map_result_params result_params;
static void _mcpack2_load_mcp_init_phone_uaJson_map_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_init_phone_uaJson_map_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_init_phone_uaJson_map_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_init_phone_uaJson_map_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_response*)=0;
do{
if(_mcpack2_load_mcp_init_phone_uaJson_map_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_init_phone_uaJson_map_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_init_phone_uaJson_map_response*)=0;
if(_mcpack2_load_mcp_init_phone_uaJson_map_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_init_phone_uaJson_map_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_init_phone_uaJson_map_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_init_phone_uaJson_map_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_type_from_ID_params
static void _mcpack2_load_mcp_get_phone_type_from_ID_params_info_id(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*);
static void _mcpack2_load_mcp_get_phone_type_from_ID_params_id_type(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*);
static void _mcpack2_load_mcp_get_phone_type_from_ID_params_head_word(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*);
static void _mcpack2_load_mcp_get_phone_type_from_ID_params_unit_num(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*);
static void _mcpack2_load_mcp_get_phone_type_from_ID_params_unit_times(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_type_from_ID_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_type_from_ID_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*)>("info_id",_mcpack2_load_mcp_get_phone_type_from_ID_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*)>("id_type",_mcpack2_load_mcp_get_phone_type_from_ID_params_id_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*)>("head_word",_mcpack2_load_mcp_get_phone_type_from_ID_params_head_word));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*)>("unit_num",_mcpack2_load_mcp_get_phone_type_from_ID_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*)>("unit_times",_mcpack2_load_mcp_get_phone_type_from_ID_params_unit_times));
_mcpack2_load_mcp_get_phone_type_from_ID_params_readmap.create(16*5);
_mcpack2_load_mcp_get_phone_type_from_ID_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_type_from_ID_params_static_inited=_mcpack2_load_mcp_get_phone_type_from_ID_params_static_init();
// @@string info_id=in();
static void _mcpack2_load_mcp_get_phone_type_from_ID_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_type_from_ID_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t id_type=in();
static void _mcpack2_load_mcp_get_phone_type_from_ID_params_id_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_type_from_ID_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_id_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id_type";
}
}
// @@string head_word=in();
static void _mcpack2_load_mcp_get_phone_type_from_ID_params_head_word(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_type_from_ID_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "head_word";
}
self->_m_head_word.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_phone_type_from_ID_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_type_from_ID_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_phone_type_from_ID_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_type_from_ID_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_phone_type_from_ID_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_type_from_ID_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_type_from_ID_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_params*)=0;
if(_mcpack2_load_mcp_get_phone_type_from_ID_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_type_from_ID_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_type_from_ID_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t id_type=in();
{
int res=mc_pack_put_uint32(pack,"id_type",_m_id_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string head_word=in();
{
int res=mc_pack_put_str(pack,"head_word",_m_head_word.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_type_from_ID_result_params
static void _mcpack2_load_mcp_get_phone_type_from_ID_result_params_phone_count(const mc_pack_item_t*,mcp_get_phone_type_from_ID_result_params*);
static void _mcpack2_load_mcp_get_phone_type_from_ID_result_params_phone_id(const mc_pack_item_t*,mcp_get_phone_type_from_ID_result_params*);
static void _mcpack2_load_mcp_get_phone_type_from_ID_result_params_phone_name(const mc_pack_item_t*,mcp_get_phone_type_from_ID_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_type_from_ID_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_type_from_ID_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_result_params*)>("phone_count",_mcpack2_load_mcp_get_phone_type_from_ID_result_params_phone_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_result_params*)>("phone_id",_mcpack2_load_mcp_get_phone_type_from_ID_result_params_phone_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_result_params*)>("phone_name",_mcpack2_load_mcp_get_phone_type_from_ID_result_params_phone_name));
_mcpack2_load_mcp_get_phone_type_from_ID_result_params_readmap.create(16*3);
_mcpack2_load_mcp_get_phone_type_from_ID_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_type_from_ID_result_params_static_inited=_mcpack2_load_mcp_get_phone_type_from_ID_result_params_static_init();
// @@uint32_t phone_count=out();
static void _mcpack2_load_mcp_get_phone_type_from_ID_result_params_phone_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_type_from_ID_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_phone_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_count";
}
}
// @@string phone_id=out(),array(0);
static void _mcpack2_load_mcp_get_phone_type_from_ID_result_params_phone_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_type_from_ID_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_id";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_phone_id)) lp0=&(self->_m_phone_id);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_id";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_id";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_id";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string phone_name=out(),array(0);
static void _mcpack2_load_mcp_get_phone_type_from_ID_result_params_phone_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_type_from_ID_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_name";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_phone_name)) lp0=&(self->_m_phone_name);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_name";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_name";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_name";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_phone_type_from_ID_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_type_from_ID_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_type_from_ID_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_result_params*)=0;
if(_mcpack2_load_mcp_get_phone_type_from_ID_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_type_from_ID_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_type_from_ID_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t phone_count=out();
{
int res=mc_pack_put_uint32(pack,"phone_count",_m_phone_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string phone_id=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"phone_id");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_phone_id)& lr0=(_m_phone_id);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string phone_name=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"phone_name");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_phone_name)& lr0=(_m_phone_name);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_type_from_ID_response
static void _mcpack2_load_mcp_get_phone_type_from_ID_response_result_params(const mc_pack_item_t*,mcp_get_phone_type_from_ID_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_type_from_ID_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_type_from_ID_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_response*)>("result_params",_mcpack2_load_mcp_get_phone_type_from_ID_response_result_params));
_mcpack2_load_mcp_get_phone_type_from_ID_response_readmap.create(16*1);
_mcpack2_load_mcp_get_phone_type_from_ID_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_type_from_ID_response_static_inited=_mcpack2_load_mcp_get_phone_type_from_ID_response_static_init();
// @@mcp_get_phone_type_from_ID_result_params result_params;
static void _mcpack2_load_mcp_get_phone_type_from_ID_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_type_from_ID_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_phone_type_from_ID_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_phone_type_from_ID_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_response*)=0;
do{
if(_mcpack2_load_mcp_get_phone_type_from_ID_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_type_from_ID_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_type_from_ID_response*)=0;
if(_mcpack2_load_mcp_get_phone_type_from_ID_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_type_from_ID_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_type_from_ID_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_phone_type_from_ID_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_headword_from_maker_params
static void _mcpack2_load_mcp_get_phone_headword_from_maker_params_maker_id(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_params*);
static void _mcpack2_load_mcp_get_phone_headword_from_maker_params_unit_num(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_params*);
static void _mcpack2_load_mcp_get_phone_headword_from_maker_params_unit_times(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_headword_from_maker_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_headword_from_maker_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_params*)>("maker_id",_mcpack2_load_mcp_get_phone_headword_from_maker_params_maker_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_params*)>("unit_num",_mcpack2_load_mcp_get_phone_headword_from_maker_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_params*)>("unit_times",_mcpack2_load_mcp_get_phone_headword_from_maker_params_unit_times));
_mcpack2_load_mcp_get_phone_headword_from_maker_params_readmap.create(16*3);
_mcpack2_load_mcp_get_phone_headword_from_maker_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_headword_from_maker_params_static_inited=_mcpack2_load_mcp_get_phone_headword_from_maker_params_static_init();
// @@string maker_id=in();
static void _mcpack2_load_mcp_get_phone_headword_from_maker_params_maker_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_headword_from_maker_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "maker_id";
}
self->_m_maker_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_phone_headword_from_maker_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_headword_from_maker_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_phone_headword_from_maker_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_headword_from_maker_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_phone_headword_from_maker_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_headword_from_maker_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_headword_from_maker_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_params*)=0;
if(_mcpack2_load_mcp_get_phone_headword_from_maker_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_headword_from_maker_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_headword_from_maker_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string maker_id=in();
{
int res=mc_pack_put_str(pack,"maker_id",_m_maker_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_headword_from_maker_result_params
static void _mcpack2_load_mcp_get_phone_headword_from_maker_result_params_headword_count(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_result_params*);
static void _mcpack2_load_mcp_get_phone_headword_from_maker_result_params_head_word(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_headword_from_maker_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_headword_from_maker_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_result_params*)>("headword_count",_mcpack2_load_mcp_get_phone_headword_from_maker_result_params_headword_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_result_params*)>("head_word",_mcpack2_load_mcp_get_phone_headword_from_maker_result_params_head_word));
_mcpack2_load_mcp_get_phone_headword_from_maker_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_phone_headword_from_maker_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_headword_from_maker_result_params_static_inited=_mcpack2_load_mcp_get_phone_headword_from_maker_result_params_static_init();
// @@uint32_t headword_count=out();
static void _mcpack2_load_mcp_get_phone_headword_from_maker_result_params_headword_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_headword_from_maker_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_headword_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "headword_count";
}
}
// @@string head_word=out(),array(0);
static void _mcpack2_load_mcp_get_phone_headword_from_maker_result_params_head_word(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_headword_from_maker_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "head_word";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_head_word)) lp0=&(self->_m_head_word);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "head_word";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "head_word";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "head_word";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_phone_headword_from_maker_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_headword_from_maker_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_headword_from_maker_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_result_params*)=0;
if(_mcpack2_load_mcp_get_phone_headword_from_maker_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_headword_from_maker_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_headword_from_maker_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t headword_count=out();
{
int res=mc_pack_put_uint32(pack,"headword_count",_m_headword_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string head_word=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"head_word");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_head_word)& lr0=(_m_head_word);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_headword_from_maker_response
static void _mcpack2_load_mcp_get_phone_headword_from_maker_response_result_params(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_headword_from_maker_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_headword_from_maker_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_response*)>("result_params",_mcpack2_load_mcp_get_phone_headword_from_maker_response_result_params));
_mcpack2_load_mcp_get_phone_headword_from_maker_response_readmap.create(16*1);
_mcpack2_load_mcp_get_phone_headword_from_maker_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_headword_from_maker_response_static_inited=_mcpack2_load_mcp_get_phone_headword_from_maker_response_static_init();
// @@mcp_get_phone_headword_from_maker_result_params result_params;
static void _mcpack2_load_mcp_get_phone_headword_from_maker_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_headword_from_maker_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_phone_headword_from_maker_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_phone_headword_from_maker_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_response*)=0;
do{
if(_mcpack2_load_mcp_get_phone_headword_from_maker_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_headword_from_maker_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_headword_from_maker_response*)=0;
if(_mcpack2_load_mcp_get_phone_headword_from_maker_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_headword_from_maker_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_headword_from_maker_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_phone_headword_from_maker_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_search_phone_info_params
static void _mcpack2_load_mcp_search_phone_info_params_key(const mc_pack_item_t*,mcp_search_phone_info_params*);
static void _mcpack2_load_mcp_search_phone_info_params_unit_num(const mc_pack_item_t*,mcp_search_phone_info_params*);
static void _mcpack2_load_mcp_search_phone_info_params_unit_times(const mc_pack_item_t*,mcp_search_phone_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_search_phone_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_search_phone_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_search_phone_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_search_phone_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_search_phone_info_params*)>("key",_mcpack2_load_mcp_search_phone_info_params_key));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_search_phone_info_params*)>("unit_num",_mcpack2_load_mcp_search_phone_info_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_search_phone_info_params*)>("unit_times",_mcpack2_load_mcp_search_phone_info_params_unit_times));
_mcpack2_load_mcp_search_phone_info_params_readmap.create(16*3);
_mcpack2_load_mcp_search_phone_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_search_phone_info_params_static_inited=_mcpack2_load_mcp_search_phone_info_params_static_init();
// @@string key=in();
static void _mcpack2_load_mcp_search_phone_info_params_key(__attribute__((unused)) const mc_pack_item_t* item,mcp_search_phone_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "key";
}
self->_m_key.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_search_phone_info_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_search_phone_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_search_phone_info_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_search_phone_info_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_search_phone_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_search_phone_info_params*)=0;
do{
if(_mcpack2_load_mcp_search_phone_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_search_phone_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_search_phone_info_params*)=0;
if(_mcpack2_load_mcp_search_phone_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_search_phone_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_search_phone_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string key=in();
{
int res=mc_pack_put_str(pack,"key",_m_key.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_search_phone_info_result_params
static void _mcpack2_load_mcp_search_phone_info_result_params_phone_count(const mc_pack_item_t*,mcp_search_phone_info_result_params*);
static void _mcpack2_load_mcp_search_phone_info_result_params_phone_id(const mc_pack_item_t*,mcp_search_phone_info_result_params*);
static void _mcpack2_load_mcp_search_phone_info_result_params_phone_name(const mc_pack_item_t*,mcp_search_phone_info_result_params*);
static void _mcpack2_load_mcp_search_phone_info_result_params_brand_id(const mc_pack_item_t*,mcp_search_phone_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_search_phone_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_search_phone_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_search_phone_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_search_phone_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_search_phone_info_result_params*)>("phone_count",_mcpack2_load_mcp_search_phone_info_result_params_phone_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_search_phone_info_result_params*)>("phone_id",_mcpack2_load_mcp_search_phone_info_result_params_phone_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_search_phone_info_result_params*)>("phone_name",_mcpack2_load_mcp_search_phone_info_result_params_phone_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_search_phone_info_result_params*)>("brand_id",_mcpack2_load_mcp_search_phone_info_result_params_brand_id));
_mcpack2_load_mcp_search_phone_info_result_params_readmap.create(16*4);
_mcpack2_load_mcp_search_phone_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_search_phone_info_result_params_static_inited=_mcpack2_load_mcp_search_phone_info_result_params_static_init();
// @@uint32_t phone_count=out();
static void _mcpack2_load_mcp_search_phone_info_result_params_phone_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_search_phone_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_phone_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_count";
}
}
// @@string phone_id=out(),array(0);
static void _mcpack2_load_mcp_search_phone_info_result_params_phone_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_search_phone_info_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_id";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_phone_id)) lp0=&(self->_m_phone_id);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_id";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_id";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_id";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string phone_name=out(),array(0);
static void _mcpack2_load_mcp_search_phone_info_result_params_phone_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_search_phone_info_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_name";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_phone_name)) lp0=&(self->_m_phone_name);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_name";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_name";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_name";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string brand_id=out(),array(0);
static void _mcpack2_load_mcp_search_phone_info_result_params_brand_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_search_phone_info_result_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "brand_id";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_brand_id)) lp0=&(self->_m_brand_id);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "brand_id";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "brand_id";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "brand_id";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_search_phone_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_search_phone_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_search_phone_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_search_phone_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_search_phone_info_result_params*)=0;
if(_mcpack2_load_mcp_search_phone_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_search_phone_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_search_phone_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t phone_count=out();
{
int res=mc_pack_put_uint32(pack,"phone_count",_m_phone_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string phone_id=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"phone_id");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_phone_id)& lr0=(_m_phone_id);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string phone_name=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"phone_name");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_phone_name)& lr0=(_m_phone_name);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string brand_id=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"brand_id");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_brand_id)& lr0=(_m_brand_id);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_search_phone_info_response
static void _mcpack2_load_mcp_search_phone_info_response_result_params(const mc_pack_item_t*,mcp_search_phone_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_search_phone_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_search_phone_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_search_phone_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_search_phone_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_search_phone_info_response*)>("result_params",_mcpack2_load_mcp_search_phone_info_response_result_params));
_mcpack2_load_mcp_search_phone_info_response_readmap.create(16*1);
_mcpack2_load_mcp_search_phone_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_search_phone_info_response_static_inited=_mcpack2_load_mcp_search_phone_info_response_static_init();
// @@mcp_search_phone_info_result_params result_params;
static void _mcpack2_load_mcp_search_phone_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_search_phone_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_search_phone_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_search_phone_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_search_phone_info_response*)=0;
do{
if(_mcpack2_load_mcp_search_phone_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_search_phone_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_search_phone_info_response*)=0;
if(_mcpack2_load_mcp_search_phone_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_search_phone_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_search_phone_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_search_phone_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_carriers_info_from_ip_params
static void _mcpack2_load_mcp_get_carriers_info_from_ip_params_ip_addres(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_carriers_info_from_ip_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_carriers_info_from_ip_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_params*)>("ip_addres",_mcpack2_load_mcp_get_carriers_info_from_ip_params_ip_addres));
_mcpack2_load_mcp_get_carriers_info_from_ip_params_readmap.create(16*1);
_mcpack2_load_mcp_get_carriers_info_from_ip_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_carriers_info_from_ip_params_static_inited=_mcpack2_load_mcp_get_carriers_info_from_ip_params_static_init();
// @@string ip_addres=in();
static void _mcpack2_load_mcp_get_carriers_info_from_ip_params_ip_addres(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_carriers_info_from_ip_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ip_addres";
}
self->_m_ip_addres.set_ptr(item->value,item->value_size-1);
}
void mcp_get_carriers_info_from_ip_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_params*)=0;
do{
if(_mcpack2_load_mcp_get_carriers_info_from_ip_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_carriers_info_from_ip_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_params*)=0;
if(_mcpack2_load_mcp_get_carriers_info_from_ip_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_carriers_info_from_ip_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_carriers_info_from_ip_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string ip_addres=in();
{
int res=mc_pack_put_str(pack,"ip_addres",_m_ip_addres.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_carriers_info_from_ip_result_params
static void _mcpack2_load_mcp_get_carriers_info_from_ip_result_params_carriers_name(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_result_params*);
static void _mcpack2_load_mcp_get_carriers_info_from_ip_result_params_owner_place(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_carriers_info_from_ip_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_carriers_info_from_ip_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_result_params*)>("carriers_name",_mcpack2_load_mcp_get_carriers_info_from_ip_result_params_carriers_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_result_params*)>("owner_place",_mcpack2_load_mcp_get_carriers_info_from_ip_result_params_owner_place));
_mcpack2_load_mcp_get_carriers_info_from_ip_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_carriers_info_from_ip_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_carriers_info_from_ip_result_params_static_inited=_mcpack2_load_mcp_get_carriers_info_from_ip_result_params_static_init();
// @@uint32_t carriers_name=out();
static void _mcpack2_load_mcp_get_carriers_info_from_ip_result_params_carriers_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_carriers_info_from_ip_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_carriers_name));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "carriers_name";
}
}
// @@uint32_t owner_place=out();
static void _mcpack2_load_mcp_get_carriers_info_from_ip_result_params_owner_place(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_carriers_info_from_ip_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_owner_place));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "owner_place";
}
}
void mcp_get_carriers_info_from_ip_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_carriers_info_from_ip_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_carriers_info_from_ip_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_result_params*)=0;
if(_mcpack2_load_mcp_get_carriers_info_from_ip_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_carriers_info_from_ip_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_carriers_info_from_ip_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t carriers_name=out();
{
int res=mc_pack_put_uint32(pack,"carriers_name",_m_carriers_name);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t owner_place=out();
{
int res=mc_pack_put_uint32(pack,"owner_place",_m_owner_place);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_carriers_info_from_ip_response
static void _mcpack2_load_mcp_get_carriers_info_from_ip_response_result_params(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_carriers_info_from_ip_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_carriers_info_from_ip_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_response*)>("result_params",_mcpack2_load_mcp_get_carriers_info_from_ip_response_result_params));
_mcpack2_load_mcp_get_carriers_info_from_ip_response_readmap.create(16*1);
_mcpack2_load_mcp_get_carriers_info_from_ip_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_carriers_info_from_ip_response_static_inited=_mcpack2_load_mcp_get_carriers_info_from_ip_response_static_init();
// @@mcp_get_carriers_info_from_ip_result_params result_params;
static void _mcpack2_load_mcp_get_carriers_info_from_ip_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_carriers_info_from_ip_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_carriers_info_from_ip_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_carriers_info_from_ip_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_response*)=0;
do{
if(_mcpack2_load_mcp_get_carriers_info_from_ip_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_carriers_info_from_ip_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_carriers_info_from_ip_response*)=0;
if(_mcpack2_load_mcp_get_carriers_info_from_ip_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_carriers_info_from_ip_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_carriers_info_from_ip_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_carriers_info_from_ip_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_info_from_maker_plat_params
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_params_maker_id(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_params*);
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_params_plat_id(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_params*);
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_params_unit_num(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_params*);
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_params_unit_times(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_info_from_maker_plat_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_info_from_maker_plat_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_params*)>("maker_id",_mcpack2_load_mcp_get_phone_info_from_maker_plat_params_maker_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_params*)>("plat_id",_mcpack2_load_mcp_get_phone_info_from_maker_plat_params_plat_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_params*)>("unit_num",_mcpack2_load_mcp_get_phone_info_from_maker_plat_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_params*)>("unit_times",_mcpack2_load_mcp_get_phone_info_from_maker_plat_params_unit_times));
_mcpack2_load_mcp_get_phone_info_from_maker_plat_params_readmap.create(16*4);
_mcpack2_load_mcp_get_phone_info_from_maker_plat_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_info_from_maker_plat_params_static_inited=_mcpack2_load_mcp_get_phone_info_from_maker_plat_params_static_init();
// @@string maker_id=in();
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_params_maker_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_info_from_maker_plat_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "maker_id";
}
self->_m_maker_id.set_ptr(item->value,item->value_size-1);
}
// @@string plat_id=in();
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_params_plat_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_info_from_maker_plat_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "plat_id";
}
self->_m_plat_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_info_from_maker_plat_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_info_from_maker_plat_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_phone_info_from_maker_plat_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_info_from_maker_plat_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_info_from_maker_plat_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_params*)=0;
if(_mcpack2_load_mcp_get_phone_info_from_maker_plat_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_info_from_maker_plat_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_info_from_maker_plat_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string maker_id=in();
{
int res=mc_pack_put_str(pack,"maker_id",_m_maker_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string plat_id=in();
{
int res=mc_pack_put_str(pack,"plat_id",_m_plat_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_info_from_maker_plat_result_params
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_phone_count(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_result_params*);
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_phone_id(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_result_params*);
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_phone_name(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_result_params*)>("phone_count",_mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_phone_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_result_params*)>("phone_id",_mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_phone_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_result_params*)>("phone_name",_mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_phone_name));
_mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_readmap.create(16*3);
_mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_static_inited=_mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_static_init();
// @@uint32_t phone_count=out();
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_phone_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_info_from_maker_plat_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_phone_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_count";
}
}
// @@string phone_id=out(),array(0);
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_phone_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_info_from_maker_plat_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_id";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_phone_id)) lp0=&(self->_m_phone_id);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_id";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_id";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_id";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string phone_name=out(),array(0);
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_phone_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_info_from_maker_plat_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_name";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_phone_name)) lp0=&(self->_m_phone_name);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_name";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_name";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "phone_name";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_phone_info_from_maker_plat_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_info_from_maker_plat_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_result_params*)=0;
if(_mcpack2_load_mcp_get_phone_info_from_maker_plat_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_info_from_maker_plat_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_info_from_maker_plat_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t phone_count=out();
{
int res=mc_pack_put_uint32(pack,"phone_count",_m_phone_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string phone_id=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"phone_id");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_phone_id)& lr0=(_m_phone_id);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string phone_name=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"phone_name");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_phone_name)& lr0=(_m_phone_name);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_info_from_maker_plat_response
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_response_result_params(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_info_from_maker_plat_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_info_from_maker_plat_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_response*)>("result_params",_mcpack2_load_mcp_get_phone_info_from_maker_plat_response_result_params));
_mcpack2_load_mcp_get_phone_info_from_maker_plat_response_readmap.create(16*1);
_mcpack2_load_mcp_get_phone_info_from_maker_plat_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_info_from_maker_plat_response_static_inited=_mcpack2_load_mcp_get_phone_info_from_maker_plat_response_static_init();
// @@mcp_get_phone_info_from_maker_plat_result_params result_params;
static void _mcpack2_load_mcp_get_phone_info_from_maker_plat_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_info_from_maker_plat_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_phone_info_from_maker_plat_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_phone_info_from_maker_plat_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_response*)=0;
do{
if(_mcpack2_load_mcp_get_phone_info_from_maker_plat_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_info_from_maker_plat_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_info_from_maker_plat_response*)=0;
if(_mcpack2_load_mcp_get_phone_info_from_maker_plat_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_info_from_maker_plat_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_info_from_maker_plat_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_phone_info_from_maker_plat_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_url_info_by_id_params
static void _mcpack2_load_mcp_get_url_info_by_id_params_id(const mc_pack_item_t*,mcp_get_url_info_by_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_url_info_by_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_url_info_by_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_url_info_by_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_id_params*)>("id",_mcpack2_load_mcp_get_url_info_by_id_params_id));
_mcpack2_load_mcp_get_url_info_by_id_params_readmap.create(16*1);
_mcpack2_load_mcp_get_url_info_by_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_url_info_by_id_params_static_inited=_mcpack2_load_mcp_get_url_info_by_id_params_static_init();
// @@string id=in();
static void _mcpack2_load_mcp_get_url_info_by_id_params_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_url_info_by_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_url_info_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_url_info_by_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_id_params*)=0;
if(_mcpack2_load_mcp_get_url_info_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_url_info_by_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_url_info_by_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id=in();
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_url_info_by_id_result_params
static void _mcpack2_load_mcp_get_url_info_by_id_result_params_url_info(const mc_pack_item_t*,mcp_get_url_info_by_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_url_info_by_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_url_info_by_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_url_info_by_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_id_result_params*)>("url_info",_mcpack2_load_mcp_get_url_info_by_id_result_params_url_info));
_mcpack2_load_mcp_get_url_info_by_id_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_url_info_by_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_url_info_by_id_result_params_static_inited=_mcpack2_load_mcp_get_url_info_by_id_result_params_static_init();
// @@string url_info=out(),array(0);
static void _mcpack2_load_mcp_get_url_info_by_id_result_params_url_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_url_info)) lp0=&(self->_m_url_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "url_info";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_url_info_by_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_url_info_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_url_info_by_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_id_result_params*)=0;
if(_mcpack2_load_mcp_get_url_info_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_url_info_by_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_url_info_by_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string url_info=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"url_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_url_info)& lr0=(_m_url_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_url_info_by_id_response
static void _mcpack2_load_mcp_get_url_info_by_id_response_result_params(const mc_pack_item_t*,mcp_get_url_info_by_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_url_info_by_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_url_info_by_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_url_info_by_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_id_response*)>("result_params",_mcpack2_load_mcp_get_url_info_by_id_response_result_params));
_mcpack2_load_mcp_get_url_info_by_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_url_info_by_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_url_info_by_id_response_static_inited=_mcpack2_load_mcp_get_url_info_by_id_response_static_init();
// @@mcp_get_url_info_by_id_result_params result_params;
static void _mcpack2_load_mcp_get_url_info_by_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_url_info_by_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_url_info_by_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_url_info_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_url_info_by_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_id_response*)=0;
if(_mcpack2_load_mcp_get_url_info_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_url_info_by_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_url_info_by_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_url_info_by_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_url_info_by_class_id_params
static void _mcpack2_load_mcp_get_url_info_by_class_id_params_class_id(const mc_pack_item_t*,mcp_get_url_info_by_class_id_params*);
static void _mcpack2_load_mcp_get_url_info_by_class_id_params_unit_num(const mc_pack_item_t*,mcp_get_url_info_by_class_id_params*);
static void _mcpack2_load_mcp_get_url_info_by_class_id_params_unit_times(const mc_pack_item_t*,mcp_get_url_info_by_class_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_url_info_by_class_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_url_info_by_class_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_params*)>("class_id",_mcpack2_load_mcp_get_url_info_by_class_id_params_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_params*)>("unit_num",_mcpack2_load_mcp_get_url_info_by_class_id_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_params*)>("unit_times",_mcpack2_load_mcp_get_url_info_by_class_id_params_unit_times));
_mcpack2_load_mcp_get_url_info_by_class_id_params_readmap.create(16*3);
_mcpack2_load_mcp_get_url_info_by_class_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_url_info_by_class_id_params_static_inited=_mcpack2_load_mcp_get_url_info_by_class_id_params_static_init();
// @@string class_id=in();
static void _mcpack2_load_mcp_get_url_info_by_class_id_params_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_class_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_url_info_by_class_id_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_class_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_url_info_by_class_id_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_class_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_url_info_by_class_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_url_info_by_class_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_url_info_by_class_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_params*)=0;
if(_mcpack2_load_mcp_get_url_info_by_class_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_url_info_by_class_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_url_info_by_class_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string class_id=in();
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_url_info_by_class_id_result_params
static void _mcpack2_load_mcp_get_url_info_by_class_id_result_params_count(const mc_pack_item_t*,mcp_get_url_info_by_class_id_result_params*);
static void _mcpack2_load_mcp_get_url_info_by_class_id_result_params_url_info(const mc_pack_item_t*,mcp_get_url_info_by_class_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_url_info_by_class_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_url_info_by_class_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_result_params*)>("count",_mcpack2_load_mcp_get_url_info_by_class_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_result_params*)>("url_info",_mcpack2_load_mcp_get_url_info_by_class_id_result_params_url_info));
_mcpack2_load_mcp_get_url_info_by_class_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_url_info_by_class_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_url_info_by_class_id_result_params_static_inited=_mcpack2_load_mcp_get_url_info_by_class_id_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_url_info_by_class_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_class_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string url_info=out(),array(0,0);
static void _mcpack2_load_mcp_get_url_info_by_class_id_result_params_url_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_class_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_url_info)) lp0=&(self->_m_url_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "url_info";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_url_info_by_class_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_url_info_by_class_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_url_info_by_class_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_result_params*)=0;
if(_mcpack2_load_mcp_get_url_info_by_class_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_url_info_by_class_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_url_info_by_class_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string url_info=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"url_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_url_info)& lr0=(_m_url_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_url_info_by_class_id_response
static void _mcpack2_load_mcp_get_url_info_by_class_id_response_result_params(const mc_pack_item_t*,mcp_get_url_info_by_class_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_url_info_by_class_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_url_info_by_class_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_response*)>("result_params",_mcpack2_load_mcp_get_url_info_by_class_id_response_result_params));
_mcpack2_load_mcp_get_url_info_by_class_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_url_info_by_class_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_url_info_by_class_id_response_static_inited=_mcpack2_load_mcp_get_url_info_by_class_id_response_static_init();
// @@mcp_get_url_info_by_class_id_result_params result_params;
static void _mcpack2_load_mcp_get_url_info_by_class_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_class_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_url_info_by_class_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_url_info_by_class_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_url_info_by_class_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_url_info_by_class_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_class_id_response*)=0;
if(_mcpack2_load_mcp_get_url_info_by_class_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_url_info_by_class_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_url_info_by_class_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_url_info_by_class_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_url_info_by_column_id_params
static void _mcpack2_load_mcp_get_url_info_by_column_id_params_column_id(const mc_pack_item_t*,mcp_get_url_info_by_column_id_params*);
static void _mcpack2_load_mcp_get_url_info_by_column_id_params_unit_num(const mc_pack_item_t*,mcp_get_url_info_by_column_id_params*);
static void _mcpack2_load_mcp_get_url_info_by_column_id_params_unit_times(const mc_pack_item_t*,mcp_get_url_info_by_column_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_url_info_by_column_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_url_info_by_column_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_params*)>("column_id",_mcpack2_load_mcp_get_url_info_by_column_id_params_column_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_params*)>("unit_num",_mcpack2_load_mcp_get_url_info_by_column_id_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_params*)>("unit_times",_mcpack2_load_mcp_get_url_info_by_column_id_params_unit_times));
_mcpack2_load_mcp_get_url_info_by_column_id_params_readmap.create(16*3);
_mcpack2_load_mcp_get_url_info_by_column_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_url_info_by_column_id_params_static_inited=_mcpack2_load_mcp_get_url_info_by_column_id_params_static_init();
// @@string column_id=in();
static void _mcpack2_load_mcp_get_url_info_by_column_id_params_column_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_column_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "column_id";
}
self->_m_column_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_url_info_by_column_id_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_column_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_url_info_by_column_id_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_column_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_url_info_by_column_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_url_info_by_column_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_url_info_by_column_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_params*)=0;
if(_mcpack2_load_mcp_get_url_info_by_column_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_url_info_by_column_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_url_info_by_column_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string column_id=in();
{
int res=mc_pack_put_str(pack,"column_id",_m_column_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_url_info_by_column_id_result_params
static void _mcpack2_load_mcp_get_url_info_by_column_id_result_params_count(const mc_pack_item_t*,mcp_get_url_info_by_column_id_result_params*);
static void _mcpack2_load_mcp_get_url_info_by_column_id_result_params_url_info(const mc_pack_item_t*,mcp_get_url_info_by_column_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_url_info_by_column_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_url_info_by_column_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_result_params*)>("count",_mcpack2_load_mcp_get_url_info_by_column_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_result_params*)>("url_info",_mcpack2_load_mcp_get_url_info_by_column_id_result_params_url_info));
_mcpack2_load_mcp_get_url_info_by_column_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_url_info_by_column_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_url_info_by_column_id_result_params_static_inited=_mcpack2_load_mcp_get_url_info_by_column_id_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_url_info_by_column_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_column_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string url_info=out(),array(0,0);
static void _mcpack2_load_mcp_get_url_info_by_column_id_result_params_url_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_column_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_url_info)) lp0=&(self->_m_url_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "url_info";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "url_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_url_info_by_column_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_url_info_by_column_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_url_info_by_column_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_result_params*)=0;
if(_mcpack2_load_mcp_get_url_info_by_column_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_url_info_by_column_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_url_info_by_column_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string url_info=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"url_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_url_info)& lr0=(_m_url_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_url_info_by_column_id_response
static void _mcpack2_load_mcp_get_url_info_by_column_id_response_result_params(const mc_pack_item_t*,mcp_get_url_info_by_column_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_url_info_by_column_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_url_info_by_column_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_response*)>("result_params",_mcpack2_load_mcp_get_url_info_by_column_id_response_result_params));
_mcpack2_load_mcp_get_url_info_by_column_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_url_info_by_column_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_url_info_by_column_id_response_static_inited=_mcpack2_load_mcp_get_url_info_by_column_id_response_static_init();
// @@mcp_get_url_info_by_column_id_result_params result_params;
static void _mcpack2_load_mcp_get_url_info_by_column_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_url_info_by_column_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_url_info_by_column_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_url_info_by_column_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_url_info_by_column_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_url_info_by_column_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_url_info_by_column_id_response*)=0;
if(_mcpack2_load_mcp_get_url_info_by_column_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_url_info_by_column_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_url_info_by_column_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_url_info_by_column_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_phone_params
static void _mcpack2_load_mcp_get_content_list_from_phone_params_p_id(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*);
static void _mcpack2_load_mcp_get_content_list_from_phone_params_priority(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*);
static void _mcpack2_load_mcp_get_content_list_from_phone_params_type(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*);
static void _mcpack2_load_mcp_get_content_list_from_phone_params_unit_num(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*);
static void _mcpack2_load_mcp_get_content_list_from_phone_params_unit_times(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_phone_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_phone_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*)>("p_id",_mcpack2_load_mcp_get_content_list_from_phone_params_p_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*)>("priority",_mcpack2_load_mcp_get_content_list_from_phone_params_priority));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*)>("type",_mcpack2_load_mcp_get_content_list_from_phone_params_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*)>("unit_num",_mcpack2_load_mcp_get_content_list_from_phone_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*)>("unit_times",_mcpack2_load_mcp_get_content_list_from_phone_params_unit_times));
_mcpack2_load_mcp_get_content_list_from_phone_params_readmap.create(16*5);
_mcpack2_load_mcp_get_content_list_from_phone_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_phone_params_static_inited=_mcpack2_load_mcp_get_content_list_from_phone_params_static_init();
// @@string p_id=in();
static void _mcpack2_load_mcp_get_content_list_from_phone_params_p_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_phone_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "p_id";
}
self->_m_p_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t priority=in();
static void _mcpack2_load_mcp_get_content_list_from_phone_params_priority(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_phone_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_priority));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "priority";
}
}
// @@uint32_t type=in();
static void _mcpack2_load_mcp_get_content_list_from_phone_params_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_phone_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type";
}
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_content_list_from_phone_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_phone_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_content_list_from_phone_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_phone_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_content_list_from_phone_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_phone_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_phone_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_phone_params*)=0;
if(_mcpack2_load_mcp_get_content_list_from_phone_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_phone_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_phone_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string p_id=in();
{
int res=mc_pack_put_str(pack,"p_id",_m_p_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t priority=in();
{
int res=mc_pack_put_uint32(pack,"priority",_m_priority);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t type=in();
{
int res=mc_pack_put_uint32(pack,"type",_m_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_phone_result_params
static void _mcpack2_load_mcp_get_content_list_from_phone_result_params_count(const mc_pack_item_t*,mcp_get_content_list_from_phone_result_params*);
static void _mcpack2_load_mcp_get_content_list_from_phone_result_params_content_list(const mc_pack_item_t*,mcp_get_content_list_from_phone_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_phone_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_phone_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_result_params*)>("count",_mcpack2_load_mcp_get_content_list_from_phone_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_result_params*)>("content_list",_mcpack2_load_mcp_get_content_list_from_phone_result_params_content_list));
_mcpack2_load_mcp_get_content_list_from_phone_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_list_from_phone_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_phone_result_params_static_inited=_mcpack2_load_mcp_get_content_list_from_phone_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_content_list_from_phone_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_phone_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string content_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_content_list_from_phone_result_params_content_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_phone_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_content_list)) lp0=&(self->_m_content_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_list_from_phone_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_phone_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_phone_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_phone_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_phone_result_params*)=0;
if(_mcpack2_load_mcp_get_content_list_from_phone_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_phone_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_phone_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"content_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_content_list)& lr0=(_m_content_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_phone_response
static void _mcpack2_load_mcp_get_content_list_from_phone_response_result_params(const mc_pack_item_t*,mcp_get_content_list_from_phone_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_phone_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_phone_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_phone_response*)>("result_params",_mcpack2_load_mcp_get_content_list_from_phone_response_result_params));
_mcpack2_load_mcp_get_content_list_from_phone_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_list_from_phone_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_phone_response_static_inited=_mcpack2_load_mcp_get_content_list_from_phone_response_static_init();
// @@mcp_get_content_list_from_phone_result_params result_params;
static void _mcpack2_load_mcp_get_content_list_from_phone_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_phone_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_list_from_phone_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_list_from_phone_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_phone_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_phone_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_phone_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_phone_response*)=0;
if(_mcpack2_load_mcp_get_content_list_from_phone_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_phone_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_phone_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_list_from_phone_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_rank_params
static void _mcpack2_load_mcp_get_content_list_by_rank_params_content_type(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*);
static void _mcpack2_load_mcp_get_content_list_by_rank_params_class_id(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*);
static void _mcpack2_load_mcp_get_content_list_by_rank_params_p_type(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*);
static void _mcpack2_load_mcp_get_content_list_by_rank_params_unit_num(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*);
static void _mcpack2_load_mcp_get_content_list_by_rank_params_unit_times(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*);
static void _mcpack2_load_mcp_get_content_list_by_rank_params_info_id(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*);
static void _mcpack2_load_mcp_get_content_list_by_rank_params_info_type(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*);
static void _mcpack2_load_mcp_get_content_list_by_rank_params_for_adapt(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_rank_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_rank_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*)>("content_type",_mcpack2_load_mcp_get_content_list_by_rank_params_content_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*)>("class_id",_mcpack2_load_mcp_get_content_list_by_rank_params_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*)>("p_type",_mcpack2_load_mcp_get_content_list_by_rank_params_p_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*)>("unit_num",_mcpack2_load_mcp_get_content_list_by_rank_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*)>("unit_times",_mcpack2_load_mcp_get_content_list_by_rank_params_unit_times));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*)>("info_id",_mcpack2_load_mcp_get_content_list_by_rank_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*)>("info_type",_mcpack2_load_mcp_get_content_list_by_rank_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*)>("for_adapt",_mcpack2_load_mcp_get_content_list_by_rank_params_for_adapt));
_mcpack2_load_mcp_get_content_list_by_rank_params_readmap.create(16*8);
_mcpack2_load_mcp_get_content_list_by_rank_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_rank_params_static_inited=_mcpack2_load_mcp_get_content_list_by_rank_params_static_init();
// @@string content_type=in();
static void _mcpack2_load_mcp_get_content_list_by_rank_params_content_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_rank_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_type";
}
self->_m_content_type.set_ptr(item->value,item->value_size-1);
}
// @@string class_id=in();
static void _mcpack2_load_mcp_get_content_list_by_rank_params_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_rank_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t p_type=in();
static void _mcpack2_load_mcp_get_content_list_by_rank_params_p_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_rank_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_p_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "p_type";
}
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_content_list_by_rank_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_rank_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_content_list_by_rank_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_rank_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
// @@string info_id=in();
static void _mcpack2_load_mcp_get_content_list_by_rank_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_rank_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t info_type=in();
static void _mcpack2_load_mcp_get_content_list_by_rank_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_rank_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
}
// @@uint32_t for_adapt=in();
static void _mcpack2_load_mcp_get_content_list_by_rank_params_for_adapt(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_rank_params* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_for_adapt));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "for_adapt";
}
}
void mcp_get_content_list_by_rank_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_rank_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_rank_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_rank_params*)=0;
if(_mcpack2_load_mcp_get_content_list_by_rank_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_rank_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_rank_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string content_type=in();
{
int res=mc_pack_put_str(pack,"content_type",_m_content_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string class_id=in();
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t p_type=in();
{
int res=mc_pack_put_uint32(pack,"p_type",_m_p_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t info_type=in();
{
int res=mc_pack_put_uint32(pack,"info_type",_m_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t for_adapt=in();
{
int res=mc_pack_put_uint32(pack,"for_adapt",_m_for_adapt);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_rank_result_params
static void _mcpack2_load_mcp_get_content_list_by_rank_result_params_count(const mc_pack_item_t*,mcp_get_content_list_by_rank_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_rank_result_params_content_list(const mc_pack_item_t*,mcp_get_content_list_by_rank_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_rank_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_rank_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_result_params*)>("count",_mcpack2_load_mcp_get_content_list_by_rank_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_result_params*)>("content_list",_mcpack2_load_mcp_get_content_list_by_rank_result_params_content_list));
_mcpack2_load_mcp_get_content_list_by_rank_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_list_by_rank_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_rank_result_params_static_inited=_mcpack2_load_mcp_get_content_list_by_rank_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_content_list_by_rank_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_rank_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string content_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_content_list_by_rank_result_params_content_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_rank_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_content_list)) lp0=&(self->_m_content_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_list_by_rank_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_rank_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_rank_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_rank_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_rank_result_params*)=0;
if(_mcpack2_load_mcp_get_content_list_by_rank_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_rank_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_rank_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"content_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_content_list)& lr0=(_m_content_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_rank_response
static void _mcpack2_load_mcp_get_content_list_by_rank_response_result_params(const mc_pack_item_t*,mcp_get_content_list_by_rank_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_rank_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_rank_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_rank_response*)>("result_params",_mcpack2_load_mcp_get_content_list_by_rank_response_result_params));
_mcpack2_load_mcp_get_content_list_by_rank_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_list_by_rank_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_rank_response_static_inited=_mcpack2_load_mcp_get_content_list_by_rank_response_static_init();
// @@mcp_get_content_list_by_rank_result_params result_params;
static void _mcpack2_load_mcp_get_content_list_by_rank_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_rank_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_list_by_rank_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_list_by_rank_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_rank_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_rank_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_rank_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_rank_response*)=0;
if(_mcpack2_load_mcp_get_content_list_by_rank_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_rank_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_rank_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_list_by_rank_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_label_by_content_id_params
static void _mcpack2_load_mcp_get_label_by_content_id_params_content_id(const mc_pack_item_t*,mcp_get_label_by_content_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_label_by_content_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_label_by_content_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_label_by_content_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_label_by_content_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_label_by_content_id_params*)>("content_id",_mcpack2_load_mcp_get_label_by_content_id_params_content_id));
_mcpack2_load_mcp_get_label_by_content_id_params_readmap.create(16*1);
_mcpack2_load_mcp_get_label_by_content_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_label_by_content_id_params_static_inited=_mcpack2_load_mcp_get_label_by_content_id_params_static_init();
// @@string content_id=in();
static void _mcpack2_load_mcp_get_label_by_content_id_params_content_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_label_by_content_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_id";
}
self->_m_content_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_label_by_content_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_label_by_content_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_label_by_content_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_label_by_content_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_label_by_content_id_params*)=0;
if(_mcpack2_load_mcp_get_label_by_content_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_label_by_content_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_label_by_content_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string content_id=in();
{
int res=mc_pack_put_str(pack,"content_id",_m_content_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_label_by_content_id_result_params
static void _mcpack2_load_mcp_get_label_by_content_id_result_params_result(const mc_pack_item_t*,mcp_get_label_by_content_id_result_params*);
static void _mcpack2_load_mcp_get_label_by_content_id_result_params_label_list(const mc_pack_item_t*,mcp_get_label_by_content_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_label_by_content_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_label_by_content_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_label_by_content_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_label_by_content_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_label_by_content_id_result_params*)>("result",_mcpack2_load_mcp_get_label_by_content_id_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_label_by_content_id_result_params*)>("label_list",_mcpack2_load_mcp_get_label_by_content_id_result_params_label_list));
_mcpack2_load_mcp_get_label_by_content_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_label_by_content_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_label_by_content_id_result_params_static_inited=_mcpack2_load_mcp_get_label_by_content_id_result_params_static_init();
// @@uint32_t result=out();
static void _mcpack2_load_mcp_get_label_by_content_id_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_label_by_content_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@string label_list=out(),array(0,2);
static void _mcpack2_load_mcp_get_label_by_content_id_result_params_label_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_label_by_content_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "label_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_label_list)) lp0=&(self->_m_label_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "label_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "label_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "label_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "label_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "label_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "label_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_label_by_content_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_label_by_content_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_label_by_content_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_label_by_content_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_label_by_content_id_result_params*)=0;
if(_mcpack2_load_mcp_get_label_by_content_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_label_by_content_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_label_by_content_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t result=out();
{
int res=mc_pack_put_uint32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string label_list=out(),array(0,2);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"label_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_label_list)& lr0=(_m_label_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_label_by_content_id_response
static void _mcpack2_load_mcp_get_label_by_content_id_response_result_params(const mc_pack_item_t*,mcp_get_label_by_content_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_label_by_content_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_label_by_content_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_label_by_content_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_label_by_content_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_label_by_content_id_response*)>("result_params",_mcpack2_load_mcp_get_label_by_content_id_response_result_params));
_mcpack2_load_mcp_get_label_by_content_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_label_by_content_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_label_by_content_id_response_static_inited=_mcpack2_load_mcp_get_label_by_content_id_response_static_init();
// @@mcp_get_label_by_content_id_result_params result_params;
static void _mcpack2_load_mcp_get_label_by_content_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_label_by_content_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_label_by_content_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_label_by_content_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_label_by_content_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_label_by_content_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_label_by_content_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_label_by_content_id_response*)=0;
if(_mcpack2_load_mcp_get_label_by_content_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_label_by_content_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_label_by_content_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_label_by_content_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_label_params
static void _mcpack2_load_mcp_get_content_list_by_label_params_label_id(const mc_pack_item_t*,mcp_get_content_list_by_label_params*);
static void _mcpack2_load_mcp_get_content_list_by_label_params_unit_num(const mc_pack_item_t*,mcp_get_content_list_by_label_params*);
static void _mcpack2_load_mcp_get_content_list_by_label_params_unit_times(const mc_pack_item_t*,mcp_get_content_list_by_label_params*);
static void _mcpack2_load_mcp_get_content_list_by_label_params_info_id(const mc_pack_item_t*,mcp_get_content_list_by_label_params*);
static void _mcpack2_load_mcp_get_content_list_by_label_params_info_type(const mc_pack_item_t*,mcp_get_content_list_by_label_params*);
static void _mcpack2_load_mcp_get_content_list_by_label_params_for_adapt(const mc_pack_item_t*,mcp_get_content_list_by_label_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_label_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_label_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_params*)>("label_id",_mcpack2_load_mcp_get_content_list_by_label_params_label_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_params*)>("unit_num",_mcpack2_load_mcp_get_content_list_by_label_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_params*)>("unit_times",_mcpack2_load_mcp_get_content_list_by_label_params_unit_times));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_params*)>("info_id",_mcpack2_load_mcp_get_content_list_by_label_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_params*)>("info_type",_mcpack2_load_mcp_get_content_list_by_label_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_params*)>("for_adapt",_mcpack2_load_mcp_get_content_list_by_label_params_for_adapt));
_mcpack2_load_mcp_get_content_list_by_label_params_readmap.create(16*6);
_mcpack2_load_mcp_get_content_list_by_label_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_label_params_static_inited=_mcpack2_load_mcp_get_content_list_by_label_params_static_init();
// @@string label_id=in();
static void _mcpack2_load_mcp_get_content_list_by_label_params_label_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_label_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "label_id";
}
self->_m_label_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_content_list_by_label_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_label_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_content_list_by_label_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_label_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
// @@string info_id=in();
static void _mcpack2_load_mcp_get_content_list_by_label_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_label_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t info_type=in();
static void _mcpack2_load_mcp_get_content_list_by_label_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_label_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
}
// @@uint32_t for_adapt=in();
static void _mcpack2_load_mcp_get_content_list_by_label_params_for_adapt(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_label_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_for_adapt));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "for_adapt";
}
}
void mcp_get_content_list_by_label_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_label_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_label_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_label_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_label_params*)=0;
if(_mcpack2_load_mcp_get_content_list_by_label_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_label_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_label_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string label_id=in();
{
int res=mc_pack_put_str(pack,"label_id",_m_label_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t info_type=in();
{
int res=mc_pack_put_uint32(pack,"info_type",_m_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t for_adapt=in();
{
int res=mc_pack_put_uint32(pack,"for_adapt",_m_for_adapt);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_label_result_params
static void _mcpack2_load_mcp_get_content_list_by_label_result_params_count(const mc_pack_item_t*,mcp_get_content_list_by_label_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_label_result_params_content_list(const mc_pack_item_t*,mcp_get_content_list_by_label_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_label_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_label_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_result_params*)>("count",_mcpack2_load_mcp_get_content_list_by_label_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_result_params*)>("content_list",_mcpack2_load_mcp_get_content_list_by_label_result_params_content_list));
_mcpack2_load_mcp_get_content_list_by_label_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_list_by_label_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_label_result_params_static_inited=_mcpack2_load_mcp_get_content_list_by_label_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_content_list_by_label_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_label_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string content_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_content_list_by_label_result_params_content_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_label_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_content_list)) lp0=&(self->_m_content_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_list_by_label_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_label_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_label_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_label_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_label_result_params*)=0;
if(_mcpack2_load_mcp_get_content_list_by_label_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_label_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_label_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"content_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_content_list)& lr0=(_m_content_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_label_response
static void _mcpack2_load_mcp_get_content_list_by_label_response_result_params(const mc_pack_item_t*,mcp_get_content_list_by_label_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_label_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_label_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_label_response*)>("result_params",_mcpack2_load_mcp_get_content_list_by_label_response_result_params));
_mcpack2_load_mcp_get_content_list_by_label_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_list_by_label_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_label_response_static_inited=_mcpack2_load_mcp_get_content_list_by_label_response_static_init();
// @@mcp_get_content_list_by_label_result_params result_params;
static void _mcpack2_load_mcp_get_content_list_by_label_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_label_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_list_by_label_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_list_by_label_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_label_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_label_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_label_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_label_response*)=0;
if(_mcpack2_load_mcp_get_content_list_by_label_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_label_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_label_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_list_by_label_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_topic_info_params
static void _mcpack2_load_mcp_get_topic_info_params_content_type(const mc_pack_item_t*,mcp_get_topic_info_params*);
static void _mcpack2_load_mcp_get_topic_info_params_unit_num(const mc_pack_item_t*,mcp_get_topic_info_params*);
static void _mcpack2_load_mcp_get_topic_info_params_unit_times(const mc_pack_item_t*,mcp_get_topic_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_topic_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_topic_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_topic_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_info_params*)>("content_type",_mcpack2_load_mcp_get_topic_info_params_content_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_info_params*)>("unit_num",_mcpack2_load_mcp_get_topic_info_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_info_params*)>("unit_times",_mcpack2_load_mcp_get_topic_info_params_unit_times));
_mcpack2_load_mcp_get_topic_info_params_readmap.create(16*3);
_mcpack2_load_mcp_get_topic_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_topic_info_params_static_inited=_mcpack2_load_mcp_get_topic_info_params_static_init();
// @@string content_type=in();
static void _mcpack2_load_mcp_get_topic_info_params_content_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_topic_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_type";
}
self->_m_content_type.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_topic_info_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_topic_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_topic_info_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_topic_info_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_topic_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_topic_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_topic_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_topic_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_topic_info_params*)=0;
if(_mcpack2_load_mcp_get_topic_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_topic_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_topic_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string content_type=in();
{
int res=mc_pack_put_str(pack,"content_type",_m_content_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_topic_info_result_params
static void _mcpack2_load_mcp_get_topic_info_result_params_count(const mc_pack_item_t*,mcp_get_topic_info_result_params*);
static void _mcpack2_load_mcp_get_topic_info_result_params_topic_list(const mc_pack_item_t*,mcp_get_topic_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_topic_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_topic_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_topic_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_info_result_params*)>("count",_mcpack2_load_mcp_get_topic_info_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_info_result_params*)>("topic_list",_mcpack2_load_mcp_get_topic_info_result_params_topic_list));
_mcpack2_load_mcp_get_topic_info_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_topic_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_topic_info_result_params_static_inited=_mcpack2_load_mcp_get_topic_info_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_topic_info_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_topic_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string topic_list=out(),array(0,2);
static void _mcpack2_load_mcp_get_topic_info_result_params_topic_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_topic_info_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "topic_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_topic_list)) lp0=&(self->_m_topic_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "topic_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "topic_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "topic_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "topic_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "topic_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "topic_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_topic_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_topic_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_topic_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_topic_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_topic_info_result_params*)=0;
if(_mcpack2_load_mcp_get_topic_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_topic_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_topic_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string topic_list=out(),array(0,2);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"topic_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_topic_list)& lr0=(_m_topic_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_topic_info_response
static void _mcpack2_load_mcp_get_topic_info_response_result_params(const mc_pack_item_t*,mcp_get_topic_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_topic_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_topic_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_topic_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_info_response*)>("result_params",_mcpack2_load_mcp_get_topic_info_response_result_params));
_mcpack2_load_mcp_get_topic_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_topic_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_topic_info_response_static_inited=_mcpack2_load_mcp_get_topic_info_response_static_init();
// @@mcp_get_topic_info_result_params result_params;
static void _mcpack2_load_mcp_get_topic_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_topic_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_topic_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_topic_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_topic_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_topic_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_topic_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_topic_info_response*)=0;
if(_mcpack2_load_mcp_get_topic_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_topic_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_topic_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_topic_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_count_by_class_params
static void _mcpack2_load_mcp_get_content_count_by_class_params_class_id(const mc_pack_item_t*,mcp_get_content_count_by_class_params*);
static void _mcpack2_load_mcp_get_content_count_by_class_params_info_id(const mc_pack_item_t*,mcp_get_content_count_by_class_params*);
static void _mcpack2_load_mcp_get_content_count_by_class_params_info_type(const mc_pack_item_t*,mcp_get_content_count_by_class_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_by_class_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_count_by_class_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_count_by_class_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_count_by_class_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_by_class_params*)>("class_id",_mcpack2_load_mcp_get_content_count_by_class_params_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_by_class_params*)>("info_id",_mcpack2_load_mcp_get_content_count_by_class_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_by_class_params*)>("info_type",_mcpack2_load_mcp_get_content_count_by_class_params_info_type));
_mcpack2_load_mcp_get_content_count_by_class_params_readmap.create(16*3);
_mcpack2_load_mcp_get_content_count_by_class_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_count_by_class_params_static_inited=_mcpack2_load_mcp_get_content_count_by_class_params_static_init();
// @@string class_id=in();
static void _mcpack2_load_mcp_get_content_count_by_class_params_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_count_by_class_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
// @@string info_id=in();
static void _mcpack2_load_mcp_get_content_count_by_class_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_count_by_class_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t info_type=in();
static void _mcpack2_load_mcp_get_content_count_by_class_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_count_by_class_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
}
void mcp_get_content_count_by_class_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_count_by_class_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_count_by_class_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_count_by_class_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_count_by_class_params*)=0;
if(_mcpack2_load_mcp_get_content_count_by_class_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_count_by_class_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_count_by_class_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string class_id=in();
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t info_type=in();
{
int res=mc_pack_put_uint32(pack,"info_type",_m_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_count_by_class_result_params
static void _mcpack2_load_mcp_get_content_count_by_class_result_params_count(const mc_pack_item_t*,mcp_get_content_count_by_class_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_by_class_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_count_by_class_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_count_by_class_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_count_by_class_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_by_class_result_params*)>("count",_mcpack2_load_mcp_get_content_count_by_class_result_params_count));
_mcpack2_load_mcp_get_content_count_by_class_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_content_count_by_class_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_count_by_class_result_params_static_inited=_mcpack2_load_mcp_get_content_count_by_class_result_params_static_init();
// @@int32_t count=out(),array(0);
static void _mcpack2_load_mcp_get_content_count_by_class_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_count_by_class_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "count";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_count)) lp0=&(self->_m_count);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "count";
}
for(int i0=0;i0<size0;i0++){
res0=mc_pack_get_int32_from_item(&item0,lp0->MutableGetWithoutCheck(i0));
if(res0){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "count";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_count_by_class_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_count_by_class_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_count_by_class_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_count_by_class_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_count_by_class_result_params*)=0;
if(_mcpack2_load_mcp_get_content_count_by_class_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_count_by_class_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_count_by_class_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"count");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_count)& lr0=(_m_count);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_int32(pack0,0,lr0.GetWithoutCheck(i0));
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_count_by_class_response
static void _mcpack2_load_mcp_get_content_count_by_class_response_result_params(const mc_pack_item_t*,mcp_get_content_count_by_class_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_by_class_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_count_by_class_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_count_by_class_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_count_by_class_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_count_by_class_response*)>("result_params",_mcpack2_load_mcp_get_content_count_by_class_response_result_params));
_mcpack2_load_mcp_get_content_count_by_class_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_count_by_class_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_count_by_class_response_static_inited=_mcpack2_load_mcp_get_content_count_by_class_response_static_init();
// @@mcp_get_content_count_by_class_result_params result_params;
static void _mcpack2_load_mcp_get_content_count_by_class_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_count_by_class_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_count_by_class_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_count_by_class_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_count_by_class_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_count_by_class_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_count_by_class_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_count_by_class_response*)=0;
if(_mcpack2_load_mcp_get_content_count_by_class_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_count_by_class_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_count_by_class_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_count_by_class_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_img_params
static void _mcpack2_load_mcp_get_content_img_params_content_id(const mc_pack_item_t*,mcp_get_content_img_params*);
static void _mcpack2_load_mcp_get_content_img_params_img_type(const mc_pack_item_t*,mcp_get_content_img_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_img_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_img_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_img_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_img_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_img_params*)>("content_id",_mcpack2_load_mcp_get_content_img_params_content_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_img_params*)>("img_type",_mcpack2_load_mcp_get_content_img_params_img_type));
_mcpack2_load_mcp_get_content_img_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_img_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_img_params_static_inited=_mcpack2_load_mcp_get_content_img_params_static_init();
// @@string content_id=in();
static void _mcpack2_load_mcp_get_content_img_params_content_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_img_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_id";
}
self->_m_content_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t img_type=in();
static void _mcpack2_load_mcp_get_content_img_params_img_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_img_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_img_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "img_type";
}
}
void mcp_get_content_img_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_img_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_img_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_img_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_img_params*)=0;
if(_mcpack2_load_mcp_get_content_img_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_img_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_img_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string content_id=in();
{
int res=mc_pack_put_str(pack,"content_id",_m_content_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t img_type=in();
{
int res=mc_pack_put_uint32(pack,"img_type",_m_img_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_img_result_params
static void _mcpack2_load_mcp_get_content_img_result_params_count(const mc_pack_item_t*,mcp_get_content_img_result_params*);
static void _mcpack2_load_mcp_get_content_img_result_params_img_url(const mc_pack_item_t*,mcp_get_content_img_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_img_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_img_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_img_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_img_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_img_result_params*)>("count",_mcpack2_load_mcp_get_content_img_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_img_result_params*)>("img_url",_mcpack2_load_mcp_get_content_img_result_params_img_url));
_mcpack2_load_mcp_get_content_img_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_img_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_img_result_params_static_inited=_mcpack2_load_mcp_get_content_img_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_content_img_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_img_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string img_url=out(),array(0);
static void _mcpack2_load_mcp_get_content_img_result_params_img_url(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_img_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_url";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_img_url)) lp0=&(self->_m_img_url);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_url";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "img_url";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "img_url";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_img_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_img_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_img_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_img_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_img_result_params*)=0;
if(_mcpack2_load_mcp_get_content_img_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_img_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_img_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string img_url=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"img_url");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_img_url)& lr0=(_m_img_url);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_img_response
static void _mcpack2_load_mcp_get_content_img_response_result_params(const mc_pack_item_t*,mcp_get_content_img_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_img_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_img_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_img_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_img_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_img_response*)>("result_params",_mcpack2_load_mcp_get_content_img_response_result_params));
_mcpack2_load_mcp_get_content_img_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_img_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_img_response_static_inited=_mcpack2_load_mcp_get_content_img_response_static_init();
// @@mcp_get_content_img_result_params result_params;
static void _mcpack2_load_mcp_get_content_img_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_img_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_img_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_img_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_img_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_img_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_img_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_img_response*)=0;
if(_mcpack2_load_mcp_get_content_img_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_img_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_img_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_img_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_label_name_by_id_params
static void _mcpack2_load_mcp_get_label_name_by_id_params_label_id(const mc_pack_item_t*,mcp_get_label_name_by_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_label_name_by_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_label_name_by_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_label_name_by_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_label_name_by_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_label_name_by_id_params*)>("label_id",_mcpack2_load_mcp_get_label_name_by_id_params_label_id));
_mcpack2_load_mcp_get_label_name_by_id_params_readmap.create(16*1);
_mcpack2_load_mcp_get_label_name_by_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_label_name_by_id_params_static_inited=_mcpack2_load_mcp_get_label_name_by_id_params_static_init();
// @@string label_id=in();
static void _mcpack2_load_mcp_get_label_name_by_id_params_label_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_label_name_by_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "label_id";
}
self->_m_label_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_label_name_by_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_label_name_by_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_label_name_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_label_name_by_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_label_name_by_id_params*)=0;
if(_mcpack2_load_mcp_get_label_name_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_label_name_by_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_label_name_by_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string label_id=in();
{
int res=mc_pack_put_str(pack,"label_id",_m_label_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_label_name_by_id_result_params
static void _mcpack2_load_mcp_get_label_name_by_id_result_params_label_name(const mc_pack_item_t*,mcp_get_label_name_by_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_label_name_by_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_label_name_by_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_label_name_by_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_label_name_by_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_label_name_by_id_result_params*)>("label_name",_mcpack2_load_mcp_get_label_name_by_id_result_params_label_name));
_mcpack2_load_mcp_get_label_name_by_id_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_label_name_by_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_label_name_by_id_result_params_static_inited=_mcpack2_load_mcp_get_label_name_by_id_result_params_static_init();
// @@string label_name=out();
static void _mcpack2_load_mcp_get_label_name_by_id_result_params_label_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_label_name_by_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "label_name";
}
self->_m_label_name.set_ptr(item->value,item->value_size-1);
}
void mcp_get_label_name_by_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_label_name_by_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_label_name_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_label_name_by_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_label_name_by_id_result_params*)=0;
if(_mcpack2_load_mcp_get_label_name_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_label_name_by_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_label_name_by_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string label_name=out();
{
int res=mc_pack_put_str(pack,"label_name",_m_label_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_label_name_by_id_response
static void _mcpack2_load_mcp_get_label_name_by_id_response_result_params(const mc_pack_item_t*,mcp_get_label_name_by_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_label_name_by_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_label_name_by_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_label_name_by_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_label_name_by_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_label_name_by_id_response*)>("result_params",_mcpack2_load_mcp_get_label_name_by_id_response_result_params));
_mcpack2_load_mcp_get_label_name_by_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_label_name_by_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_label_name_by_id_response_static_inited=_mcpack2_load_mcp_get_label_name_by_id_response_static_init();
// @@mcp_get_label_name_by_id_result_params result_params;
static void _mcpack2_load_mcp_get_label_name_by_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_label_name_by_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_label_name_by_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_label_name_by_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_label_name_by_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_label_name_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_label_name_by_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_label_name_by_id_response*)=0;
if(_mcpack2_load_mcp_get_label_name_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_label_name_by_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_label_name_by_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_label_name_by_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_date_params
static void _mcpack2_load_mcp_get_content_list_by_date_params_content_type(const mc_pack_item_t*,mcp_get_content_list_by_date_params*);
static void _mcpack2_load_mcp_get_content_list_by_date_params_unit_num(const mc_pack_item_t*,mcp_get_content_list_by_date_params*);
static void _mcpack2_load_mcp_get_content_list_by_date_params_unit_times(const mc_pack_item_t*,mcp_get_content_list_by_date_params*);
static void _mcpack2_load_mcp_get_content_list_by_date_params_info_id(const mc_pack_item_t*,mcp_get_content_list_by_date_params*);
static void _mcpack2_load_mcp_get_content_list_by_date_params_info_type(const mc_pack_item_t*,mcp_get_content_list_by_date_params*);
static void _mcpack2_load_mcp_get_content_list_by_date_params_for_adapt(const mc_pack_item_t*,mcp_get_content_list_by_date_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_date_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_date_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_params*)>("content_type",_mcpack2_load_mcp_get_content_list_by_date_params_content_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_params*)>("unit_num",_mcpack2_load_mcp_get_content_list_by_date_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_params*)>("unit_times",_mcpack2_load_mcp_get_content_list_by_date_params_unit_times));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_params*)>("info_id",_mcpack2_load_mcp_get_content_list_by_date_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_params*)>("info_type",_mcpack2_load_mcp_get_content_list_by_date_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_params*)>("for_adapt",_mcpack2_load_mcp_get_content_list_by_date_params_for_adapt));
_mcpack2_load_mcp_get_content_list_by_date_params_readmap.create(16*6);
_mcpack2_load_mcp_get_content_list_by_date_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_date_params_static_inited=_mcpack2_load_mcp_get_content_list_by_date_params_static_init();
// @@string content_type=in();
static void _mcpack2_load_mcp_get_content_list_by_date_params_content_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_date_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_type";
}
self->_m_content_type.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_content_list_by_date_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_date_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_content_list_by_date_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_date_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
// @@string info_id=in();
static void _mcpack2_load_mcp_get_content_list_by_date_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_date_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t info_type=in();
static void _mcpack2_load_mcp_get_content_list_by_date_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_date_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
}
// @@uint32_t for_adapt=in();
static void _mcpack2_load_mcp_get_content_list_by_date_params_for_adapt(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_date_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_for_adapt));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "for_adapt";
}
}
void mcp_get_content_list_by_date_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_date_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_date_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_date_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_date_params*)=0;
if(_mcpack2_load_mcp_get_content_list_by_date_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_date_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_date_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string content_type=in();
{
int res=mc_pack_put_str(pack,"content_type",_m_content_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t info_type=in();
{
int res=mc_pack_put_uint32(pack,"info_type",_m_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t for_adapt=in();
{
int res=mc_pack_put_uint32(pack,"for_adapt",_m_for_adapt);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_date_result_params
static void _mcpack2_load_mcp_get_content_list_by_date_result_params_result(const mc_pack_item_t*,mcp_get_content_list_by_date_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_date_result_params_content_list(const mc_pack_item_t*,mcp_get_content_list_by_date_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_date_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_date_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_result_params*)>("result",_mcpack2_load_mcp_get_content_list_by_date_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_result_params*)>("content_list",_mcpack2_load_mcp_get_content_list_by_date_result_params_content_list));
_mcpack2_load_mcp_get_content_list_by_date_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_list_by_date_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_date_result_params_static_inited=_mcpack2_load_mcp_get_content_list_by_date_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_get_content_list_by_date_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_date_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@string content_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_content_list_by_date_result_params_content_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_date_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_content_list)) lp0=&(self->_m_content_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_list_by_date_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_date_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_date_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_date_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_date_result_params*)=0;
if(_mcpack2_load_mcp_get_content_list_by_date_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_date_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_date_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"content_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_content_list)& lr0=(_m_content_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_date_response
static void _mcpack2_load_mcp_get_content_list_by_date_response_result_params(const mc_pack_item_t*,mcp_get_content_list_by_date_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_date_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_date_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_date_response*)>("result_params",_mcpack2_load_mcp_get_content_list_by_date_response_result_params));
_mcpack2_load_mcp_get_content_list_by_date_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_list_by_date_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_date_response_static_inited=_mcpack2_load_mcp_get_content_list_by_date_response_static_init();
// @@mcp_get_content_list_by_date_result_params result_params;
static void _mcpack2_load_mcp_get_content_list_by_date_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_date_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_list_by_date_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_list_by_date_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_date_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_date_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_date_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_date_response*)=0;
if(_mcpack2_load_mcp_get_content_list_by_date_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_date_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_date_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_list_by_date_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_soft_info_by_id_params
static void _mcpack2_load_mcp_get_soft_info_by_id_params_soft_id(const mc_pack_item_t*,mcp_get_soft_info_by_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_info_by_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_soft_info_by_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_soft_info_by_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_soft_info_by_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_info_by_id_params*)>("soft_id",_mcpack2_load_mcp_get_soft_info_by_id_params_soft_id));
_mcpack2_load_mcp_get_soft_info_by_id_params_readmap.create(16*1);
_mcpack2_load_mcp_get_soft_info_by_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_soft_info_by_id_params_static_inited=_mcpack2_load_mcp_get_soft_info_by_id_params_static_init();
// @@string soft_id=in();
static void _mcpack2_load_mcp_get_soft_info_by_id_params_soft_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_info_by_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "soft_id";
}
self->_m_soft_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_soft_info_by_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_soft_info_by_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_soft_info_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_soft_info_by_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_soft_info_by_id_params*)=0;
if(_mcpack2_load_mcp_get_soft_info_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_soft_info_by_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_soft_info_by_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string soft_id=in();
{
int res=mc_pack_put_str(pack,"soft_id",_m_soft_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_soft_info_by_id_result_params
static void _mcpack2_load_mcp_get_soft_info_by_id_result_params_result(const mc_pack_item_t*,mcp_get_soft_info_by_id_result_params*);
static void _mcpack2_load_mcp_get_soft_info_by_id_result_params_soft_info(const mc_pack_item_t*,mcp_get_soft_info_by_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_info_by_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_soft_info_by_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_soft_info_by_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_soft_info_by_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_info_by_id_result_params*)>("result",_mcpack2_load_mcp_get_soft_info_by_id_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_info_by_id_result_params*)>("soft_info",_mcpack2_load_mcp_get_soft_info_by_id_result_params_soft_info));
_mcpack2_load_mcp_get_soft_info_by_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_soft_info_by_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_soft_info_by_id_result_params_static_inited=_mcpack2_load_mcp_get_soft_info_by_id_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_get_soft_info_by_id_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_info_by_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@string soft_info=out(),array(0);
static void _mcpack2_load_mcp_get_soft_info_by_id_result_params_soft_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_info_by_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_soft_info)) lp0=&(self->_m_soft_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_info";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "soft_info";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_soft_info_by_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_soft_info_by_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_soft_info_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_soft_info_by_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_soft_info_by_id_result_params*)=0;
if(_mcpack2_load_mcp_get_soft_info_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_soft_info_by_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_soft_info_by_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string soft_info=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"soft_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_soft_info)& lr0=(_m_soft_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_soft_info_by_id_response
static void _mcpack2_load_mcp_get_soft_info_by_id_response_result_params(const mc_pack_item_t*,mcp_get_soft_info_by_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_info_by_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_soft_info_by_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_soft_info_by_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_soft_info_by_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_info_by_id_response*)>("result_params",_mcpack2_load_mcp_get_soft_info_by_id_response_result_params));
_mcpack2_load_mcp_get_soft_info_by_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_soft_info_by_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_soft_info_by_id_response_static_inited=_mcpack2_load_mcp_get_soft_info_by_id_response_static_init();
// @@mcp_get_soft_info_by_id_result_params result_params;
static void _mcpack2_load_mcp_get_soft_info_by_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_info_by_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_soft_info_by_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_soft_info_by_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_soft_info_by_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_soft_info_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_soft_info_by_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_soft_info_by_id_response*)=0;
if(_mcpack2_load_mcp_get_soft_info_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_soft_info_by_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_soft_info_by_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_soft_info_by_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_android_theme_by_id_params
static void _mcpack2_load_mcp_get_android_theme_by_id_params_id(const mc_pack_item_t*,mcp_get_android_theme_by_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_android_theme_by_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_android_theme_by_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_id_params*)>("id",_mcpack2_load_mcp_get_android_theme_by_id_params_id));
_mcpack2_load_mcp_get_android_theme_by_id_params_readmap.create(16*1);
_mcpack2_load_mcp_get_android_theme_by_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_android_theme_by_id_params_static_inited=_mcpack2_load_mcp_get_android_theme_by_id_params_static_init();
// @@string id=in();
static void _mcpack2_load_mcp_get_android_theme_by_id_params_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_android_theme_by_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_android_theme_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_android_theme_by_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_id_params*)=0;
if(_mcpack2_load_mcp_get_android_theme_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_android_theme_by_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_android_theme_by_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id=in();
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_android_theme_by_id_result_params
static void _mcpack2_load_mcp_get_android_theme_by_id_result_params_result(const mc_pack_item_t*,mcp_get_android_theme_by_id_result_params*);
static void _mcpack2_load_mcp_get_android_theme_by_id_result_params_info(const mc_pack_item_t*,mcp_get_android_theme_by_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_android_theme_by_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_android_theme_by_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_id_result_params*)>("result",_mcpack2_load_mcp_get_android_theme_by_id_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_id_result_params*)>("info",_mcpack2_load_mcp_get_android_theme_by_id_result_params_info));
_mcpack2_load_mcp_get_android_theme_by_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_android_theme_by_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_android_theme_by_id_result_params_static_inited=_mcpack2_load_mcp_get_android_theme_by_id_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_get_android_theme_by_id_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@string info=out(),array(0);
static void _mcpack2_load_mcp_get_android_theme_by_id_result_params_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info)) lp0=&(self->_m_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_android_theme_by_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_android_theme_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_android_theme_by_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_id_result_params*)=0;
if(_mcpack2_load_mcp_get_android_theme_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_android_theme_by_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_android_theme_by_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info)& lr0=(_m_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_android_theme_by_id_response
static void _mcpack2_load_mcp_get_android_theme_by_id_response_result_params(const mc_pack_item_t*,mcp_get_android_theme_by_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_android_theme_by_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_android_theme_by_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_id_response*)>("result_params",_mcpack2_load_mcp_get_android_theme_by_id_response_result_params));
_mcpack2_load_mcp_get_android_theme_by_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_android_theme_by_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_android_theme_by_id_response_static_inited=_mcpack2_load_mcp_get_android_theme_by_id_response_static_init();
// @@mcp_get_android_theme_by_id_result_params result_params;
static void _mcpack2_load_mcp_get_android_theme_by_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_android_theme_by_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_android_theme_by_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_android_theme_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_android_theme_by_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_id_response*)=0;
if(_mcpack2_load_mcp_get_android_theme_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_android_theme_by_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_android_theme_by_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_android_theme_by_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_mcp_stat_params
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_mcp_stat_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_mcp_stat_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_mcp_stat_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_mcp_stat_params*)> >_vec;
_mcpack2_load_mcp_get_mcp_stat_params_readmap.create(16*0);
_mcpack2_load_mcp_get_mcp_stat_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_mcp_stat_params_static_inited=_mcpack2_load_mcp_get_mcp_stat_params_static_init();
void mcp_get_mcp_stat_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_mcp_stat_params*)=0;
do{
if(_mcpack2_load_mcp_get_mcp_stat_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_mcp_stat_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_mcp_stat_params*)=0;
if(_mcpack2_load_mcp_get_mcp_stat_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_mcp_stat_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_mcp_stat_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_mcp_stat_result_params
static void _mcpack2_load_mcp_get_mcp_stat_result_params_stat(const mc_pack_item_t*,mcp_get_mcp_stat_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_mcp_stat_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_mcp_stat_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_mcp_stat_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_mcp_stat_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_mcp_stat_result_params*)>("stat",_mcpack2_load_mcp_get_mcp_stat_result_params_stat));
_mcpack2_load_mcp_get_mcp_stat_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_mcp_stat_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_mcp_stat_result_params_static_inited=_mcpack2_load_mcp_get_mcp_stat_result_params_static_init();
// @@int32_t stat=out(),array(0);
static void _mcpack2_load_mcp_get_mcp_stat_result_params_stat(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_mcp_stat_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "stat";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_stat)) lp0=&(self->_m_stat);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "stat";
}
for(int i0=0;i0<size0;i0++){
res0=mc_pack_get_int32_from_item(&item0,lp0->MutableGetWithoutCheck(i0));
if(res0){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "stat";
}
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "stat";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_mcp_stat_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_mcp_stat_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_mcp_stat_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_mcp_stat_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_mcp_stat_result_params*)=0;
if(_mcpack2_load_mcp_get_mcp_stat_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_mcp_stat_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_mcp_stat_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t stat=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"stat");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_stat)& lr0=(_m_stat);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_int32(pack0,0,lr0.GetWithoutCheck(i0));
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_mcp_stat_response
static void _mcpack2_load_mcp_get_mcp_stat_response_result_params(const mc_pack_item_t*,mcp_get_mcp_stat_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_mcp_stat_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_mcp_stat_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_mcp_stat_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_mcp_stat_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_mcp_stat_response*)>("result_params",_mcpack2_load_mcp_get_mcp_stat_response_result_params));
_mcpack2_load_mcp_get_mcp_stat_response_readmap.create(16*1);
_mcpack2_load_mcp_get_mcp_stat_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_mcp_stat_response_static_inited=_mcpack2_load_mcp_get_mcp_stat_response_static_init();
// @@mcp_get_mcp_stat_result_params result_params;
static void _mcpack2_load_mcp_get_mcp_stat_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_mcp_stat_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_mcp_stat_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_mcp_stat_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_mcp_stat_response*)=0;
do{
if(_mcpack2_load_mcp_get_mcp_stat_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_mcp_stat_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_mcp_stat_response*)=0;
if(_mcpack2_load_mcp_get_mcp_stat_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_mcp_stat_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_mcp_stat_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_mcp_stat_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_col_list_by_topic_params
static void _mcpack2_load_mcp_get_col_list_by_topic_params_topic_id(const mc_pack_item_t*,mcp_get_col_list_by_topic_params*);
static void _mcpack2_load_mcp_get_col_list_by_topic_params_page(const mc_pack_item_t*,mcp_get_col_list_by_topic_params*);
static void _mcpack2_load_mcp_get_col_list_by_topic_params_page_size(const mc_pack_item_t*,mcp_get_col_list_by_topic_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_col_list_by_topic_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_col_list_by_topic_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_params*)>("topic_id",_mcpack2_load_mcp_get_col_list_by_topic_params_topic_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_params*)>("page",_mcpack2_load_mcp_get_col_list_by_topic_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_params*)>("page_size",_mcpack2_load_mcp_get_col_list_by_topic_params_page_size));
_mcpack2_load_mcp_get_col_list_by_topic_params_readmap.create(16*3);
_mcpack2_load_mcp_get_col_list_by_topic_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_col_list_by_topic_params_static_inited=_mcpack2_load_mcp_get_col_list_by_topic_params_static_init();
// @@string topic_id=in();
static void _mcpack2_load_mcp_get_col_list_by_topic_params_topic_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "topic_id";
}
self->_m_topic_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_col_list_by_topic_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_col_list_by_topic_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_col_list_by_topic_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_col_list_by_topic_params*)=0;
do{
if(_mcpack2_load_mcp_get_col_list_by_topic_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_col_list_by_topic_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_col_list_by_topic_params*)=0;
if(_mcpack2_load_mcp_get_col_list_by_topic_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_col_list_by_topic_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_col_list_by_topic_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string topic_id=in();
{
int res=mc_pack_put_str(pack,"topic_id",_m_topic_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_col_list_by_topic_result_params
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_count(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*);
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_topic_name(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*);
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_topic_img(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*);
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_topic_intro(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*);
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_log_date(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*);
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_before_topic(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*);
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_before_name(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*);
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_next_topic(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*);
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_next_name(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*);
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_col_id_list(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_col_list_by_topic_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_col_list_by_topic_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*)>("count",_mcpack2_load_mcp_get_col_list_by_topic_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*)>("topic_name",_mcpack2_load_mcp_get_col_list_by_topic_result_params_topic_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*)>("topic_img",_mcpack2_load_mcp_get_col_list_by_topic_result_params_topic_img));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*)>("topic_intro",_mcpack2_load_mcp_get_col_list_by_topic_result_params_topic_intro));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*)>("log_date",_mcpack2_load_mcp_get_col_list_by_topic_result_params_log_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*)>("before_topic",_mcpack2_load_mcp_get_col_list_by_topic_result_params_before_topic));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*)>("before_name",_mcpack2_load_mcp_get_col_list_by_topic_result_params_before_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*)>("next_topic",_mcpack2_load_mcp_get_col_list_by_topic_result_params_next_topic));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*)>("next_name",_mcpack2_load_mcp_get_col_list_by_topic_result_params_next_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*)>("col_id_list",_mcpack2_load_mcp_get_col_list_by_topic_result_params_col_id_list));
_mcpack2_load_mcp_get_col_list_by_topic_result_params_readmap.create(16*10);
_mcpack2_load_mcp_get_col_list_by_topic_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_col_list_by_topic_result_params_static_inited=_mcpack2_load_mcp_get_col_list_by_topic_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string topic_name=out();
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_topic_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "topic_name";
}
self->_m_topic_name.set_ptr(item->value,item->value_size-1);
}
// @@string topic_img=out();
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_topic_img(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "topic_img";
}
self->_m_topic_img.set_ptr(item->value,item->value_size-1);
}
// @@string topic_intro=out();
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_topic_intro(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_result_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "topic_intro";
}
self->_m_topic_intro.set_ptr(item->value,item->value_size-1);
}
// @@string log_date=out();
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_log_date(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_result_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "log_date";
}
self->_m_log_date.set_ptr(item->value,item->value_size-1);
}
// @@string before_topic=out();
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_before_topic(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_result_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "before_topic";
}
self->_m_before_topic.set_ptr(item->value,item->value_size-1);
}
// @@string before_name=out();
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_before_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_result_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "before_name";
}
self->_m_before_name.set_ptr(item->value,item->value_size-1);
}
// @@string next_topic=out();
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_next_topic(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_result_params* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "next_topic";
}
self->_m_next_topic.set_ptr(item->value,item->value_size-1);
}
// @@string next_name=out();
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_next_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_result_params* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "next_name";
}
self->_m_next_name.set_ptr(item->value,item->value_size-1);
}
// @@string col_id_list=out(),array(0);
static void _mcpack2_load_mcp_get_col_list_by_topic_result_params_col_id_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_result_params* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "col_id_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_col_id_list)) lp0=&(self->_m_col_id_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "col_id_list";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_id_list";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "col_id_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_col_list_by_topic_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_col_list_by_topic_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_col_list_by_topic_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_col_list_by_topic_result_params*)=0;
if(_mcpack2_load_mcp_get_col_list_by_topic_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_col_list_by_topic_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_col_list_by_topic_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string topic_name=out();
{
int res=mc_pack_put_str(pack,"topic_name",_m_topic_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string topic_img=out();
{
int res=mc_pack_put_str(pack,"topic_img",_m_topic_img.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string topic_intro=out();
{
int res=mc_pack_put_str(pack,"topic_intro",_m_topic_intro.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string log_date=out();
{
int res=mc_pack_put_str(pack,"log_date",_m_log_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string before_topic=out();
{
int res=mc_pack_put_str(pack,"before_topic",_m_before_topic.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string before_name=out();
{
int res=mc_pack_put_str(pack,"before_name",_m_before_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string next_topic=out();
{
int res=mc_pack_put_str(pack,"next_topic",_m_next_topic.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string next_name=out();
{
int res=mc_pack_put_str(pack,"next_name",_m_next_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string col_id_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"col_id_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_col_id_list)& lr0=(_m_col_id_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_col_list_by_topic_response
static void _mcpack2_load_mcp_get_col_list_by_topic_response_result_params(const mc_pack_item_t*,mcp_get_col_list_by_topic_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_col_list_by_topic_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_col_list_by_topic_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_col_list_by_topic_response*)>("result_params",_mcpack2_load_mcp_get_col_list_by_topic_response_result_params));
_mcpack2_load_mcp_get_col_list_by_topic_response_readmap.create(16*1);
_mcpack2_load_mcp_get_col_list_by_topic_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_col_list_by_topic_response_static_inited=_mcpack2_load_mcp_get_col_list_by_topic_response_static_init();
// @@mcp_get_col_list_by_topic_result_params result_params;
static void _mcpack2_load_mcp_get_col_list_by_topic_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_col_list_by_topic_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_col_list_by_topic_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_col_list_by_topic_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_col_list_by_topic_response*)=0;
do{
if(_mcpack2_load_mcp_get_col_list_by_topic_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_col_list_by_topic_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_col_list_by_topic_response*)=0;
if(_mcpack2_load_mcp_get_col_list_by_topic_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_col_list_by_topic_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_col_list_by_topic_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_col_list_by_topic_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_soft_list_by_col_id_params
static void _mcpack2_load_mcp_get_soft_list_by_col_id_params_col_id(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_params*);
static void _mcpack2_load_mcp_get_soft_list_by_col_id_params_type_id(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_params*);
static void _mcpack2_load_mcp_get_soft_list_by_col_id_params_page(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_params*);
static void _mcpack2_load_mcp_get_soft_list_by_col_id_params_page_size(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_soft_list_by_col_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_soft_list_by_col_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_params*)>("col_id",_mcpack2_load_mcp_get_soft_list_by_col_id_params_col_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_params*)>("type_id",_mcpack2_load_mcp_get_soft_list_by_col_id_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_params*)>("page",_mcpack2_load_mcp_get_soft_list_by_col_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_params*)>("page_size",_mcpack2_load_mcp_get_soft_list_by_col_id_params_page_size));
_mcpack2_load_mcp_get_soft_list_by_col_id_params_readmap.create(16*4);
_mcpack2_load_mcp_get_soft_list_by_col_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_soft_list_by_col_id_params_static_inited=_mcpack2_load_mcp_get_soft_list_by_col_id_params_static_init();
// @@string col_id=in();
static void _mcpack2_load_mcp_get_soft_list_by_col_id_params_col_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_col_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_id";
}
self->_m_col_id.set_ptr(item->value,item->value_size-1);
}
// @@string type_id=in();
static void _mcpack2_load_mcp_get_soft_list_by_col_id_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_col_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_soft_list_by_col_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_col_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_soft_list_by_col_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_col_id_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_soft_list_by_col_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_soft_list_by_col_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_soft_list_by_col_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_params*)=0;
if(_mcpack2_load_mcp_get_soft_list_by_col_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_soft_list_by_col_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_soft_list_by_col_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string col_id=in();
{
int res=mc_pack_put_str(pack,"col_id",_m_col_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_soft_list_by_col_id_result_params
static void _mcpack2_load_mcp_get_soft_list_by_col_id_result_params_count(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_result_params*);
static void _mcpack2_load_mcp_get_soft_list_by_col_id_result_params_col_name(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_result_params*);
static void _mcpack2_load_mcp_get_soft_list_by_col_id_result_params_soft_list(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_soft_list_by_col_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_soft_list_by_col_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_result_params*)>("count",_mcpack2_load_mcp_get_soft_list_by_col_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_result_params*)>("col_name",_mcpack2_load_mcp_get_soft_list_by_col_id_result_params_col_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_result_params*)>("soft_list",_mcpack2_load_mcp_get_soft_list_by_col_id_result_params_soft_list));
_mcpack2_load_mcp_get_soft_list_by_col_id_result_params_readmap.create(16*3);
_mcpack2_load_mcp_get_soft_list_by_col_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_soft_list_by_col_id_result_params_static_inited=_mcpack2_load_mcp_get_soft_list_by_col_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_soft_list_by_col_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_col_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string col_name=out();
static void _mcpack2_load_mcp_get_soft_list_by_col_id_result_params_col_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_col_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_name";
}
self->_m_col_name.set_ptr(item->value,item->value_size-1);
}
// @@string soft_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_soft_list_by_col_id_result_params_soft_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_col_id_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_soft_list)) lp0=&(self->_m_soft_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "soft_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_soft_list_by_col_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_soft_list_by_col_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_soft_list_by_col_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_result_params*)=0;
if(_mcpack2_load_mcp_get_soft_list_by_col_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_soft_list_by_col_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_soft_list_by_col_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string col_name=out();
{
int res=mc_pack_put_str(pack,"col_name",_m_col_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string soft_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"soft_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_soft_list)& lr0=(_m_soft_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_soft_list_by_col_id_response
static void _mcpack2_load_mcp_get_soft_list_by_col_id_response_result_params(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_soft_list_by_col_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_soft_list_by_col_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_response*)>("result_params",_mcpack2_load_mcp_get_soft_list_by_col_id_response_result_params));
_mcpack2_load_mcp_get_soft_list_by_col_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_soft_list_by_col_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_soft_list_by_col_id_response_static_inited=_mcpack2_load_mcp_get_soft_list_by_col_id_response_static_init();
// @@mcp_get_soft_list_by_col_id_result_params result_params;
static void _mcpack2_load_mcp_get_soft_list_by_col_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_col_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_soft_list_by_col_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_soft_list_by_col_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_soft_list_by_col_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_soft_list_by_col_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_soft_list_by_col_id_response*)=0;
if(_mcpack2_load_mcp_get_soft_list_by_col_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_soft_list_by_col_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_soft_list_by_col_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_soft_list_by_col_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_soft_list_by_class_id_params
static void _mcpack2_load_mcp_get_soft_list_by_class_id_params_class_id(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*);
static void _mcpack2_load_mcp_get_soft_list_by_class_id_params_type_id(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*);
static void _mcpack2_load_mcp_get_soft_list_by_class_id_params_orderby(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*);
static void _mcpack2_load_mcp_get_soft_list_by_class_id_params_page(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*);
static void _mcpack2_load_mcp_get_soft_list_by_class_id_params_page_size(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_soft_list_by_class_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_soft_list_by_class_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*)>("class_id",_mcpack2_load_mcp_get_soft_list_by_class_id_params_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*)>("type_id",_mcpack2_load_mcp_get_soft_list_by_class_id_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*)>("orderby",_mcpack2_load_mcp_get_soft_list_by_class_id_params_orderby));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*)>("page",_mcpack2_load_mcp_get_soft_list_by_class_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*)>("page_size",_mcpack2_load_mcp_get_soft_list_by_class_id_params_page_size));
_mcpack2_load_mcp_get_soft_list_by_class_id_params_readmap.create(16*5);
_mcpack2_load_mcp_get_soft_list_by_class_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_soft_list_by_class_id_params_static_inited=_mcpack2_load_mcp_get_soft_list_by_class_id_params_static_init();
// @@string class_id=in();
static void _mcpack2_load_mcp_get_soft_list_by_class_id_params_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_class_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
// @@string type_id=in();
static void _mcpack2_load_mcp_get_soft_list_by_class_id_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_class_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t orderby=in();
static void _mcpack2_load_mcp_get_soft_list_by_class_id_params_orderby(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_class_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_orderby));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "orderby";
}
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_soft_list_by_class_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_class_id_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_soft_list_by_class_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_class_id_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_soft_list_by_class_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_soft_list_by_class_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_soft_list_by_class_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_params*)=0;
if(_mcpack2_load_mcp_get_soft_list_by_class_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_soft_list_by_class_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_soft_list_by_class_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string class_id=in();
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t orderby=in();
{
int res=mc_pack_put_uint32(pack,"orderby",_m_orderby);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_soft_list_by_class_id_result_params
static void _mcpack2_load_mcp_get_soft_list_by_class_id_result_params_count(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_result_params*);
static void _mcpack2_load_mcp_get_soft_list_by_class_id_result_params_class_name(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_result_params*);
static void _mcpack2_load_mcp_get_soft_list_by_class_id_result_params_class_icon(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_result_params*);
static void _mcpack2_load_mcp_get_soft_list_by_class_id_result_params_soft_list(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_soft_list_by_class_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_soft_list_by_class_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_result_params*)>("count",_mcpack2_load_mcp_get_soft_list_by_class_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_result_params*)>("class_name",_mcpack2_load_mcp_get_soft_list_by_class_id_result_params_class_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_result_params*)>("class_icon",_mcpack2_load_mcp_get_soft_list_by_class_id_result_params_class_icon));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_result_params*)>("soft_list",_mcpack2_load_mcp_get_soft_list_by_class_id_result_params_soft_list));
_mcpack2_load_mcp_get_soft_list_by_class_id_result_params_readmap.create(16*4);
_mcpack2_load_mcp_get_soft_list_by_class_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_soft_list_by_class_id_result_params_static_inited=_mcpack2_load_mcp_get_soft_list_by_class_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_soft_list_by_class_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_class_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string class_name=out();
static void _mcpack2_load_mcp_get_soft_list_by_class_id_result_params_class_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_class_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_name";
}
self->_m_class_name.set_ptr(item->value,item->value_size-1);
}
// @@string class_icon=out();
static void _mcpack2_load_mcp_get_soft_list_by_class_id_result_params_class_icon(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_class_id_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_icon";
}
self->_m_class_icon.set_ptr(item->value,item->value_size-1);
}
// @@string soft_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_soft_list_by_class_id_result_params_soft_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_class_id_result_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_soft_list)) lp0=&(self->_m_soft_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "soft_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_soft_list_by_class_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_soft_list_by_class_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_soft_list_by_class_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_result_params*)=0;
if(_mcpack2_load_mcp_get_soft_list_by_class_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_soft_list_by_class_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_soft_list_by_class_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string class_name=out();
{
int res=mc_pack_put_str(pack,"class_name",_m_class_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string class_icon=out();
{
int res=mc_pack_put_str(pack,"class_icon",_m_class_icon.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string soft_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"soft_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_soft_list)& lr0=(_m_soft_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_soft_list_by_class_id_response
static void _mcpack2_load_mcp_get_soft_list_by_class_id_response_result_params(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_soft_list_by_class_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_soft_list_by_class_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_response*)>("result_params",_mcpack2_load_mcp_get_soft_list_by_class_id_response_result_params));
_mcpack2_load_mcp_get_soft_list_by_class_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_soft_list_by_class_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_soft_list_by_class_id_response_static_inited=_mcpack2_load_mcp_get_soft_list_by_class_id_response_static_init();
// @@mcp_get_soft_list_by_class_id_result_params result_params;
static void _mcpack2_load_mcp_get_soft_list_by_class_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_list_by_class_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_soft_list_by_class_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_soft_list_by_class_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_soft_list_by_class_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_soft_list_by_class_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_soft_list_by_class_id_response*)=0;
if(_mcpack2_load_mcp_get_soft_list_by_class_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_soft_list_by_class_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_soft_list_by_class_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_soft_list_by_class_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_android_theme_by_col_id_params
static void _mcpack2_load_mcp_get_android_theme_by_col_id_params_col_id(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_params*);
static void _mcpack2_load_mcp_get_android_theme_by_col_id_params_type_id(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_params*);
static void _mcpack2_load_mcp_get_android_theme_by_col_id_params_page(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_params*);
static void _mcpack2_load_mcp_get_android_theme_by_col_id_params_page_size(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_android_theme_by_col_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_android_theme_by_col_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_params*)>("col_id",_mcpack2_load_mcp_get_android_theme_by_col_id_params_col_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_params*)>("type_id",_mcpack2_load_mcp_get_android_theme_by_col_id_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_params*)>("page",_mcpack2_load_mcp_get_android_theme_by_col_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_params*)>("page_size",_mcpack2_load_mcp_get_android_theme_by_col_id_params_page_size));
_mcpack2_load_mcp_get_android_theme_by_col_id_params_readmap.create(16*4);
_mcpack2_load_mcp_get_android_theme_by_col_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_android_theme_by_col_id_params_static_inited=_mcpack2_load_mcp_get_android_theme_by_col_id_params_static_init();
// @@string col_id=in();
static void _mcpack2_load_mcp_get_android_theme_by_col_id_params_col_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_col_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_id";
}
self->_m_col_id.set_ptr(item->value,item->value_size-1);
}
// @@string type_id=in();
static void _mcpack2_load_mcp_get_android_theme_by_col_id_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_col_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_android_theme_by_col_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_col_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_android_theme_by_col_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_col_id_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_android_theme_by_col_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_android_theme_by_col_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_android_theme_by_col_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_params*)=0;
if(_mcpack2_load_mcp_get_android_theme_by_col_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_android_theme_by_col_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_android_theme_by_col_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string col_id=in();
{
int res=mc_pack_put_str(pack,"col_id",_m_col_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_android_theme_by_col_id_result_params
static void _mcpack2_load_mcp_get_android_theme_by_col_id_result_params_count(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_result_params*);
static void _mcpack2_load_mcp_get_android_theme_by_col_id_result_params_col_name(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_result_params*);
static void _mcpack2_load_mcp_get_android_theme_by_col_id_result_params_theme_list(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_android_theme_by_col_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_android_theme_by_col_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_result_params*)>("count",_mcpack2_load_mcp_get_android_theme_by_col_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_result_params*)>("col_name",_mcpack2_load_mcp_get_android_theme_by_col_id_result_params_col_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_result_params*)>("theme_list",_mcpack2_load_mcp_get_android_theme_by_col_id_result_params_theme_list));
_mcpack2_load_mcp_get_android_theme_by_col_id_result_params_readmap.create(16*3);
_mcpack2_load_mcp_get_android_theme_by_col_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_android_theme_by_col_id_result_params_static_inited=_mcpack2_load_mcp_get_android_theme_by_col_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_android_theme_by_col_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_col_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string col_name=out();
static void _mcpack2_load_mcp_get_android_theme_by_col_id_result_params_col_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_col_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_name";
}
self->_m_col_name.set_ptr(item->value,item->value_size-1);
}
// @@string theme_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_android_theme_by_col_id_result_params_theme_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_col_id_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_theme_list)) lp0=&(self->_m_theme_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "theme_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_android_theme_by_col_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_android_theme_by_col_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_android_theme_by_col_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_result_params*)=0;
if(_mcpack2_load_mcp_get_android_theme_by_col_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_android_theme_by_col_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_android_theme_by_col_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string col_name=out();
{
int res=mc_pack_put_str(pack,"col_name",_m_col_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string theme_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"theme_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_theme_list)& lr0=(_m_theme_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_android_theme_by_col_id_response
static void _mcpack2_load_mcp_get_android_theme_by_col_id_response_result_params(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_android_theme_by_col_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_android_theme_by_col_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_response*)>("result_params",_mcpack2_load_mcp_get_android_theme_by_col_id_response_result_params));
_mcpack2_load_mcp_get_android_theme_by_col_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_android_theme_by_col_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_android_theme_by_col_id_response_static_inited=_mcpack2_load_mcp_get_android_theme_by_col_id_response_static_init();
// @@mcp_get_android_theme_by_col_id_result_params result_params;
static void _mcpack2_load_mcp_get_android_theme_by_col_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_col_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_android_theme_by_col_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_android_theme_by_col_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_android_theme_by_col_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_android_theme_by_col_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_col_id_response*)=0;
if(_mcpack2_load_mcp_get_android_theme_by_col_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_android_theme_by_col_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_android_theme_by_col_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_android_theme_by_col_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_android_theme_by_class_id_params
static void _mcpack2_load_mcp_get_android_theme_by_class_id_params_class_id(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*);
static void _mcpack2_load_mcp_get_android_theme_by_class_id_params_type_id(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*);
static void _mcpack2_load_mcp_get_android_theme_by_class_id_params_orderby(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*);
static void _mcpack2_load_mcp_get_android_theme_by_class_id_params_page(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*);
static void _mcpack2_load_mcp_get_android_theme_by_class_id_params_page_size(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_android_theme_by_class_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_android_theme_by_class_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*)>("class_id",_mcpack2_load_mcp_get_android_theme_by_class_id_params_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*)>("type_id",_mcpack2_load_mcp_get_android_theme_by_class_id_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*)>("orderby",_mcpack2_load_mcp_get_android_theme_by_class_id_params_orderby));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*)>("page",_mcpack2_load_mcp_get_android_theme_by_class_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*)>("page_size",_mcpack2_load_mcp_get_android_theme_by_class_id_params_page_size));
_mcpack2_load_mcp_get_android_theme_by_class_id_params_readmap.create(16*5);
_mcpack2_load_mcp_get_android_theme_by_class_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_android_theme_by_class_id_params_static_inited=_mcpack2_load_mcp_get_android_theme_by_class_id_params_static_init();
// @@string class_id=in();
static void _mcpack2_load_mcp_get_android_theme_by_class_id_params_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_class_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
// @@string type_id=in();
static void _mcpack2_load_mcp_get_android_theme_by_class_id_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_class_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t orderby=in();
static void _mcpack2_load_mcp_get_android_theme_by_class_id_params_orderby(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_class_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_orderby));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "orderby";
}
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_android_theme_by_class_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_class_id_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_android_theme_by_class_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_class_id_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_android_theme_by_class_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_android_theme_by_class_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_android_theme_by_class_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_params*)=0;
if(_mcpack2_load_mcp_get_android_theme_by_class_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_android_theme_by_class_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_android_theme_by_class_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string class_id=in();
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t orderby=in();
{
int res=mc_pack_put_uint32(pack,"orderby",_m_orderby);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_android_theme_by_class_id_result_params
static void _mcpack2_load_mcp_get_android_theme_by_class_id_result_params_count(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_result_params*);
static void _mcpack2_load_mcp_get_android_theme_by_class_id_result_params_class_name(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_result_params*);
static void _mcpack2_load_mcp_get_android_theme_by_class_id_result_params_class_icon(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_result_params*);
static void _mcpack2_load_mcp_get_android_theme_by_class_id_result_params_theme_list(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_android_theme_by_class_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_android_theme_by_class_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_result_params*)>("count",_mcpack2_load_mcp_get_android_theme_by_class_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_result_params*)>("class_name",_mcpack2_load_mcp_get_android_theme_by_class_id_result_params_class_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_result_params*)>("class_icon",_mcpack2_load_mcp_get_android_theme_by_class_id_result_params_class_icon));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_result_params*)>("theme_list",_mcpack2_load_mcp_get_android_theme_by_class_id_result_params_theme_list));
_mcpack2_load_mcp_get_android_theme_by_class_id_result_params_readmap.create(16*4);
_mcpack2_load_mcp_get_android_theme_by_class_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_android_theme_by_class_id_result_params_static_inited=_mcpack2_load_mcp_get_android_theme_by_class_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_android_theme_by_class_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_class_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string class_name=out();
static void _mcpack2_load_mcp_get_android_theme_by_class_id_result_params_class_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_class_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_name";
}
self->_m_class_name.set_ptr(item->value,item->value_size-1);
}
// @@string class_icon=out();
static void _mcpack2_load_mcp_get_android_theme_by_class_id_result_params_class_icon(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_class_id_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_icon";
}
self->_m_class_icon.set_ptr(item->value,item->value_size-1);
}
// @@string theme_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_android_theme_by_class_id_result_params_theme_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_class_id_result_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_theme_list)) lp0=&(self->_m_theme_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "theme_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_android_theme_by_class_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_android_theme_by_class_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_android_theme_by_class_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_result_params*)=0;
if(_mcpack2_load_mcp_get_android_theme_by_class_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_android_theme_by_class_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_android_theme_by_class_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string class_name=out();
{
int res=mc_pack_put_str(pack,"class_name",_m_class_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string class_icon=out();
{
int res=mc_pack_put_str(pack,"class_icon",_m_class_icon.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string theme_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"theme_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_theme_list)& lr0=(_m_theme_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_android_theme_by_class_id_response
static void _mcpack2_load_mcp_get_android_theme_by_class_id_response_result_params(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_android_theme_by_class_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_android_theme_by_class_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_response*)>("result_params",_mcpack2_load_mcp_get_android_theme_by_class_id_response_result_params));
_mcpack2_load_mcp_get_android_theme_by_class_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_android_theme_by_class_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_android_theme_by_class_id_response_static_inited=_mcpack2_load_mcp_get_android_theme_by_class_id_response_static_init();
// @@mcp_get_android_theme_by_class_id_result_params result_params;
static void _mcpack2_load_mcp_get_android_theme_by_class_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_android_theme_by_class_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_android_theme_by_class_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_android_theme_by_class_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_android_theme_by_class_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_android_theme_by_class_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_android_theme_by_class_id_response*)=0;
if(_mcpack2_load_mcp_get_android_theme_by_class_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_android_theme_by_class_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_android_theme_by_class_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_android_theme_by_class_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_topic_list_by_type_params
static void _mcpack2_load_mcp_get_topic_list_by_type_params_type_id(const mc_pack_item_t*,mcp_get_topic_list_by_type_params*);
static void _mcpack2_load_mcp_get_topic_list_by_type_params_page(const mc_pack_item_t*,mcp_get_topic_list_by_type_params*);
static void _mcpack2_load_mcp_get_topic_list_by_type_params_page_size(const mc_pack_item_t*,mcp_get_topic_list_by_type_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_list_by_type_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_topic_list_by_type_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_topic_list_by_type_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_topic_list_by_type_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_list_by_type_params*)>("type_id",_mcpack2_load_mcp_get_topic_list_by_type_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_list_by_type_params*)>("page",_mcpack2_load_mcp_get_topic_list_by_type_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_list_by_type_params*)>("page_size",_mcpack2_load_mcp_get_topic_list_by_type_params_page_size));
_mcpack2_load_mcp_get_topic_list_by_type_params_readmap.create(16*3);
_mcpack2_load_mcp_get_topic_list_by_type_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_topic_list_by_type_params_static_inited=_mcpack2_load_mcp_get_topic_list_by_type_params_static_init();
// @@string type_id=in();
static void _mcpack2_load_mcp_get_topic_list_by_type_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_topic_list_by_type_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_topic_list_by_type_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_topic_list_by_type_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_topic_list_by_type_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_topic_list_by_type_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_topic_list_by_type_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_topic_list_by_type_params*)=0;
do{
if(_mcpack2_load_mcp_get_topic_list_by_type_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_topic_list_by_type_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_topic_list_by_type_params*)=0;
if(_mcpack2_load_mcp_get_topic_list_by_type_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_topic_list_by_type_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_topic_list_by_type_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_topic_list_by_type_result_params
static void _mcpack2_load_mcp_get_topic_list_by_type_result_params_count(const mc_pack_item_t*,mcp_get_topic_list_by_type_result_params*);
static void _mcpack2_load_mcp_get_topic_list_by_type_result_params_topic_list(const mc_pack_item_t*,mcp_get_topic_list_by_type_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_list_by_type_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_topic_list_by_type_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_topic_list_by_type_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_topic_list_by_type_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_list_by_type_result_params*)>("count",_mcpack2_load_mcp_get_topic_list_by_type_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_list_by_type_result_params*)>("topic_list",_mcpack2_load_mcp_get_topic_list_by_type_result_params_topic_list));
_mcpack2_load_mcp_get_topic_list_by_type_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_topic_list_by_type_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_topic_list_by_type_result_params_static_inited=_mcpack2_load_mcp_get_topic_list_by_type_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_topic_list_by_type_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_topic_list_by_type_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string topic_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_topic_list_by_type_result_params_topic_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_topic_list_by_type_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "topic_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_topic_list)) lp0=&(self->_m_topic_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "topic_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "topic_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "topic_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "topic_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "topic_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "topic_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_topic_list_by_type_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_topic_list_by_type_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_topic_list_by_type_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_topic_list_by_type_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_topic_list_by_type_result_params*)=0;
if(_mcpack2_load_mcp_get_topic_list_by_type_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_topic_list_by_type_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_topic_list_by_type_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string topic_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"topic_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_topic_list)& lr0=(_m_topic_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_topic_list_by_type_response
static void _mcpack2_load_mcp_get_topic_list_by_type_response_result_params(const mc_pack_item_t*,mcp_get_topic_list_by_type_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_list_by_type_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_topic_list_by_type_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_topic_list_by_type_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_topic_list_by_type_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_topic_list_by_type_response*)>("result_params",_mcpack2_load_mcp_get_topic_list_by_type_response_result_params));
_mcpack2_load_mcp_get_topic_list_by_type_response_readmap.create(16*1);
_mcpack2_load_mcp_get_topic_list_by_type_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_topic_list_by_type_response_static_inited=_mcpack2_load_mcp_get_topic_list_by_type_response_static_init();
// @@mcp_get_topic_list_by_type_result_params result_params;
static void _mcpack2_load_mcp_get_topic_list_by_type_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_topic_list_by_type_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_topic_list_by_type_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_topic_list_by_type_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_topic_list_by_type_response*)=0;
do{
if(_mcpack2_load_mcp_get_topic_list_by_type_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_topic_list_by_type_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_topic_list_by_type_response*)=0;
if(_mcpack2_load_mcp_get_topic_list_by_type_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_topic_list_by_type_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_topic_list_by_type_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_topic_list_by_type_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_sub_class_by_class_params
static void _mcpack2_load_mcp_get_sub_class_by_class_params_class_id(const mc_pack_item_t*,mcp_get_sub_class_by_class_params*);
static void _mcpack2_load_mcp_get_sub_class_by_class_params_page(const mc_pack_item_t*,mcp_get_sub_class_by_class_params*);
static void _mcpack2_load_mcp_get_sub_class_by_class_params_page_size(const mc_pack_item_t*,mcp_get_sub_class_by_class_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_sub_class_by_class_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_sub_class_by_class_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_sub_class_by_class_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_sub_class_by_class_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_sub_class_by_class_params*)>("class_id",_mcpack2_load_mcp_get_sub_class_by_class_params_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_sub_class_by_class_params*)>("page",_mcpack2_load_mcp_get_sub_class_by_class_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_sub_class_by_class_params*)>("page_size",_mcpack2_load_mcp_get_sub_class_by_class_params_page_size));
_mcpack2_load_mcp_get_sub_class_by_class_params_readmap.create(16*3);
_mcpack2_load_mcp_get_sub_class_by_class_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_sub_class_by_class_params_static_inited=_mcpack2_load_mcp_get_sub_class_by_class_params_static_init();
// @@string class_id=in();
static void _mcpack2_load_mcp_get_sub_class_by_class_params_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_sub_class_by_class_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_sub_class_by_class_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_sub_class_by_class_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_sub_class_by_class_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_sub_class_by_class_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_sub_class_by_class_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_sub_class_by_class_params*)=0;
do{
if(_mcpack2_load_mcp_get_sub_class_by_class_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_sub_class_by_class_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_sub_class_by_class_params*)=0;
if(_mcpack2_load_mcp_get_sub_class_by_class_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_sub_class_by_class_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_sub_class_by_class_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string class_id=in();
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_sub_class_by_class_result_params
static void _mcpack2_load_mcp_get_sub_class_by_class_result_params_cooooooount(const mc_pack_item_t*,mcp_get_sub_class_by_class_result_params*);
static void _mcpack2_load_mcp_get_sub_class_by_class_result_params_sub_list(const mc_pack_item_t*,mcp_get_sub_class_by_class_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_sub_class_by_class_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_sub_class_by_class_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_sub_class_by_class_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_sub_class_by_class_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_sub_class_by_class_result_params*)>("cooooooount",_mcpack2_load_mcp_get_sub_class_by_class_result_params_cooooooount));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_sub_class_by_class_result_params*)>("sub_list",_mcpack2_load_mcp_get_sub_class_by_class_result_params_sub_list));
_mcpack2_load_mcp_get_sub_class_by_class_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_sub_class_by_class_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_sub_class_by_class_result_params_static_inited=_mcpack2_load_mcp_get_sub_class_by_class_result_params_static_init();
// @@int32_t cooooooount=out();
static void _mcpack2_load_mcp_get_sub_class_by_class_result_params_cooooooount(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_sub_class_by_class_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_cooooooount));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "cooooooount";
}
}
// @@sub_class_t sub_list=out(),array(0);
static void _mcpack2_load_mcp_get_sub_class_by_class_result_params_sub_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_sub_class_by_class_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "sub_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_sub_list)) lp0=&(self->_m_sub_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "sub_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "sub_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "sub_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_sub_class_by_class_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_sub_class_by_class_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_sub_class_by_class_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_sub_class_by_class_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_sub_class_by_class_result_params*)=0;
if(_mcpack2_load_mcp_get_sub_class_by_class_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_sub_class_by_class_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_sub_class_by_class_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t cooooooount=out();
{
int res=mc_pack_put_int32(pack,"cooooooount",_m_cooooooount);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@sub_class_t sub_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"sub_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_sub_list)& lr0=(_m_sub_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_sub_class_by_class_response
static void _mcpack2_load_mcp_get_sub_class_by_class_response_result_params(const mc_pack_item_t*,mcp_get_sub_class_by_class_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_sub_class_by_class_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_sub_class_by_class_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_sub_class_by_class_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_sub_class_by_class_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_sub_class_by_class_response*)>("result_params",_mcpack2_load_mcp_get_sub_class_by_class_response_result_params));
_mcpack2_load_mcp_get_sub_class_by_class_response_readmap.create(16*1);
_mcpack2_load_mcp_get_sub_class_by_class_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_sub_class_by_class_response_static_inited=_mcpack2_load_mcp_get_sub_class_by_class_response_static_init();
// @@mcp_get_sub_class_by_class_result_params result_params;
static void _mcpack2_load_mcp_get_sub_class_by_class_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_sub_class_by_class_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_sub_class_by_class_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_sub_class_by_class_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_sub_class_by_class_response*)=0;
do{
if(_mcpack2_load_mcp_get_sub_class_by_class_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_sub_class_by_class_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_sub_class_by_class_response*)=0;
if(_mcpack2_load_mcp_get_sub_class_by_class_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_sub_class_by_class_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_sub_class_by_class_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_sub_class_by_class_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_mcp_content_common_init_params
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_mcp_content_common_init_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_mcp_content_common_init_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_mcp_content_common_init_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_mcp_content_common_init_params*)> >_vec;
_mcpack2_load_mcp_mcp_content_common_init_params_readmap.create(16*0);
_mcpack2_load_mcp_mcp_content_common_init_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_mcp_content_common_init_params_static_inited=_mcpack2_load_mcp_mcp_content_common_init_params_static_init();
void mcp_mcp_content_common_init_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_mcp_content_common_init_params*)=0;
do{
if(_mcpack2_load_mcp_mcp_content_common_init_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_mcp_content_common_init_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_mcp_content_common_init_params*)=0;
if(_mcpack2_load_mcp_mcp_content_common_init_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_mcp_content_common_init_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_mcp_content_common_init_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_mcp_content_common_init_result_params
static void _mcpack2_load_mcp_mcp_content_common_init_result_params_result(const mc_pack_item_t*,mcp_mcp_content_common_init_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_mcp_content_common_init_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_mcp_content_common_init_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_mcp_content_common_init_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_mcp_content_common_init_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_mcp_content_common_init_result_params*)>("result",_mcpack2_load_mcp_mcp_content_common_init_result_params_result));
_mcpack2_load_mcp_mcp_content_common_init_result_params_readmap.create(16*1);
_mcpack2_load_mcp_mcp_content_common_init_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_mcp_content_common_init_result_params_static_inited=_mcpack2_load_mcp_mcp_content_common_init_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_mcp_content_common_init_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_mcp_content_common_init_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
void mcp_mcp_content_common_init_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_mcp_content_common_init_result_params*)=0;
do{
if(_mcpack2_load_mcp_mcp_content_common_init_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_mcp_content_common_init_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_mcp_content_common_init_result_params*)=0;
if(_mcpack2_load_mcp_mcp_content_common_init_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_mcp_content_common_init_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_mcp_content_common_init_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_mcp_content_common_init_response
static void _mcpack2_load_mcp_mcp_content_common_init_response_result_params(const mc_pack_item_t*,mcp_mcp_content_common_init_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_mcp_content_common_init_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_mcp_content_common_init_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_mcp_content_common_init_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_mcp_content_common_init_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_mcp_content_common_init_response*)>("result_params",_mcpack2_load_mcp_mcp_content_common_init_response_result_params));
_mcpack2_load_mcp_mcp_content_common_init_response_readmap.create(16*1);
_mcpack2_load_mcp_mcp_content_common_init_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_mcp_content_common_init_response_static_inited=_mcpack2_load_mcp_mcp_content_common_init_response_static_init();
// @@mcp_mcp_content_common_init_result_params result_params;
static void _mcpack2_load_mcp_mcp_content_common_init_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_mcp_content_common_init_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_mcp_content_common_init_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_mcp_content_common_init_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_mcp_content_common_init_response*)=0;
do{
if(_mcpack2_load_mcp_mcp_content_common_init_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_mcp_content_common_init_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_mcp_content_common_init_response*)=0;
if(_mcpack2_load_mcp_mcp_content_common_init_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_mcp_content_common_init_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_mcp_content_common_init_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_mcp_content_common_init_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_area_by_phone_num_params
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_params_phone_num(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_area_by_phone_num_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_area_by_phone_num_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_params*)>("phone_num",_mcpack2_load_mcp_get_phone_area_by_phone_num_params_phone_num));
_mcpack2_load_mcp_get_phone_area_by_phone_num_params_readmap.create(16*1);
_mcpack2_load_mcp_get_phone_area_by_phone_num_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_area_by_phone_num_params_static_inited=_mcpack2_load_mcp_get_phone_area_by_phone_num_params_static_init();
// @@string phone_num=in();
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_params_phone_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_area_by_phone_num_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone_num";
}
self->_m_phone_num.set_ptr(item->value,item->value_size-1);
}
void mcp_get_phone_area_by_phone_num_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_area_by_phone_num_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_area_by_phone_num_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_params*)=0;
if(_mcpack2_load_mcp_get_phone_area_by_phone_num_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_area_by_phone_num_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_area_by_phone_num_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string phone_num=in();
{
int res=mc_pack_put_str(pack,"phone_num",_m_phone_num.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_area_by_phone_num_result_params
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_numseg(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*);
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_result(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*);
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_type(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*);
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_oid(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*);
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_provice(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*);
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_city(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*);
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_code(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*);
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_enabled(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*)>("numseg",_mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_numseg));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*)>("result",_mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*)>("type",_mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*)>("oid",_mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_oid));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*)>("provice",_mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_provice));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*)>("city",_mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_city));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*)>("code",_mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_code));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*)>("enabled",_mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_enabled));
_mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_readmap.create(16*8);
_mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_static_inited=_mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_static_init();
// @@string numseg=out();
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_numseg(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_area_by_phone_num_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "numseg";
}
self->_m_numseg.set_ptr(item->value,item->value_size-1);
}
// @@string result=out();
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_area_by_phone_num_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
self->_m_result.set_ptr(item->value,item->value_size-1);
}
// @@string type=out();
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_area_by_phone_num_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type";
}
self->_m_type.set_ptr(item->value,item->value_size-1);
}
// @@string oid=out();
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_oid(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_area_by_phone_num_result_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "oid";
}
self->_m_oid.set_ptr(item->value,item->value_size-1);
}
// @@string provice=out();
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_provice(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_area_by_phone_num_result_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "provice";
}
self->_m_provice.set_ptr(item->value,item->value_size-1);
}
// @@string city=out();
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_city(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_area_by_phone_num_result_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "city";
}
self->_m_city.set_ptr(item->value,item->value_size-1);
}
// @@string code=out();
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_code(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_area_by_phone_num_result_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "code";
}
self->_m_code.set_ptr(item->value,item->value_size-1);
}
// @@string enabled=out();
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_enabled(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_area_by_phone_num_result_params* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "enabled";
}
self->_m_enabled.set_ptr(item->value,item->value_size-1);
}
void mcp_get_phone_area_by_phone_num_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_area_by_phone_num_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_result_params*)=0;
if(_mcpack2_load_mcp_get_phone_area_by_phone_num_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_area_by_phone_num_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_area_by_phone_num_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string numseg=out();
{
int res=mc_pack_put_str(pack,"numseg",_m_numseg.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string result=out();
{
int res=mc_pack_put_str(pack,"result",_m_result.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type=out();
{
int res=mc_pack_put_str(pack,"type",_m_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string oid=out();
{
int res=mc_pack_put_str(pack,"oid",_m_oid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string provice=out();
{
int res=mc_pack_put_str(pack,"provice",_m_provice.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string city=out();
{
int res=mc_pack_put_str(pack,"city",_m_city.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string code=out();
{
int res=mc_pack_put_str(pack,"code",_m_code.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string enabled=out();
{
int res=mc_pack_put_str(pack,"enabled",_m_enabled.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_phone_area_by_phone_num_response
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_response_result_params(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_phone_area_by_phone_num_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_phone_area_by_phone_num_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_response*)>("result_params",_mcpack2_load_mcp_get_phone_area_by_phone_num_response_result_params));
_mcpack2_load_mcp_get_phone_area_by_phone_num_response_readmap.create(16*1);
_mcpack2_load_mcp_get_phone_area_by_phone_num_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_phone_area_by_phone_num_response_static_inited=_mcpack2_load_mcp_get_phone_area_by_phone_num_response_static_init();
// @@mcp_get_phone_area_by_phone_num_result_params result_params;
static void _mcpack2_load_mcp_get_phone_area_by_phone_num_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_phone_area_by_phone_num_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_phone_area_by_phone_num_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_phone_area_by_phone_num_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_response*)=0;
do{
if(_mcpack2_load_mcp_get_phone_area_by_phone_num_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_phone_area_by_phone_num_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_phone_area_by_phone_num_response*)=0;
if(_mcpack2_load_mcp_get_phone_area_by_phone_num_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_phone_area_by_phone_num_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_phone_area_by_phone_num_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_phone_area_by_phone_num_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_reload_config_by_id_params
static void _mcpack2_load_mcp_reload_config_by_id_params_reload_id(const mc_pack_item_t*,mcp_reload_config_by_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_reload_config_by_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_reload_config_by_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_reload_config_by_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_reload_config_by_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_reload_config_by_id_params*)>("reload_id",_mcpack2_load_mcp_reload_config_by_id_params_reload_id));
_mcpack2_load_mcp_reload_config_by_id_params_readmap.create(16*1);
_mcpack2_load_mcp_reload_config_by_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_reload_config_by_id_params_static_inited=_mcpack2_load_mcp_reload_config_by_id_params_static_init();
// @@uint32_t reload_id=in();
static void _mcpack2_load_mcp_reload_config_by_id_params_reload_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_reload_config_by_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_reload_id));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "reload_id";
}
}
void mcp_reload_config_by_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_reload_config_by_id_params*)=0;
do{
if(_mcpack2_load_mcp_reload_config_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_reload_config_by_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_reload_config_by_id_params*)=0;
if(_mcpack2_load_mcp_reload_config_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_reload_config_by_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_reload_config_by_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t reload_id=in();
{
int res=mc_pack_put_uint32(pack,"reload_id",_m_reload_id);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_reload_config_by_id_result_params
static void _mcpack2_load_mcp_reload_config_by_id_result_params_result(const mc_pack_item_t*,mcp_reload_config_by_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_reload_config_by_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_reload_config_by_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_reload_config_by_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_reload_config_by_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_reload_config_by_id_result_params*)>("result",_mcpack2_load_mcp_reload_config_by_id_result_params_result));
_mcpack2_load_mcp_reload_config_by_id_result_params_readmap.create(16*1);
_mcpack2_load_mcp_reload_config_by_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_reload_config_by_id_result_params_static_inited=_mcpack2_load_mcp_reload_config_by_id_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_reload_config_by_id_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_reload_config_by_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
void mcp_reload_config_by_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_reload_config_by_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_reload_config_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_reload_config_by_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_reload_config_by_id_result_params*)=0;
if(_mcpack2_load_mcp_reload_config_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_reload_config_by_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_reload_config_by_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_reload_config_by_id_response
static void _mcpack2_load_mcp_reload_config_by_id_response_result_params(const mc_pack_item_t*,mcp_reload_config_by_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_reload_config_by_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_reload_config_by_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_reload_config_by_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_reload_config_by_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_reload_config_by_id_response*)>("result_params",_mcpack2_load_mcp_reload_config_by_id_response_result_params));
_mcpack2_load_mcp_reload_config_by_id_response_readmap.create(16*1);
_mcpack2_load_mcp_reload_config_by_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_reload_config_by_id_response_static_inited=_mcpack2_load_mcp_reload_config_by_id_response_static_init();
// @@mcp_reload_config_by_id_result_params result_params;
static void _mcpack2_load_mcp_reload_config_by_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_reload_config_by_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_reload_config_by_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_reload_config_by_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_reload_config_by_id_response*)=0;
do{
if(_mcpack2_load_mcp_reload_config_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_reload_config_by_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_reload_config_by_id_response*)=0;
if(_mcpack2_load_mcp_reload_config_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_reload_config_by_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_reload_config_by_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_reload_config_by_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_id_params
static void _mcpack2_load_mcp_get_ios_content_by_id_params_id(const mc_pack_item_t*,mcp_get_ios_content_by_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_id_params*)>("id",_mcpack2_load_mcp_get_ios_content_by_id_params_id));
_mcpack2_load_mcp_get_ios_content_by_id_params_readmap.create(16*1);
_mcpack2_load_mcp_get_ios_content_by_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_id_params_static_inited=_mcpack2_load_mcp_get_ios_content_by_id_params_static_init();
// @@string id=in();
static void _mcpack2_load_mcp_get_ios_content_by_id_params_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_ios_content_by_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_id_params*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id=in();
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_id_result_params
static void _mcpack2_load_mcp_get_ios_content_by_id_result_params_result(const mc_pack_item_t*,mcp_get_ios_content_by_id_result_params*);
static void _mcpack2_load_mcp_get_ios_content_by_id_result_params_info(const mc_pack_item_t*,mcp_get_ios_content_by_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_id_result_params*)>("result",_mcpack2_load_mcp_get_ios_content_by_id_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_id_result_params*)>("info",_mcpack2_load_mcp_get_ios_content_by_id_result_params_info));
_mcpack2_load_mcp_get_ios_content_by_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_ios_content_by_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_id_result_params_static_inited=_mcpack2_load_mcp_get_ios_content_by_id_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_get_ios_content_by_id_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@ios_content_info_t info=out();
static void _mcpack2_load_mcp_get_ios_content_by_id_result_params_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_info){
self->_m_info=::idl::ios_content_info_t::create(self->_pool);
}
self->_m_info->LoadWithoutCheck(pack);
}
void mcp_get_ios_content_by_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_id_result_params*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@ios_content_info_t info=out();
{
mc_pack_t* subpack=mc_pack_put_object(pack,"info");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_info->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_id_response
static void _mcpack2_load_mcp_get_ios_content_by_id_response_result_params(const mc_pack_item_t*,mcp_get_ios_content_by_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_id_response*)>("result_params",_mcpack2_load_mcp_get_ios_content_by_id_response_result_params));
_mcpack2_load_mcp_get_ios_content_by_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_ios_content_by_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_id_response_static_inited=_mcpack2_load_mcp_get_ios_content_by_id_response_static_init();
// @@mcp_get_ios_content_by_id_result_params result_params;
static void _mcpack2_load_mcp_get_ios_content_by_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_ios_content_by_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_ios_content_by_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_id_response*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_ios_content_by_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_class_id_params
const uint32_t mcp_get_ios_content_by_class_id_params::k_for_free(0);
static void _mcpack2_load_mcp_get_ios_content_by_class_id_params_class_id(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*);
static void _mcpack2_load_mcp_get_ios_content_by_class_id_params_type_id(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*);
static void _mcpack2_load_mcp_get_ios_content_by_class_id_params_orderby(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*);
static void _mcpack2_load_mcp_get_ios_content_by_class_id_params_page(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*);
static void _mcpack2_load_mcp_get_ios_content_by_class_id_params_page_size(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*);
static void _mcpack2_load_mcp_get_ios_content_by_class_id_params_for_free(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_class_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_class_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*)>("class_id",_mcpack2_load_mcp_get_ios_content_by_class_id_params_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*)>("type_id",_mcpack2_load_mcp_get_ios_content_by_class_id_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*)>("orderby",_mcpack2_load_mcp_get_ios_content_by_class_id_params_orderby));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*)>("page",_mcpack2_load_mcp_get_ios_content_by_class_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*)>("page_size",_mcpack2_load_mcp_get_ios_content_by_class_id_params_page_size));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*)>("for_free",_mcpack2_load_mcp_get_ios_content_by_class_id_params_for_free));
_mcpack2_load_mcp_get_ios_content_by_class_id_params_readmap.create(16*6);
_mcpack2_load_mcp_get_ios_content_by_class_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_class_id_params_static_inited=_mcpack2_load_mcp_get_ios_content_by_class_id_params_static_init();
// @@string class_id=in();
static void _mcpack2_load_mcp_get_ios_content_by_class_id_params_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_class_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
// @@string type_id=in();
static void _mcpack2_load_mcp_get_ios_content_by_class_id_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_class_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t orderby=in();
static void _mcpack2_load_mcp_get_ios_content_by_class_id_params_orderby(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_class_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_orderby));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "orderby";
}
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_ios_content_by_class_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_class_id_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_ios_content_by_class_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_class_id_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
// @@uint32_t for_free=in(),default(0);
static void _mcpack2_load_mcp_get_ios_content_by_class_id_params_for_free(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_class_id_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_for_free));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "for_free";
}
}
void mcp_get_ios_content_by_class_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_class_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_class_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_params*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_class_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_class_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_class_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string class_id=in();
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t orderby=in();
{
int res=mc_pack_put_uint32(pack,"orderby",_m_orderby);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t for_free=in(),default(0);
{
int res=mc_pack_put_uint32(pack,"for_free",_m_for_free);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_class_id_result_params
static void _mcpack2_load_mcp_get_ios_content_by_class_id_result_params_count(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_result_params*);
static void _mcpack2_load_mcp_get_ios_content_by_class_id_result_params_info_list(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_class_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_class_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_result_params*)>("count",_mcpack2_load_mcp_get_ios_content_by_class_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_result_params*)>("info_list",_mcpack2_load_mcp_get_ios_content_by_class_id_result_params_info_list));
_mcpack2_load_mcp_get_ios_content_by_class_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_ios_content_by_class_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_class_id_result_params_static_inited=_mcpack2_load_mcp_get_ios_content_by_class_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_ios_content_by_class_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_class_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@ios_content_info_t info_list=out(),array(0);
static void _mcpack2_load_mcp_get_ios_content_by_class_id_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_class_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_ios_content_by_class_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_class_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_class_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_result_params*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_class_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_class_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_class_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@ios_content_info_t info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_class_id_response
static void _mcpack2_load_mcp_get_ios_content_by_class_id_response_result_params(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_class_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_class_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_response*)>("result_params",_mcpack2_load_mcp_get_ios_content_by_class_id_response_result_params));
_mcpack2_load_mcp_get_ios_content_by_class_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_ios_content_by_class_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_class_id_response_static_inited=_mcpack2_load_mcp_get_ios_content_by_class_id_response_static_init();
// @@mcp_get_ios_content_by_class_id_result_params result_params;
static void _mcpack2_load_mcp_get_ios_content_by_class_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_class_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_ios_content_by_class_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_ios_content_by_class_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_class_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_class_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_class_id_response*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_class_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_class_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_class_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_ios_content_by_class_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_cp_id_params
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_params_cp_id(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*);
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_params_type_id(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*);
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_params_orderby(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*);
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_params_page(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*);
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_params_page_size(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_cp_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_cp_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*)>("cp_id",_mcpack2_load_mcp_get_ios_content_by_cp_id_params_cp_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*)>("type_id",_mcpack2_load_mcp_get_ios_content_by_cp_id_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*)>("orderby",_mcpack2_load_mcp_get_ios_content_by_cp_id_params_orderby));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*)>("page",_mcpack2_load_mcp_get_ios_content_by_cp_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*)>("page_size",_mcpack2_load_mcp_get_ios_content_by_cp_id_params_page_size));
_mcpack2_load_mcp_get_ios_content_by_cp_id_params_readmap.create(16*5);
_mcpack2_load_mcp_get_ios_content_by_cp_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_cp_id_params_static_inited=_mcpack2_load_mcp_get_ios_content_by_cp_id_params_static_init();
// @@string cp_id=in();
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_params_cp_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_cp_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "cp_id";
}
self->_m_cp_id.set_ptr(item->value,item->value_size-1);
}
// @@string type_id=in();
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_cp_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t orderby=in();
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_params_orderby(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_cp_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_orderby));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "orderby";
}
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_cp_id_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_cp_id_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_ios_content_by_cp_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_cp_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_cp_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_params*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_cp_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_cp_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_cp_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string cp_id=in();
{
int res=mc_pack_put_str(pack,"cp_id",_m_cp_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t orderby=in();
{
int res=mc_pack_put_uint32(pack,"orderby",_m_orderby);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_cp_id_result_params
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_count(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_result_params*);
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_cp_name(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_result_params*);
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_info_list(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_result_params*)>("count",_mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_result_params*)>("cp_name",_mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_cp_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_result_params*)>("info_list",_mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_info_list));
_mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_readmap.create(16*3);
_mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_static_inited=_mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_cp_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string cp_name=out();
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_cp_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_cp_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "cp_name";
}
self->_m_cp_name.set_ptr(item->value,item->value_size-1);
}
// @@ios_content_info_t info_list=out(),array(0);
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_cp_id_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_ios_content_by_cp_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_cp_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_result_params*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_cp_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_cp_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_cp_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string cp_name=out();
{
int res=mc_pack_put_str(pack,"cp_name",_m_cp_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@ios_content_info_t info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_cp_id_response
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_response_result_params(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_cp_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_cp_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_response*)>("result_params",_mcpack2_load_mcp_get_ios_content_by_cp_id_response_result_params));
_mcpack2_load_mcp_get_ios_content_by_cp_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_ios_content_by_cp_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_cp_id_response_static_inited=_mcpack2_load_mcp_get_ios_content_by_cp_id_response_static_init();
// @@mcp_get_ios_content_by_cp_id_result_params result_params;
static void _mcpack2_load_mcp_get_ios_content_by_cp_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_cp_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_ios_content_by_cp_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_ios_content_by_cp_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_cp_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_cp_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_cp_id_response*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_cp_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_cp_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_cp_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_ios_content_by_cp_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_col_id_params
static void _mcpack2_load_mcp_get_ios_content_by_col_id_params_column_id(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*);
static void _mcpack2_load_mcp_get_ios_content_by_col_id_params_type_id(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*);
static void _mcpack2_load_mcp_get_ios_content_by_col_id_params_orderby(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*);
static void _mcpack2_load_mcp_get_ios_content_by_col_id_params_page(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*);
static void _mcpack2_load_mcp_get_ios_content_by_col_id_params_page_size(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_col_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_col_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*)>("column_id",_mcpack2_load_mcp_get_ios_content_by_col_id_params_column_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*)>("type_id",_mcpack2_load_mcp_get_ios_content_by_col_id_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*)>("orderby",_mcpack2_load_mcp_get_ios_content_by_col_id_params_orderby));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*)>("page",_mcpack2_load_mcp_get_ios_content_by_col_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*)>("page_size",_mcpack2_load_mcp_get_ios_content_by_col_id_params_page_size));
_mcpack2_load_mcp_get_ios_content_by_col_id_params_readmap.create(16*5);
_mcpack2_load_mcp_get_ios_content_by_col_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_col_id_params_static_inited=_mcpack2_load_mcp_get_ios_content_by_col_id_params_static_init();
// @@string column_id=in();
static void _mcpack2_load_mcp_get_ios_content_by_col_id_params_column_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_col_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "column_id";
}
self->_m_column_id.set_ptr(item->value,item->value_size-1);
}
// @@string type_id=in();
static void _mcpack2_load_mcp_get_ios_content_by_col_id_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_col_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t orderby=in();
static void _mcpack2_load_mcp_get_ios_content_by_col_id_params_orderby(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_col_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_orderby));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "orderby";
}
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_ios_content_by_col_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_col_id_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_ios_content_by_col_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_col_id_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_ios_content_by_col_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_col_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_col_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_params*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_col_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_col_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_col_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string column_id=in();
{
int res=mc_pack_put_str(pack,"column_id",_m_column_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t orderby=in();
{
int res=mc_pack_put_uint32(pack,"orderby",_m_orderby);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_col_id_result_params
static void _mcpack2_load_mcp_get_ios_content_by_col_id_result_params_count(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_result_params*);
static void _mcpack2_load_mcp_get_ios_content_by_col_id_result_params_name(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_result_params*);
static void _mcpack2_load_mcp_get_ios_content_by_col_id_result_params_info_list(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_col_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_col_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_result_params*)>("count",_mcpack2_load_mcp_get_ios_content_by_col_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_result_params*)>("name",_mcpack2_load_mcp_get_ios_content_by_col_id_result_params_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_result_params*)>("info_list",_mcpack2_load_mcp_get_ios_content_by_col_id_result_params_info_list));
_mcpack2_load_mcp_get_ios_content_by_col_id_result_params_readmap.create(16*3);
_mcpack2_load_mcp_get_ios_content_by_col_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_col_id_result_params_static_inited=_mcpack2_load_mcp_get_ios_content_by_col_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_ios_content_by_col_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_col_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string name=out();
static void _mcpack2_load_mcp_get_ios_content_by_col_id_result_params_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_col_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@ios_content_info_t info_list=out(),array(0);
static void _mcpack2_load_mcp_get_ios_content_by_col_id_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_col_id_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_ios_content_by_col_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_col_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_col_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_result_params*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_col_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_col_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_col_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name=out();
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@ios_content_info_t info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_col_id_response
static void _mcpack2_load_mcp_get_ios_content_by_col_id_response_result_params(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_col_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_col_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_response*)>("result_params",_mcpack2_load_mcp_get_ios_content_by_col_id_response_result_params));
_mcpack2_load_mcp_get_ios_content_by_col_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_ios_content_by_col_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_col_id_response_static_inited=_mcpack2_load_mcp_get_ios_content_by_col_id_response_static_init();
// @@mcp_get_ios_content_by_col_id_result_params result_params;
static void _mcpack2_load_mcp_get_ios_content_by_col_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_col_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_ios_content_by_col_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_ios_content_by_col_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_col_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_col_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_col_id_response*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_col_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_col_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_col_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_ios_content_by_col_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_rank_params
const uint32_t mcp_get_ios_content_by_rank_params::k_for_free(0);
static void _mcpack2_load_mcp_get_ios_content_by_rank_params_type_id(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*);
static void _mcpack2_load_mcp_get_ios_content_by_rank_params_p_type(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*);
static void _mcpack2_load_mcp_get_ios_content_by_rank_params_page(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*);
static void _mcpack2_load_mcp_get_ios_content_by_rank_params_page_size(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*);
static void _mcpack2_load_mcp_get_ios_content_by_rank_params_for_free(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_rank_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_rank_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*)>("type_id",_mcpack2_load_mcp_get_ios_content_by_rank_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*)>("p_type",_mcpack2_load_mcp_get_ios_content_by_rank_params_p_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*)>("page",_mcpack2_load_mcp_get_ios_content_by_rank_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*)>("page_size",_mcpack2_load_mcp_get_ios_content_by_rank_params_page_size));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*)>("for_free",_mcpack2_load_mcp_get_ios_content_by_rank_params_for_free));
_mcpack2_load_mcp_get_ios_content_by_rank_params_readmap.create(16*5);
_mcpack2_load_mcp_get_ios_content_by_rank_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_rank_params_static_inited=_mcpack2_load_mcp_get_ios_content_by_rank_params_static_init();
// @@string type_id=in();
static void _mcpack2_load_mcp_get_ios_content_by_rank_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_rank_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t p_type=in();
static void _mcpack2_load_mcp_get_ios_content_by_rank_params_p_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_rank_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_p_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "p_type";
}
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_ios_content_by_rank_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_rank_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_ios_content_by_rank_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_rank_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
// @@uint32_t for_free=in(),default(0);
static void _mcpack2_load_mcp_get_ios_content_by_rank_params_for_free(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_rank_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_for_free));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "for_free";
}
}
void mcp_get_ios_content_by_rank_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_rank_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_rank_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_params*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_rank_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_rank_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_rank_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t p_type=in();
{
int res=mc_pack_put_uint32(pack,"p_type",_m_p_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t for_free=in(),default(0);
{
int res=mc_pack_put_uint32(pack,"for_free",_m_for_free);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_rank_result_params
static void _mcpack2_load_mcp_get_ios_content_by_rank_result_params_count(const mc_pack_item_t*,mcp_get_ios_content_by_rank_result_params*);
static void _mcpack2_load_mcp_get_ios_content_by_rank_result_params_info_list(const mc_pack_item_t*,mcp_get_ios_content_by_rank_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_rank_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_rank_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_result_params*)>("count",_mcpack2_load_mcp_get_ios_content_by_rank_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_result_params*)>("info_list",_mcpack2_load_mcp_get_ios_content_by_rank_result_params_info_list));
_mcpack2_load_mcp_get_ios_content_by_rank_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_ios_content_by_rank_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_rank_result_params_static_inited=_mcpack2_load_mcp_get_ios_content_by_rank_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_ios_content_by_rank_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_rank_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@ios_content_info_t info_list=out(),array(0);
static void _mcpack2_load_mcp_get_ios_content_by_rank_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_rank_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_ios_content_by_rank_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_rank_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_rank_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_result_params*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_rank_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_rank_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_rank_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@ios_content_info_t info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_content_by_rank_response
static void _mcpack2_load_mcp_get_ios_content_by_rank_response_result_params(const mc_pack_item_t*,mcp_get_ios_content_by_rank_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_content_by_rank_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_content_by_rank_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_response*)>("result_params",_mcpack2_load_mcp_get_ios_content_by_rank_response_result_params));
_mcpack2_load_mcp_get_ios_content_by_rank_response_readmap.create(16*1);
_mcpack2_load_mcp_get_ios_content_by_rank_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_content_by_rank_response_static_inited=_mcpack2_load_mcp_get_ios_content_by_rank_response_static_init();
// @@mcp_get_ios_content_by_rank_result_params result_params;
static void _mcpack2_load_mcp_get_ios_content_by_rank_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_content_by_rank_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_ios_content_by_rank_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_ios_content_by_rank_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_response*)=0;
do{
if(_mcpack2_load_mcp_get_ios_content_by_rank_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_content_by_rank_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_content_by_rank_response*)=0;
if(_mcpack2_load_mcp_get_ios_content_by_rank_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_content_by_rank_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_content_by_rank_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_ios_content_by_rank_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_class_list_by_type_id_params
static void _mcpack2_load_mcp_get_class_list_by_type_id_params_type_id(const mc_pack_item_t*,mcp_get_class_list_by_type_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_class_list_by_type_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_class_list_by_type_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_params*)>("type_id",_mcpack2_load_mcp_get_class_list_by_type_id_params_type_id));
_mcpack2_load_mcp_get_class_list_by_type_id_params_readmap.create(16*1);
_mcpack2_load_mcp_get_class_list_by_type_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_class_list_by_type_id_params_static_inited=_mcpack2_load_mcp_get_class_list_by_type_id_params_static_init();
// @@string type_id=in();
static void _mcpack2_load_mcp_get_class_list_by_type_id_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_class_list_by_type_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_class_list_by_type_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_class_list_by_type_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_class_list_by_type_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_params*)=0;
if(_mcpack2_load_mcp_get_class_list_by_type_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_class_list_by_type_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_class_list_by_type_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_class_list_by_type_id_result_params
static void _mcpack2_load_mcp_get_class_list_by_type_id_result_params_count(const mc_pack_item_t*,mcp_get_class_list_by_type_id_result_params*);
static void _mcpack2_load_mcp_get_class_list_by_type_id_result_params_class_list(const mc_pack_item_t*,mcp_get_class_list_by_type_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_class_list_by_type_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_class_list_by_type_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_result_params*)>("count",_mcpack2_load_mcp_get_class_list_by_type_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_result_params*)>("class_list",_mcpack2_load_mcp_get_class_list_by_type_id_result_params_class_list));
_mcpack2_load_mcp_get_class_list_by_type_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_class_list_by_type_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_class_list_by_type_id_result_params_static_inited=_mcpack2_load_mcp_get_class_list_by_type_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_class_list_by_type_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_class_list_by_type_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@class_detail_count_t class_list=out(),array(0);
static void _mcpack2_load_mcp_get_class_list_by_type_id_result_params_class_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_class_list_by_type_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_class_list)) lp0=&(self->_m_class_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "class_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_class_list_by_type_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_class_list_by_type_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_class_list_by_type_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_result_params*)=0;
if(_mcpack2_load_mcp_get_class_list_by_type_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_class_list_by_type_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_class_list_by_type_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@class_detail_count_t class_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"class_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_class_list)& lr0=(_m_class_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_class_list_by_type_id_response
static void _mcpack2_load_mcp_get_class_list_by_type_id_response_result_params(const mc_pack_item_t*,mcp_get_class_list_by_type_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_class_list_by_type_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_class_list_by_type_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_response*)>("result_params",_mcpack2_load_mcp_get_class_list_by_type_id_response_result_params));
_mcpack2_load_mcp_get_class_list_by_type_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_class_list_by_type_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_class_list_by_type_id_response_static_inited=_mcpack2_load_mcp_get_class_list_by_type_id_response_static_init();
// @@mcp_get_class_list_by_type_id_result_params result_params;
static void _mcpack2_load_mcp_get_class_list_by_type_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_class_list_by_type_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_class_list_by_type_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_class_list_by_type_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_class_list_by_type_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_class_list_by_type_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_class_list_by_type_id_response*)=0;
if(_mcpack2_load_mcp_get_class_list_by_type_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_class_list_by_type_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_class_list_by_type_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_class_list_by_type_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_probably_like_list_by_id_params
static void _mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_id(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_params*);
static void _mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_list_cnt(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_params*);
static void _mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_type(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_params*)>("id",_mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_params*)>("list_cnt",_mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_list_cnt));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_params*)>("type",_mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_type));
_mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_readmap.create(16*3);
_mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_static_inited=_mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_static_init();
// @@string id=in();
static void _mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_probably_like_list_by_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t list_cnt=in();
static void _mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_list_cnt(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_probably_like_list_by_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_list_cnt));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "list_cnt";
}
}
// @@uint32_t type=in();
static void _mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_probably_like_list_by_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type";
}
}
void mcp_get_ios_probably_like_list_by_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_probably_like_list_by_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_params*)=0;
if(_mcpack2_load_mcp_get_ios_probably_like_list_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_probably_like_list_by_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_probably_like_list_by_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id=in();
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t list_cnt=in();
{
int res=mc_pack_put_uint32(pack,"list_cnt",_m_list_cnt);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t type=in();
{
int res=mc_pack_put_uint32(pack,"type",_m_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_probably_like_list_by_id_result_params
static void _mcpack2_load_mcp_get_ios_probably_like_list_by_id_result_params_info_list(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_probably_like_list_by_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_probably_like_list_by_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_result_params*)>("info_list",_mcpack2_load_mcp_get_ios_probably_like_list_by_id_result_params_info_list));
_mcpack2_load_mcp_get_ios_probably_like_list_by_id_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_ios_probably_like_list_by_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_probably_like_list_by_id_result_params_static_inited=_mcpack2_load_mcp_get_ios_probably_like_list_by_id_result_params_static_init();
// @@ios_content_info_t info_list=out(),array(0);
static void _mcpack2_load_mcp_get_ios_probably_like_list_by_id_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_probably_like_list_by_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_ios_probably_like_list_by_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_ios_probably_like_list_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_probably_like_list_by_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_result_params*)=0;
if(_mcpack2_load_mcp_get_ios_probably_like_list_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_probably_like_list_by_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_probably_like_list_by_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@ios_content_info_t info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ios_probably_like_list_by_id_response
static void _mcpack2_load_mcp_get_ios_probably_like_list_by_id_response_result_params(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ios_probably_like_list_by_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ios_probably_like_list_by_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_response*)>("result_params",_mcpack2_load_mcp_get_ios_probably_like_list_by_id_response_result_params));
_mcpack2_load_mcp_get_ios_probably_like_list_by_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_ios_probably_like_list_by_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ios_probably_like_list_by_id_response_static_inited=_mcpack2_load_mcp_get_ios_probably_like_list_by_id_response_static_init();
// @@mcp_get_ios_probably_like_list_by_id_result_params result_params;
static void _mcpack2_load_mcp_get_ios_probably_like_list_by_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ios_probably_like_list_by_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_ios_probably_like_list_by_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_ios_probably_like_list_by_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_ios_probably_like_list_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ios_probably_like_list_by_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ios_probably_like_list_by_id_response*)=0;
if(_mcpack2_load_mcp_get_ios_probably_like_list_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ios_probably_like_list_by_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ios_probably_like_list_by_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_ios_probably_like_list_by_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_info_list_params
static void _mcpack2_load_mcp_get_game_info_list_params_info_type(const mc_pack_item_t*,mcp_get_game_info_list_params*);
static void _mcpack2_load_mcp_get_game_info_list_params_game_type(const mc_pack_item_t*,mcp_get_game_info_list_params*);
static void _mcpack2_load_mcp_get_game_info_list_params_page(const mc_pack_item_t*,mcp_get_game_info_list_params*);
static void _mcpack2_load_mcp_get_game_info_list_params_page_size(const mc_pack_item_t*,mcp_get_game_info_list_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_info_list_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_info_list_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_info_list_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_params*)>("info_type",_mcpack2_load_mcp_get_game_info_list_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_params*)>("game_type",_mcpack2_load_mcp_get_game_info_list_params_game_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_params*)>("page",_mcpack2_load_mcp_get_game_info_list_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_params*)>("page_size",_mcpack2_load_mcp_get_game_info_list_params_page_size));
_mcpack2_load_mcp_get_game_info_list_params_readmap.create(16*4);
_mcpack2_load_mcp_get_game_info_list_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_info_list_params_static_inited=_mcpack2_load_mcp_get_game_info_list_params_static_init();
// @@string info_type=in();
static void _mcpack2_load_mcp_get_game_info_list_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
self->_m_info_type.set_ptr(item->value,item->value_size-1);
}
// @@string game_type=in();
static void _mcpack2_load_mcp_get_game_info_list_params_game_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_type";
}
self->_m_game_type.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_game_info_list_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_game_info_list_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_game_info_list_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_info_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_info_list_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_params*)=0;
if(_mcpack2_load_mcp_get_game_info_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_info_list_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_info_list_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string info_type=in();
{
int res=mc_pack_put_str(pack,"info_type",_m_info_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_type=in();
{
int res=mc_pack_put_str(pack,"game_type",_m_game_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_info_list_result_params
static void _mcpack2_load_mcp_get_game_info_list_result_params_count(const mc_pack_item_t*,mcp_get_game_info_list_result_params*);
static void _mcpack2_load_mcp_get_game_info_list_result_params_game_info_list(const mc_pack_item_t*,mcp_get_game_info_list_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_info_list_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_info_list_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_info_list_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_result_params*)>("count",_mcpack2_load_mcp_get_game_info_list_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_result_params*)>("game_info_list",_mcpack2_load_mcp_get_game_info_list_result_params_game_info_list));
_mcpack2_load_mcp_get_game_info_list_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_game_info_list_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_info_list_result_params_static_inited=_mcpack2_load_mcp_get_game_info_list_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_game_info_list_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_brief_info_t game_info_list=out(),array(0);
static void _mcpack2_load_mcp_get_game_info_list_result_params_game_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_game_info_list)) lp0=&(self->_m_game_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_game_info_list_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_info_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_info_list_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_result_params*)=0;
if(_mcpack2_load_mcp_get_game_info_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_info_list_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_info_list_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_brief_info_t game_info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"game_info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_game_info_list)& lr0=(_m_game_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_info_list_response
static void _mcpack2_load_mcp_get_game_info_list_response_result_params(const mc_pack_item_t*,mcp_get_game_info_list_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_info_list_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_info_list_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_info_list_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_response*)>("result_params",_mcpack2_load_mcp_get_game_info_list_response_result_params));
_mcpack2_load_mcp_get_game_info_list_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_info_list_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_info_list_response_static_inited=_mcpack2_load_mcp_get_game_info_list_response_static_init();
// @@mcp_get_game_info_list_result_params result_params;
static void _mcpack2_load_mcp_get_game_info_list_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_info_list_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_info_list_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_info_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_info_list_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_response*)=0;
if(_mcpack2_load_mcp_get_game_info_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_info_list_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_info_list_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_info_list_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_info_params
static void _mcpack2_load_mcp_get_game_info_params_info_id(const mc_pack_item_t*,mcp_get_game_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_params*)>("info_id",_mcpack2_load_mcp_get_game_info_params_info_id));
_mcpack2_load_mcp_get_game_info_params_readmap.create(16*1);
_mcpack2_load_mcp_get_game_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_info_params_static_inited=_mcpack2_load_mcp_get_game_info_params_static_init();
// @@string info_id=in();
static void _mcpack2_load_mcp_get_game_info_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_game_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_params*)=0;
if(_mcpack2_load_mcp_get_game_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_info_result_params
static void _mcpack2_load_mcp_get_game_info_result_params_game_info(const mc_pack_item_t*,mcp_get_game_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_result_params*)>("game_info",_mcpack2_load_mcp_get_game_info_result_params_game_info));
_mcpack2_load_mcp_get_game_info_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_game_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_info_result_params_static_inited=_mcpack2_load_mcp_get_game_info_result_params_static_init();
// @@game_info_t game_info=out();
static void _mcpack2_load_mcp_get_game_info_result_params_game_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_game_info){
self->_m_game_info=::idl::game_info_t::create(self->_pool);
}
self->_m_game_info->LoadWithoutCheck(pack);
}
void mcp_get_game_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_result_params*)=0;
if(_mcpack2_load_mcp_get_game_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@game_info_t game_info=out();
{
mc_pack_t* subpack=mc_pack_put_object(pack,"game_info");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_game_info->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_info_response
static void _mcpack2_load_mcp_get_game_info_response_result_params(const mc_pack_item_t*,mcp_get_game_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_response*)>("result_params",_mcpack2_load_mcp_get_game_info_response_result_params));
_mcpack2_load_mcp_get_game_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_info_response_static_inited=_mcpack2_load_mcp_get_game_info_response_static_init();
// @@mcp_get_game_info_result_params result_params;
static void _mcpack2_load_mcp_get_game_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_response*)=0;
if(_mcpack2_load_mcp_get_game_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_info_list_by_c_id_params
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_params_c_id(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_params*);
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_params_info_type(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_params*);
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_params_page(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_params*);
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_params_page_size(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_info_list_by_c_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_info_list_by_c_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_params*)>("c_id",_mcpack2_load_mcp_get_game_info_list_by_c_id_params_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_params*)>("info_type",_mcpack2_load_mcp_get_game_info_list_by_c_id_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_params*)>("page",_mcpack2_load_mcp_get_game_info_list_by_c_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_params*)>("page_size",_mcpack2_load_mcp_get_game_info_list_by_c_id_params_page_size));
_mcpack2_load_mcp_get_game_info_list_by_c_id_params_readmap.create(16*4);
_mcpack2_load_mcp_get_game_info_list_by_c_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_info_list_by_c_id_params_static_inited=_mcpack2_load_mcp_get_game_info_list_by_c_id_params_static_init();
// @@string c_id=in();
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_by_c_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string info_type=in();
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_by_c_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
self->_m_info_type.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_by_c_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_by_c_id_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_game_info_list_by_c_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_info_list_by_c_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_info_list_by_c_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_params*)=0;
if(_mcpack2_load_mcp_get_game_info_list_by_c_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_info_list_by_c_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_info_list_by_c_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_type=in();
{
int res=mc_pack_put_str(pack,"info_type",_m_info_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_info_list_by_c_id_result_params
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_count(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_result_params*);
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_game_info_list(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_result_params*)>("count",_mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_result_params*)>("game_info_list",_mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_game_info_list));
_mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_static_inited=_mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_by_c_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_brief_info_t game_info_list=out(),array(0);
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_game_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_by_c_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_game_info_list)) lp0=&(self->_m_game_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_game_info_list_by_c_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_info_list_by_c_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_result_params*)=0;
if(_mcpack2_load_mcp_get_game_info_list_by_c_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_info_list_by_c_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_info_list_by_c_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_brief_info_t game_info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"game_info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_game_info_list)& lr0=(_m_game_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_info_list_by_c_id_response
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_response_result_params(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_info_list_by_c_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_info_list_by_c_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_response*)>("result_params",_mcpack2_load_mcp_get_game_info_list_by_c_id_response_result_params));
_mcpack2_load_mcp_get_game_info_list_by_c_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_info_list_by_c_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_info_list_by_c_id_response_static_inited=_mcpack2_load_mcp_get_game_info_list_by_c_id_response_static_init();
// @@mcp_get_game_info_list_by_c_id_result_params result_params;
static void _mcpack2_load_mcp_get_game_info_list_by_c_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_by_c_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_info_list_by_c_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_info_list_by_c_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_info_list_by_c_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_info_list_by_c_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_by_c_id_response*)=0;
if(_mcpack2_load_mcp_get_game_info_list_by_c_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_info_list_by_c_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_info_list_by_c_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_info_list_by_c_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_score_by_imei_or_uid_params
static void _mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_id(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_params*);
static void _mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_c_id(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_params*);
static void _mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_type(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_params*)>("id",_mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_params*)>("c_id",_mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_params*)>("type",_mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_type));
_mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_readmap.create(16*3);
_mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_static_inited=_mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_static_init();
// @@string id=in();
static void _mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_score_by_imei_or_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id=in();
static void _mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_score_by_imei_or_uid_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string type=in();
static void _mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_score_by_imei_or_uid_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type";
}
self->_m_type.set_ptr(item->value,item->value_size-1);
}
void mcp_get_game_score_by_imei_or_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_score_by_imei_or_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_params*)=0;
if(_mcpack2_load_mcp_get_game_score_by_imei_or_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_score_by_imei_or_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_score_by_imei_or_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id=in();
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type=in();
{
int res=mc_pack_put_str(pack,"type",_m_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_score_by_imei_or_uid_result_params
static void _mcpack2_load_mcp_get_game_score_by_imei_or_uid_result_params_score(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_score_by_imei_or_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_score_by_imei_or_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_result_params*)>("score",_mcpack2_load_mcp_get_game_score_by_imei_or_uid_result_params_score));
_mcpack2_load_mcp_get_game_score_by_imei_or_uid_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_game_score_by_imei_or_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_score_by_imei_or_uid_result_params_static_inited=_mcpack2_load_mcp_get_game_score_by_imei_or_uid_result_params_static_init();
// @@string score=out();
static void _mcpack2_load_mcp_get_game_score_by_imei_or_uid_result_params_score(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_score_by_imei_or_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "score";
}
self->_m_score.set_ptr(item->value,item->value_size-1);
}
void mcp_get_game_score_by_imei_or_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_score_by_imei_or_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_score_by_imei_or_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_result_params*)=0;
if(_mcpack2_load_mcp_get_game_score_by_imei_or_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_score_by_imei_or_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_score_by_imei_or_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string score=out();
{
int res=mc_pack_put_str(pack,"score",_m_score.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_score_by_imei_or_uid_response
static void _mcpack2_load_mcp_get_game_score_by_imei_or_uid_response_result_params(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_score_by_imei_or_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_score_by_imei_or_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_response*)>("result_params",_mcpack2_load_mcp_get_game_score_by_imei_or_uid_response_result_params));
_mcpack2_load_mcp_get_game_score_by_imei_or_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_score_by_imei_or_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_score_by_imei_or_uid_response_static_inited=_mcpack2_load_mcp_get_game_score_by_imei_or_uid_response_static_init();
// @@mcp_get_game_score_by_imei_or_uid_result_params result_params;
static void _mcpack2_load_mcp_get_game_score_by_imei_or_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_score_by_imei_or_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_score_by_imei_or_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_score_by_imei_or_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_score_by_imei_or_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_score_by_imei_or_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_score_by_imei_or_uid_response*)=0;
if(_mcpack2_load_mcp_get_game_score_by_imei_or_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_score_by_imei_or_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_score_by_imei_or_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_score_by_imei_or_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_appinfo_by_packagename_params
static void _mcpack2_load_mcp_get_appinfo_by_packagename_params_packagename(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_appinfo_by_packagename_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_appinfo_by_packagename_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_params*)>("packagename",_mcpack2_load_mcp_get_appinfo_by_packagename_params_packagename));
_mcpack2_load_mcp_get_appinfo_by_packagename_params_readmap.create(16*1);
_mcpack2_load_mcp_get_appinfo_by_packagename_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_appinfo_by_packagename_params_static_inited=_mcpack2_load_mcp_get_appinfo_by_packagename_params_static_init();
// @@string packagename=in();
static void _mcpack2_load_mcp_get_appinfo_by_packagename_params_packagename(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_appinfo_by_packagename_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "packagename";
}
self->_m_packagename.set_ptr(item->value,item->value_size-1);
}
void mcp_get_appinfo_by_packagename_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_params*)=0;
do{
if(_mcpack2_load_mcp_get_appinfo_by_packagename_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_appinfo_by_packagename_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_params*)=0;
if(_mcpack2_load_mcp_get_appinfo_by_packagename_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_appinfo_by_packagename_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_appinfo_by_packagename_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string packagename=in();
{
int res=mc_pack_put_str(pack,"packagename",_m_packagename.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_appinfo_by_packagename_result_params
static void _mcpack2_load_mcp_get_appinfo_by_packagename_result_params_package_info(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_appinfo_by_packagename_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_appinfo_by_packagename_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_result_params*)>("package_info",_mcpack2_load_mcp_get_appinfo_by_packagename_result_params_package_info));
_mcpack2_load_mcp_get_appinfo_by_packagename_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_appinfo_by_packagename_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_appinfo_by_packagename_result_params_static_inited=_mcpack2_load_mcp_get_appinfo_by_packagename_result_params_static_init();
// @@string package_info=out(),array(0);
static void _mcpack2_load_mcp_get_appinfo_by_packagename_result_params_package_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_appinfo_by_packagename_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "package_info";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_package_info)) lp0=&(self->_m_package_info);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "package_info";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "package_info";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "package_info";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_appinfo_by_packagename_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_appinfo_by_packagename_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_appinfo_by_packagename_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_result_params*)=0;
if(_mcpack2_load_mcp_get_appinfo_by_packagename_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_appinfo_by_packagename_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_appinfo_by_packagename_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string package_info=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"package_info");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_package_info)& lr0=(_m_package_info);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_appinfo_by_packagename_response
static void _mcpack2_load_mcp_get_appinfo_by_packagename_response_result_params(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_appinfo_by_packagename_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_appinfo_by_packagename_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_response*)>("result_params",_mcpack2_load_mcp_get_appinfo_by_packagename_response_result_params));
_mcpack2_load_mcp_get_appinfo_by_packagename_response_readmap.create(16*1);
_mcpack2_load_mcp_get_appinfo_by_packagename_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_appinfo_by_packagename_response_static_inited=_mcpack2_load_mcp_get_appinfo_by_packagename_response_static_init();
// @@mcp_get_appinfo_by_packagename_result_params result_params;
static void _mcpack2_load_mcp_get_appinfo_by_packagename_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_appinfo_by_packagename_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_appinfo_by_packagename_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_appinfo_by_packagename_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_response*)=0;
do{
if(_mcpack2_load_mcp_get_appinfo_by_packagename_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_appinfo_by_packagename_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_appinfo_by_packagename_response*)=0;
if(_mcpack2_load_mcp_get_appinfo_by_packagename_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_appinfo_by_packagename_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_appinfo_by_packagename_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_appinfo_by_packagename_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_score_by_packagename_and_versioncode_params
static void _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_params_packagename_versioncode_json(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_params*)>("packagename_versioncode_json",_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_params_packagename_versioncode_json));
_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_params_readmap.create(16*1);
_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_params_static_inited=_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_params_static_init();
// @@string packagename_versioncode_json=in();
static void _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_params_packagename_versioncode_json(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_score_by_packagename_and_versioncode_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "packagename_versioncode_json";
}
self->_m_packagename_versioncode_json.set_ptr(item->value,item->value_size-1);
}
void mcp_get_score_by_packagename_and_versioncode_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_params*)=0;
do{
if(_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_score_by_packagename_and_versioncode_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_params*)=0;
if(_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_score_by_packagename_and_versioncode_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_score_by_packagename_and_versioncode_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string packagename_versioncode_json=in();
{
int res=mc_pack_put_str(pack,"packagename_versioncode_json",_m_packagename_versioncode_json.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_score_by_packagename_and_versioncode_result_params
static void _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_result_params_scores_json(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_result_params*)>("scores_json",_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_result_params_scores_json));
_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_result_params_static_inited=_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_result_params_static_init();
// @@string scores_json=out();
static void _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_result_params_scores_json(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_score_by_packagename_and_versioncode_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "scores_json";
}
self->_m_scores_json.set_ptr(item->value,item->value_size-1);
}
void mcp_get_score_by_packagename_and_versioncode_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_score_by_packagename_and_versioncode_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_result_params*)=0;
if(_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_score_by_packagename_and_versioncode_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_score_by_packagename_and_versioncode_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string scores_json=out();
{
int res=mc_pack_put_str(pack,"scores_json",_m_scores_json.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_score_by_packagename_and_versioncode_response
static void _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_response_result_params(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_response*)>("result_params",_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_response_result_params));
_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_response_readmap.create(16*1);
_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_response_static_inited=_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_response_static_init();
// @@mcp_get_score_by_packagename_and_versioncode_result_params result_params;
static void _mcpack2_load_mcp_get_score_by_packagename_and_versioncode_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_score_by_packagename_and_versioncode_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_score_by_packagename_and_versioncode_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_score_by_packagename_and_versioncode_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_response*)=0;
do{
if(_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_score_by_packagename_and_versioncode_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_score_by_packagename_and_versioncode_response*)=0;
if(_mcpack2_load_mcp_get_score_by_packagename_and_versioncode_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_score_by_packagename_and_versioncode_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_score_by_packagename_and_versioncode_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_score_by_packagename_and_versioncode_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_info_by_packagename_and_versioncode_params
static void _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_packagename(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_params*);
static void _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_versioncode(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_params*)>("packagename",_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_packagename));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_params*)>("versioncode",_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_versioncode));
_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_static_inited=_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_static_init();
// @@string packagename=in();
static void _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_packagename(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_info_by_packagename_and_versioncode_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "packagename";
}
self->_m_packagename.set_ptr(item->value,item->value_size-1);
}
// @@string versioncode=in();
static void _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_versioncode(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_info_by_packagename_and_versioncode_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "versioncode";
}
self->_m_versioncode.set_ptr(item->value,item->value_size-1);
}
void mcp_get_content_info_by_packagename_and_versioncode_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_info_by_packagename_and_versioncode_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_params*)=0;
if(_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_info_by_packagename_and_versioncode_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_info_by_packagename_and_versioncode_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string packagename=in();
{
int res=mc_pack_put_str(pack,"packagename",_m_packagename.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string versioncode=in();
{
int res=mc_pack_put_str(pack,"versioncode",_m_versioncode.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_info_by_packagename_and_versioncode_result_params
static void _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_result_params_info_list(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_result_params*)>("info_list",_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_result_params_info_list));
_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_result_params_static_inited=_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_result_params_static_init();
// @@string info_list=out(),array(0);
static void _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_info_by_packagename_and_versioncode_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_list";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_info_by_packagename_and_versioncode_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_info_by_packagename_and_versioncode_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_result_params*)=0;
if(_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_info_by_packagename_and_versioncode_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_info_by_packagename_and_versioncode_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_info_by_packagename_and_versioncode_response
static void _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_response_result_params(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_response*)>("result_params",_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_response_result_params));
_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_response_static_inited=_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_response_static_init();
// @@mcp_get_content_info_by_packagename_and_versioncode_result_params result_params;
static void _mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_info_by_packagename_and_versioncode_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_info_by_packagename_and_versioncode_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_info_by_packagename_and_versioncode_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_info_by_packagename_and_versioncode_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_and_versioncode_response*)=0;
if(_mcpack2_load_mcp_get_content_info_by_packagename_and_versioncode_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_info_by_packagename_and_versioncode_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_info_by_packagename_and_versioncode_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_info_by_packagename_and_versioncode_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_info_by_packagename_params
static void _mcpack2_load_mcp_get_content_info_by_packagename_params_packagename(const mc_pack_item_t*,mcp_get_content_info_by_packagename_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_info_by_packagename_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_info_by_packagename_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_params*)>("packagename",_mcpack2_load_mcp_get_content_info_by_packagename_params_packagename));
_mcpack2_load_mcp_get_content_info_by_packagename_params_readmap.create(16*1);
_mcpack2_load_mcp_get_content_info_by_packagename_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_info_by_packagename_params_static_inited=_mcpack2_load_mcp_get_content_info_by_packagename_params_static_init();
// @@string packagename=in();
static void _mcpack2_load_mcp_get_content_info_by_packagename_params_packagename(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_info_by_packagename_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "packagename";
}
self->_m_packagename.set_ptr(item->value,item->value_size-1);
}
void mcp_get_content_info_by_packagename_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_info_by_packagename_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_info_by_packagename_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_params*)=0;
if(_mcpack2_load_mcp_get_content_info_by_packagename_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_info_by_packagename_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_info_by_packagename_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string packagename=in();
{
int res=mc_pack_put_str(pack,"packagename",_m_packagename.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_info_by_packagename_result_params
static void _mcpack2_load_mcp_get_content_info_by_packagename_result_params_info_list(const mc_pack_item_t*,mcp_get_content_info_by_packagename_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_info_by_packagename_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_info_by_packagename_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_result_params*)>("info_list",_mcpack2_load_mcp_get_content_info_by_packagename_result_params_info_list));
_mcpack2_load_mcp_get_content_info_by_packagename_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_content_info_by_packagename_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_info_by_packagename_result_params_static_inited=_mcpack2_load_mcp_get_content_info_by_packagename_result_params_static_init();
// @@string info_list=out(),array(0);
static void _mcpack2_load_mcp_get_content_info_by_packagename_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_info_by_packagename_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_list";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_info_by_packagename_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_info_by_packagename_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_info_by_packagename_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_result_params*)=0;
if(_mcpack2_load_mcp_get_content_info_by_packagename_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_info_by_packagename_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_info_by_packagename_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_info_by_packagename_response
static void _mcpack2_load_mcp_get_content_info_by_packagename_response_result_params(const mc_pack_item_t*,mcp_get_content_info_by_packagename_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_info_by_packagename_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_info_by_packagename_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_response*)>("result_params",_mcpack2_load_mcp_get_content_info_by_packagename_response_result_params));
_mcpack2_load_mcp_get_content_info_by_packagename_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_info_by_packagename_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_info_by_packagename_response_static_inited=_mcpack2_load_mcp_get_content_info_by_packagename_response_static_init();
// @@mcp_get_content_info_by_packagename_result_params result_params;
static void _mcpack2_load_mcp_get_content_info_by_packagename_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_info_by_packagename_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_info_by_packagename_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_info_by_packagename_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_info_by_packagename_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_info_by_packagename_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_info_by_packagename_response*)=0;
if(_mcpack2_load_mcp_get_content_info_by_packagename_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_info_by_packagename_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_info_by_packagename_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_info_by_packagename_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_id_params
static void _mcpack2_load_mcp_get_online_game_by_id_params_id(const mc_pack_item_t*,mcp_get_online_game_by_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_id_params*)>("id",_mcpack2_load_mcp_get_online_game_by_id_params_id));
_mcpack2_load_mcp_get_online_game_by_id_params_readmap.create(16*1);
_mcpack2_load_mcp_get_online_game_by_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_id_params_static_inited=_mcpack2_load_mcp_get_online_game_by_id_params_static_init();
// @@string id=in();
static void _mcpack2_load_mcp_get_online_game_by_id_params_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_online_game_by_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_id_params*)=0;
if(_mcpack2_load_mcp_get_online_game_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id=in();
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_id_result_params
static void _mcpack2_load_mcp_get_online_game_by_id_result_params_result(const mc_pack_item_t*,mcp_get_online_game_by_id_result_params*);
static void _mcpack2_load_mcp_get_online_game_by_id_result_params_info(const mc_pack_item_t*,mcp_get_online_game_by_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_id_result_params*)>("result",_mcpack2_load_mcp_get_online_game_by_id_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_id_result_params*)>("info",_mcpack2_load_mcp_get_online_game_by_id_result_params_info));
_mcpack2_load_mcp_get_online_game_by_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_online_game_by_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_id_result_params_static_inited=_mcpack2_load_mcp_get_online_game_by_id_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_get_online_game_by_id_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@online_game_info_t info=out();
static void _mcpack2_load_mcp_get_online_game_by_id_result_params_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_info){
self->_m_info=::idl::online_game_info_t::create(self->_pool);
}
self->_m_info->LoadWithoutCheck(pack);
}
void mcp_get_online_game_by_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_id_result_params*)=0;
if(_mcpack2_load_mcp_get_online_game_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@online_game_info_t info=out();
{
mc_pack_t* subpack=mc_pack_put_object(pack,"info");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_info->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_id_response
static void _mcpack2_load_mcp_get_online_game_by_id_response_result_params(const mc_pack_item_t*,mcp_get_online_game_by_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_id_response*)>("result_params",_mcpack2_load_mcp_get_online_game_by_id_response_result_params));
_mcpack2_load_mcp_get_online_game_by_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_online_game_by_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_id_response_static_inited=_mcpack2_load_mcp_get_online_game_by_id_response_static_init();
// @@mcp_get_online_game_by_id_result_params result_params;
static void _mcpack2_load_mcp_get_online_game_by_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_online_game_by_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_online_game_by_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_id_response*)=0;
if(_mcpack2_load_mcp_get_online_game_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_online_game_by_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_class_id_params
static void _mcpack2_load_mcp_get_online_game_by_class_id_params_class_id(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*);
static void _mcpack2_load_mcp_get_online_game_by_class_id_params_type_id(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*);
static void _mcpack2_load_mcp_get_online_game_by_class_id_params_orderby(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*);
static void _mcpack2_load_mcp_get_online_game_by_class_id_params_page(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*);
static void _mcpack2_load_mcp_get_online_game_by_class_id_params_page_size(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_class_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_class_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*)>("class_id",_mcpack2_load_mcp_get_online_game_by_class_id_params_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*)>("type_id",_mcpack2_load_mcp_get_online_game_by_class_id_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*)>("orderby",_mcpack2_load_mcp_get_online_game_by_class_id_params_orderby));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*)>("page",_mcpack2_load_mcp_get_online_game_by_class_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*)>("page_size",_mcpack2_load_mcp_get_online_game_by_class_id_params_page_size));
_mcpack2_load_mcp_get_online_game_by_class_id_params_readmap.create(16*5);
_mcpack2_load_mcp_get_online_game_by_class_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_class_id_params_static_inited=_mcpack2_load_mcp_get_online_game_by_class_id_params_static_init();
// @@string class_id=in();
static void _mcpack2_load_mcp_get_online_game_by_class_id_params_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_class_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
// @@string type_id=in();
static void _mcpack2_load_mcp_get_online_game_by_class_id_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_class_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t orderby=in();
static void _mcpack2_load_mcp_get_online_game_by_class_id_params_orderby(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_class_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_orderby));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "orderby";
}
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_online_game_by_class_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_class_id_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_online_game_by_class_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_class_id_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_online_game_by_class_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_class_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_class_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_params*)=0;
if(_mcpack2_load_mcp_get_online_game_by_class_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_class_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_class_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string class_id=in();
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t orderby=in();
{
int res=mc_pack_put_uint32(pack,"orderby",_m_orderby);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_class_id_result_params
static void _mcpack2_load_mcp_get_online_game_by_class_id_result_params_count(const mc_pack_item_t*,mcp_get_online_game_by_class_id_result_params*);
static void _mcpack2_load_mcp_get_online_game_by_class_id_result_params_class_name(const mc_pack_item_t*,mcp_get_online_game_by_class_id_result_params*);
static void _mcpack2_load_mcp_get_online_game_by_class_id_result_params_class_icon(const mc_pack_item_t*,mcp_get_online_game_by_class_id_result_params*);
static void _mcpack2_load_mcp_get_online_game_by_class_id_result_params_info_list(const mc_pack_item_t*,mcp_get_online_game_by_class_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_class_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_class_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_result_params*)>("count",_mcpack2_load_mcp_get_online_game_by_class_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_result_params*)>("class_name",_mcpack2_load_mcp_get_online_game_by_class_id_result_params_class_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_result_params*)>("class_icon",_mcpack2_load_mcp_get_online_game_by_class_id_result_params_class_icon));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_result_params*)>("info_list",_mcpack2_load_mcp_get_online_game_by_class_id_result_params_info_list));
_mcpack2_load_mcp_get_online_game_by_class_id_result_params_readmap.create(16*4);
_mcpack2_load_mcp_get_online_game_by_class_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_class_id_result_params_static_inited=_mcpack2_load_mcp_get_online_game_by_class_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_online_game_by_class_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_class_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string class_name=out();
static void _mcpack2_load_mcp_get_online_game_by_class_id_result_params_class_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_class_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_name";
}
self->_m_class_name.set_ptr(item->value,item->value_size-1);
}
// @@string class_icon=out();
static void _mcpack2_load_mcp_get_online_game_by_class_id_result_params_class_icon(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_class_id_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_icon";
}
self->_m_class_icon.set_ptr(item->value,item->value_size-1);
}
// @@online_game_info_t info_list=out(),array(0);
static void _mcpack2_load_mcp_get_online_game_by_class_id_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_class_id_result_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_online_game_by_class_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_class_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_class_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_result_params*)=0;
if(_mcpack2_load_mcp_get_online_game_by_class_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_class_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_class_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string class_name=out();
{
int res=mc_pack_put_str(pack,"class_name",_m_class_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string class_icon=out();
{
int res=mc_pack_put_str(pack,"class_icon",_m_class_icon.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@online_game_info_t info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_class_id_response
static void _mcpack2_load_mcp_get_online_game_by_class_id_response_result_params(const mc_pack_item_t*,mcp_get_online_game_by_class_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_class_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_class_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_response*)>("result_params",_mcpack2_load_mcp_get_online_game_by_class_id_response_result_params));
_mcpack2_load_mcp_get_online_game_by_class_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_online_game_by_class_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_class_id_response_static_inited=_mcpack2_load_mcp_get_online_game_by_class_id_response_static_init();
// @@mcp_get_online_game_by_class_id_result_params result_params;
static void _mcpack2_load_mcp_get_online_game_by_class_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_class_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_online_game_by_class_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_online_game_by_class_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_class_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_class_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_class_id_response*)=0;
if(_mcpack2_load_mcp_get_online_game_by_class_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_class_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_class_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_online_game_by_class_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_cp_id_params
static void _mcpack2_load_mcp_get_online_game_by_cp_id_params_cp_id(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*);
static void _mcpack2_load_mcp_get_online_game_by_cp_id_params_type_id(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*);
static void _mcpack2_load_mcp_get_online_game_by_cp_id_params_orderby(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*);
static void _mcpack2_load_mcp_get_online_game_by_cp_id_params_page(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*);
static void _mcpack2_load_mcp_get_online_game_by_cp_id_params_page_size(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_cp_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_cp_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*)>("cp_id",_mcpack2_load_mcp_get_online_game_by_cp_id_params_cp_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*)>("type_id",_mcpack2_load_mcp_get_online_game_by_cp_id_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*)>("orderby",_mcpack2_load_mcp_get_online_game_by_cp_id_params_orderby));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*)>("page",_mcpack2_load_mcp_get_online_game_by_cp_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*)>("page_size",_mcpack2_load_mcp_get_online_game_by_cp_id_params_page_size));
_mcpack2_load_mcp_get_online_game_by_cp_id_params_readmap.create(16*5);
_mcpack2_load_mcp_get_online_game_by_cp_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_cp_id_params_static_inited=_mcpack2_load_mcp_get_online_game_by_cp_id_params_static_init();
// @@string cp_id=in();
static void _mcpack2_load_mcp_get_online_game_by_cp_id_params_cp_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_cp_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "cp_id";
}
self->_m_cp_id.set_ptr(item->value,item->value_size-1);
}
// @@string type_id=in();
static void _mcpack2_load_mcp_get_online_game_by_cp_id_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_cp_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t orderby=in();
static void _mcpack2_load_mcp_get_online_game_by_cp_id_params_orderby(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_cp_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_orderby));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "orderby";
}
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_online_game_by_cp_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_cp_id_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_online_game_by_cp_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_cp_id_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_online_game_by_cp_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_cp_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_cp_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_params*)=0;
if(_mcpack2_load_mcp_get_online_game_by_cp_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_cp_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_cp_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string cp_id=in();
{
int res=mc_pack_put_str(pack,"cp_id",_m_cp_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t orderby=in();
{
int res=mc_pack_put_uint32(pack,"orderby",_m_orderby);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_cp_id_result_params
static void _mcpack2_load_mcp_get_online_game_by_cp_id_result_params_count(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_result_params*);
static void _mcpack2_load_mcp_get_online_game_by_cp_id_result_params_cp_name(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_result_params*);
static void _mcpack2_load_mcp_get_online_game_by_cp_id_result_params_info_list(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_cp_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_cp_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_result_params*)>("count",_mcpack2_load_mcp_get_online_game_by_cp_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_result_params*)>("cp_name",_mcpack2_load_mcp_get_online_game_by_cp_id_result_params_cp_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_result_params*)>("info_list",_mcpack2_load_mcp_get_online_game_by_cp_id_result_params_info_list));
_mcpack2_load_mcp_get_online_game_by_cp_id_result_params_readmap.create(16*3);
_mcpack2_load_mcp_get_online_game_by_cp_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_cp_id_result_params_static_inited=_mcpack2_load_mcp_get_online_game_by_cp_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_online_game_by_cp_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_cp_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string cp_name=out();
static void _mcpack2_load_mcp_get_online_game_by_cp_id_result_params_cp_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_cp_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "cp_name";
}
self->_m_cp_name.set_ptr(item->value,item->value_size-1);
}
// @@online_game_info_t info_list=out(),array(0);
static void _mcpack2_load_mcp_get_online_game_by_cp_id_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_cp_id_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_online_game_by_cp_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_cp_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_cp_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_result_params*)=0;
if(_mcpack2_load_mcp_get_online_game_by_cp_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_cp_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_cp_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string cp_name=out();
{
int res=mc_pack_put_str(pack,"cp_name",_m_cp_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@online_game_info_t info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_cp_id_response
static void _mcpack2_load_mcp_get_online_game_by_cp_id_response_result_params(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_cp_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_cp_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_response*)>("result_params",_mcpack2_load_mcp_get_online_game_by_cp_id_response_result_params));
_mcpack2_load_mcp_get_online_game_by_cp_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_online_game_by_cp_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_cp_id_response_static_inited=_mcpack2_load_mcp_get_online_game_by_cp_id_response_static_init();
// @@mcp_get_online_game_by_cp_id_result_params result_params;
static void _mcpack2_load_mcp_get_online_game_by_cp_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_cp_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_online_game_by_cp_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_online_game_by_cp_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_cp_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_cp_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_cp_id_response*)=0;
if(_mcpack2_load_mcp_get_online_game_by_cp_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_cp_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_cp_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_online_game_by_cp_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_col_id_params
static void _mcpack2_load_mcp_get_online_game_by_col_id_params_column_id(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*);
static void _mcpack2_load_mcp_get_online_game_by_col_id_params_type_id(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*);
static void _mcpack2_load_mcp_get_online_game_by_col_id_params_orderby(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*);
static void _mcpack2_load_mcp_get_online_game_by_col_id_params_page(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*);
static void _mcpack2_load_mcp_get_online_game_by_col_id_params_page_size(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_col_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_col_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*)>("column_id",_mcpack2_load_mcp_get_online_game_by_col_id_params_column_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*)>("type_id",_mcpack2_load_mcp_get_online_game_by_col_id_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*)>("orderby",_mcpack2_load_mcp_get_online_game_by_col_id_params_orderby));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*)>("page",_mcpack2_load_mcp_get_online_game_by_col_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*)>("page_size",_mcpack2_load_mcp_get_online_game_by_col_id_params_page_size));
_mcpack2_load_mcp_get_online_game_by_col_id_params_readmap.create(16*5);
_mcpack2_load_mcp_get_online_game_by_col_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_col_id_params_static_inited=_mcpack2_load_mcp_get_online_game_by_col_id_params_static_init();
// @@string column_id=in();
static void _mcpack2_load_mcp_get_online_game_by_col_id_params_column_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_col_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "column_id";
}
self->_m_column_id.set_ptr(item->value,item->value_size-1);
}
// @@string type_id=in();
static void _mcpack2_load_mcp_get_online_game_by_col_id_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_col_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t orderby=in();
static void _mcpack2_load_mcp_get_online_game_by_col_id_params_orderby(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_col_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_orderby));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "orderby";
}
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_online_game_by_col_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_col_id_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_online_game_by_col_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_col_id_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_online_game_by_col_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_col_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_col_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_params*)=0;
if(_mcpack2_load_mcp_get_online_game_by_col_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_col_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_col_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string column_id=in();
{
int res=mc_pack_put_str(pack,"column_id",_m_column_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t orderby=in();
{
int res=mc_pack_put_uint32(pack,"orderby",_m_orderby);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_col_id_result_params
static void _mcpack2_load_mcp_get_online_game_by_col_id_result_params_count(const mc_pack_item_t*,mcp_get_online_game_by_col_id_result_params*);
static void _mcpack2_load_mcp_get_online_game_by_col_id_result_params_name(const mc_pack_item_t*,mcp_get_online_game_by_col_id_result_params*);
static void _mcpack2_load_mcp_get_online_game_by_col_id_result_params_info_list(const mc_pack_item_t*,mcp_get_online_game_by_col_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_col_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_col_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_result_params*)>("count",_mcpack2_load_mcp_get_online_game_by_col_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_result_params*)>("name",_mcpack2_load_mcp_get_online_game_by_col_id_result_params_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_result_params*)>("info_list",_mcpack2_load_mcp_get_online_game_by_col_id_result_params_info_list));
_mcpack2_load_mcp_get_online_game_by_col_id_result_params_readmap.create(16*3);
_mcpack2_load_mcp_get_online_game_by_col_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_col_id_result_params_static_inited=_mcpack2_load_mcp_get_online_game_by_col_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_online_game_by_col_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_col_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string name=out();
static void _mcpack2_load_mcp_get_online_game_by_col_id_result_params_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_col_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@online_game_info_t info_list=out(),array(0);
static void _mcpack2_load_mcp_get_online_game_by_col_id_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_col_id_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_online_game_by_col_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_col_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_col_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_result_params*)=0;
if(_mcpack2_load_mcp_get_online_game_by_col_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_col_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_col_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string name=out();
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@online_game_info_t info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_col_id_response
static void _mcpack2_load_mcp_get_online_game_by_col_id_response_result_params(const mc_pack_item_t*,mcp_get_online_game_by_col_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_col_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_col_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_response*)>("result_params",_mcpack2_load_mcp_get_online_game_by_col_id_response_result_params));
_mcpack2_load_mcp_get_online_game_by_col_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_online_game_by_col_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_col_id_response_static_inited=_mcpack2_load_mcp_get_online_game_by_col_id_response_static_init();
// @@mcp_get_online_game_by_col_id_result_params result_params;
static void _mcpack2_load_mcp_get_online_game_by_col_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_col_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_online_game_by_col_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_online_game_by_col_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_col_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_col_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_col_id_response*)=0;
if(_mcpack2_load_mcp_get_online_game_by_col_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_col_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_col_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_online_game_by_col_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_rank_params
static void _mcpack2_load_mcp_get_online_game_by_rank_params_type_id(const mc_pack_item_t*,mcp_get_online_game_by_rank_params*);
static void _mcpack2_load_mcp_get_online_game_by_rank_params_p_type(const mc_pack_item_t*,mcp_get_online_game_by_rank_params*);
static void _mcpack2_load_mcp_get_online_game_by_rank_params_page(const mc_pack_item_t*,mcp_get_online_game_by_rank_params*);
static void _mcpack2_load_mcp_get_online_game_by_rank_params_page_size(const mc_pack_item_t*,mcp_get_online_game_by_rank_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_rank_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_rank_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_rank_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_rank_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_rank_params*)>("type_id",_mcpack2_load_mcp_get_online_game_by_rank_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_rank_params*)>("p_type",_mcpack2_load_mcp_get_online_game_by_rank_params_p_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_rank_params*)>("page",_mcpack2_load_mcp_get_online_game_by_rank_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_rank_params*)>("page_size",_mcpack2_load_mcp_get_online_game_by_rank_params_page_size));
_mcpack2_load_mcp_get_online_game_by_rank_params_readmap.create(16*4);
_mcpack2_load_mcp_get_online_game_by_rank_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_rank_params_static_inited=_mcpack2_load_mcp_get_online_game_by_rank_params_static_init();
// @@string type_id=in();
static void _mcpack2_load_mcp_get_online_game_by_rank_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_rank_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t p_type=in();
static void _mcpack2_load_mcp_get_online_game_by_rank_params_p_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_rank_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_p_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "p_type";
}
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_online_game_by_rank_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_rank_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_online_game_by_rank_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_rank_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_online_game_by_rank_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_rank_params*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_rank_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_rank_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_rank_params*)=0;
if(_mcpack2_load_mcp_get_online_game_by_rank_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_rank_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_rank_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t p_type=in();
{
int res=mc_pack_put_uint32(pack,"p_type",_m_p_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_rank_result_params
static void _mcpack2_load_mcp_get_online_game_by_rank_result_params_count(const mc_pack_item_t*,mcp_get_online_game_by_rank_result_params*);
static void _mcpack2_load_mcp_get_online_game_by_rank_result_params_info_list(const mc_pack_item_t*,mcp_get_online_game_by_rank_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_rank_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_rank_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_rank_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_rank_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_rank_result_params*)>("count",_mcpack2_load_mcp_get_online_game_by_rank_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_rank_result_params*)>("info_list",_mcpack2_load_mcp_get_online_game_by_rank_result_params_info_list));
_mcpack2_load_mcp_get_online_game_by_rank_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_online_game_by_rank_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_rank_result_params_static_inited=_mcpack2_load_mcp_get_online_game_by_rank_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_online_game_by_rank_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_rank_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@online_game_info_t info_list=out(),array(0);
static void _mcpack2_load_mcp_get_online_game_by_rank_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_rank_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_online_game_by_rank_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_rank_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_rank_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_rank_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_rank_result_params*)=0;
if(_mcpack2_load_mcp_get_online_game_by_rank_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_rank_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_rank_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@online_game_info_t info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_online_game_by_rank_response
static void _mcpack2_load_mcp_get_online_game_by_rank_response_result_params(const mc_pack_item_t*,mcp_get_online_game_by_rank_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_rank_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_online_game_by_rank_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_online_game_by_rank_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_online_game_by_rank_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_online_game_by_rank_response*)>("result_params",_mcpack2_load_mcp_get_online_game_by_rank_response_result_params));
_mcpack2_load_mcp_get_online_game_by_rank_response_readmap.create(16*1);
_mcpack2_load_mcp_get_online_game_by_rank_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_online_game_by_rank_response_static_inited=_mcpack2_load_mcp_get_online_game_by_rank_response_static_init();
// @@mcp_get_online_game_by_rank_result_params result_params;
static void _mcpack2_load_mcp_get_online_game_by_rank_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_online_game_by_rank_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_online_game_by_rank_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_online_game_by_rank_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_rank_response*)=0;
do{
if(_mcpack2_load_mcp_get_online_game_by_rank_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_online_game_by_rank_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_online_game_by_rank_response*)=0;
if(_mcpack2_load_mcp_get_online_game_by_rank_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_online_game_by_rank_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_online_game_by_rank_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_online_game_by_rank_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_grab_list_by_type_params
static void _mcpack2_load_mcp_get_grab_list_by_type_params_type_id(const mc_pack_item_t*,mcp_get_grab_list_by_type_params*);
static void _mcpack2_load_mcp_get_grab_list_by_type_params_page(const mc_pack_item_t*,mcp_get_grab_list_by_type_params*);
static void _mcpack2_load_mcp_get_grab_list_by_type_params_page_size(const mc_pack_item_t*,mcp_get_grab_list_by_type_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_by_type_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_grab_list_by_type_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_grab_list_by_type_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_grab_list_by_type_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_by_type_params*)>("type_id",_mcpack2_load_mcp_get_grab_list_by_type_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_by_type_params*)>("page",_mcpack2_load_mcp_get_grab_list_by_type_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_by_type_params*)>("page_size",_mcpack2_load_mcp_get_grab_list_by_type_params_page_size));
_mcpack2_load_mcp_get_grab_list_by_type_params_readmap.create(16*3);
_mcpack2_load_mcp_get_grab_list_by_type_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_grab_list_by_type_params_static_inited=_mcpack2_load_mcp_get_grab_list_by_type_params_static_init();
// @@string type_id=in();
static void _mcpack2_load_mcp_get_grab_list_by_type_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_by_type_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_grab_list_by_type_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_by_type_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_grab_list_by_type_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_by_type_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_grab_list_by_type_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_grab_list_by_type_params*)=0;
do{
if(_mcpack2_load_mcp_get_grab_list_by_type_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_grab_list_by_type_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_grab_list_by_type_params*)=0;
if(_mcpack2_load_mcp_get_grab_list_by_type_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_grab_list_by_type_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_grab_list_by_type_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_grab_list_by_type_result_params
static void _mcpack2_load_mcp_get_grab_list_by_type_result_params_result(const mc_pack_item_t*,mcp_get_grab_list_by_type_result_params*);
static void _mcpack2_load_mcp_get_grab_list_by_type_result_params_grab_list(const mc_pack_item_t*,mcp_get_grab_list_by_type_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_by_type_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_grab_list_by_type_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_grab_list_by_type_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_grab_list_by_type_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_by_type_result_params*)>("result",_mcpack2_load_mcp_get_grab_list_by_type_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_by_type_result_params*)>("grab_list",_mcpack2_load_mcp_get_grab_list_by_type_result_params_grab_list));
_mcpack2_load_mcp_get_grab_list_by_type_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_grab_list_by_type_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_grab_list_by_type_result_params_static_inited=_mcpack2_load_mcp_get_grab_list_by_type_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_get_grab_list_by_type_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_by_type_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@grab_info_t grab_list=out(),array(0);
static void _mcpack2_load_mcp_get_grab_list_by_type_result_params_grab_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_by_type_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "grab_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_grab_list)) lp0=&(self->_m_grab_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "grab_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "grab_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "grab_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_grab_list_by_type_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_grab_list_by_type_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_grab_list_by_type_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_grab_list_by_type_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_grab_list_by_type_result_params*)=0;
if(_mcpack2_load_mcp_get_grab_list_by_type_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_grab_list_by_type_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_grab_list_by_type_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@grab_info_t grab_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"grab_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_grab_list)& lr0=(_m_grab_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_grab_list_by_type_response
static void _mcpack2_load_mcp_get_grab_list_by_type_response_result_params(const mc_pack_item_t*,mcp_get_grab_list_by_type_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_by_type_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_grab_list_by_type_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_grab_list_by_type_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_grab_list_by_type_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_by_type_response*)>("result_params",_mcpack2_load_mcp_get_grab_list_by_type_response_result_params));
_mcpack2_load_mcp_get_grab_list_by_type_response_readmap.create(16*1);
_mcpack2_load_mcp_get_grab_list_by_type_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_grab_list_by_type_response_static_inited=_mcpack2_load_mcp_get_grab_list_by_type_response_static_init();
// @@mcp_get_grab_list_by_type_result_params result_params;
static void _mcpack2_load_mcp_get_grab_list_by_type_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_by_type_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_grab_list_by_type_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_grab_list_by_type_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_grab_list_by_type_response*)=0;
do{
if(_mcpack2_load_mcp_get_grab_list_by_type_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_grab_list_by_type_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_grab_list_by_type_response*)=0;
if(_mcpack2_load_mcp_get_grab_list_by_type_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_grab_list_by_type_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_grab_list_by_type_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_grab_list_by_type_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_grab_info_by_c_id_params
static void _mcpack2_load_mcp_get_grab_info_by_c_id_params_c_id(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_grab_info_by_c_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_grab_info_by_c_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_params*)>("c_id",_mcpack2_load_mcp_get_grab_info_by_c_id_params_c_id));
_mcpack2_load_mcp_get_grab_info_by_c_id_params_readmap.create(16*1);
_mcpack2_load_mcp_get_grab_info_by_c_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_grab_info_by_c_id_params_static_inited=_mcpack2_load_mcp_get_grab_info_by_c_id_params_static_init();
// @@string c_id=in();
static void _mcpack2_load_mcp_get_grab_info_by_c_id_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_info_by_c_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_grab_info_by_c_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_grab_info_by_c_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_grab_info_by_c_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_params*)=0;
if(_mcpack2_load_mcp_get_grab_info_by_c_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_grab_info_by_c_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_grab_info_by_c_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_grab_info_by_c_id_result_params
static void _mcpack2_load_mcp_get_grab_info_by_c_id_result_params_result(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_result_params*);
static void _mcpack2_load_mcp_get_grab_info_by_c_id_result_params_grab_list(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_grab_info_by_c_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_grab_info_by_c_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_result_params*)>("result",_mcpack2_load_mcp_get_grab_info_by_c_id_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_result_params*)>("grab_list",_mcpack2_load_mcp_get_grab_info_by_c_id_result_params_grab_list));
_mcpack2_load_mcp_get_grab_info_by_c_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_grab_info_by_c_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_grab_info_by_c_id_result_params_static_inited=_mcpack2_load_mcp_get_grab_info_by_c_id_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_get_grab_info_by_c_id_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_info_by_c_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@grab_info_t grab_list=out(),array(0);
static void _mcpack2_load_mcp_get_grab_info_by_c_id_result_params_grab_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_info_by_c_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "grab_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_grab_list)) lp0=&(self->_m_grab_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "grab_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "grab_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "grab_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_grab_info_by_c_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_grab_info_by_c_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_grab_info_by_c_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_result_params*)=0;
if(_mcpack2_load_mcp_get_grab_info_by_c_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_grab_info_by_c_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_grab_info_by_c_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@grab_info_t grab_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"grab_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_grab_list)& lr0=(_m_grab_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_grab_info_by_c_id_response
static void _mcpack2_load_mcp_get_grab_info_by_c_id_response_result_params(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_grab_info_by_c_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_grab_info_by_c_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_response*)>("result_params",_mcpack2_load_mcp_get_grab_info_by_c_id_response_result_params));
_mcpack2_load_mcp_get_grab_info_by_c_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_grab_info_by_c_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_grab_info_by_c_id_response_static_inited=_mcpack2_load_mcp_get_grab_info_by_c_id_response_static_init();
// @@mcp_get_grab_info_by_c_id_result_params result_params;
static void _mcpack2_load_mcp_get_grab_info_by_c_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_info_by_c_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_grab_info_by_c_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_grab_info_by_c_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_grab_info_by_c_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_grab_info_by_c_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_grab_info_by_c_id_response*)=0;
if(_mcpack2_load_mcp_get_grab_info_by_c_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_grab_info_by_c_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_grab_info_by_c_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_grab_info_by_c_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_grab_info_by_id_params
static void _mcpack2_load_mcp_get_grab_info_by_id_params_id(const mc_pack_item_t*,mcp_get_grab_info_by_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_grab_info_by_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_grab_info_by_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_id_params*)>("id",_mcpack2_load_mcp_get_grab_info_by_id_params_id));
_mcpack2_load_mcp_get_grab_info_by_id_params_readmap.create(16*1);
_mcpack2_load_mcp_get_grab_info_by_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_grab_info_by_id_params_static_inited=_mcpack2_load_mcp_get_grab_info_by_id_params_static_init();
// @@uint32_t id=in();
static void _mcpack2_load_mcp_get_grab_info_by_id_params_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_info_by_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_id));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
}
void mcp_get_grab_info_by_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_grab_info_by_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_grab_info_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_grab_info_by_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_grab_info_by_id_params*)=0;
if(_mcpack2_load_mcp_get_grab_info_by_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_grab_info_by_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_grab_info_by_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t id=in();
{
int res=mc_pack_put_uint32(pack,"id",_m_id);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_grab_info_by_id_result_params
static void _mcpack2_load_mcp_get_grab_info_by_id_result_params_result(const mc_pack_item_t*,mcp_get_grab_info_by_id_result_params*);
static void _mcpack2_load_mcp_get_grab_info_by_id_result_params_info(const mc_pack_item_t*,mcp_get_grab_info_by_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_grab_info_by_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_grab_info_by_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_id_result_params*)>("result",_mcpack2_load_mcp_get_grab_info_by_id_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_id_result_params*)>("info",_mcpack2_load_mcp_get_grab_info_by_id_result_params_info));
_mcpack2_load_mcp_get_grab_info_by_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_grab_info_by_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_grab_info_by_id_result_params_static_inited=_mcpack2_load_mcp_get_grab_info_by_id_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_get_grab_info_by_id_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_info_by_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@grab_info_t info=out();
static void _mcpack2_load_mcp_get_grab_info_by_id_result_params_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_info_by_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_info){
self->_m_info=::idl::grab_info_t::create(self->_pool);
}
self->_m_info->LoadWithoutCheck(pack);
}
void mcp_get_grab_info_by_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_grab_info_by_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_grab_info_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_grab_info_by_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_grab_info_by_id_result_params*)=0;
if(_mcpack2_load_mcp_get_grab_info_by_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_grab_info_by_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_grab_info_by_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@grab_info_t info=out();
{
mc_pack_t* subpack=mc_pack_put_object(pack,"info");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_info->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_grab_info_by_id_response
static void _mcpack2_load_mcp_get_grab_info_by_id_response_result_params(const mc_pack_item_t*,mcp_get_grab_info_by_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_grab_info_by_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_grab_info_by_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_info_by_id_response*)>("result_params",_mcpack2_load_mcp_get_grab_info_by_id_response_result_params));
_mcpack2_load_mcp_get_grab_info_by_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_grab_info_by_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_grab_info_by_id_response_static_inited=_mcpack2_load_mcp_get_grab_info_by_id_response_static_init();
// @@mcp_get_grab_info_by_id_result_params result_params;
static void _mcpack2_load_mcp_get_grab_info_by_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_info_by_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_grab_info_by_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_grab_info_by_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_grab_info_by_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_grab_info_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_grab_info_by_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_grab_info_by_id_response*)=0;
if(_mcpack2_load_mcp_get_grab_info_by_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_grab_info_by_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_grab_info_by_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_grab_info_by_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_user_grab_num_params
static void _mcpack2_load_mcp_user_grab_num_params_user_id(const mc_pack_item_t*,mcp_user_grab_num_params*);
static void _mcpack2_load_mcp_user_grab_num_params_grab_id(const mc_pack_item_t*,mcp_user_grab_num_params*);
static void _mcpack2_load_mcp_user_grab_num_params_push_channelid(const mc_pack_item_t*,mcp_user_grab_num_params*);
static void _mcpack2_load_mcp_user_grab_num_params_push_userid(const mc_pack_item_t*,mcp_user_grab_num_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_user_grab_num_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_user_grab_num_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_user_grab_num_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_params*)>("user_id",_mcpack2_load_mcp_user_grab_num_params_user_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_params*)>("grab_id",_mcpack2_load_mcp_user_grab_num_params_grab_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_params*)>("push_channelid",_mcpack2_load_mcp_user_grab_num_params_push_channelid));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_params*)>("push_userid",_mcpack2_load_mcp_user_grab_num_params_push_userid));
_mcpack2_load_mcp_user_grab_num_params_readmap.create(16*4);
_mcpack2_load_mcp_user_grab_num_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_user_grab_num_params_static_inited=_mcpack2_load_mcp_user_grab_num_params_static_init();
// @@string user_id=in();
static void _mcpack2_load_mcp_user_grab_num_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t grab_id=in();
static void _mcpack2_load_mcp_user_grab_num_params_grab_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_grab_id));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "grab_id";
}
}
// @@string push_channelid=in();
static void _mcpack2_load_mcp_user_grab_num_params_push_channelid(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "push_channelid";
}
self->_m_push_channelid.set_ptr(item->value,item->value_size-1);
}
// @@string push_userid=in();
static void _mcpack2_load_mcp_user_grab_num_params_push_userid(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "push_userid";
}
self->_m_push_userid.set_ptr(item->value,item->value_size-1);
}
void mcp_user_grab_num_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_user_grab_num_params*)=0;
do{
if(_mcpack2_load_mcp_user_grab_num_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_user_grab_num_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_user_grab_num_params*)=0;
if(_mcpack2_load_mcp_user_grab_num_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_user_grab_num_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_user_grab_num_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string user_id=in();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t grab_id=in();
{
int res=mc_pack_put_uint32(pack,"grab_id",_m_grab_id);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string push_channelid=in();
{
int res=mc_pack_put_str(pack,"push_channelid",_m_push_channelid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string push_userid=in();
{
int res=mc_pack_put_str(pack,"push_userid",_m_push_userid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_user_grab_num_result_params
static void _mcpack2_load_mcp_user_grab_num_result_params_result(const mc_pack_item_t*,mcp_user_grab_num_result_params*);
static void _mcpack2_load_mcp_user_grab_num_result_params_num(const mc_pack_item_t*,mcp_user_grab_num_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_user_grab_num_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_user_grab_num_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_user_grab_num_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_result_params*)>("result",_mcpack2_load_mcp_user_grab_num_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_result_params*)>("num",_mcpack2_load_mcp_user_grab_num_result_params_num));
_mcpack2_load_mcp_user_grab_num_result_params_readmap.create(16*2);
_mcpack2_load_mcp_user_grab_num_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_user_grab_num_result_params_static_inited=_mcpack2_load_mcp_user_grab_num_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_user_grab_num_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@string num=out();
static void _mcpack2_load_mcp_user_grab_num_result_params_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "num";
}
self->_m_num.set_ptr(item->value,item->value_size-1);
}
void mcp_user_grab_num_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_user_grab_num_result_params*)=0;
do{
if(_mcpack2_load_mcp_user_grab_num_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_user_grab_num_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_user_grab_num_result_params*)=0;
if(_mcpack2_load_mcp_user_grab_num_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_user_grab_num_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_user_grab_num_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string num=out();
{
int res=mc_pack_put_str(pack,"num",_m_num.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_user_grab_num_response
static void _mcpack2_load_mcp_user_grab_num_response_result_params(const mc_pack_item_t*,mcp_user_grab_num_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_user_grab_num_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_user_grab_num_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_user_grab_num_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_response*)>("result_params",_mcpack2_load_mcp_user_grab_num_response_result_params));
_mcpack2_load_mcp_user_grab_num_response_readmap.create(16*1);
_mcpack2_load_mcp_user_grab_num_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_user_grab_num_response_static_inited=_mcpack2_load_mcp_user_grab_num_response_static_init();
// @@mcp_user_grab_num_result_params result_params;
static void _mcpack2_load_mcp_user_grab_num_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_user_grab_num_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_user_grab_num_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_user_grab_num_response*)=0;
do{
if(_mcpack2_load_mcp_user_grab_num_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_user_grab_num_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_user_grab_num_response*)=0;
if(_mcpack2_load_mcp_user_grab_num_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_user_grab_num_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_user_grab_num_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_user_grab_num_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_user_grab_num_pre_params
static void _mcpack2_load_mcp_user_grab_num_pre_params_user_id(const mc_pack_item_t*,mcp_user_grab_num_pre_params*);
static void _mcpack2_load_mcp_user_grab_num_pre_params_grab_id(const mc_pack_item_t*,mcp_user_grab_num_pre_params*);
static void _mcpack2_load_mcp_user_grab_num_pre_params_push_channelid(const mc_pack_item_t*,mcp_user_grab_num_pre_params*);
static void _mcpack2_load_mcp_user_grab_num_pre_params_push_userid(const mc_pack_item_t*,mcp_user_grab_num_pre_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_pre_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_user_grab_num_pre_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_user_grab_num_pre_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_user_grab_num_pre_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_pre_params*)>("user_id",_mcpack2_load_mcp_user_grab_num_pre_params_user_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_pre_params*)>("grab_id",_mcpack2_load_mcp_user_grab_num_pre_params_grab_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_pre_params*)>("push_channelid",_mcpack2_load_mcp_user_grab_num_pre_params_push_channelid));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_pre_params*)>("push_userid",_mcpack2_load_mcp_user_grab_num_pre_params_push_userid));
_mcpack2_load_mcp_user_grab_num_pre_params_readmap.create(16*4);
_mcpack2_load_mcp_user_grab_num_pre_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_user_grab_num_pre_params_static_inited=_mcpack2_load_mcp_user_grab_num_pre_params_static_init();
// @@string user_id=in();
static void _mcpack2_load_mcp_user_grab_num_pre_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_pre_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t grab_id=in();
static void _mcpack2_load_mcp_user_grab_num_pre_params_grab_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_pre_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_grab_id));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "grab_id";
}
}
// @@string push_channelid=in();
static void _mcpack2_load_mcp_user_grab_num_pre_params_push_channelid(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_pre_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "push_channelid";
}
self->_m_push_channelid.set_ptr(item->value,item->value_size-1);
}
// @@string push_userid=in();
static void _mcpack2_load_mcp_user_grab_num_pre_params_push_userid(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_pre_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "push_userid";
}
self->_m_push_userid.set_ptr(item->value,item->value_size-1);
}
void mcp_user_grab_num_pre_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_user_grab_num_pre_params*)=0;
do{
if(_mcpack2_load_mcp_user_grab_num_pre_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_user_grab_num_pre_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_user_grab_num_pre_params*)=0;
if(_mcpack2_load_mcp_user_grab_num_pre_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_user_grab_num_pre_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_user_grab_num_pre_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string user_id=in();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t grab_id=in();
{
int res=mc_pack_put_uint32(pack,"grab_id",_m_grab_id);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string push_channelid=in();
{
int res=mc_pack_put_str(pack,"push_channelid",_m_push_channelid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string push_userid=in();
{
int res=mc_pack_put_str(pack,"push_userid",_m_push_userid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_user_grab_num_pre_result_params
static void _mcpack2_load_mcp_user_grab_num_pre_result_params_result(const mc_pack_item_t*,mcp_user_grab_num_pre_result_params*);
static void _mcpack2_load_mcp_user_grab_num_pre_result_params_num(const mc_pack_item_t*,mcp_user_grab_num_pre_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_pre_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_user_grab_num_pre_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_user_grab_num_pre_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_user_grab_num_pre_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_pre_result_params*)>("result",_mcpack2_load_mcp_user_grab_num_pre_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_pre_result_params*)>("num",_mcpack2_load_mcp_user_grab_num_pre_result_params_num));
_mcpack2_load_mcp_user_grab_num_pre_result_params_readmap.create(16*2);
_mcpack2_load_mcp_user_grab_num_pre_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_user_grab_num_pre_result_params_static_inited=_mcpack2_load_mcp_user_grab_num_pre_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_user_grab_num_pre_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_pre_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@string num=out();
static void _mcpack2_load_mcp_user_grab_num_pre_result_params_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_pre_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "num";
}
self->_m_num.set_ptr(item->value,item->value_size-1);
}
void mcp_user_grab_num_pre_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_user_grab_num_pre_result_params*)=0;
do{
if(_mcpack2_load_mcp_user_grab_num_pre_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_user_grab_num_pre_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_user_grab_num_pre_result_params*)=0;
if(_mcpack2_load_mcp_user_grab_num_pre_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_user_grab_num_pre_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_user_grab_num_pre_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string num=out();
{
int res=mc_pack_put_str(pack,"num",_m_num.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_user_grab_num_pre_response
static void _mcpack2_load_mcp_user_grab_num_pre_response_result_params(const mc_pack_item_t*,mcp_user_grab_num_pre_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_pre_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_user_grab_num_pre_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_user_grab_num_pre_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_user_grab_num_pre_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_grab_num_pre_response*)>("result_params",_mcpack2_load_mcp_user_grab_num_pre_response_result_params));
_mcpack2_load_mcp_user_grab_num_pre_response_readmap.create(16*1);
_mcpack2_load_mcp_user_grab_num_pre_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_user_grab_num_pre_response_static_inited=_mcpack2_load_mcp_user_grab_num_pre_response_static_init();
// @@mcp_user_grab_num_pre_result_params result_params;
static void _mcpack2_load_mcp_user_grab_num_pre_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_grab_num_pre_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_user_grab_num_pre_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_user_grab_num_pre_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_user_grab_num_pre_response*)=0;
do{
if(_mcpack2_load_mcp_user_grab_num_pre_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_user_grab_num_pre_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_user_grab_num_pre_response*)=0;
if(_mcpack2_load_mcp_user_grab_num_pre_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_user_grab_num_pre_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_user_grab_num_pre_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_user_grab_num_pre_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_set_user_rating_params
static void _mcpack2_load_mcp_set_user_rating_params_user_id(const mc_pack_item_t*,mcp_set_user_rating_params*);
static void _mcpack2_load_mcp_set_user_rating_params_c_id(const mc_pack_item_t*,mcp_set_user_rating_params*);
static void _mcpack2_load_mcp_set_user_rating_params_rating(const mc_pack_item_t*,mcp_set_user_rating_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_set_user_rating_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_set_user_rating_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_set_user_rating_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_set_user_rating_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_set_user_rating_params*)>("user_id",_mcpack2_load_mcp_set_user_rating_params_user_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_set_user_rating_params*)>("c_id",_mcpack2_load_mcp_set_user_rating_params_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_set_user_rating_params*)>("rating",_mcpack2_load_mcp_set_user_rating_params_rating));
_mcpack2_load_mcp_set_user_rating_params_readmap.create(16*3);
_mcpack2_load_mcp_set_user_rating_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_set_user_rating_params_static_inited=_mcpack2_load_mcp_set_user_rating_params_static_init();
// @@string user_id=in();
static void _mcpack2_load_mcp_set_user_rating_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_set_user_rating_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id=in();
static void _mcpack2_load_mcp_set_user_rating_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_set_user_rating_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t rating=in();
static void _mcpack2_load_mcp_set_user_rating_params_rating(__attribute__((unused)) const mc_pack_item_t* item,mcp_set_user_rating_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_rating));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "rating";
}
}
void mcp_set_user_rating_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_set_user_rating_params*)=0;
do{
if(_mcpack2_load_mcp_set_user_rating_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_set_user_rating_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_set_user_rating_params*)=0;
if(_mcpack2_load_mcp_set_user_rating_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_set_user_rating_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_set_user_rating_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string user_id=in();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t rating=in();
{
int res=mc_pack_put_uint32(pack,"rating",_m_rating);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_set_user_rating_result_params
static void _mcpack2_load_mcp_set_user_rating_result_params_result(const mc_pack_item_t*,mcp_set_user_rating_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_set_user_rating_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_set_user_rating_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_set_user_rating_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_set_user_rating_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_set_user_rating_result_params*)>("result",_mcpack2_load_mcp_set_user_rating_result_params_result));
_mcpack2_load_mcp_set_user_rating_result_params_readmap.create(16*1);
_mcpack2_load_mcp_set_user_rating_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_set_user_rating_result_params_static_inited=_mcpack2_load_mcp_set_user_rating_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_set_user_rating_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_set_user_rating_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
void mcp_set_user_rating_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_set_user_rating_result_params*)=0;
do{
if(_mcpack2_load_mcp_set_user_rating_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_set_user_rating_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_set_user_rating_result_params*)=0;
if(_mcpack2_load_mcp_set_user_rating_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_set_user_rating_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_set_user_rating_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_set_user_rating_response
static void _mcpack2_load_mcp_set_user_rating_response_result_params(const mc_pack_item_t*,mcp_set_user_rating_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_set_user_rating_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_set_user_rating_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_set_user_rating_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_set_user_rating_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_set_user_rating_response*)>("result_params",_mcpack2_load_mcp_set_user_rating_response_result_params));
_mcpack2_load_mcp_set_user_rating_response_readmap.create(16*1);
_mcpack2_load_mcp_set_user_rating_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_set_user_rating_response_static_inited=_mcpack2_load_mcp_set_user_rating_response_static_init();
// @@mcp_set_user_rating_result_params result_params;
static void _mcpack2_load_mcp_set_user_rating_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_set_user_rating_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_set_user_rating_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_set_user_rating_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_set_user_rating_response*)=0;
do{
if(_mcpack2_load_mcp_set_user_rating_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_set_user_rating_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_set_user_rating_response*)=0;
if(_mcpack2_load_mcp_set_user_rating_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_set_user_rating_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_set_user_rating_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_set_user_rating_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_user_rating_params
static void _mcpack2_load_mcp_get_user_rating_params_user_id(const mc_pack_item_t*,mcp_get_user_rating_params*);
static void _mcpack2_load_mcp_get_user_rating_params_c_id(const mc_pack_item_t*,mcp_get_user_rating_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_rating_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_user_rating_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_user_rating_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_user_rating_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_rating_params*)>("user_id",_mcpack2_load_mcp_get_user_rating_params_user_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_rating_params*)>("c_id",_mcpack2_load_mcp_get_user_rating_params_c_id));
_mcpack2_load_mcp_get_user_rating_params_readmap.create(16*2);
_mcpack2_load_mcp_get_user_rating_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_user_rating_params_static_inited=_mcpack2_load_mcp_get_user_rating_params_static_init();
// @@string user_id=in();
static void _mcpack2_load_mcp_get_user_rating_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_rating_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id=in();
static void _mcpack2_load_mcp_get_user_rating_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_rating_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_user_rating_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_user_rating_params*)=0;
do{
if(_mcpack2_load_mcp_get_user_rating_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_user_rating_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_user_rating_params*)=0;
if(_mcpack2_load_mcp_get_user_rating_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_user_rating_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_user_rating_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string user_id=in();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_user_rating_result_params
static void _mcpack2_load_mcp_get_user_rating_result_params_result(const mc_pack_item_t*,mcp_get_user_rating_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_rating_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_user_rating_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_user_rating_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_user_rating_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_rating_result_params*)>("result",_mcpack2_load_mcp_get_user_rating_result_params_result));
_mcpack2_load_mcp_get_user_rating_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_user_rating_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_user_rating_result_params_static_inited=_mcpack2_load_mcp_get_user_rating_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_get_user_rating_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_rating_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
void mcp_get_user_rating_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_user_rating_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_user_rating_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_user_rating_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_user_rating_result_params*)=0;
if(_mcpack2_load_mcp_get_user_rating_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_user_rating_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_user_rating_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_user_rating_response
static void _mcpack2_load_mcp_get_user_rating_response_result_params(const mc_pack_item_t*,mcp_get_user_rating_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_rating_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_user_rating_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_user_rating_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_user_rating_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_rating_response*)>("result_params",_mcpack2_load_mcp_get_user_rating_response_result_params));
_mcpack2_load_mcp_get_user_rating_response_readmap.create(16*1);
_mcpack2_load_mcp_get_user_rating_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_user_rating_response_static_inited=_mcpack2_load_mcp_get_user_rating_response_static_init();
// @@mcp_get_user_rating_result_params result_params;
static void _mcpack2_load_mcp_get_user_rating_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_rating_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_user_rating_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_user_rating_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_user_rating_response*)=0;
do{
if(_mcpack2_load_mcp_get_user_rating_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_user_rating_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_user_rating_response*)=0;
if(_mcpack2_load_mcp_get_user_rating_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_user_rating_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_user_rating_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_user_rating_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_calender_list_params
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_calender_list_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_calender_list_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_calender_list_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_calender_list_params*)> >_vec;
_mcpack2_load_mcp_get_calender_list_params_readmap.create(16*0);
_mcpack2_load_mcp_get_calender_list_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_calender_list_params_static_inited=_mcpack2_load_mcp_get_calender_list_params_static_init();
void mcp_get_calender_list_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_calender_list_params*)=0;
do{
if(_mcpack2_load_mcp_get_calender_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_calender_list_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_calender_list_params*)=0;
if(_mcpack2_load_mcp_get_calender_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_calender_list_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_calender_list_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_calender_list_result_params
static void _mcpack2_load_mcp_get_calender_list_result_params_result(const mc_pack_item_t*,mcp_get_calender_list_result_params*);
static void _mcpack2_load_mcp_get_calender_list_result_params_calender_list(const mc_pack_item_t*,mcp_get_calender_list_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_calender_list_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_calender_list_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_calender_list_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_calender_list_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_calender_list_result_params*)>("result",_mcpack2_load_mcp_get_calender_list_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_calender_list_result_params*)>("calender_list",_mcpack2_load_mcp_get_calender_list_result_params_calender_list));
_mcpack2_load_mcp_get_calender_list_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_calender_list_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_calender_list_result_params_static_inited=_mcpack2_load_mcp_get_calender_list_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_get_calender_list_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_calender_list_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@calender_info_t calender_list=out(),array(0);
static void _mcpack2_load_mcp_get_calender_list_result_params_calender_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_calender_list_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "calender_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_calender_list)) lp0=&(self->_m_calender_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "calender_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "calender_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "calender_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_calender_list_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_calender_list_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_calender_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_calender_list_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_calender_list_result_params*)=0;
if(_mcpack2_load_mcp_get_calender_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_calender_list_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_calender_list_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@calender_info_t calender_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"calender_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_calender_list)& lr0=(_m_calender_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_calender_list_response
static void _mcpack2_load_mcp_get_calender_list_response_result_params(const mc_pack_item_t*,mcp_get_calender_list_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_calender_list_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_calender_list_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_calender_list_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_calender_list_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_calender_list_response*)>("result_params",_mcpack2_load_mcp_get_calender_list_response_result_params));
_mcpack2_load_mcp_get_calender_list_response_readmap.create(16*1);
_mcpack2_load_mcp_get_calender_list_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_calender_list_response_static_inited=_mcpack2_load_mcp_get_calender_list_response_static_init();
// @@mcp_get_calender_list_result_params result_params;
static void _mcpack2_load_mcp_get_calender_list_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_calender_list_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_calender_list_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_calender_list_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_calender_list_response*)=0;
do{
if(_mcpack2_load_mcp_get_calender_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_calender_list_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_calender_list_response*)=0;
if(_mcpack2_load_mcp_get_calender_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_calender_list_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_calender_list_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_calender_list_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_mixed_topic_id_params
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_topic_id(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_page(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_page_size(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_params*)>("topic_id",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_topic_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_params*)>("page",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_params*)>("page_size",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_page_size));
_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_readmap.create(16*3);
_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_static_inited=_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_static_init();
// @@string topic_id=in();
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_topic_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "topic_id";
}
self->_m_topic_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_content_list_by_mixed_topic_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_mixed_topic_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_params*)=0;
if(_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_mixed_topic_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_mixed_topic_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string topic_id=in();
{
int res=mc_pack_put_str(pack,"topic_id",_m_topic_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_mixed_topic_id_result_params
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_count_soft(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_count_theme(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_count_song(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_soft_info_list(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_theme_info_list(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_music_info_list(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*)>("count_soft",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_count_soft));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*)>("count_theme",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_count_theme));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*)>("count_song",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_count_song));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*)>("soft_info_list",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_soft_info_list));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*)>("theme_info_list",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_theme_info_list));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*)>("music_info_list",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_music_info_list));
_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_readmap.create(16*6);
_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_static_inited=_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_static_init();
// @@uint32_t count_soft=out();
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_count_soft(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count_soft));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count_soft";
}
}
// @@uint32_t count_theme=out();
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_count_theme(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count_theme));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count_theme";
}
}
// @@uint32_t count_song=out();
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_count_song(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count_song));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count_song";
}
}
// @@soft_info_t soft_info_list=out(),array(0);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_soft_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id_result_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_soft_info_list)) lp0=&(self->_m_soft_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@theme_info_t theme_info_list=out(),array(0);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_theme_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id_result_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_theme_info_list)) lp0=&(self->_m_theme_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@music_info_t music_info_list=out(),array(0);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_music_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id_result_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "music_info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_music_info_list)) lp0=&(self->_m_music_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "music_info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "music_info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "music_info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_list_by_mixed_topic_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_mixed_topic_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_result_params*)=0;
if(_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_mixed_topic_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_mixed_topic_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count_soft=out();
{
int res=mc_pack_put_uint32(pack,"count_soft",_m_count_soft);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t count_theme=out();
{
int res=mc_pack_put_uint32(pack,"count_theme",_m_count_theme);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t count_song=out();
{
int res=mc_pack_put_uint32(pack,"count_song",_m_count_song);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@soft_info_t soft_info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"soft_info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_soft_info_list)& lr0=(_m_soft_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@theme_info_t theme_info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"theme_info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_theme_info_list)& lr0=(_m_theme_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@music_info_t music_info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"music_info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_music_info_list)& lr0=(_m_music_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_mixed_topic_id_response
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_response_result_params(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_response*)>("result_params",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_response_result_params));
_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_response_static_inited=_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_response_static_init();
// @@mcp_get_content_list_by_mixed_topic_id_result_params result_params;
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_list_by_mixed_topic_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_list_by_mixed_topic_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_mixed_topic_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id_response*)=0;
if(_mcpack2_load_mcp_get_content_list_by_mixed_topic_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_mixed_topic_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_mixed_topic_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_list_by_mixed_topic_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_mixed_topic_id1_params
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_topic_id(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_page(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_page_size(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_params*)>("topic_id",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_topic_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_params*)>("page",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_params*)>("page_size",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_page_size));
_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_readmap.create(16*3);
_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_static_inited=_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_static_init();
// @@string topic_id=in();
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_topic_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id1_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "topic_id";
}
self->_m_topic_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id1_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id1_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_content_list_by_mixed_topic_id1_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_mixed_topic_id1_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_params*)=0;
if(_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_mixed_topic_id1_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_mixed_topic_id1_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string topic_id=in();
{
int res=mc_pack_put_str(pack,"topic_id",_m_topic_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_mixed_topic_id1_result_params
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_num1(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_num2(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_num3(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_id(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_name(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_soft_info_list(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_theme_info_list(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_music_id(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*)>("col_num1",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_num1));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*)>("col_num2",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_num2));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*)>("col_num3",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_num3));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*)>("col_id",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*)>("col_name",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*)>("soft_info_list",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_soft_info_list));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*)>("theme_info_list",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_theme_info_list));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*)>("music_id",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_music_id));
_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_readmap.create(16*8);
_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_static_inited=_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_static_init();
// @@uint32_t col_num1=out();
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_num1(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id1_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_col_num1));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_num1";
}
}
// @@uint32_t col_num2=out();
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_num2(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id1_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_col_num2));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_num2";
}
}
// @@uint32_t col_num3=out();
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_num3(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id1_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_col_num3));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_num3";
}
}
// @@string col_id=out(),array(0);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id1_result_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "col_id";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_col_id)) lp0=&(self->_m_col_id);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "col_id";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_id";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "col_id";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string col_name=out(),array(0);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_col_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id1_result_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "col_name";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_col_name)) lp0=&(self->_m_col_name);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "col_name";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_name";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "col_name";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@soft_info_t soft_info_list=out(),array(0);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_soft_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id1_result_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_soft_info_list)) lp0=&(self->_m_soft_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@theme_info_t theme_info_list=out(),array(0);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_theme_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id1_result_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_theme_info_list)) lp0=&(self->_m_theme_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "theme_info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string music_id=out(),array(0);
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_music_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id1_result_params* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "music_id";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_music_id)) lp0=&(self->_m_music_id);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "music_id";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "music_id";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "music_id";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_list_by_mixed_topic_id1_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_mixed_topic_id1_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_result_params*)=0;
if(_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_mixed_topic_id1_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_mixed_topic_id1_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t col_num1=out();
{
int res=mc_pack_put_uint32(pack,"col_num1",_m_col_num1);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t col_num2=out();
{
int res=mc_pack_put_uint32(pack,"col_num2",_m_col_num2);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t col_num3=out();
{
int res=mc_pack_put_uint32(pack,"col_num3",_m_col_num3);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string col_id=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"col_id");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_col_id)& lr0=(_m_col_id);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string col_name=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"col_name");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_col_name)& lr0=(_m_col_name);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@soft_info_t soft_info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"soft_info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_soft_info_list)& lr0=(_m_soft_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@theme_info_t theme_info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"theme_info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_theme_info_list)& lr0=(_m_theme_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string music_id=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"music_id");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_music_id)& lr0=(_m_music_id);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_by_mixed_topic_id1_response
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_response_result_params(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_response*)>("result_params",_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_response_result_params));
_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_response_static_inited=_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_response_static_init();
// @@mcp_get_content_list_by_mixed_topic_id1_result_params result_params;
static void _mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_by_mixed_topic_id1_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_list_by_mixed_topic_id1_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_list_by_mixed_topic_id1_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_by_mixed_topic_id1_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_by_mixed_topic_id1_response*)=0;
if(_mcpack2_load_mcp_get_content_list_by_mixed_topic_id1_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_by_mixed_topic_id1_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_by_mixed_topic_id1_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_list_by_mixed_topic_id1_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_user_grab_num_params
static void _mcpack2_load_mcp_get_user_grab_num_params_user_id(const mc_pack_item_t*,mcp_get_user_grab_num_params*);
static void _mcpack2_load_mcp_get_user_grab_num_params_grab_id(const mc_pack_item_t*,mcp_get_user_grab_num_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_user_grab_num_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_user_grab_num_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_params*)>("user_id",_mcpack2_load_mcp_get_user_grab_num_params_user_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_params*)>("grab_id",_mcpack2_load_mcp_get_user_grab_num_params_grab_id));
_mcpack2_load_mcp_get_user_grab_num_params_readmap.create(16*2);
_mcpack2_load_mcp_get_user_grab_num_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_user_grab_num_params_static_inited=_mcpack2_load_mcp_get_user_grab_num_params_static_init();
// @@string user_id=in();
static void _mcpack2_load_mcp_get_user_grab_num_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_grab_num_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t grab_id=in();
static void _mcpack2_load_mcp_get_user_grab_num_params_grab_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_grab_num_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_grab_id));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "grab_id";
}
}
void mcp_get_user_grab_num_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_user_grab_num_params*)=0;
do{
if(_mcpack2_load_mcp_get_user_grab_num_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_user_grab_num_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_user_grab_num_params*)=0;
if(_mcpack2_load_mcp_get_user_grab_num_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_user_grab_num_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_user_grab_num_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string user_id=in();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t grab_id=in();
{
int res=mc_pack_put_uint32(pack,"grab_id",_m_grab_id);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_user_grab_num_result_params
static void _mcpack2_load_mcp_get_user_grab_num_result_params_result(const mc_pack_item_t*,mcp_get_user_grab_num_result_params*);
static void _mcpack2_load_mcp_get_user_grab_num_result_params_num(const mc_pack_item_t*,mcp_get_user_grab_num_result_params*);
static void _mcpack2_load_mcp_get_user_grab_num_result_params_occupy(const mc_pack_item_t*,mcp_get_user_grab_num_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_user_grab_num_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_user_grab_num_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_result_params*)>("result",_mcpack2_load_mcp_get_user_grab_num_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_result_params*)>("num",_mcpack2_load_mcp_get_user_grab_num_result_params_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_result_params*)>("occupy",_mcpack2_load_mcp_get_user_grab_num_result_params_occupy));
_mcpack2_load_mcp_get_user_grab_num_result_params_readmap.create(16*3);
_mcpack2_load_mcp_get_user_grab_num_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_user_grab_num_result_params_static_inited=_mcpack2_load_mcp_get_user_grab_num_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_get_user_grab_num_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_grab_num_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@string num=out();
static void _mcpack2_load_mcp_get_user_grab_num_result_params_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_grab_num_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "num";
}
self->_m_num.set_ptr(item->value,item->value_size-1);
}
// @@int32_t occupy=out();
static void _mcpack2_load_mcp_get_user_grab_num_result_params_occupy(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_grab_num_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_occupy));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "occupy";
}
}
void mcp_get_user_grab_num_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_user_grab_num_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_user_grab_num_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_user_grab_num_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_user_grab_num_result_params*)=0;
if(_mcpack2_load_mcp_get_user_grab_num_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_user_grab_num_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_user_grab_num_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string num=out();
{
int res=mc_pack_put_str(pack,"num",_m_num.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int32_t occupy=out();
{
int res=mc_pack_put_int32(pack,"occupy",_m_occupy);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_user_grab_num_response
static void _mcpack2_load_mcp_get_user_grab_num_response_result_params(const mc_pack_item_t*,mcp_get_user_grab_num_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_user_grab_num_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_user_grab_num_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_response*)>("result_params",_mcpack2_load_mcp_get_user_grab_num_response_result_params));
_mcpack2_load_mcp_get_user_grab_num_response_readmap.create(16*1);
_mcpack2_load_mcp_get_user_grab_num_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_user_grab_num_response_static_inited=_mcpack2_load_mcp_get_user_grab_num_response_static_init();
// @@mcp_get_user_grab_num_result_params result_params;
static void _mcpack2_load_mcp_get_user_grab_num_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_grab_num_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_user_grab_num_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_user_grab_num_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_user_grab_num_response*)=0;
do{
if(_mcpack2_load_mcp_get_user_grab_num_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_user_grab_num_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_user_grab_num_response*)=0;
if(_mcpack2_load_mcp_get_user_grab_num_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_user_grab_num_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_user_grab_num_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_user_grab_num_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_set_recently_played_params
static void _mcpack2_load_mcp_set_recently_played_params_u_id(const mc_pack_item_t*,mcp_set_recently_played_params*);
static void _mcpack2_load_mcp_set_recently_played_params_c_id(const mc_pack_item_t*,mcp_set_recently_played_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_set_recently_played_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_set_recently_played_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_set_recently_played_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_set_recently_played_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_set_recently_played_params*)>("u_id",_mcpack2_load_mcp_set_recently_played_params_u_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_set_recently_played_params*)>("c_id",_mcpack2_load_mcp_set_recently_played_params_c_id));
_mcpack2_load_mcp_set_recently_played_params_readmap.create(16*2);
_mcpack2_load_mcp_set_recently_played_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_set_recently_played_params_static_inited=_mcpack2_load_mcp_set_recently_played_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_set_recently_played_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_set_recently_played_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id=in();
static void _mcpack2_load_mcp_set_recently_played_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_set_recently_played_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
void mcp_set_recently_played_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_set_recently_played_params*)=0;
do{
if(_mcpack2_load_mcp_set_recently_played_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_set_recently_played_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_set_recently_played_params*)=0;
if(_mcpack2_load_mcp_set_recently_played_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_set_recently_played_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_set_recently_played_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_set_recently_played_result_params
static void _mcpack2_load_mcp_set_recently_played_result_params_result(const mc_pack_item_t*,mcp_set_recently_played_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_set_recently_played_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_set_recently_played_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_set_recently_played_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_set_recently_played_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_set_recently_played_result_params*)>("result",_mcpack2_load_mcp_set_recently_played_result_params_result));
_mcpack2_load_mcp_set_recently_played_result_params_readmap.create(16*1);
_mcpack2_load_mcp_set_recently_played_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_set_recently_played_result_params_static_inited=_mcpack2_load_mcp_set_recently_played_result_params_static_init();
// @@int32_t result=out();
static void _mcpack2_load_mcp_set_recently_played_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_set_recently_played_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
void mcp_set_recently_played_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_set_recently_played_result_params*)=0;
do{
if(_mcpack2_load_mcp_set_recently_played_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_set_recently_played_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_set_recently_played_result_params*)=0;
if(_mcpack2_load_mcp_set_recently_played_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_set_recently_played_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_set_recently_played_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t result=out();
{
int res=mc_pack_put_int32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_set_recently_played_response
static void _mcpack2_load_mcp_set_recently_played_response_result_params(const mc_pack_item_t*,mcp_set_recently_played_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_set_recently_played_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_set_recently_played_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_set_recently_played_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_set_recently_played_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_set_recently_played_response*)>("result_params",_mcpack2_load_mcp_set_recently_played_response_result_params));
_mcpack2_load_mcp_set_recently_played_response_readmap.create(16*1);
_mcpack2_load_mcp_set_recently_played_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_set_recently_played_response_static_inited=_mcpack2_load_mcp_set_recently_played_response_static_init();
// @@mcp_set_recently_played_result_params result_params;
static void _mcpack2_load_mcp_set_recently_played_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_set_recently_played_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_set_recently_played_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_set_recently_played_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_set_recently_played_response*)=0;
do{
if(_mcpack2_load_mcp_set_recently_played_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_set_recently_played_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_set_recently_played_response*)=0;
if(_mcpack2_load_mcp_set_recently_played_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_set_recently_played_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_set_recently_played_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_set_recently_played_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_recently_played_by_uid_params
static void _mcpack2_load_mcp_get_recently_played_by_uid_params_u_id(const mc_pack_item_t*,mcp_get_recently_played_by_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_recently_played_by_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_recently_played_by_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_params*)>("u_id",_mcpack2_load_mcp_get_recently_played_by_uid_params_u_id));
_mcpack2_load_mcp_get_recently_played_by_uid_params_readmap.create(16*1);
_mcpack2_load_mcp_get_recently_played_by_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_recently_played_by_uid_params_static_inited=_mcpack2_load_mcp_get_recently_played_by_uid_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_get_recently_played_by_uid_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_recently_played_by_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_recently_played_by_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_params*)=0;
do{
if(_mcpack2_load_mcp_get_recently_played_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_recently_played_by_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_params*)=0;
if(_mcpack2_load_mcp_get_recently_played_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_recently_played_by_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_recently_played_by_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_recently_played_by_uid_result_params
static void _mcpack2_load_mcp_get_recently_played_by_uid_result_params_count(const mc_pack_item_t*,mcp_get_recently_played_by_uid_result_params*);
static void _mcpack2_load_mcp_get_recently_played_by_uid_result_params_info_list(const mc_pack_item_t*,mcp_get_recently_played_by_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_recently_played_by_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_recently_played_by_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_result_params*)>("count",_mcpack2_load_mcp_get_recently_played_by_uid_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_result_params*)>("info_list",_mcpack2_load_mcp_get_recently_played_by_uid_result_params_info_list));
_mcpack2_load_mcp_get_recently_played_by_uid_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_recently_played_by_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_recently_played_by_uid_result_params_static_inited=_mcpack2_load_mcp_get_recently_played_by_uid_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_recently_played_by_uid_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_recently_played_by_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string info_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_recently_played_by_uid_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_recently_played_by_uid_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_recently_played_by_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_recently_played_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_recently_played_by_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_result_params*)=0;
if(_mcpack2_load_mcp_get_recently_played_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_recently_played_by_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_recently_played_by_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_recently_played_by_uid_response
static void _mcpack2_load_mcp_get_recently_played_by_uid_response_result_params(const mc_pack_item_t*,mcp_get_recently_played_by_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_recently_played_by_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_recently_played_by_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_response*)>("result_params",_mcpack2_load_mcp_get_recently_played_by_uid_response_result_params));
_mcpack2_load_mcp_get_recently_played_by_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_get_recently_played_by_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_recently_played_by_uid_response_static_inited=_mcpack2_load_mcp_get_recently_played_by_uid_response_static_init();
// @@mcp_get_recently_played_by_uid_result_params result_params;
static void _mcpack2_load_mcp_get_recently_played_by_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_recently_played_by_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_recently_played_by_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_recently_played_by_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_response*)=0;
do{
if(_mcpack2_load_mcp_get_recently_played_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_recently_played_by_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_recently_played_by_uid_response*)=0;
if(_mcpack2_load_mcp_get_recently_played_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_recently_played_by_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_recently_played_by_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_recently_played_by_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_game_to_favorite_params
static void _mcpack2_load_mcp_add_game_to_favorite_params_u_id(const mc_pack_item_t*,mcp_add_game_to_favorite_params*);
static void _mcpack2_load_mcp_add_game_to_favorite_params_c_id(const mc_pack_item_t*,mcp_add_game_to_favorite_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_game_to_favorite_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_game_to_favorite_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_game_to_favorite_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_game_to_favorite_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_game_to_favorite_params*)>("u_id",_mcpack2_load_mcp_add_game_to_favorite_params_u_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_game_to_favorite_params*)>("c_id",_mcpack2_load_mcp_add_game_to_favorite_params_c_id));
_mcpack2_load_mcp_add_game_to_favorite_params_readmap.create(16*2);
_mcpack2_load_mcp_add_game_to_favorite_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_game_to_favorite_params_static_inited=_mcpack2_load_mcp_add_game_to_favorite_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_add_game_to_favorite_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_game_to_favorite_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id=in();
static void _mcpack2_load_mcp_add_game_to_favorite_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_game_to_favorite_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
void mcp_add_game_to_favorite_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_game_to_favorite_params*)=0;
do{
if(_mcpack2_load_mcp_add_game_to_favorite_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_game_to_favorite_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_game_to_favorite_params*)=0;
if(_mcpack2_load_mcp_add_game_to_favorite_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_game_to_favorite_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_game_to_favorite_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_game_to_favorite_result_params
static void _mcpack2_load_mcp_add_game_to_favorite_result_params_result(const mc_pack_item_t*,mcp_add_game_to_favorite_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_game_to_favorite_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_game_to_favorite_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_game_to_favorite_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_game_to_favorite_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_game_to_favorite_result_params*)>("result",_mcpack2_load_mcp_add_game_to_favorite_result_params_result));
_mcpack2_load_mcp_add_game_to_favorite_result_params_readmap.create(16*1);
_mcpack2_load_mcp_add_game_to_favorite_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_game_to_favorite_result_params_static_inited=_mcpack2_load_mcp_add_game_to_favorite_result_params_static_init();
// @@uint32_t result=out();
static void _mcpack2_load_mcp_add_game_to_favorite_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_game_to_favorite_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
void mcp_add_game_to_favorite_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_game_to_favorite_result_params*)=0;
do{
if(_mcpack2_load_mcp_add_game_to_favorite_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_game_to_favorite_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_game_to_favorite_result_params*)=0;
if(_mcpack2_load_mcp_add_game_to_favorite_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_game_to_favorite_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_game_to_favorite_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t result=out();
{
int res=mc_pack_put_uint32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_game_to_favorite_response
static void _mcpack2_load_mcp_add_game_to_favorite_response_result_params(const mc_pack_item_t*,mcp_add_game_to_favorite_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_game_to_favorite_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_game_to_favorite_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_game_to_favorite_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_game_to_favorite_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_game_to_favorite_response*)>("result_params",_mcpack2_load_mcp_add_game_to_favorite_response_result_params));
_mcpack2_load_mcp_add_game_to_favorite_response_readmap.create(16*1);
_mcpack2_load_mcp_add_game_to_favorite_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_game_to_favorite_response_static_inited=_mcpack2_load_mcp_add_game_to_favorite_response_static_init();
// @@mcp_add_game_to_favorite_result_params result_params;
static void _mcpack2_load_mcp_add_game_to_favorite_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_game_to_favorite_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_add_game_to_favorite_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_add_game_to_favorite_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_game_to_favorite_response*)=0;
do{
if(_mcpack2_load_mcp_add_game_to_favorite_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_game_to_favorite_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_game_to_favorite_response*)=0;
if(_mcpack2_load_mcp_add_game_to_favorite_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_game_to_favorite_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_game_to_favorite_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_add_game_to_favorite_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_favoraite_by_uid_params
static void _mcpack2_load_mcp_get_favoraite_by_uid_params_u_id(const mc_pack_item_t*,mcp_get_favoraite_by_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_favoraite_by_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_favoraite_by_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_params*)>("u_id",_mcpack2_load_mcp_get_favoraite_by_uid_params_u_id));
_mcpack2_load_mcp_get_favoraite_by_uid_params_readmap.create(16*1);
_mcpack2_load_mcp_get_favoraite_by_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_favoraite_by_uid_params_static_inited=_mcpack2_load_mcp_get_favoraite_by_uid_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_get_favoraite_by_uid_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favoraite_by_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_favoraite_by_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_params*)=0;
do{
if(_mcpack2_load_mcp_get_favoraite_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_favoraite_by_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_params*)=0;
if(_mcpack2_load_mcp_get_favoraite_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_favoraite_by_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_favoraite_by_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_favoraite_by_uid_result_params
static void _mcpack2_load_mcp_get_favoraite_by_uid_result_params_count(const mc_pack_item_t*,mcp_get_favoraite_by_uid_result_params*);
static void _mcpack2_load_mcp_get_favoraite_by_uid_result_params_info_list(const mc_pack_item_t*,mcp_get_favoraite_by_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_favoraite_by_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_favoraite_by_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_result_params*)>("count",_mcpack2_load_mcp_get_favoraite_by_uid_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_result_params*)>("info_list",_mcpack2_load_mcp_get_favoraite_by_uid_result_params_info_list));
_mcpack2_load_mcp_get_favoraite_by_uid_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_favoraite_by_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_favoraite_by_uid_result_params_static_inited=_mcpack2_load_mcp_get_favoraite_by_uid_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_favoraite_by_uid_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favoraite_by_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string info_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_favoraite_by_uid_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favoraite_by_uid_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_favoraite_by_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_favoraite_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_favoraite_by_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_result_params*)=0;
if(_mcpack2_load_mcp_get_favoraite_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_favoraite_by_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_favoraite_by_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_favoraite_by_uid_response
static void _mcpack2_load_mcp_get_favoraite_by_uid_response_result_params(const mc_pack_item_t*,mcp_get_favoraite_by_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_favoraite_by_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_favoraite_by_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_response*)>("result_params",_mcpack2_load_mcp_get_favoraite_by_uid_response_result_params));
_mcpack2_load_mcp_get_favoraite_by_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_get_favoraite_by_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_favoraite_by_uid_response_static_inited=_mcpack2_load_mcp_get_favoraite_by_uid_response_static_init();
// @@mcp_get_favoraite_by_uid_result_params result_params;
static void _mcpack2_load_mcp_get_favoraite_by_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favoraite_by_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_favoraite_by_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_favoraite_by_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_response*)=0;
do{
if(_mcpack2_load_mcp_get_favoraite_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_favoraite_by_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_favoraite_by_uid_response*)=0;
if(_mcpack2_load_mcp_get_favoraite_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_favoraite_by_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_favoraite_by_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_favoraite_by_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_H5_latest_on_shelf_by_date_params
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_unit_num(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_params*);
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_unit_times(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_params*)>("unit_num",_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_params*)>("unit_times",_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_unit_times));
_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_readmap.create(16*2);
_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_static_inited=_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_static_init();
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_latest_on_shelf_by_date_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_latest_on_shelf_by_date_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_H5_latest_on_shelf_by_date_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_params*)=0;
do{
if(_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_H5_latest_on_shelf_by_date_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_params*)=0;
if(_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_H5_latest_on_shelf_by_date_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_H5_latest_on_shelf_by_date_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_H5_latest_on_shelf_by_date_result_params
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_count(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_result_params*);
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_info_list(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_result_params*)>("count",_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_result_params*)>("info_list",_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_info_list));
_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_static_inited=_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_latest_on_shelf_by_date_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string info_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_latest_on_shelf_by_date_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_H5_latest_on_shelf_by_date_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_H5_latest_on_shelf_by_date_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_result_params*)=0;
if(_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_H5_latest_on_shelf_by_date_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_H5_latest_on_shelf_by_date_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_H5_latest_on_shelf_by_date_response
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_response_result_params(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_response*)>("result_params",_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_response_result_params));
_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_response_readmap.create(16*1);
_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_response_static_inited=_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_response_static_init();
// @@mcp_get_H5_latest_on_shelf_by_date_result_params result_params;
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_latest_on_shelf_by_date_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_H5_latest_on_shelf_by_date_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_H5_latest_on_shelf_by_date_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_response*)=0;
do{
if(_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_H5_latest_on_shelf_by_date_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_response*)=0;
if(_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_H5_latest_on_shelf_by_date_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_H5_latest_on_shelf_by_date_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_H5_latest_on_shelf_by_date_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_H5_latest_on_shelf_by_date_and_type_params
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_unit_num(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_params*);
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_unit_times(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_params*);
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_content_type(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_params*)>("unit_num",_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_params*)>("unit_times",_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_unit_times));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_params*)>("content_type",_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_content_type));
_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_readmap.create(16*3);
_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_static_inited=_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_static_init();
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_latest_on_shelf_by_date_and_type_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_latest_on_shelf_by_date_and_type_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
// @@string content_type=in();
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_content_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_latest_on_shelf_by_date_and_type_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_type";
}
self->_m_content_type.set_ptr(item->value,item->value_size-1);
}
void mcp_get_H5_latest_on_shelf_by_date_and_type_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_params*)=0;
do{
if(_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_H5_latest_on_shelf_by_date_and_type_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_params*)=0;
if(_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_H5_latest_on_shelf_by_date_and_type_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_H5_latest_on_shelf_by_date_and_type_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_type=in();
{
int res=mc_pack_put_str(pack,"content_type",_m_content_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_H5_latest_on_shelf_by_date_and_type_result_params
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_count(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_result_params*);
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_info_list(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_result_params*)>("count",_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_result_params*)>("info_list",_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_info_list));
_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_static_inited=_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_latest_on_shelf_by_date_and_type_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string info_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_latest_on_shelf_by_date_and_type_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_result_params*)=0;
if(_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_H5_latest_on_shelf_by_date_and_type_response
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_response_result_params(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_response*)>("result_params",_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_response_result_params));
_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_response_readmap.create(16*1);
_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_response_static_inited=_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_response_static_init();
// @@mcp_get_H5_latest_on_shelf_by_date_and_type_result_params result_params;
static void _mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_latest_on_shelf_by_date_and_type_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_H5_latest_on_shelf_by_date_and_type_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_H5_latest_on_shelf_by_date_and_type_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_response*)=0;
do{
if(_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_H5_latest_on_shelf_by_date_and_type_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_H5_latest_on_shelf_by_date_and_type_response*)=0;
if(_mcpack2_load_mcp_get_H5_latest_on_shelf_by_date_and_type_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_H5_latest_on_shelf_by_date_and_type_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_H5_latest_on_shelf_by_date_and_type_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_H5_latest_on_shelf_by_date_and_type_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_H5_info_list_by_col_id_params
static void _mcpack2_load_mcp_get_H5_info_list_by_col_id_params_unit_num(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_params*);
static void _mcpack2_load_mcp_get_H5_info_list_by_col_id_params_unit_times(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_params*);
static void _mcpack2_load_mcp_get_H5_info_list_by_col_id_params_col_id(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_H5_info_list_by_col_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_H5_info_list_by_col_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_params*)>("unit_num",_mcpack2_load_mcp_get_H5_info_list_by_col_id_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_params*)>("unit_times",_mcpack2_load_mcp_get_H5_info_list_by_col_id_params_unit_times));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_params*)>("col_id",_mcpack2_load_mcp_get_H5_info_list_by_col_id_params_col_id));
_mcpack2_load_mcp_get_H5_info_list_by_col_id_params_readmap.create(16*3);
_mcpack2_load_mcp_get_H5_info_list_by_col_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_H5_info_list_by_col_id_params_static_inited=_mcpack2_load_mcp_get_H5_info_list_by_col_id_params_static_init();
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_H5_info_list_by_col_id_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_info_list_by_col_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_H5_info_list_by_col_id_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_info_list_by_col_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
// @@string col_id=in();
static void _mcpack2_load_mcp_get_H5_info_list_by_col_id_params_col_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_info_list_by_col_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_id";
}
self->_m_col_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_H5_info_list_by_col_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_H5_info_list_by_col_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_H5_info_list_by_col_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_params*)=0;
if(_mcpack2_load_mcp_get_H5_info_list_by_col_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_H5_info_list_by_col_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_H5_info_list_by_col_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string col_id=in();
{
int res=mc_pack_put_str(pack,"col_id",_m_col_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_H5_info_list_by_col_id_result_params
static void _mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_count(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_result_params*);
static void _mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_info_list(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_result_params*)>("count",_mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_result_params*)>("info_list",_mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_info_list));
_mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_static_inited=_mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_info_list_by_col_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string info_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_info_list_by_col_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_H5_info_list_by_col_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_H5_info_list_by_col_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_result_params*)=0;
if(_mcpack2_load_mcp_get_H5_info_list_by_col_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_H5_info_list_by_col_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_H5_info_list_by_col_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_H5_info_list_by_col_id_response
static void _mcpack2_load_mcp_get_H5_info_list_by_col_id_response_result_params(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_H5_info_list_by_col_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_H5_info_list_by_col_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_response*)>("result_params",_mcpack2_load_mcp_get_H5_info_list_by_col_id_response_result_params));
_mcpack2_load_mcp_get_H5_info_list_by_col_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_H5_info_list_by_col_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_H5_info_list_by_col_id_response_static_inited=_mcpack2_load_mcp_get_H5_info_list_by_col_id_response_static_init();
// @@mcp_get_H5_info_list_by_col_id_result_params result_params;
static void _mcpack2_load_mcp_get_H5_info_list_by_col_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_H5_info_list_by_col_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_H5_info_list_by_col_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_H5_info_list_by_col_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_H5_info_list_by_col_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_H5_info_list_by_col_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_H5_info_list_by_col_id_response*)=0;
if(_mcpack2_load_mcp_get_H5_info_list_by_col_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_H5_info_list_by_col_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_H5_info_list_by_col_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_H5_info_list_by_col_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_imgurls_and_favorite_by_uid_cid_params
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_uid(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_params*);
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_cid(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_params*)>("uid",_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_uid));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_params*)>("cid",_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_cid));
_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_readmap.create(16*2);
_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_static_inited=_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_static_init();
// @@string uid=in();
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_uid(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_imgurls_and_favorite_by_uid_cid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "uid";
}
self->_m_uid.set_ptr(item->value,item->value_size-1);
}
// @@string cid=in();
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_cid(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_imgurls_and_favorite_by_uid_cid_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "cid";
}
self->_m_cid.set_ptr(item->value,item->value_size-1);
}
void mcp_get_imgurls_and_favorite_by_uid_cid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_params*)=0;
do{
if(_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_imgurls_and_favorite_by_uid_cid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_params*)=0;
if(_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_imgurls_and_favorite_by_uid_cid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_imgurls_and_favorite_by_uid_cid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string uid=in();
{
int res=mc_pack_put_str(pack,"uid",_m_uid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string cid=in();
{
int res=mc_pack_put_str(pack,"cid",_m_cid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_imgurls_and_favorite_by_uid_cid_result_params
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_icon_url(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*);
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_xc_url1(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*);
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_xc_url2(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*);
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_count(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*);
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_xq_url(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*);
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_is_favorite(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*)>("icon_url",_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_icon_url));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*)>("xc_url1",_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_xc_url1));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*)>("xc_url2",_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_xc_url2));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*)>("count",_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*)>("xq_url",_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_xq_url));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*)>("is_favorite",_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_is_favorite));
_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_readmap.create(16*6);
_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_static_inited=_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_static_init();
// @@string icon_url=out();
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_icon_url(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_imgurls_and_favorite_by_uid_cid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "icon_url";
}
self->_m_icon_url.set_ptr(item->value,item->value_size-1);
}
// @@string xc_url1=out();
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_xc_url1(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_imgurls_and_favorite_by_uid_cid_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "xc_url1";
}
self->_m_xc_url1.set_ptr(item->value,item->value_size-1);
}
// @@string xc_url2=out();
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_xc_url2(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_imgurls_and_favorite_by_uid_cid_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "xc_url2";
}
self->_m_xc_url2.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_imgurls_and_favorite_by_uid_cid_result_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string xq_url=out(),array(0);
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_xq_url(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_imgurls_and_favorite_by_uid_cid_result_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "xq_url";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_xq_url)) lp0=&(self->_m_xq_url);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "xq_url";
}
for(int i0=0;i0<size0;i0++){
if(item0.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "xq_url";
}
lp0->MutableGetWithoutCheck(i0)->set_ptr(item0.value,item0.value_size-1);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "xq_url";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@uint32_t is_favorite=out();
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_is_favorite(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_imgurls_and_favorite_by_uid_cid_result_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_is_favorite));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "is_favorite";
}
}
void mcp_get_imgurls_and_favorite_by_uid_cid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_imgurls_and_favorite_by_uid_cid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_result_params*)=0;
if(_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_imgurls_and_favorite_by_uid_cid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_imgurls_and_favorite_by_uid_cid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string icon_url=out();
{
int res=mc_pack_put_str(pack,"icon_url",_m_icon_url.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string xc_url1=out();
{
int res=mc_pack_put_str(pack,"xc_url1",_m_xc_url1.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string xc_url2=out();
{
int res=mc_pack_put_str(pack,"xc_url2",_m_xc_url2.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string xq_url=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"xq_url");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_xq_url)& lr0=(_m_xq_url);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_str(pack0,0,lr0.GetWithoutCheck(i0).get());
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@uint32_t is_favorite=out();
{
int res=mc_pack_put_uint32(pack,"is_favorite",_m_is_favorite);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_imgurls_and_favorite_by_uid_cid_response
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_response_result_params(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_response*)>("result_params",_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_response_result_params));
_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_response_readmap.create(16*1);
_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_response_static_inited=_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_response_static_init();
// @@mcp_get_imgurls_and_favorite_by_uid_cid_result_params result_params;
static void _mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_imgurls_and_favorite_by_uid_cid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_imgurls_and_favorite_by_uid_cid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_imgurls_and_favorite_by_uid_cid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_response*)=0;
do{
if(_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_imgurls_and_favorite_by_uid_cid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_imgurls_and_favorite_by_uid_cid_response*)=0;
if(_mcpack2_load_mcp_get_imgurls_and_favorite_by_uid_cid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_imgurls_and_favorite_by_uid_cid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_imgurls_and_favorite_by_uid_cid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_imgurls_and_favorite_by_uid_cid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_random_h5_games_params
static void _mcpack2_load_mcp_get_random_h5_games_params_count(const mc_pack_item_t*,mcp_get_random_h5_games_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_random_h5_games_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_random_h5_games_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_random_h5_games_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_random_h5_games_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_random_h5_games_params*)>("count",_mcpack2_load_mcp_get_random_h5_games_params_count));
_mcpack2_load_mcp_get_random_h5_games_params_readmap.create(16*1);
_mcpack2_load_mcp_get_random_h5_games_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_random_h5_games_params_static_inited=_mcpack2_load_mcp_get_random_h5_games_params_static_init();
// @@uint32_t count=in();
static void _mcpack2_load_mcp_get_random_h5_games_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_random_h5_games_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
void mcp_get_random_h5_games_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_random_h5_games_params*)=0;
do{
if(_mcpack2_load_mcp_get_random_h5_games_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_random_h5_games_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_random_h5_games_params*)=0;
if(_mcpack2_load_mcp_get_random_h5_games_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_random_h5_games_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_random_h5_games_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=in();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_random_h5_games_result_params
static void _mcpack2_load_mcp_get_random_h5_games_result_params_actual_count(const mc_pack_item_t*,mcp_get_random_h5_games_result_params*);
static void _mcpack2_load_mcp_get_random_h5_games_result_params_info_list(const mc_pack_item_t*,mcp_get_random_h5_games_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_random_h5_games_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_random_h5_games_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_random_h5_games_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_random_h5_games_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_random_h5_games_result_params*)>("actual_count",_mcpack2_load_mcp_get_random_h5_games_result_params_actual_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_random_h5_games_result_params*)>("info_list",_mcpack2_load_mcp_get_random_h5_games_result_params_info_list));
_mcpack2_load_mcp_get_random_h5_games_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_random_h5_games_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_random_h5_games_result_params_static_inited=_mcpack2_load_mcp_get_random_h5_games_result_params_static_init();
// @@uint32_t actual_count=out();
static void _mcpack2_load_mcp_get_random_h5_games_result_params_actual_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_random_h5_games_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_actual_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "actual_count";
}
}
// @@string info_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_random_h5_games_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_random_h5_games_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_random_h5_games_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_random_h5_games_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_random_h5_games_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_random_h5_games_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_random_h5_games_result_params*)=0;
if(_mcpack2_load_mcp_get_random_h5_games_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_random_h5_games_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_random_h5_games_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t actual_count=out();
{
int res=mc_pack_put_uint32(pack,"actual_count",_m_actual_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_random_h5_games_response
static void _mcpack2_load_mcp_get_random_h5_games_response_result_params(const mc_pack_item_t*,mcp_get_random_h5_games_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_random_h5_games_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_random_h5_games_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_random_h5_games_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_random_h5_games_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_random_h5_games_response*)>("result_params",_mcpack2_load_mcp_get_random_h5_games_response_result_params));
_mcpack2_load_mcp_get_random_h5_games_response_readmap.create(16*1);
_mcpack2_load_mcp_get_random_h5_games_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_random_h5_games_response_static_inited=_mcpack2_load_mcp_get_random_h5_games_response_static_init();
// @@mcp_get_random_h5_games_result_params result_params;
static void _mcpack2_load_mcp_get_random_h5_games_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_random_h5_games_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_random_h5_games_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_random_h5_games_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_random_h5_games_response*)=0;
do{
if(_mcpack2_load_mcp_get_random_h5_games_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_random_h5_games_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_random_h5_games_response*)=0;
if(_mcpack2_load_mcp_get_random_h5_games_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_random_h5_games_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_random_h5_games_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_random_h5_games_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_info_by_col_id_and_type_id_params
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_col_id(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_params*);
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_type_id(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_params*);
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_page(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_params*);
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_page_size(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_params*)>("col_id",_mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_col_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_params*)>("type_id",_mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_params*)>("page",_mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_params*)>("page_size",_mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_page_size));
_mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_readmap.create(16*4);
_mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_static_inited=_mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_static_init();
// @@string col_id=in();
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_col_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_and_type_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_id";
}
self->_m_col_id.set_ptr(item->value,item->value_size-1);
}
// @@string type_id=in();
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_and_type_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_and_type_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_and_type_id_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_info_by_col_id_and_type_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_info_by_col_id_and_type_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_params*)=0;
if(_mcpack2_load_mcp_get_info_by_col_id_and_type_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_info_by_col_id_and_type_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_info_by_col_id_and_type_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string col_id=in();
{
int res=mc_pack_put_str(pack,"col_id",_m_col_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_info_by_col_id_and_type_id_result_params
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_count(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_result_params*);
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_info_list(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_result_params*)>("count",_mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_result_params*)>("info_list",_mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_info_list));
_mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_static_inited=_mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_and_type_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string info_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_and_type_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_info_by_col_id_and_type_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_info_by_col_id_and_type_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_result_params*)=0;
if(_mcpack2_load_mcp_get_info_by_col_id_and_type_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_info_by_col_id_and_type_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_info_by_col_id_and_type_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_info_by_col_id_and_type_id_response
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_response_result_params(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_info_by_col_id_and_type_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_info_by_col_id_and_type_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_response*)>("result_params",_mcpack2_load_mcp_get_info_by_col_id_and_type_id_response_result_params));
_mcpack2_load_mcp_get_info_by_col_id_and_type_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_info_by_col_id_and_type_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_info_by_col_id_and_type_id_response_static_inited=_mcpack2_load_mcp_get_info_by_col_id_and_type_id_response_static_init();
// @@mcp_get_info_by_col_id_and_type_id_result_params result_params;
static void _mcpack2_load_mcp_get_info_by_col_id_and_type_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_and_type_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_info_by_col_id_and_type_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_info_by_col_id_and_type_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_info_by_col_id_and_type_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_info_by_col_id_and_type_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_info_by_col_id_and_type_id_response*)=0;
if(_mcpack2_load_mcp_get_info_by_col_id_and_type_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_info_by_col_id_and_type_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_info_by_col_id_and_type_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_info_by_col_id_and_type_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_info_by_col_id_params
static void _mcpack2_load_mcp_get_info_by_col_id_params_col_id(const mc_pack_item_t*,mcp_get_info_by_col_id_params*);
static void _mcpack2_load_mcp_get_info_by_col_id_params_page(const mc_pack_item_t*,mcp_get_info_by_col_id_params*);
static void _mcpack2_load_mcp_get_info_by_col_id_params_page_size(const mc_pack_item_t*,mcp_get_info_by_col_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_info_by_col_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_info_by_col_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_params*)>("col_id",_mcpack2_load_mcp_get_info_by_col_id_params_col_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_params*)>("page",_mcpack2_load_mcp_get_info_by_col_id_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_params*)>("page_size",_mcpack2_load_mcp_get_info_by_col_id_params_page_size));
_mcpack2_load_mcp_get_info_by_col_id_params_readmap.create(16*3);
_mcpack2_load_mcp_get_info_by_col_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_info_by_col_id_params_static_inited=_mcpack2_load_mcp_get_info_by_col_id_params_static_init();
// @@string col_id=in();
static void _mcpack2_load_mcp_get_info_by_col_id_params_col_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_id";
}
self->_m_col_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_info_by_col_id_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_info_by_col_id_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_info_by_col_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_info_by_col_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_info_by_col_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_info_by_col_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_info_by_col_id_params*)=0;
if(_mcpack2_load_mcp_get_info_by_col_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_info_by_col_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_info_by_col_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string col_id=in();
{
int res=mc_pack_put_str(pack,"col_id",_m_col_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_info_by_col_id_result_params
static void _mcpack2_load_mcp_get_info_by_col_id_result_params_col_name(const mc_pack_item_t*,mcp_get_info_by_col_id_result_params*);
static void _mcpack2_load_mcp_get_info_by_col_id_result_params_type_id(const mc_pack_item_t*,mcp_get_info_by_col_id_result_params*);
static void _mcpack2_load_mcp_get_info_by_col_id_result_params_count(const mc_pack_item_t*,mcp_get_info_by_col_id_result_params*);
static void _mcpack2_load_mcp_get_info_by_col_id_result_params_info_list(const mc_pack_item_t*,mcp_get_info_by_col_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_info_by_col_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_info_by_col_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_result_params*)>("col_name",_mcpack2_load_mcp_get_info_by_col_id_result_params_col_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_result_params*)>("type_id",_mcpack2_load_mcp_get_info_by_col_id_result_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_result_params*)>("count",_mcpack2_load_mcp_get_info_by_col_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_result_params*)>("info_list",_mcpack2_load_mcp_get_info_by_col_id_result_params_info_list));
_mcpack2_load_mcp_get_info_by_col_id_result_params_readmap.create(16*4);
_mcpack2_load_mcp_get_info_by_col_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_info_by_col_id_result_params_static_inited=_mcpack2_load_mcp_get_info_by_col_id_result_params_static_init();
// @@string col_name=out();
static void _mcpack2_load_mcp_get_info_by_col_id_result_params_col_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "col_name";
}
self->_m_col_name.set_ptr(item->value,item->value_size-1);
}
// @@string type_id=out();
static void _mcpack2_load_mcp_get_info_by_col_id_result_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_info_by_col_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string info_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_info_by_col_id_result_params_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_result_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_info_list)) lp0=&(self->_m_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_info_by_col_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_info_by_col_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_info_by_col_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_info_by_col_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_info_by_col_id_result_params*)=0;
if(_mcpack2_load_mcp_get_info_by_col_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_info_by_col_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_info_by_col_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string col_name=out();
{
int res=mc_pack_put_str(pack,"col_name",_m_col_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id=out();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_info_list)& lr0=(_m_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_info_by_col_id_response
static void _mcpack2_load_mcp_get_info_by_col_id_response_result_params(const mc_pack_item_t*,mcp_get_info_by_col_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_info_by_col_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_info_by_col_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_info_by_col_id_response*)>("result_params",_mcpack2_load_mcp_get_info_by_col_id_response_result_params));
_mcpack2_load_mcp_get_info_by_col_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_info_by_col_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_info_by_col_id_response_static_inited=_mcpack2_load_mcp_get_info_by_col_id_response_static_init();
// @@mcp_get_info_by_col_id_result_params result_params;
static void _mcpack2_load_mcp_get_info_by_col_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_info_by_col_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_info_by_col_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_info_by_col_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_info_by_col_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_info_by_col_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_info_by_col_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_info_by_col_id_response*)=0;
if(_mcpack2_load_mcp_get_info_by_col_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_info_by_col_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_info_by_col_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_info_by_col_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_soft_by_date_or_star_params
static void _mcpack2_load_mcp_get_soft_by_date_or_star_params_page(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*);
static void _mcpack2_load_mcp_get_soft_by_date_or_star_params_page_size(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*);
static void _mcpack2_load_mcp_get_soft_by_date_or_star_params_orderby(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*);
static void _mcpack2_load_mcp_get_soft_by_date_or_star_params_for_adapt(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*);
static void _mcpack2_load_mcp_get_soft_by_date_or_star_params_except_class_ids(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_soft_by_date_or_star_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_soft_by_date_or_star_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*)>("page",_mcpack2_load_mcp_get_soft_by_date_or_star_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*)>("page_size",_mcpack2_load_mcp_get_soft_by_date_or_star_params_page_size));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*)>("orderby",_mcpack2_load_mcp_get_soft_by_date_or_star_params_orderby));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*)>("for_adapt",_mcpack2_load_mcp_get_soft_by_date_or_star_params_for_adapt));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*)>("except_class_ids",_mcpack2_load_mcp_get_soft_by_date_or_star_params_except_class_ids));
_mcpack2_load_mcp_get_soft_by_date_or_star_params_readmap.create(16*5);
_mcpack2_load_mcp_get_soft_by_date_or_star_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_soft_by_date_or_star_params_static_inited=_mcpack2_load_mcp_get_soft_by_date_or_star_params_static_init();
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_soft_by_date_or_star_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_by_date_or_star_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_soft_by_date_or_star_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_by_date_or_star_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
// @@uint32_t orderby=in();
static void _mcpack2_load_mcp_get_soft_by_date_or_star_params_orderby(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_by_date_or_star_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_orderby));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "orderby";
}
}
// @@uint32_t for_adapt=in();
static void _mcpack2_load_mcp_get_soft_by_date_or_star_params_for_adapt(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_by_date_or_star_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_for_adapt));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "for_adapt";
}
}
// @@string except_class_ids=in();
static void _mcpack2_load_mcp_get_soft_by_date_or_star_params_except_class_ids(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_by_date_or_star_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "except_class_ids";
}
self->_m_except_class_ids.set_ptr(item->value,item->value_size-1);
}
void mcp_get_soft_by_date_or_star_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*)=0;
do{
if(_mcpack2_load_mcp_get_soft_by_date_or_star_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_soft_by_date_or_star_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_params*)=0;
if(_mcpack2_load_mcp_get_soft_by_date_or_star_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_soft_by_date_or_star_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_soft_by_date_or_star_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t orderby=in();
{
int res=mc_pack_put_uint32(pack,"orderby",_m_orderby);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t for_adapt=in();
{
int res=mc_pack_put_uint32(pack,"for_adapt",_m_for_adapt);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string except_class_ids=in();
{
int res=mc_pack_put_str(pack,"except_class_ids",_m_except_class_ids.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_soft_by_date_or_star_result_params
static void _mcpack2_load_mcp_get_soft_by_date_or_star_result_params_count(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_result_params*);
static void _mcpack2_load_mcp_get_soft_by_date_or_star_result_params_soft_list(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_soft_by_date_or_star_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_soft_by_date_or_star_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_result_params*)>("count",_mcpack2_load_mcp_get_soft_by_date_or_star_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_result_params*)>("soft_list",_mcpack2_load_mcp_get_soft_by_date_or_star_result_params_soft_list));
_mcpack2_load_mcp_get_soft_by_date_or_star_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_soft_by_date_or_star_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_soft_by_date_or_star_result_params_static_inited=_mcpack2_load_mcp_get_soft_by_date_or_star_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_soft_by_date_or_star_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_by_date_or_star_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string soft_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_soft_by_date_or_star_result_params_soft_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_by_date_or_star_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_soft_list)) lp0=&(self->_m_soft_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "soft_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "soft_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_soft_by_date_or_star_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_soft_by_date_or_star_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_soft_by_date_or_star_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_result_params*)=0;
if(_mcpack2_load_mcp_get_soft_by_date_or_star_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_soft_by_date_or_star_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_soft_by_date_or_star_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string soft_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"soft_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_soft_list)& lr0=(_m_soft_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_soft_by_date_or_star_response
static void _mcpack2_load_mcp_get_soft_by_date_or_star_response_result_params(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_soft_by_date_or_star_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_soft_by_date_or_star_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_response*)>("result_params",_mcpack2_load_mcp_get_soft_by_date_or_star_response_result_params));
_mcpack2_load_mcp_get_soft_by_date_or_star_response_readmap.create(16*1);
_mcpack2_load_mcp_get_soft_by_date_or_star_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_soft_by_date_or_star_response_static_inited=_mcpack2_load_mcp_get_soft_by_date_or_star_response_static_init();
// @@mcp_get_soft_by_date_or_star_result_params result_params;
static void _mcpack2_load_mcp_get_soft_by_date_or_star_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_soft_by_date_or_star_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_soft_by_date_or_star_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_soft_by_date_or_star_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_response*)=0;
do{
if(_mcpack2_load_mcp_get_soft_by_date_or_star_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_soft_by_date_or_star_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_soft_by_date_or_star_response*)=0;
if(_mcpack2_load_mcp_get_soft_by_date_or_star_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_soft_by_date_or_star_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_soft_by_date_or_star_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_soft_by_date_or_star_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_star_by_cid_and_type_params
static void _mcpack2_load_mcp_get_star_by_cid_and_type_params_c_id(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_params*);
static void _mcpack2_load_mcp_get_star_by_cid_and_type_params_type_id(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_star_by_cid_and_type_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_star_by_cid_and_type_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_params*)>("c_id",_mcpack2_load_mcp_get_star_by_cid_and_type_params_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_params*)>("type_id",_mcpack2_load_mcp_get_star_by_cid_and_type_params_type_id));
_mcpack2_load_mcp_get_star_by_cid_and_type_params_readmap.create(16*2);
_mcpack2_load_mcp_get_star_by_cid_and_type_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_star_by_cid_and_type_params_static_inited=_mcpack2_load_mcp_get_star_by_cid_and_type_params_static_init();
// @@string c_id=in();
static void _mcpack2_load_mcp_get_star_by_cid_and_type_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_star_by_cid_and_type_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string type_id=in();
static void _mcpack2_load_mcp_get_star_by_cid_and_type_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_star_by_cid_and_type_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_star_by_cid_and_type_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_params*)=0;
do{
if(_mcpack2_load_mcp_get_star_by_cid_and_type_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_star_by_cid_and_type_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_params*)=0;
if(_mcpack2_load_mcp_get_star_by_cid_and_type_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_star_by_cid_and_type_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_star_by_cid_and_type_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_star_by_cid_and_type_result_params
static void _mcpack2_load_mcp_get_star_by_cid_and_type_result_params_star(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_star_by_cid_and_type_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_star_by_cid_and_type_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_result_params*)>("star",_mcpack2_load_mcp_get_star_by_cid_and_type_result_params_star));
_mcpack2_load_mcp_get_star_by_cid_and_type_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_star_by_cid_and_type_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_star_by_cid_and_type_result_params_static_inited=_mcpack2_load_mcp_get_star_by_cid_and_type_result_params_static_init();
// @@uint32_t star=out();
static void _mcpack2_load_mcp_get_star_by_cid_and_type_result_params_star(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_star_by_cid_and_type_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_star));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "star";
}
}
void mcp_get_star_by_cid_and_type_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_star_by_cid_and_type_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_star_by_cid_and_type_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_result_params*)=0;
if(_mcpack2_load_mcp_get_star_by_cid_and_type_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_star_by_cid_and_type_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_star_by_cid_and_type_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t star=out();
{
int res=mc_pack_put_uint32(pack,"star",_m_star);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_star_by_cid_and_type_response
static void _mcpack2_load_mcp_get_star_by_cid_and_type_response_result_params(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_star_by_cid_and_type_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_star_by_cid_and_type_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_response*)>("result_params",_mcpack2_load_mcp_get_star_by_cid_and_type_response_result_params));
_mcpack2_load_mcp_get_star_by_cid_and_type_response_readmap.create(16*1);
_mcpack2_load_mcp_get_star_by_cid_and_type_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_star_by_cid_and_type_response_static_inited=_mcpack2_load_mcp_get_star_by_cid_and_type_response_static_init();
// @@mcp_get_star_by_cid_and_type_result_params result_params;
static void _mcpack2_load_mcp_get_star_by_cid_and_type_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_star_by_cid_and_type_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_star_by_cid_and_type_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_star_by_cid_and_type_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_response*)=0;
do{
if(_mcpack2_load_mcp_get_star_by_cid_and_type_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_star_by_cid_and_type_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_star_by_cid_and_type_response*)=0;
if(_mcpack2_load_mcp_get_star_by_cid_and_type_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_star_by_cid_and_type_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_star_by_cid_and_type_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_star_by_cid_and_type_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_classID_with_weight_params
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_class_id(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_content_type_id(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_priority(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_info_id(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_info_type(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_img_size(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_unit_num(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_unit_times(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_for_adapt(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_weight_type(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*)>("class_id",_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*)>("content_type_id",_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_content_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*)>("priority",_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_priority));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*)>("info_id",_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*)>("info_type",_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*)>("img_size",_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_img_size));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*)>("unit_num",_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*)>("unit_times",_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_unit_times));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*)>("for_adapt",_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_for_adapt));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*)>("weight_type",_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_weight_type));
_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_readmap.create(16*10);
_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_static_inited=_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_static_init();
// @@string class_id=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_with_weight_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
// @@string content_type_id=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_content_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_with_weight_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_type_id";
}
self->_m_content_type_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t priority=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_priority(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_with_weight_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_priority));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "priority";
}
}
// @@string info_id=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_with_weight_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t info_type=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_with_weight_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_info_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
}
// @@string img_size=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_img_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_with_weight_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "img_size";
}
self->_m_img_size.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_with_weight_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_with_weight_params* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
// @@uint32_t for_adapt=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_for_adapt(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_with_weight_params* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_for_adapt));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "for_adapt";
}
}
// @@int32_t weight_type=in();
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_weight_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_with_weight_params* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_weight_type));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "weight_type";
}
}
void mcp_get_content_list_from_classID_with_weight_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_classID_with_weight_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_params*)=0;
if(_mcpack2_load_mcp_get_content_list_from_classID_with_weight_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_classID_with_weight_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_classID_with_weight_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string class_id=in();
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_type_id=in();
{
int res=mc_pack_put_str(pack,"content_type_id",_m_content_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t priority=in();
{
int res=mc_pack_put_uint32(pack,"priority",_m_priority);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t info_type=in();
{
int res=mc_pack_put_uint32(pack,"info_type",_m_info_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string img_size=in();
{
int res=mc_pack_put_str(pack,"img_size",_m_img_size.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t for_adapt=in();
{
int res=mc_pack_put_uint32(pack,"for_adapt",_m_for_adapt);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int32_t weight_type=in();
{
int res=mc_pack_put_int32(pack,"weight_type",_m_weight_type);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_classID_with_weight_result_params
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_count(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_result_params*);
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_content_list(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_result_params*)>("count",_mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_result_params*)>("content_list",_mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_content_list));
_mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_static_inited=_mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_with_weight_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string content_list=out(),array(0,0);
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_content_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_with_weight_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_content_list)) lp0=&(self->_m_content_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack1=0;
res0=mc_pack_get_array_from_item(&item0,&pack1);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
// level 1 begin.
int size1=mc_pack_get_item_count(pack1);

typeof(lp0->MutableGetWithoutCheck(i0)) lp1=lp0->MutableGetWithoutCheck(i0);
lp1->resize(size1);
if(size1>0){
mc_pack_item_t item1;
int res1=mc_pack_first_item(pack1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
for(int i1=0;i1<size1;i1++){
if(item1.type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "content_list";
}
lp1->MutableGetWithoutCheck(i1)->set_ptr(item1.value,item1.value_size-1);
if(i1<(size1-1)){
res1=mc_pack_next_item(&item1,&item1);
if(res1<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i1=0;i1<size;i1++)
} // if(size1>0)
// level 1 end.
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "content_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_list_from_classID_with_weight_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_classID_with_weight_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_result_params*)=0;
if(_mcpack2_load_mcp_get_content_list_from_classID_with_weight_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_classID_with_weight_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_classID_with_weight_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string content_list=out(),array(0,0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"content_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_content_list)& lr0=(_m_content_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t* pack1=mc_pack_put_array(pack0,0);
if(MC_PACK_PTR_ERR(pack1)){
throw ::idl::McpackException(pack1) << BSL_EARG;
}
// level 1 begin.
typeof(lr0.GetWithoutCheck(i0)) lr1=lr0.GetWithoutCheck(i0);
size_t size1=lr1.size();
for(size_t i1=0;i1<size1;i1++){
int res1=mc_pack_put_str(pack1,0,lr1.GetWithoutCheck(i1).get());
if(res1){
throw ::idl::McpackException(res1) << BSL_EARG;
}
}
// level 1 end.

mc_pack_finish(pack1);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_list_from_classID_with_weight_response
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_response_result_params(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_list_from_classID_with_weight_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_list_from_classID_with_weight_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_response*)>("result_params",_mcpack2_load_mcp_get_content_list_from_classID_with_weight_response_result_params));
_mcpack2_load_mcp_get_content_list_from_classID_with_weight_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_list_from_classID_with_weight_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_list_from_classID_with_weight_response_static_inited=_mcpack2_load_mcp_get_content_list_from_classID_with_weight_response_static_init();
// @@mcp_get_content_list_from_classID_with_weight_result_params result_params;
static void _mcpack2_load_mcp_get_content_list_from_classID_with_weight_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_list_from_classID_with_weight_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_list_from_classID_with_weight_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_list_from_classID_with_weight_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_list_from_classID_with_weight_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_list_from_classID_with_weight_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_list_from_classID_with_weight_response*)=0;
if(_mcpack2_load_mcp_get_content_list_from_classID_with_weight_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_list_from_classID_with_weight_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_list_from_classID_with_weight_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_list_from_classID_with_weight_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_with_download_info_params
static void _mcpack2_load_mcp_get_content_with_download_info_params_in_param(const mc_pack_item_t*,mcp_get_content_with_download_info_params*);
static void _mcpack2_load_mcp_get_content_with_download_info_params_unit_num(const mc_pack_item_t*,mcp_get_content_with_download_info_params*);
static void _mcpack2_load_mcp_get_content_with_download_info_params_unit_times(const mc_pack_item_t*,mcp_get_content_with_download_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_with_download_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_with_download_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_with_download_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_with_download_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_with_download_info_params*)>("in_param",_mcpack2_load_mcp_get_content_with_download_info_params_in_param));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_with_download_info_params*)>("unit_num",_mcpack2_load_mcp_get_content_with_download_info_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_with_download_info_params*)>("unit_times",_mcpack2_load_mcp_get_content_with_download_info_params_unit_times));
_mcpack2_load_mcp_get_content_with_download_info_params_readmap.create(16*3);
_mcpack2_load_mcp_get_content_with_download_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_with_download_info_params_static_inited=_mcpack2_load_mcp_get_content_with_download_info_params_static_init();
// @@mcp_content_in_param in_param=in();
static void _mcpack2_load_mcp_get_content_with_download_info_params_in_param(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_with_download_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_in_param){
self->_m_in_param=::idl::mcp_content_in_param::create(self->_pool);
}
self->_m_in_param->LoadWithoutCheck(pack);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_content_with_download_info_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_with_download_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_content_with_download_info_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_with_download_info_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_content_with_download_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_with_download_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_with_download_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_with_download_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_with_download_info_params*)=0;
if(_mcpack2_load_mcp_get_content_with_download_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_with_download_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_with_download_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_content_in_param in_param=in();
{
mc_pack_t* subpack=mc_pack_put_object(pack,"in_param");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_in_param->save(subpack);
mc_pack_finish(subpack);
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_with_download_info_result_params
static void _mcpack2_load_mcp_get_content_with_download_info_result_params_count(const mc_pack_item_t*,mcp_get_content_with_download_info_result_params*);
static void _mcpack2_load_mcp_get_content_with_download_info_result_params_result_list(const mc_pack_item_t*,mcp_get_content_with_download_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_with_download_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_with_download_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_with_download_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_with_download_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_with_download_info_result_params*)>("count",_mcpack2_load_mcp_get_content_with_download_info_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_with_download_info_result_params*)>("result_list",_mcpack2_load_mcp_get_content_with_download_info_result_params_result_list));
_mcpack2_load_mcp_get_content_with_download_info_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_content_with_download_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_with_download_info_result_params_static_inited=_mcpack2_load_mcp_get_content_with_download_info_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_content_with_download_info_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_with_download_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@content_detail_t result_list=out(),array(0);
static void _mcpack2_load_mcp_get_content_with_download_info_result_params_result_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_with_download_info_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_result_list)) lp0=&(self->_m_result_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_content_with_download_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_with_download_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_content_with_download_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_with_download_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_with_download_info_result_params*)=0;
if(_mcpack2_load_mcp_get_content_with_download_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_with_download_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_with_download_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@content_detail_t result_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"result_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_result_list)& lr0=(_m_result_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_content_with_download_info_response
static void _mcpack2_load_mcp_get_content_with_download_info_response_result_params(const mc_pack_item_t*,mcp_get_content_with_download_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_with_download_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_content_with_download_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_content_with_download_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_content_with_download_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_content_with_download_info_response*)>("result_params",_mcpack2_load_mcp_get_content_with_download_info_response_result_params));
_mcpack2_load_mcp_get_content_with_download_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_content_with_download_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_content_with_download_info_response_static_inited=_mcpack2_load_mcp_get_content_with_download_info_response_static_init();
// @@mcp_get_content_with_download_info_result_params result_params;
static void _mcpack2_load_mcp_get_content_with_download_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_content_with_download_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_content_with_download_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_content_with_download_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_content_with_download_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_content_with_download_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_content_with_download_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_content_with_download_info_response*)=0;
if(_mcpack2_load_mcp_get_content_with_download_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_content_with_download_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_content_with_download_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_content_with_download_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_contents_count_params
static void _mcpack2_load_mcp_get_game_contents_count_params_type_id(const mc_pack_item_t*,mcp_get_game_contents_count_params*);
static void _mcpack2_load_mcp_get_game_contents_count_params_class_id(const mc_pack_item_t*,mcp_get_game_contents_count_params*);
static void _mcpack2_load_mcp_get_game_contents_count_params_label_id(const mc_pack_item_t*,mcp_get_game_contents_count_params*);
static void _mcpack2_load_mcp_get_game_contents_count_params_column_id(const mc_pack_item_t*,mcp_get_game_contents_count_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_contents_count_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_contents_count_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_contents_count_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_contents_count_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_contents_count_params*)>("type_id",_mcpack2_load_mcp_get_game_contents_count_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_contents_count_params*)>("class_id",_mcpack2_load_mcp_get_game_contents_count_params_class_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_contents_count_params*)>("label_id",_mcpack2_load_mcp_get_game_contents_count_params_label_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_contents_count_params*)>("column_id",_mcpack2_load_mcp_get_game_contents_count_params_column_id));
_mcpack2_load_mcp_get_game_contents_count_params_readmap.create(16*4);
_mcpack2_load_mcp_get_game_contents_count_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_contents_count_params_static_inited=_mcpack2_load_mcp_get_game_contents_count_params_static_init();
// @@string type_id=in();
static void _mcpack2_load_mcp_get_game_contents_count_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_contents_count_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@string class_id=in();
static void _mcpack2_load_mcp_get_game_contents_count_params_class_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_contents_count_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "class_id";
}
self->_m_class_id.set_ptr(item->value,item->value_size-1);
}
// @@string label_id=in();
static void _mcpack2_load_mcp_get_game_contents_count_params_label_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_contents_count_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "label_id";
}
self->_m_label_id.set_ptr(item->value,item->value_size-1);
}
// @@string column_id=in();
static void _mcpack2_load_mcp_get_game_contents_count_params_column_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_contents_count_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "column_id";
}
self->_m_column_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_game_contents_count_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_contents_count_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_contents_count_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_contents_count_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_contents_count_params*)=0;
if(_mcpack2_load_mcp_get_game_contents_count_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_contents_count_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_contents_count_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string class_id=in();
{
int res=mc_pack_put_str(pack,"class_id",_m_class_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string label_id=in();
{
int res=mc_pack_put_str(pack,"label_id",_m_label_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string column_id=in();
{
int res=mc_pack_put_str(pack,"column_id",_m_column_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_contents_count_result_params
static void _mcpack2_load_mcp_get_game_contents_count_result_params_count(const mc_pack_item_t*,mcp_get_game_contents_count_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_contents_count_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_contents_count_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_contents_count_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_contents_count_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_contents_count_result_params*)>("count",_mcpack2_load_mcp_get_game_contents_count_result_params_count));
_mcpack2_load_mcp_get_game_contents_count_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_game_contents_count_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_contents_count_result_params_static_inited=_mcpack2_load_mcp_get_game_contents_count_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_game_contents_count_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_contents_count_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
void mcp_get_game_contents_count_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_contents_count_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_contents_count_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_contents_count_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_contents_count_result_params*)=0;
if(_mcpack2_load_mcp_get_game_contents_count_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_contents_count_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_contents_count_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_contents_count_response
static void _mcpack2_load_mcp_get_game_contents_count_response_result_params(const mc_pack_item_t*,mcp_get_game_contents_count_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_contents_count_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_contents_count_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_contents_count_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_contents_count_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_contents_count_response*)>("result_params",_mcpack2_load_mcp_get_game_contents_count_response_result_params));
_mcpack2_load_mcp_get_game_contents_count_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_contents_count_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_contents_count_response_static_inited=_mcpack2_load_mcp_get_game_contents_count_response_static_init();
// @@mcp_get_game_contents_count_result_params result_params;
static void _mcpack2_load_mcp_get_game_contents_count_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_contents_count_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_contents_count_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_contents_count_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_contents_count_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_contents_count_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_contents_count_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_contents_count_response*)=0;
if(_mcpack2_load_mcp_get_game_contents_count_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_contents_count_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_contents_count_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_contents_count_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_columns_info_params
static void _mcpack2_load_mcp_get_columns_info_params_type_id(const mc_pack_item_t*,mcp_get_columns_info_params*);
static void _mcpack2_load_mcp_get_columns_info_params_column_id(const mc_pack_item_t*,mcp_get_columns_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_columns_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_columns_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_columns_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_columns_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_columns_info_params*)>("type_id",_mcpack2_load_mcp_get_columns_info_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_columns_info_params*)>("column_id",_mcpack2_load_mcp_get_columns_info_params_column_id));
_mcpack2_load_mcp_get_columns_info_params_readmap.create(16*2);
_mcpack2_load_mcp_get_columns_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_columns_info_params_static_inited=_mcpack2_load_mcp_get_columns_info_params_static_init();
// @@string type_id=in();
static void _mcpack2_load_mcp_get_columns_info_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_columns_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@string column_id=in();
static void _mcpack2_load_mcp_get_columns_info_params_column_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_columns_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "column_id";
}
self->_m_column_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_columns_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_columns_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_columns_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_columns_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_columns_info_params*)=0;
if(_mcpack2_load_mcp_get_columns_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_columns_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_columns_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string column_id=in();
{
int res=mc_pack_put_str(pack,"column_id",_m_column_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_columns_info_result_params
static void _mcpack2_load_mcp_get_columns_info_result_params_count(const mc_pack_item_t*,mcp_get_columns_info_result_params*);
static void _mcpack2_load_mcp_get_columns_info_result_params_result_list(const mc_pack_item_t*,mcp_get_columns_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_columns_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_columns_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_columns_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_columns_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_columns_info_result_params*)>("count",_mcpack2_load_mcp_get_columns_info_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_columns_info_result_params*)>("result_list",_mcpack2_load_mcp_get_columns_info_result_params_result_list));
_mcpack2_load_mcp_get_columns_info_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_columns_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_columns_info_result_params_static_inited=_mcpack2_load_mcp_get_columns_info_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_columns_info_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_columns_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@column_info_t result_list=out(),array(0);
static void _mcpack2_load_mcp_get_columns_info_result_params_result_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_columns_info_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_result_list)) lp0=&(self->_m_result_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_columns_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_columns_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_columns_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_columns_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_columns_info_result_params*)=0;
if(_mcpack2_load_mcp_get_columns_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_columns_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_columns_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@column_info_t result_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"result_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_result_list)& lr0=(_m_result_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_columns_info_response
static void _mcpack2_load_mcp_get_columns_info_response_result_params(const mc_pack_item_t*,mcp_get_columns_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_columns_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_columns_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_columns_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_columns_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_columns_info_response*)>("result_params",_mcpack2_load_mcp_get_columns_info_response_result_params));
_mcpack2_load_mcp_get_columns_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_columns_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_columns_info_response_static_inited=_mcpack2_load_mcp_get_columns_info_response_static_init();
// @@mcp_get_columns_info_result_params result_params;
static void _mcpack2_load_mcp_get_columns_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_columns_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_columns_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_columns_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_columns_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_columns_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_columns_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_columns_info_response*)=0;
if(_mcpack2_load_mcp_get_columns_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_columns_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_columns_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_columns_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_once_consume_goods_list_params
static void _mcpack2_load_mcp_get_once_consume_goods_list_params_udid(const mc_pack_item_t*,mcp_get_once_consume_goods_list_params*);
static void _mcpack2_load_mcp_get_once_consume_goods_list_params_app_id(const mc_pack_item_t*,mcp_get_once_consume_goods_list_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_once_consume_goods_list_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_once_consume_goods_list_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_params*)>("udid",_mcpack2_load_mcp_get_once_consume_goods_list_params_udid));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_params*)>("app_id",_mcpack2_load_mcp_get_once_consume_goods_list_params_app_id));
_mcpack2_load_mcp_get_once_consume_goods_list_params_readmap.create(16*2);
_mcpack2_load_mcp_get_once_consume_goods_list_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_once_consume_goods_list_params_static_inited=_mcpack2_load_mcp_get_once_consume_goods_list_params_static_init();
// @@string udid=in();
static void _mcpack2_load_mcp_get_once_consume_goods_list_params_udid(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_once_consume_goods_list_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "udid";
}
self->_m_udid.set_ptr(item->value,item->value_size-1);
}
// @@string app_id=in();
static void _mcpack2_load_mcp_get_once_consume_goods_list_params_app_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_once_consume_goods_list_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "app_id";
}
self->_m_app_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_once_consume_goods_list_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_params*)=0;
do{
if(_mcpack2_load_mcp_get_once_consume_goods_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_once_consume_goods_list_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_params*)=0;
if(_mcpack2_load_mcp_get_once_consume_goods_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_once_consume_goods_list_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_once_consume_goods_list_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string udid=in();
{
int res=mc_pack_put_str(pack,"udid",_m_udid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string app_id=in();
{
int res=mc_pack_put_str(pack,"app_id",_m_app_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_once_consume_goods_list_result_params
static void _mcpack2_load_mcp_get_once_consume_goods_list_result_params_itemcount(const mc_pack_item_t*,mcp_get_once_consume_goods_list_result_params*);
static void _mcpack2_load_mcp_get_once_consume_goods_list_result_params_items(const mc_pack_item_t*,mcp_get_once_consume_goods_list_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_once_consume_goods_list_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_once_consume_goods_list_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_result_params*)>("itemcount",_mcpack2_load_mcp_get_once_consume_goods_list_result_params_itemcount));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_result_params*)>("items",_mcpack2_load_mcp_get_once_consume_goods_list_result_params_items));
_mcpack2_load_mcp_get_once_consume_goods_list_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_once_consume_goods_list_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_once_consume_goods_list_result_params_static_inited=_mcpack2_load_mcp_get_once_consume_goods_list_result_params_static_init();
// @@uint32_t itemcount=out();
static void _mcpack2_load_mcp_get_once_consume_goods_list_result_params_itemcount(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_once_consume_goods_list_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_itemcount));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "itemcount";
}
}
// @@once_consume_goods_t items=out(),array(0);
static void _mcpack2_load_mcp_get_once_consume_goods_list_result_params_items(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_once_consume_goods_list_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "items";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_items)) lp0=&(self->_m_items);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "items";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "items";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "items";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_once_consume_goods_list_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_once_consume_goods_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_once_consume_goods_list_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_result_params*)=0;
if(_mcpack2_load_mcp_get_once_consume_goods_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_once_consume_goods_list_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_once_consume_goods_list_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t itemcount=out();
{
int res=mc_pack_put_uint32(pack,"itemcount",_m_itemcount);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@once_consume_goods_t items=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"items");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_items)& lr0=(_m_items);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_once_consume_goods_list_response
static void _mcpack2_load_mcp_get_once_consume_goods_list_response_result_params(const mc_pack_item_t*,mcp_get_once_consume_goods_list_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_once_consume_goods_list_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_once_consume_goods_list_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_response*)>("result_params",_mcpack2_load_mcp_get_once_consume_goods_list_response_result_params));
_mcpack2_load_mcp_get_once_consume_goods_list_response_readmap.create(16*1);
_mcpack2_load_mcp_get_once_consume_goods_list_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_once_consume_goods_list_response_static_inited=_mcpack2_load_mcp_get_once_consume_goods_list_response_static_init();
// @@mcp_get_once_consume_goods_list_result_params result_params;
static void _mcpack2_load_mcp_get_once_consume_goods_list_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_once_consume_goods_list_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_once_consume_goods_list_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_once_consume_goods_list_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_response*)=0;
do{
if(_mcpack2_load_mcp_get_once_consume_goods_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_once_consume_goods_list_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_once_consume_goods_list_response*)=0;
if(_mcpack2_load_mcp_get_once_consume_goods_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_once_consume_goods_list_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_once_consume_goods_list_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_once_consume_goods_list_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_info_list_ext_params
static void _mcpack2_load_mcp_get_game_info_list_ext_params_info_id(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*);
static void _mcpack2_load_mcp_get_game_info_list_ext_params_c_id(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*);
static void _mcpack2_load_mcp_get_game_info_list_ext_params_info_type(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*);
static void _mcpack2_load_mcp_get_game_info_list_ext_params_game_type(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*);
static void _mcpack2_load_mcp_get_game_info_list_ext_params_date_limit(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*);
static void _mcpack2_load_mcp_get_game_info_list_ext_params_page(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*);
static void _mcpack2_load_mcp_get_game_info_list_ext_params_page_size(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_info_list_ext_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_info_list_ext_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*)>("info_id",_mcpack2_load_mcp_get_game_info_list_ext_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*)>("c_id",_mcpack2_load_mcp_get_game_info_list_ext_params_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*)>("info_type",_mcpack2_load_mcp_get_game_info_list_ext_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*)>("game_type",_mcpack2_load_mcp_get_game_info_list_ext_params_game_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*)>("date_limit",_mcpack2_load_mcp_get_game_info_list_ext_params_date_limit));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*)>("page",_mcpack2_load_mcp_get_game_info_list_ext_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*)>("page_size",_mcpack2_load_mcp_get_game_info_list_ext_params_page_size));
_mcpack2_load_mcp_get_game_info_list_ext_params_readmap.create(16*7);
_mcpack2_load_mcp_get_game_info_list_ext_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_info_list_ext_params_static_inited=_mcpack2_load_mcp_get_game_info_list_ext_params_static_init();
// @@string info_id=in();
static void _mcpack2_load_mcp_get_game_info_list_ext_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_ext_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id=in();
static void _mcpack2_load_mcp_get_game_info_list_ext_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_ext_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string info_type=in();
static void _mcpack2_load_mcp_get_game_info_list_ext_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_ext_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
self->_m_info_type.set_ptr(item->value,item->value_size-1);
}
// @@string game_type=in();
static void _mcpack2_load_mcp_get_game_info_list_ext_params_game_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_ext_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_type";
}
self->_m_game_type.set_ptr(item->value,item->value_size-1);
}
// @@string date_limit=in();
static void _mcpack2_load_mcp_get_game_info_list_ext_params_date_limit(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_ext_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "date_limit";
}
self->_m_date_limit.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_game_info_list_ext_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_ext_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_game_info_list_ext_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_ext_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_game_info_list_ext_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_info_list_ext_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_info_list_ext_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_ext_params*)=0;
if(_mcpack2_load_mcp_get_game_info_list_ext_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_info_list_ext_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_info_list_ext_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_type=in();
{
int res=mc_pack_put_str(pack,"info_type",_m_info_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_type=in();
{
int res=mc_pack_put_str(pack,"game_type",_m_game_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string date_limit=in();
{
int res=mc_pack_put_str(pack,"date_limit",_m_date_limit.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_info_list_ext_result_params
static void _mcpack2_load_mcp_get_game_info_list_ext_result_params_count(const mc_pack_item_t*,mcp_get_game_info_list_ext_result_params*);
static void _mcpack2_load_mcp_get_game_info_list_ext_result_params_game_info_list(const mc_pack_item_t*,mcp_get_game_info_list_ext_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_info_list_ext_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_info_list_ext_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_result_params*)>("count",_mcpack2_load_mcp_get_game_info_list_ext_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_result_params*)>("game_info_list",_mcpack2_load_mcp_get_game_info_list_ext_result_params_game_info_list));
_mcpack2_load_mcp_get_game_info_list_ext_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_game_info_list_ext_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_info_list_ext_result_params_static_inited=_mcpack2_load_mcp_get_game_info_list_ext_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_game_info_list_ext_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_ext_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_info_t game_info_list=out(),array(0);
static void _mcpack2_load_mcp_get_game_info_list_ext_result_params_game_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_ext_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_game_info_list)) lp0=&(self->_m_game_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_game_info_list_ext_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_ext_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_info_list_ext_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_info_list_ext_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_ext_result_params*)=0;
if(_mcpack2_load_mcp_get_game_info_list_ext_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_info_list_ext_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_info_list_ext_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_info_t game_info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"game_info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_game_info_list)& lr0=(_m_game_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_info_list_ext_response
static void _mcpack2_load_mcp_get_game_info_list_ext_response_result_params(const mc_pack_item_t*,mcp_get_game_info_list_ext_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_info_list_ext_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_info_list_ext_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_info_list_ext_response*)>("result_params",_mcpack2_load_mcp_get_game_info_list_ext_response_result_params));
_mcpack2_load_mcp_get_game_info_list_ext_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_info_list_ext_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_info_list_ext_response_static_inited=_mcpack2_load_mcp_get_game_info_list_ext_response_static_init();
// @@mcp_get_game_info_list_ext_result_params result_params;
static void _mcpack2_load_mcp_get_game_info_list_ext_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_info_list_ext_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_info_list_ext_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_info_list_ext_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_ext_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_info_list_ext_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_info_list_ext_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_info_list_ext_response*)=0;
if(_mcpack2_load_mcp_get_game_info_list_ext_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_info_list_ext_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_info_list_ext_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_info_list_ext_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_new_download_game_by_uid_params
static void _mcpack2_load_mcp_add_new_download_game_by_uid_params_u_id(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_params*);
static void _mcpack2_load_mcp_add_new_download_game_by_uid_params_game_id(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_new_download_game_by_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_new_download_game_by_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_params*)>("u_id",_mcpack2_load_mcp_add_new_download_game_by_uid_params_u_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_params*)>("game_id",_mcpack2_load_mcp_add_new_download_game_by_uid_params_game_id));
_mcpack2_load_mcp_add_new_download_game_by_uid_params_readmap.create(16*2);
_mcpack2_load_mcp_add_new_download_game_by_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_new_download_game_by_uid_params_static_inited=_mcpack2_load_mcp_add_new_download_game_by_uid_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_add_new_download_game_by_uid_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_download_game_by_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
// @@string game_id=in();
static void _mcpack2_load_mcp_add_new_download_game_by_uid_params_game_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_download_game_by_uid_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
void mcp_add_new_download_game_by_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_params*)=0;
do{
if(_mcpack2_load_mcp_add_new_download_game_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_new_download_game_by_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_params*)=0;
if(_mcpack2_load_mcp_add_new_download_game_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_new_download_game_by_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_new_download_game_by_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_id=in();
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_new_download_game_by_uid_result_params
static void _mcpack2_load_mcp_add_new_download_game_by_uid_result_params_ret_code(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_new_download_game_by_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_new_download_game_by_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_result_params*)>("ret_code",_mcpack2_load_mcp_add_new_download_game_by_uid_result_params_ret_code));
_mcpack2_load_mcp_add_new_download_game_by_uid_result_params_readmap.create(16*1);
_mcpack2_load_mcp_add_new_download_game_by_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_new_download_game_by_uid_result_params_static_inited=_mcpack2_load_mcp_add_new_download_game_by_uid_result_params_static_init();
// @@int32_t ret_code=out();
static void _mcpack2_load_mcp_add_new_download_game_by_uid_result_params_ret_code(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_download_game_by_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_ret_code));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ret_code";
}
}
void mcp_add_new_download_game_by_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_add_new_download_game_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_new_download_game_by_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_result_params*)=0;
if(_mcpack2_load_mcp_add_new_download_game_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_new_download_game_by_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_new_download_game_by_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t ret_code=out();
{
int res=mc_pack_put_int32(pack,"ret_code",_m_ret_code);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_new_download_game_by_uid_response
static void _mcpack2_load_mcp_add_new_download_game_by_uid_response_result_params(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_new_download_game_by_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_new_download_game_by_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_response*)>("result_params",_mcpack2_load_mcp_add_new_download_game_by_uid_response_result_params));
_mcpack2_load_mcp_add_new_download_game_by_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_add_new_download_game_by_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_new_download_game_by_uid_response_static_inited=_mcpack2_load_mcp_add_new_download_game_by_uid_response_static_init();
// @@mcp_add_new_download_game_by_uid_result_params result_params;
static void _mcpack2_load_mcp_add_new_download_game_by_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_download_game_by_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_add_new_download_game_by_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_add_new_download_game_by_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_response*)=0;
do{
if(_mcpack2_load_mcp_add_new_download_game_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_new_download_game_by_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_new_download_game_by_uid_response*)=0;
if(_mcpack2_load_mcp_add_new_download_game_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_new_download_game_by_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_new_download_game_by_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_add_new_download_game_by_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_download_games_count_by_uid_params
static void _mcpack2_load_mcp_get_download_games_count_by_uid_params_u_id(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_download_games_count_by_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_download_games_count_by_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_params*)>("u_id",_mcpack2_load_mcp_get_download_games_count_by_uid_params_u_id));
_mcpack2_load_mcp_get_download_games_count_by_uid_params_readmap.create(16*1);
_mcpack2_load_mcp_get_download_games_count_by_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_download_games_count_by_uid_params_static_inited=_mcpack2_load_mcp_get_download_games_count_by_uid_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_get_download_games_count_by_uid_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_games_count_by_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_download_games_count_by_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_params*)=0;
do{
if(_mcpack2_load_mcp_get_download_games_count_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_download_games_count_by_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_params*)=0;
if(_mcpack2_load_mcp_get_download_games_count_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_download_games_count_by_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_download_games_count_by_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_download_games_count_by_uid_result_params
static void _mcpack2_load_mcp_get_download_games_count_by_uid_result_params_count(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_download_games_count_by_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_download_games_count_by_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_result_params*)>("count",_mcpack2_load_mcp_get_download_games_count_by_uid_result_params_count));
_mcpack2_load_mcp_get_download_games_count_by_uid_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_download_games_count_by_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_download_games_count_by_uid_result_params_static_inited=_mcpack2_load_mcp_get_download_games_count_by_uid_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_download_games_count_by_uid_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_games_count_by_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
void mcp_get_download_games_count_by_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_download_games_count_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_download_games_count_by_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_result_params*)=0;
if(_mcpack2_load_mcp_get_download_games_count_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_download_games_count_by_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_download_games_count_by_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_download_games_count_by_uid_response
static void _mcpack2_load_mcp_get_download_games_count_by_uid_response_result_params(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_download_games_count_by_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_download_games_count_by_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_response*)>("result_params",_mcpack2_load_mcp_get_download_games_count_by_uid_response_result_params));
_mcpack2_load_mcp_get_download_games_count_by_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_get_download_games_count_by_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_download_games_count_by_uid_response_static_inited=_mcpack2_load_mcp_get_download_games_count_by_uid_response_static_init();
// @@mcp_get_download_games_count_by_uid_result_params result_params;
static void _mcpack2_load_mcp_get_download_games_count_by_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_games_count_by_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_download_games_count_by_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_download_games_count_by_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_response*)=0;
do{
if(_mcpack2_load_mcp_get_download_games_count_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_download_games_count_by_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_download_games_count_by_uid_response*)=0;
if(_mcpack2_load_mcp_get_download_games_count_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_download_games_count_by_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_download_games_count_by_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_download_games_count_by_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_is_user_has_relation_with_params
static void _mcpack2_load_mcp_is_user_has_relation_with_params_u_id(const mc_pack_item_t*,mcp_is_user_has_relation_with_params*);
static void _mcpack2_load_mcp_is_user_has_relation_with_params_c_id(const mc_pack_item_t*,mcp_is_user_has_relation_with_params*);
static void _mcpack2_load_mcp_is_user_has_relation_with_params_c_type(const mc_pack_item_t*,mcp_is_user_has_relation_with_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_is_user_has_relation_with_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_is_user_has_relation_with_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_is_user_has_relation_with_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_is_user_has_relation_with_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_is_user_has_relation_with_params*)>("u_id",_mcpack2_load_mcp_is_user_has_relation_with_params_u_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_is_user_has_relation_with_params*)>("c_id",_mcpack2_load_mcp_is_user_has_relation_with_params_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_is_user_has_relation_with_params*)>("c_type",_mcpack2_load_mcp_is_user_has_relation_with_params_c_type));
_mcpack2_load_mcp_is_user_has_relation_with_params_readmap.create(16*3);
_mcpack2_load_mcp_is_user_has_relation_with_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_is_user_has_relation_with_params_static_inited=_mcpack2_load_mcp_is_user_has_relation_with_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_is_user_has_relation_with_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_is_user_has_relation_with_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id=in();
static void _mcpack2_load_mcp_is_user_has_relation_with_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_is_user_has_relation_with_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_type=in();
static void _mcpack2_load_mcp_is_user_has_relation_with_params_c_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_is_user_has_relation_with_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_type";
}
self->_m_c_type.set_ptr(item->value,item->value_size-1);
}
void mcp_is_user_has_relation_with_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_is_user_has_relation_with_params*)=0;
do{
if(_mcpack2_load_mcp_is_user_has_relation_with_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_is_user_has_relation_with_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_is_user_has_relation_with_params*)=0;
if(_mcpack2_load_mcp_is_user_has_relation_with_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_is_user_has_relation_with_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_is_user_has_relation_with_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_type=in();
{
int res=mc_pack_put_str(pack,"c_type",_m_c_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_is_user_has_relation_with_result_params
static void _mcpack2_load_mcp_is_user_has_relation_with_result_params_has_relation(const mc_pack_item_t*,mcp_is_user_has_relation_with_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_is_user_has_relation_with_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_is_user_has_relation_with_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_is_user_has_relation_with_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_is_user_has_relation_with_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_is_user_has_relation_with_result_params*)>("has_relation",_mcpack2_load_mcp_is_user_has_relation_with_result_params_has_relation));
_mcpack2_load_mcp_is_user_has_relation_with_result_params_readmap.create(16*1);
_mcpack2_load_mcp_is_user_has_relation_with_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_is_user_has_relation_with_result_params_static_inited=_mcpack2_load_mcp_is_user_has_relation_with_result_params_static_init();
// @@int32_t has_relation=out();
static void _mcpack2_load_mcp_is_user_has_relation_with_result_params_has_relation(__attribute__((unused)) const mc_pack_item_t* item,mcp_is_user_has_relation_with_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_has_relation));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "has_relation";
}
}
void mcp_is_user_has_relation_with_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_is_user_has_relation_with_result_params*)=0;
do{
if(_mcpack2_load_mcp_is_user_has_relation_with_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_is_user_has_relation_with_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_is_user_has_relation_with_result_params*)=0;
if(_mcpack2_load_mcp_is_user_has_relation_with_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_is_user_has_relation_with_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_is_user_has_relation_with_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t has_relation=out();
{
int res=mc_pack_put_int32(pack,"has_relation",_m_has_relation);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_is_user_has_relation_with_response
static void _mcpack2_load_mcp_is_user_has_relation_with_response_result_params(const mc_pack_item_t*,mcp_is_user_has_relation_with_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_is_user_has_relation_with_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_is_user_has_relation_with_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_is_user_has_relation_with_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_is_user_has_relation_with_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_is_user_has_relation_with_response*)>("result_params",_mcpack2_load_mcp_is_user_has_relation_with_response_result_params));
_mcpack2_load_mcp_is_user_has_relation_with_response_readmap.create(16*1);
_mcpack2_load_mcp_is_user_has_relation_with_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_is_user_has_relation_with_response_static_inited=_mcpack2_load_mcp_is_user_has_relation_with_response_static_init();
// @@mcp_is_user_has_relation_with_result_params result_params;
static void _mcpack2_load_mcp_is_user_has_relation_with_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_is_user_has_relation_with_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_is_user_has_relation_with_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_is_user_has_relation_with_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_is_user_has_relation_with_response*)=0;
do{
if(_mcpack2_load_mcp_is_user_has_relation_with_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_is_user_has_relation_with_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_is_user_has_relation_with_response*)=0;
if(_mcpack2_load_mcp_is_user_has_relation_with_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_is_user_has_relation_with_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_is_user_has_relation_with_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_is_user_has_relation_with_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_download_games_info_by_uid_params
static void _mcpack2_load_mcp_get_download_games_info_by_uid_params_u_id(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*);
static void _mcpack2_load_mcp_get_download_games_info_by_uid_params_img_types(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*);
static void _mcpack2_load_mcp_get_download_games_info_by_uid_params_filter(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*);
static void _mcpack2_load_mcp_get_download_games_info_by_uid_params_unit_num(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*);
static void _mcpack2_load_mcp_get_download_games_info_by_uid_params_unit_times(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_download_games_info_by_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_download_games_info_by_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*)>("u_id",_mcpack2_load_mcp_get_download_games_info_by_uid_params_u_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*)>("img_types",_mcpack2_load_mcp_get_download_games_info_by_uid_params_img_types));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*)>("filter",_mcpack2_load_mcp_get_download_games_info_by_uid_params_filter));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*)>("unit_num",_mcpack2_load_mcp_get_download_games_info_by_uid_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*)>("unit_times",_mcpack2_load_mcp_get_download_games_info_by_uid_params_unit_times));
_mcpack2_load_mcp_get_download_games_info_by_uid_params_readmap.create(16*5);
_mcpack2_load_mcp_get_download_games_info_by_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_download_games_info_by_uid_params_static_inited=_mcpack2_load_mcp_get_download_games_info_by_uid_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_get_download_games_info_by_uid_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_games_info_by_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
// @@string img_types=in();
static void _mcpack2_load_mcp_get_download_games_info_by_uid_params_img_types(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_games_info_by_uid_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "img_types";
}
self->_m_img_types.set_ptr(item->value,item->value_size-1);
}
// @@string filter=in();
static void _mcpack2_load_mcp_get_download_games_info_by_uid_params_filter(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_games_info_by_uid_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "filter";
}
self->_m_filter.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_download_games_info_by_uid_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_games_info_by_uid_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_download_games_info_by_uid_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_games_info_by_uid_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_download_games_info_by_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*)=0;
do{
if(_mcpack2_load_mcp_get_download_games_info_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_download_games_info_by_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_params*)=0;
if(_mcpack2_load_mcp_get_download_games_info_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_download_games_info_by_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_download_games_info_by_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string img_types=in();
{
int res=mc_pack_put_str(pack,"img_types",_m_img_types.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string filter=in();
{
int res=mc_pack_put_str(pack,"filter",_m_filter.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_download_games_info_by_uid_result_params
static void _mcpack2_load_mcp_get_download_games_info_by_uid_result_params_count(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_result_params*);
static void _mcpack2_load_mcp_get_download_games_info_by_uid_result_params_result_list(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_download_games_info_by_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_download_games_info_by_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_result_params*)>("count",_mcpack2_load_mcp_get_download_games_info_by_uid_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_result_params*)>("result_list",_mcpack2_load_mcp_get_download_games_info_by_uid_result_params_result_list));
_mcpack2_load_mcp_get_download_games_info_by_uid_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_download_games_info_by_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_download_games_info_by_uid_result_params_static_inited=_mcpack2_load_mcp_get_download_games_info_by_uid_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_download_games_info_by_uid_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_games_info_by_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_content_download_info_t result_list=out(),array(0);
static void _mcpack2_load_mcp_get_download_games_info_by_uid_result_params_result_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_games_info_by_uid_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_result_list)) lp0=&(self->_m_result_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_download_games_info_by_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_download_games_info_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_download_games_info_by_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_result_params*)=0;
if(_mcpack2_load_mcp_get_download_games_info_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_download_games_info_by_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_download_games_info_by_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_content_download_info_t result_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"result_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_result_list)& lr0=(_m_result_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_download_games_info_by_uid_response
static void _mcpack2_load_mcp_get_download_games_info_by_uid_response_result_params(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_download_games_info_by_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_download_games_info_by_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_response*)>("result_params",_mcpack2_load_mcp_get_download_games_info_by_uid_response_result_params));
_mcpack2_load_mcp_get_download_games_info_by_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_get_download_games_info_by_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_download_games_info_by_uid_response_static_inited=_mcpack2_load_mcp_get_download_games_info_by_uid_response_static_init();
// @@mcp_get_download_games_info_by_uid_result_params result_params;
static void _mcpack2_load_mcp_get_download_games_info_by_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_download_games_info_by_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_download_games_info_by_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_download_games_info_by_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_response*)=0;
do{
if(_mcpack2_load_mcp_get_download_games_info_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_download_games_info_by_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_download_games_info_by_uid_response*)=0;
if(_mcpack2_load_mcp_get_download_games_info_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_download_games_info_by_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_download_games_info_by_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_download_games_info_by_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_new_guide_by_uid_params
static void _mcpack2_load_mcp_add_new_guide_by_uid_params_u_id(const mc_pack_item_t*,mcp_add_new_guide_by_uid_params*);
static void _mcpack2_load_mcp_add_new_guide_by_uid_params_guide_id(const mc_pack_item_t*,mcp_add_new_guide_by_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_new_guide_by_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_new_guide_by_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_params*)>("u_id",_mcpack2_load_mcp_add_new_guide_by_uid_params_u_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_params*)>("guide_id",_mcpack2_load_mcp_add_new_guide_by_uid_params_guide_id));
_mcpack2_load_mcp_add_new_guide_by_uid_params_readmap.create(16*2);
_mcpack2_load_mcp_add_new_guide_by_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_new_guide_by_uid_params_static_inited=_mcpack2_load_mcp_add_new_guide_by_uid_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_add_new_guide_by_uid_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_guide_by_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
// @@string guide_id=in();
static void _mcpack2_load_mcp_add_new_guide_by_uid_params_guide_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_guide_by_uid_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "guide_id";
}
self->_m_guide_id.set_ptr(item->value,item->value_size-1);
}
void mcp_add_new_guide_by_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_params*)=0;
do{
if(_mcpack2_load_mcp_add_new_guide_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_new_guide_by_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_params*)=0;
if(_mcpack2_load_mcp_add_new_guide_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_new_guide_by_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_new_guide_by_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string guide_id=in();
{
int res=mc_pack_put_str(pack,"guide_id",_m_guide_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_new_guide_by_uid_result_params
static void _mcpack2_load_mcp_add_new_guide_by_uid_result_params_ret_code(const mc_pack_item_t*,mcp_add_new_guide_by_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_new_guide_by_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_new_guide_by_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_result_params*)>("ret_code",_mcpack2_load_mcp_add_new_guide_by_uid_result_params_ret_code));
_mcpack2_load_mcp_add_new_guide_by_uid_result_params_readmap.create(16*1);
_mcpack2_load_mcp_add_new_guide_by_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_new_guide_by_uid_result_params_static_inited=_mcpack2_load_mcp_add_new_guide_by_uid_result_params_static_init();
// @@int32_t ret_code=out();
static void _mcpack2_load_mcp_add_new_guide_by_uid_result_params_ret_code(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_guide_by_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_ret_code));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ret_code";
}
}
void mcp_add_new_guide_by_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_add_new_guide_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_new_guide_by_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_result_params*)=0;
if(_mcpack2_load_mcp_add_new_guide_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_new_guide_by_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_new_guide_by_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t ret_code=out();
{
int res=mc_pack_put_int32(pack,"ret_code",_m_ret_code);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_new_guide_by_uid_response
static void _mcpack2_load_mcp_add_new_guide_by_uid_response_result_params(const mc_pack_item_t*,mcp_add_new_guide_by_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_new_guide_by_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_new_guide_by_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_response*)>("result_params",_mcpack2_load_mcp_add_new_guide_by_uid_response_result_params));
_mcpack2_load_mcp_add_new_guide_by_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_add_new_guide_by_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_new_guide_by_uid_response_static_inited=_mcpack2_load_mcp_add_new_guide_by_uid_response_static_init();
// @@mcp_add_new_guide_by_uid_result_params result_params;
static void _mcpack2_load_mcp_add_new_guide_by_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_guide_by_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_add_new_guide_by_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_add_new_guide_by_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_response*)=0;
do{
if(_mcpack2_load_mcp_add_new_guide_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_new_guide_by_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_new_guide_by_uid_response*)=0;
if(_mcpack2_load_mcp_add_new_guide_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_new_guide_by_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_new_guide_by_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_add_new_guide_by_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_remove_guide_by_uid_params
static void _mcpack2_load_mcp_remove_guide_by_uid_params_u_id(const mc_pack_item_t*,mcp_remove_guide_by_uid_params*);
static void _mcpack2_load_mcp_remove_guide_by_uid_params_guide_id(const mc_pack_item_t*,mcp_remove_guide_by_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_remove_guide_by_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_remove_guide_by_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_remove_guide_by_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_remove_guide_by_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_remove_guide_by_uid_params*)>("u_id",_mcpack2_load_mcp_remove_guide_by_uid_params_u_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_remove_guide_by_uid_params*)>("guide_id",_mcpack2_load_mcp_remove_guide_by_uid_params_guide_id));
_mcpack2_load_mcp_remove_guide_by_uid_params_readmap.create(16*2);
_mcpack2_load_mcp_remove_guide_by_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_remove_guide_by_uid_params_static_inited=_mcpack2_load_mcp_remove_guide_by_uid_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_remove_guide_by_uid_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_remove_guide_by_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
// @@string guide_id=in();
static void _mcpack2_load_mcp_remove_guide_by_uid_params_guide_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_remove_guide_by_uid_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "guide_id";
}
self->_m_guide_id.set_ptr(item->value,item->value_size-1);
}
void mcp_remove_guide_by_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_remove_guide_by_uid_params*)=0;
do{
if(_mcpack2_load_mcp_remove_guide_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_remove_guide_by_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_remove_guide_by_uid_params*)=0;
if(_mcpack2_load_mcp_remove_guide_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_remove_guide_by_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_remove_guide_by_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string guide_id=in();
{
int res=mc_pack_put_str(pack,"guide_id",_m_guide_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_remove_guide_by_uid_result_params
static void _mcpack2_load_mcp_remove_guide_by_uid_result_params_ret_code(const mc_pack_item_t*,mcp_remove_guide_by_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_remove_guide_by_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_remove_guide_by_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_remove_guide_by_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_remove_guide_by_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_remove_guide_by_uid_result_params*)>("ret_code",_mcpack2_load_mcp_remove_guide_by_uid_result_params_ret_code));
_mcpack2_load_mcp_remove_guide_by_uid_result_params_readmap.create(16*1);
_mcpack2_load_mcp_remove_guide_by_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_remove_guide_by_uid_result_params_static_inited=_mcpack2_load_mcp_remove_guide_by_uid_result_params_static_init();
// @@int32_t ret_code=out();
static void _mcpack2_load_mcp_remove_guide_by_uid_result_params_ret_code(__attribute__((unused)) const mc_pack_item_t* item,mcp_remove_guide_by_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_ret_code));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ret_code";
}
}
void mcp_remove_guide_by_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_remove_guide_by_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_remove_guide_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_remove_guide_by_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_remove_guide_by_uid_result_params*)=0;
if(_mcpack2_load_mcp_remove_guide_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_remove_guide_by_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_remove_guide_by_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t ret_code=out();
{
int res=mc_pack_put_int32(pack,"ret_code",_m_ret_code);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_remove_guide_by_uid_response
static void _mcpack2_load_mcp_remove_guide_by_uid_response_result_params(const mc_pack_item_t*,mcp_remove_guide_by_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_remove_guide_by_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_remove_guide_by_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_remove_guide_by_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_remove_guide_by_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_remove_guide_by_uid_response*)>("result_params",_mcpack2_load_mcp_remove_guide_by_uid_response_result_params));
_mcpack2_load_mcp_remove_guide_by_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_remove_guide_by_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_remove_guide_by_uid_response_static_inited=_mcpack2_load_mcp_remove_guide_by_uid_response_static_init();
// @@mcp_remove_guide_by_uid_result_params result_params;
static void _mcpack2_load_mcp_remove_guide_by_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_remove_guide_by_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_remove_guide_by_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_remove_guide_by_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_remove_guide_by_uid_response*)=0;
do{
if(_mcpack2_load_mcp_remove_guide_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_remove_guide_by_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_remove_guide_by_uid_response*)=0;
if(_mcpack2_load_mcp_remove_guide_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_remove_guide_by_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_remove_guide_by_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_remove_guide_by_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_guides_count_by_uid_params
static void _mcpack2_load_mcp_get_guides_count_by_uid_params_u_id(const mc_pack_item_t*,mcp_get_guides_count_by_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_guides_count_by_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_guides_count_by_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_params*)>("u_id",_mcpack2_load_mcp_get_guides_count_by_uid_params_u_id));
_mcpack2_load_mcp_get_guides_count_by_uid_params_readmap.create(16*1);
_mcpack2_load_mcp_get_guides_count_by_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_guides_count_by_uid_params_static_inited=_mcpack2_load_mcp_get_guides_count_by_uid_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_get_guides_count_by_uid_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_guides_count_by_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_guides_count_by_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_params*)=0;
do{
if(_mcpack2_load_mcp_get_guides_count_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_guides_count_by_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_params*)=0;
if(_mcpack2_load_mcp_get_guides_count_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_guides_count_by_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_guides_count_by_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_guides_count_by_uid_result_params
static void _mcpack2_load_mcp_get_guides_count_by_uid_result_params_count(const mc_pack_item_t*,mcp_get_guides_count_by_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_guides_count_by_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_guides_count_by_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_result_params*)>("count",_mcpack2_load_mcp_get_guides_count_by_uid_result_params_count));
_mcpack2_load_mcp_get_guides_count_by_uid_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_guides_count_by_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_guides_count_by_uid_result_params_static_inited=_mcpack2_load_mcp_get_guides_count_by_uid_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_guides_count_by_uid_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_guides_count_by_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
void mcp_get_guides_count_by_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_guides_count_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_guides_count_by_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_result_params*)=0;
if(_mcpack2_load_mcp_get_guides_count_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_guides_count_by_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_guides_count_by_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_guides_count_by_uid_response
static void _mcpack2_load_mcp_get_guides_count_by_uid_response_result_params(const mc_pack_item_t*,mcp_get_guides_count_by_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_guides_count_by_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_guides_count_by_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_response*)>("result_params",_mcpack2_load_mcp_get_guides_count_by_uid_response_result_params));
_mcpack2_load_mcp_get_guides_count_by_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_get_guides_count_by_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_guides_count_by_uid_response_static_inited=_mcpack2_load_mcp_get_guides_count_by_uid_response_static_init();
// @@mcp_get_guides_count_by_uid_result_params result_params;
static void _mcpack2_load_mcp_get_guides_count_by_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_guides_count_by_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_guides_count_by_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_guides_count_by_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_response*)=0;
do{
if(_mcpack2_load_mcp_get_guides_count_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_guides_count_by_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_guides_count_by_uid_response*)=0;
if(_mcpack2_load_mcp_get_guides_count_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_guides_count_by_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_guides_count_by_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_guides_count_by_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_guides_info_by_uid_params
static void _mcpack2_load_mcp_get_guides_info_by_uid_params_u_id(const mc_pack_item_t*,mcp_get_guides_info_by_uid_params*);
static void _mcpack2_load_mcp_get_guides_info_by_uid_params_unit_num(const mc_pack_item_t*,mcp_get_guides_info_by_uid_params*);
static void _mcpack2_load_mcp_get_guides_info_by_uid_params_unit_times(const mc_pack_item_t*,mcp_get_guides_info_by_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_guides_info_by_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_guides_info_by_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_params*)>("u_id",_mcpack2_load_mcp_get_guides_info_by_uid_params_u_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_params*)>("unit_num",_mcpack2_load_mcp_get_guides_info_by_uid_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_params*)>("unit_times",_mcpack2_load_mcp_get_guides_info_by_uid_params_unit_times));
_mcpack2_load_mcp_get_guides_info_by_uid_params_readmap.create(16*3);
_mcpack2_load_mcp_get_guides_info_by_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_guides_info_by_uid_params_static_inited=_mcpack2_load_mcp_get_guides_info_by_uid_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_get_guides_info_by_uid_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_guides_info_by_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_guides_info_by_uid_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_guides_info_by_uid_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_guides_info_by_uid_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_guides_info_by_uid_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_guides_info_by_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_params*)=0;
do{
if(_mcpack2_load_mcp_get_guides_info_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_guides_info_by_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_params*)=0;
if(_mcpack2_load_mcp_get_guides_info_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_guides_info_by_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_guides_info_by_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_guides_info_by_uid_result_params
static void _mcpack2_load_mcp_get_guides_info_by_uid_result_params_count(const mc_pack_item_t*,mcp_get_guides_info_by_uid_result_params*);
static void _mcpack2_load_mcp_get_guides_info_by_uid_result_params_result_list(const mc_pack_item_t*,mcp_get_guides_info_by_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_guides_info_by_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_guides_info_by_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_result_params*)>("count",_mcpack2_load_mcp_get_guides_info_by_uid_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_result_params*)>("result_list",_mcpack2_load_mcp_get_guides_info_by_uid_result_params_result_list));
_mcpack2_load_mcp_get_guides_info_by_uid_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_guides_info_by_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_guides_info_by_uid_result_params_static_inited=_mcpack2_load_mcp_get_guides_info_by_uid_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_guides_info_by_uid_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_guides_info_by_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_info_t result_list=out(),array(0);
static void _mcpack2_load_mcp_get_guides_info_by_uid_result_params_result_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_guides_info_by_uid_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_result_list)) lp0=&(self->_m_result_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_guides_info_by_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_guides_info_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_guides_info_by_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_result_params*)=0;
if(_mcpack2_load_mcp_get_guides_info_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_guides_info_by_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_guides_info_by_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_info_t result_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"result_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_result_list)& lr0=(_m_result_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_guides_info_by_uid_response
static void _mcpack2_load_mcp_get_guides_info_by_uid_response_result_params(const mc_pack_item_t*,mcp_get_guides_info_by_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_guides_info_by_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_guides_info_by_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_response*)>("result_params",_mcpack2_load_mcp_get_guides_info_by_uid_response_result_params));
_mcpack2_load_mcp_get_guides_info_by_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_get_guides_info_by_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_guides_info_by_uid_response_static_inited=_mcpack2_load_mcp_get_guides_info_by_uid_response_static_init();
// @@mcp_get_guides_info_by_uid_result_params result_params;
static void _mcpack2_load_mcp_get_guides_info_by_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_guides_info_by_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_guides_info_by_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_guides_info_by_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_response*)=0;
do{
if(_mcpack2_load_mcp_get_guides_info_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_guides_info_by_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_guides_info_by_uid_response*)=0;
if(_mcpack2_load_mcp_get_guides_info_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_guides_info_by_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_guides_info_by_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_guides_info_by_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_new_favorite_by_uid_params
static void _mcpack2_load_mcp_add_new_favorite_by_uid_params_u_id(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_params*);
static void _mcpack2_load_mcp_add_new_favorite_by_uid_params_favorites_id(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_new_favorite_by_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_new_favorite_by_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_params*)>("u_id",_mcpack2_load_mcp_add_new_favorite_by_uid_params_u_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_params*)>("favorites_id",_mcpack2_load_mcp_add_new_favorite_by_uid_params_favorites_id));
_mcpack2_load_mcp_add_new_favorite_by_uid_params_readmap.create(16*2);
_mcpack2_load_mcp_add_new_favorite_by_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_new_favorite_by_uid_params_static_inited=_mcpack2_load_mcp_add_new_favorite_by_uid_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_add_new_favorite_by_uid_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_favorite_by_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
// @@string favorites_id=in();
static void _mcpack2_load_mcp_add_new_favorite_by_uid_params_favorites_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_favorite_by_uid_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "favorites_id";
}
self->_m_favorites_id.set_ptr(item->value,item->value_size-1);
}
void mcp_add_new_favorite_by_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_params*)=0;
do{
if(_mcpack2_load_mcp_add_new_favorite_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_new_favorite_by_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_params*)=0;
if(_mcpack2_load_mcp_add_new_favorite_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_new_favorite_by_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_new_favorite_by_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string favorites_id=in();
{
int res=mc_pack_put_str(pack,"favorites_id",_m_favorites_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_new_favorite_by_uid_result_params
static void _mcpack2_load_mcp_add_new_favorite_by_uid_result_params_ret_code(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_new_favorite_by_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_new_favorite_by_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_result_params*)>("ret_code",_mcpack2_load_mcp_add_new_favorite_by_uid_result_params_ret_code));
_mcpack2_load_mcp_add_new_favorite_by_uid_result_params_readmap.create(16*1);
_mcpack2_load_mcp_add_new_favorite_by_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_new_favorite_by_uid_result_params_static_inited=_mcpack2_load_mcp_add_new_favorite_by_uid_result_params_static_init();
// @@int32_t ret_code=out();
static void _mcpack2_load_mcp_add_new_favorite_by_uid_result_params_ret_code(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_favorite_by_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_ret_code));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ret_code";
}
}
void mcp_add_new_favorite_by_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_add_new_favorite_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_new_favorite_by_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_result_params*)=0;
if(_mcpack2_load_mcp_add_new_favorite_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_new_favorite_by_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_new_favorite_by_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t ret_code=out();
{
int res=mc_pack_put_int32(pack,"ret_code",_m_ret_code);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_new_favorite_by_uid_response
static void _mcpack2_load_mcp_add_new_favorite_by_uid_response_result_params(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_new_favorite_by_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_new_favorite_by_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_response*)>("result_params",_mcpack2_load_mcp_add_new_favorite_by_uid_response_result_params));
_mcpack2_load_mcp_add_new_favorite_by_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_add_new_favorite_by_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_new_favorite_by_uid_response_static_inited=_mcpack2_load_mcp_add_new_favorite_by_uid_response_static_init();
// @@mcp_add_new_favorite_by_uid_result_params result_params;
static void _mcpack2_load_mcp_add_new_favorite_by_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_favorite_by_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_add_new_favorite_by_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_add_new_favorite_by_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_response*)=0;
do{
if(_mcpack2_load_mcp_add_new_favorite_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_new_favorite_by_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_new_favorite_by_uid_response*)=0;
if(_mcpack2_load_mcp_add_new_favorite_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_new_favorite_by_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_new_favorite_by_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_add_new_favorite_by_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_remove_favorite_by_uid_params
static void _mcpack2_load_mcp_remove_favorite_by_uid_params_u_id(const mc_pack_item_t*,mcp_remove_favorite_by_uid_params*);
static void _mcpack2_load_mcp_remove_favorite_by_uid_params_favorites_id(const mc_pack_item_t*,mcp_remove_favorite_by_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_remove_favorite_by_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_remove_favorite_by_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_params*)>("u_id",_mcpack2_load_mcp_remove_favorite_by_uid_params_u_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_params*)>("favorites_id",_mcpack2_load_mcp_remove_favorite_by_uid_params_favorites_id));
_mcpack2_load_mcp_remove_favorite_by_uid_params_readmap.create(16*2);
_mcpack2_load_mcp_remove_favorite_by_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_remove_favorite_by_uid_params_static_inited=_mcpack2_load_mcp_remove_favorite_by_uid_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_remove_favorite_by_uid_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_remove_favorite_by_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
// @@string favorites_id=in();
static void _mcpack2_load_mcp_remove_favorite_by_uid_params_favorites_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_remove_favorite_by_uid_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "favorites_id";
}
self->_m_favorites_id.set_ptr(item->value,item->value_size-1);
}
void mcp_remove_favorite_by_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_params*)=0;
do{
if(_mcpack2_load_mcp_remove_favorite_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_remove_favorite_by_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_params*)=0;
if(_mcpack2_load_mcp_remove_favorite_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_remove_favorite_by_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_remove_favorite_by_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string favorites_id=in();
{
int res=mc_pack_put_str(pack,"favorites_id",_m_favorites_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_remove_favorite_by_uid_result_params
static void _mcpack2_load_mcp_remove_favorite_by_uid_result_params_ret_code(const mc_pack_item_t*,mcp_remove_favorite_by_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_remove_favorite_by_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_remove_favorite_by_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_result_params*)>("ret_code",_mcpack2_load_mcp_remove_favorite_by_uid_result_params_ret_code));
_mcpack2_load_mcp_remove_favorite_by_uid_result_params_readmap.create(16*1);
_mcpack2_load_mcp_remove_favorite_by_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_remove_favorite_by_uid_result_params_static_inited=_mcpack2_load_mcp_remove_favorite_by_uid_result_params_static_init();
// @@int32_t ret_code=out();
static void _mcpack2_load_mcp_remove_favorite_by_uid_result_params_ret_code(__attribute__((unused)) const mc_pack_item_t* item,mcp_remove_favorite_by_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_ret_code));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ret_code";
}
}
void mcp_remove_favorite_by_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_remove_favorite_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_remove_favorite_by_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_result_params*)=0;
if(_mcpack2_load_mcp_remove_favorite_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_remove_favorite_by_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_remove_favorite_by_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t ret_code=out();
{
int res=mc_pack_put_int32(pack,"ret_code",_m_ret_code);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_remove_favorite_by_uid_response
static void _mcpack2_load_mcp_remove_favorite_by_uid_response_result_params(const mc_pack_item_t*,mcp_remove_favorite_by_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_remove_favorite_by_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_remove_favorite_by_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_response*)>("result_params",_mcpack2_load_mcp_remove_favorite_by_uid_response_result_params));
_mcpack2_load_mcp_remove_favorite_by_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_remove_favorite_by_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_remove_favorite_by_uid_response_static_inited=_mcpack2_load_mcp_remove_favorite_by_uid_response_static_init();
// @@mcp_remove_favorite_by_uid_result_params result_params;
static void _mcpack2_load_mcp_remove_favorite_by_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_remove_favorite_by_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_remove_favorite_by_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_remove_favorite_by_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_response*)=0;
do{
if(_mcpack2_load_mcp_remove_favorite_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_remove_favorite_by_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_remove_favorite_by_uid_response*)=0;
if(_mcpack2_load_mcp_remove_favorite_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_remove_favorite_by_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_remove_favorite_by_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_remove_favorite_by_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_favorites_count_by_uid_params
static void _mcpack2_load_mcp_get_favorites_count_by_uid_params_u_id(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_favorites_count_by_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_favorites_count_by_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_params*)>("u_id",_mcpack2_load_mcp_get_favorites_count_by_uid_params_u_id));
_mcpack2_load_mcp_get_favorites_count_by_uid_params_readmap.create(16*1);
_mcpack2_load_mcp_get_favorites_count_by_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_favorites_count_by_uid_params_static_inited=_mcpack2_load_mcp_get_favorites_count_by_uid_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_get_favorites_count_by_uid_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favorites_count_by_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_favorites_count_by_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_params*)=0;
do{
if(_mcpack2_load_mcp_get_favorites_count_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_favorites_count_by_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_params*)=0;
if(_mcpack2_load_mcp_get_favorites_count_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_favorites_count_by_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_favorites_count_by_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_favorites_count_by_uid_result_params
static void _mcpack2_load_mcp_get_favorites_count_by_uid_result_params_count(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_favorites_count_by_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_favorites_count_by_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_result_params*)>("count",_mcpack2_load_mcp_get_favorites_count_by_uid_result_params_count));
_mcpack2_load_mcp_get_favorites_count_by_uid_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_favorites_count_by_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_favorites_count_by_uid_result_params_static_inited=_mcpack2_load_mcp_get_favorites_count_by_uid_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_favorites_count_by_uid_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favorites_count_by_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
void mcp_get_favorites_count_by_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_favorites_count_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_favorites_count_by_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_result_params*)=0;
if(_mcpack2_load_mcp_get_favorites_count_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_favorites_count_by_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_favorites_count_by_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_favorites_count_by_uid_response
static void _mcpack2_load_mcp_get_favorites_count_by_uid_response_result_params(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_favorites_count_by_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_favorites_count_by_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_response*)>("result_params",_mcpack2_load_mcp_get_favorites_count_by_uid_response_result_params));
_mcpack2_load_mcp_get_favorites_count_by_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_get_favorites_count_by_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_favorites_count_by_uid_response_static_inited=_mcpack2_load_mcp_get_favorites_count_by_uid_response_static_init();
// @@mcp_get_favorites_count_by_uid_result_params result_params;
static void _mcpack2_load_mcp_get_favorites_count_by_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favorites_count_by_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_favorites_count_by_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_favorites_count_by_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_response*)=0;
do{
if(_mcpack2_load_mcp_get_favorites_count_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_favorites_count_by_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_favorites_count_by_uid_response*)=0;
if(_mcpack2_load_mcp_get_favorites_count_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_favorites_count_by_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_favorites_count_by_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_favorites_count_by_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_favorites_info_by_uid_params
static void _mcpack2_load_mcp_get_favorites_info_by_uid_params_u_id(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*);
static void _mcpack2_load_mcp_get_favorites_info_by_uid_params_img_types(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*);
static void _mcpack2_load_mcp_get_favorites_info_by_uid_params_filter(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*);
static void _mcpack2_load_mcp_get_favorites_info_by_uid_params_unit_num(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*);
static void _mcpack2_load_mcp_get_favorites_info_by_uid_params_unit_times(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_favorites_info_by_uid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_favorites_info_by_uid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*)>("u_id",_mcpack2_load_mcp_get_favorites_info_by_uid_params_u_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*)>("img_types",_mcpack2_load_mcp_get_favorites_info_by_uid_params_img_types));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*)>("filter",_mcpack2_load_mcp_get_favorites_info_by_uid_params_filter));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*)>("unit_num",_mcpack2_load_mcp_get_favorites_info_by_uid_params_unit_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*)>("unit_times",_mcpack2_load_mcp_get_favorites_info_by_uid_params_unit_times));
_mcpack2_load_mcp_get_favorites_info_by_uid_params_readmap.create(16*5);
_mcpack2_load_mcp_get_favorites_info_by_uid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_favorites_info_by_uid_params_static_inited=_mcpack2_load_mcp_get_favorites_info_by_uid_params_static_init();
// @@string u_id=in();
static void _mcpack2_load_mcp_get_favorites_info_by_uid_params_u_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favorites_info_by_uid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "u_id";
}
self->_m_u_id.set_ptr(item->value,item->value_size-1);
}
// @@string img_types=in();
static void _mcpack2_load_mcp_get_favorites_info_by_uid_params_img_types(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favorites_info_by_uid_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "img_types";
}
self->_m_img_types.set_ptr(item->value,item->value_size-1);
}
// @@string filter=in();
static void _mcpack2_load_mcp_get_favorites_info_by_uid_params_filter(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favorites_info_by_uid_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "filter";
}
self->_m_filter.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t unit_num=in();
static void _mcpack2_load_mcp_get_favorites_info_by_uid_params_unit_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favorites_info_by_uid_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_num";
}
}
// @@uint32_t unit_times=in();
static void _mcpack2_load_mcp_get_favorites_info_by_uid_params_unit_times(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favorites_info_by_uid_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_unit_times));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "unit_times";
}
}
void mcp_get_favorites_info_by_uid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*)=0;
do{
if(_mcpack2_load_mcp_get_favorites_info_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_favorites_info_by_uid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_params*)=0;
if(_mcpack2_load_mcp_get_favorites_info_by_uid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_favorites_info_by_uid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_favorites_info_by_uid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string u_id=in();
{
int res=mc_pack_put_str(pack,"u_id",_m_u_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string img_types=in();
{
int res=mc_pack_put_str(pack,"img_types",_m_img_types.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string filter=in();
{
int res=mc_pack_put_str(pack,"filter",_m_filter.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_num=in();
{
int res=mc_pack_put_uint32(pack,"unit_num",_m_unit_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t unit_times=in();
{
int res=mc_pack_put_uint32(pack,"unit_times",_m_unit_times);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_favorites_info_by_uid_result_params
static void _mcpack2_load_mcp_get_favorites_info_by_uid_result_params_count(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_result_params*);
static void _mcpack2_load_mcp_get_favorites_info_by_uid_result_params_result_list(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_favorites_info_by_uid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_favorites_info_by_uid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_result_params*)>("count",_mcpack2_load_mcp_get_favorites_info_by_uid_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_result_params*)>("result_list",_mcpack2_load_mcp_get_favorites_info_by_uid_result_params_result_list));
_mcpack2_load_mcp_get_favorites_info_by_uid_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_favorites_info_by_uid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_favorites_info_by_uid_result_params_static_inited=_mcpack2_load_mcp_get_favorites_info_by_uid_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_favorites_info_by_uid_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favorites_info_by_uid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_content_download_info_t result_list=out(),array(0);
static void _mcpack2_load_mcp_get_favorites_info_by_uid_result_params_result_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favorites_info_by_uid_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_result_list)) lp0=&(self->_m_result_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_favorites_info_by_uid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_favorites_info_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_favorites_info_by_uid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_result_params*)=0;
if(_mcpack2_load_mcp_get_favorites_info_by_uid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_favorites_info_by_uid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_favorites_info_by_uid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_content_download_info_t result_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"result_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_result_list)& lr0=(_m_result_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_favorites_info_by_uid_response
static void _mcpack2_load_mcp_get_favorites_info_by_uid_response_result_params(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_favorites_info_by_uid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_favorites_info_by_uid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_response*)>("result_params",_mcpack2_load_mcp_get_favorites_info_by_uid_response_result_params));
_mcpack2_load_mcp_get_favorites_info_by_uid_response_readmap.create(16*1);
_mcpack2_load_mcp_get_favorites_info_by_uid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_favorites_info_by_uid_response_static_inited=_mcpack2_load_mcp_get_favorites_info_by_uid_response_static_init();
// @@mcp_get_favorites_info_by_uid_result_params result_params;
static void _mcpack2_load_mcp_get_favorites_info_by_uid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_favorites_info_by_uid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_favorites_info_by_uid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_favorites_info_by_uid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_response*)=0;
do{
if(_mcpack2_load_mcp_get_favorites_info_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_favorites_info_by_uid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_favorites_info_by_uid_response*)=0;
if(_mcpack2_load_mcp_get_favorites_info_by_uid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_favorites_info_by_uid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_favorites_info_by_uid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_favorites_info_by_uid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_grab_list_params
static void _mcpack2_load_mcp_get_grab_list_params_type_id(const mc_pack_item_t*,mcp_get_grab_list_params*);
static void _mcpack2_load_mcp_get_grab_list_params_c_id(const mc_pack_item_t*,mcp_get_grab_list_params*);
static void _mcpack2_load_mcp_get_grab_list_params_id(const mc_pack_item_t*,mcp_get_grab_list_params*);
static void _mcpack2_load_mcp_get_grab_list_params_user_id(const mc_pack_item_t*,mcp_get_grab_list_params*);
static void _mcpack2_load_mcp_get_grab_list_params_page(const mc_pack_item_t*,mcp_get_grab_list_params*);
static void _mcpack2_load_mcp_get_grab_list_params_page_size(const mc_pack_item_t*,mcp_get_grab_list_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_grab_list_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_grab_list_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_grab_list_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_params*)>("type_id",_mcpack2_load_mcp_get_grab_list_params_type_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_params*)>("c_id",_mcpack2_load_mcp_get_grab_list_params_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_params*)>("id",_mcpack2_load_mcp_get_grab_list_params_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_params*)>("user_id",_mcpack2_load_mcp_get_grab_list_params_user_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_params*)>("page",_mcpack2_load_mcp_get_grab_list_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_params*)>("page_size",_mcpack2_load_mcp_get_grab_list_params_page_size));
_mcpack2_load_mcp_get_grab_list_params_readmap.create(16*6);
_mcpack2_load_mcp_get_grab_list_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_grab_list_params_static_inited=_mcpack2_load_mcp_get_grab_list_params_static_init();
// @@string type_id=in();
static void _mcpack2_load_mcp_get_grab_list_params_type_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "type_id";
}
self->_m_type_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id=in();
static void _mcpack2_load_mcp_get_grab_list_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t id=in();
static void _mcpack2_load_mcp_get_grab_list_params_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_id));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
}
// @@string user_id=in();
static void _mcpack2_load_mcp_get_grab_list_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_grab_list_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_grab_list_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_grab_list_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_grab_list_params*)=0;
do{
if(_mcpack2_load_mcp_get_grab_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_grab_list_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_grab_list_params*)=0;
if(_mcpack2_load_mcp_get_grab_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_grab_list_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_grab_list_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string type_id=in();
{
int res=mc_pack_put_str(pack,"type_id",_m_type_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t id=in();
{
int res=mc_pack_put_uint32(pack,"id",_m_id);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string user_id=in();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_grab_list_result_params
static void _mcpack2_load_mcp_get_grab_list_result_params_count(const mc_pack_item_t*,mcp_get_grab_list_result_params*);
static void _mcpack2_load_mcp_get_grab_list_result_params_grab_list(const mc_pack_item_t*,mcp_get_grab_list_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_grab_list_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_grab_list_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_grab_list_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_result_params*)>("count",_mcpack2_load_mcp_get_grab_list_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_result_params*)>("grab_list",_mcpack2_load_mcp_get_grab_list_result_params_grab_list));
_mcpack2_load_mcp_get_grab_list_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_grab_list_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_grab_list_result_params_static_inited=_mcpack2_load_mcp_get_grab_list_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_grab_list_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@grab_info_t grab_list=out(),array(0);
static void _mcpack2_load_mcp_get_grab_list_result_params_grab_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "grab_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_grab_list)) lp0=&(self->_m_grab_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "grab_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "grab_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "grab_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_grab_list_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_grab_list_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_grab_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_grab_list_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_grab_list_result_params*)=0;
if(_mcpack2_load_mcp_get_grab_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_grab_list_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_grab_list_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@grab_info_t grab_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"grab_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_grab_list)& lr0=(_m_grab_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_grab_list_response
static void _mcpack2_load_mcp_get_grab_list_response_result_params(const mc_pack_item_t*,mcp_get_grab_list_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_grab_list_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_grab_list_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_grab_list_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_grab_list_response*)>("result_params",_mcpack2_load_mcp_get_grab_list_response_result_params));
_mcpack2_load_mcp_get_grab_list_response_readmap.create(16*1);
_mcpack2_load_mcp_get_grab_list_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_grab_list_response_static_inited=_mcpack2_load_mcp_get_grab_list_response_static_init();
// @@mcp_get_grab_list_result_params result_params;
static void _mcpack2_load_mcp_get_grab_list_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_grab_list_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_grab_list_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_grab_list_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_grab_list_response*)=0;
do{
if(_mcpack2_load_mcp_get_grab_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_grab_list_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_grab_list_response*)=0;
if(_mcpack2_load_mcp_get_grab_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_grab_list_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_grab_list_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_grab_list_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_user_grab_num_list_params
static void _mcpack2_load_mcp_get_user_grab_num_list_params_user_id(const mc_pack_item_t*,mcp_get_user_grab_num_list_params*);
static void _mcpack2_load_mcp_get_user_grab_num_list_params_page(const mc_pack_item_t*,mcp_get_user_grab_num_list_params*);
static void _mcpack2_load_mcp_get_user_grab_num_list_params_page_size(const mc_pack_item_t*,mcp_get_user_grab_num_list_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_list_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_user_grab_num_list_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_user_grab_num_list_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_list_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_list_params*)>("user_id",_mcpack2_load_mcp_get_user_grab_num_list_params_user_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_list_params*)>("page",_mcpack2_load_mcp_get_user_grab_num_list_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_list_params*)>("page_size",_mcpack2_load_mcp_get_user_grab_num_list_params_page_size));
_mcpack2_load_mcp_get_user_grab_num_list_params_readmap.create(16*3);
_mcpack2_load_mcp_get_user_grab_num_list_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_user_grab_num_list_params_static_inited=_mcpack2_load_mcp_get_user_grab_num_list_params_static_init();
// @@string user_id=in();
static void _mcpack2_load_mcp_get_user_grab_num_list_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_grab_num_list_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_user_grab_num_list_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_grab_num_list_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_user_grab_num_list_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_grab_num_list_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_user_grab_num_list_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_user_grab_num_list_params*)=0;
do{
if(_mcpack2_load_mcp_get_user_grab_num_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_user_grab_num_list_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_user_grab_num_list_params*)=0;
if(_mcpack2_load_mcp_get_user_grab_num_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_user_grab_num_list_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_user_grab_num_list_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string user_id=in();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_user_grab_num_list_result_params
static void _mcpack2_load_mcp_get_user_grab_num_list_result_params_count(const mc_pack_item_t*,mcp_get_user_grab_num_list_result_params*);
static void _mcpack2_load_mcp_get_user_grab_num_list_result_params_user_grab_num_list(const mc_pack_item_t*,mcp_get_user_grab_num_list_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_list_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_user_grab_num_list_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_user_grab_num_list_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_list_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_list_result_params*)>("count",_mcpack2_load_mcp_get_user_grab_num_list_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_list_result_params*)>("user_grab_num_list",_mcpack2_load_mcp_get_user_grab_num_list_result_params_user_grab_num_list));
_mcpack2_load_mcp_get_user_grab_num_list_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_user_grab_num_list_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_user_grab_num_list_result_params_static_inited=_mcpack2_load_mcp_get_user_grab_num_list_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_user_grab_num_list_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_grab_num_list_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@user_grab_number_t user_grab_num_list=out(),array(0);
static void _mcpack2_load_mcp_get_user_grab_num_list_result_params_user_grab_num_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_grab_num_list_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "user_grab_num_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_user_grab_num_list)) lp0=&(self->_m_user_grab_num_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "user_grab_num_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "user_grab_num_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "user_grab_num_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_user_grab_num_list_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_user_grab_num_list_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_user_grab_num_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_user_grab_num_list_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_user_grab_num_list_result_params*)=0;
if(_mcpack2_load_mcp_get_user_grab_num_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_user_grab_num_list_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_user_grab_num_list_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@user_grab_number_t user_grab_num_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"user_grab_num_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_user_grab_num_list)& lr0=(_m_user_grab_num_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_user_grab_num_list_response
static void _mcpack2_load_mcp_get_user_grab_num_list_response_result_params(const mc_pack_item_t*,mcp_get_user_grab_num_list_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_list_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_user_grab_num_list_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_user_grab_num_list_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_list_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_grab_num_list_response*)>("result_params",_mcpack2_load_mcp_get_user_grab_num_list_response_result_params));
_mcpack2_load_mcp_get_user_grab_num_list_response_readmap.create(16*1);
_mcpack2_load_mcp_get_user_grab_num_list_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_user_grab_num_list_response_static_inited=_mcpack2_load_mcp_get_user_grab_num_list_response_static_init();
// @@mcp_get_user_grab_num_list_result_params result_params;
static void _mcpack2_load_mcp_get_user_grab_num_list_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_grab_num_list_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_user_grab_num_list_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_user_grab_num_list_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_user_grab_num_list_response*)=0;
do{
if(_mcpack2_load_mcp_get_user_grab_num_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_user_grab_num_list_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_user_grab_num_list_response*)=0;
if(_mcpack2_load_mcp_get_user_grab_num_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_user_grab_num_list_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_user_grab_num_list_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_user_grab_num_list_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_common_adv_info_params
static void _mcpack2_load_mcp_get_common_adv_info_params_id(const mc_pack_item_t*,mcp_get_common_adv_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_common_adv_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_common_adv_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_common_adv_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_common_adv_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_common_adv_info_params*)>("id",_mcpack2_load_mcp_get_common_adv_info_params_id));
_mcpack2_load_mcp_get_common_adv_info_params_readmap.create(16*1);
_mcpack2_load_mcp_get_common_adv_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_common_adv_info_params_static_inited=_mcpack2_load_mcp_get_common_adv_info_params_static_init();
// @@string id=in();
static void _mcpack2_load_mcp_get_common_adv_info_params_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_common_adv_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_common_adv_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_common_adv_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_common_adv_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_common_adv_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_common_adv_info_params*)=0;
if(_mcpack2_load_mcp_get_common_adv_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_common_adv_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_common_adv_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id=in();
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_common_adv_info_result_params
static void _mcpack2_load_mcp_get_common_adv_info_result_params_info(const mc_pack_item_t*,mcp_get_common_adv_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_common_adv_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_common_adv_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_common_adv_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_common_adv_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_common_adv_info_result_params*)>("info",_mcpack2_load_mcp_get_common_adv_info_result_params_info));
_mcpack2_load_mcp_get_common_adv_info_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_common_adv_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_common_adv_info_result_params_static_inited=_mcpack2_load_mcp_get_common_adv_info_result_params_static_init();
// @@string info=out();
static void _mcpack2_load_mcp_get_common_adv_info_result_params_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_common_adv_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info";
}
self->_m_info.set_ptr(item->value,item->value_size-1);
}
void mcp_get_common_adv_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_common_adv_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_common_adv_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_common_adv_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_common_adv_info_result_params*)=0;
if(_mcpack2_load_mcp_get_common_adv_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_common_adv_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_common_adv_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string info=out();
{
int res=mc_pack_put_str(pack,"info",_m_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_common_adv_info_response
static void _mcpack2_load_mcp_get_common_adv_info_response_result_params(const mc_pack_item_t*,mcp_get_common_adv_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_common_adv_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_common_adv_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_common_adv_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_common_adv_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_common_adv_info_response*)>("result_params",_mcpack2_load_mcp_get_common_adv_info_response_result_params));
_mcpack2_load_mcp_get_common_adv_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_common_adv_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_common_adv_info_response_static_inited=_mcpack2_load_mcp_get_common_adv_info_response_static_init();
// @@mcp_get_common_adv_info_result_params result_params;
static void _mcpack2_load_mcp_get_common_adv_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_common_adv_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_common_adv_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_common_adv_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_common_adv_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_common_adv_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_common_adv_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_common_adv_info_response*)=0;
if(_mcpack2_load_mcp_get_common_adv_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_common_adv_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_common_adv_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_common_adv_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_pt_game_basic_list_by_game_id_params
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_params_game_id(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_params*)>("game_id",_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_params_game_id));
_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_params_readmap.create(16*1);
_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_params_static_inited=_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_params_static_init();
// @@string game_id=in();
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_params_game_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_game_basic_list_by_game_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_pt_game_basic_list_by_game_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_pt_game_basic_list_by_game_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_params*)=0;
if(_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_pt_game_basic_list_by_game_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_pt_game_basic_list_by_game_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string game_id=in();
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_pt_game_basic_list_by_game_id_result_params
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_count(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_result_params*);
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_pt_game_basic_list(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_result_params*)>("count",_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_result_params*)>("pt_game_basic_list",_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_pt_game_basic_list));
_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_static_inited=_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_game_basic_list_by_game_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@pt_game_basic_info_t pt_game_basic_list=out(),array(0);
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_pt_game_basic_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_game_basic_list_by_game_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "pt_game_basic_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_pt_game_basic_list)) lp0=&(self->_m_pt_game_basic_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pt_game_basic_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pt_game_basic_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pt_game_basic_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_pt_game_basic_list_by_game_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_pt_game_basic_list_by_game_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_result_params*)=0;
if(_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_pt_game_basic_list_by_game_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_pt_game_basic_list_by_game_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@pt_game_basic_info_t pt_game_basic_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"pt_game_basic_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_pt_game_basic_list)& lr0=(_m_pt_game_basic_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_pt_game_basic_list_by_game_id_response
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_response_result_params(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_response*)>("result_params",_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_response_result_params));
_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_response_static_inited=_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_response_static_init();
// @@mcp_get_pt_game_basic_list_by_game_id_result_params result_params;
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_game_basic_list_by_game_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_pt_game_basic_list_by_game_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_pt_game_basic_list_by_game_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_pt_game_basic_list_by_game_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_game_id_response*)=0;
if(_mcpack2_load_mcp_get_pt_game_basic_list_by_game_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_pt_game_basic_list_by_game_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_pt_game_basic_list_by_game_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_pt_game_basic_list_by_game_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_pt_game_basic_list_by_app_key_params
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_params_app_key(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_params*)>("app_key",_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_params_app_key));
_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_params_readmap.create(16*1);
_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_params_static_inited=_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_params_static_init();
// @@string app_key=in();
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_params_app_key(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_game_basic_list_by_app_key_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "app_key";
}
self->_m_app_key.set_ptr(item->value,item->value_size-1);
}
void mcp_get_pt_game_basic_list_by_app_key_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_params*)=0;
do{
if(_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_pt_game_basic_list_by_app_key_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_params*)=0;
if(_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_pt_game_basic_list_by_app_key_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_pt_game_basic_list_by_app_key_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string app_key=in();
{
int res=mc_pack_put_str(pack,"app_key",_m_app_key.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_pt_game_basic_list_by_app_key_result_params
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_count(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_result_params*);
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_pt_game_basic_list(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_result_params*)>("count",_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_result_params*)>("pt_game_basic_list",_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_pt_game_basic_list));
_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_static_inited=_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_game_basic_list_by_app_key_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@pt_game_basic_info_t pt_game_basic_list=out(),array(0);
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_pt_game_basic_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_game_basic_list_by_app_key_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "pt_game_basic_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_pt_game_basic_list)) lp0=&(self->_m_pt_game_basic_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pt_game_basic_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pt_game_basic_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "pt_game_basic_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_pt_game_basic_list_by_app_key_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_pt_game_basic_list_by_app_key_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_result_params*)=0;
if(_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_pt_game_basic_list_by_app_key_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_pt_game_basic_list_by_app_key_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@pt_game_basic_info_t pt_game_basic_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"pt_game_basic_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_pt_game_basic_list)& lr0=(_m_pt_game_basic_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_pt_game_basic_list_by_app_key_response
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_response_result_params(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_response*)>("result_params",_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_response_result_params));
_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_response_readmap.create(16*1);
_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_response_static_inited=_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_response_static_init();
// @@mcp_get_pt_game_basic_list_by_app_key_result_params result_params;
static void _mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_game_basic_list_by_app_key_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_pt_game_basic_list_by_app_key_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_pt_game_basic_list_by_app_key_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_response*)=0;
do{
if(_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_pt_game_basic_list_by_app_key_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_basic_list_by_app_key_response*)=0;
if(_mcpack2_load_mcp_get_pt_game_basic_list_by_app_key_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_pt_game_basic_list_by_app_key_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_pt_game_basic_list_by_app_key_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_pt_game_basic_list_by_app_key_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_pt_app_key_by_game_id_params
static void _mcpack2_load_mcp_get_pt_app_key_by_game_id_params_game_id(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_pt_app_key_by_game_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_pt_app_key_by_game_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_params*)>("game_id",_mcpack2_load_mcp_get_pt_app_key_by_game_id_params_game_id));
_mcpack2_load_mcp_get_pt_app_key_by_game_id_params_readmap.create(16*1);
_mcpack2_load_mcp_get_pt_app_key_by_game_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_pt_app_key_by_game_id_params_static_inited=_mcpack2_load_mcp_get_pt_app_key_by_game_id_params_static_init();
// @@string game_id=in();
static void _mcpack2_load_mcp_get_pt_app_key_by_game_id_params_game_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_app_key_by_game_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_pt_app_key_by_game_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_params*)=0;
do{
if(_mcpack2_load_mcp_get_pt_app_key_by_game_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_pt_app_key_by_game_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_params*)=0;
if(_mcpack2_load_mcp_get_pt_app_key_by_game_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_pt_app_key_by_game_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_pt_app_key_by_game_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string game_id=in();
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_pt_app_key_by_game_id_result_params
static void _mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_count(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_result_params*);
static void _mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_app_key(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_result_params*)>("count",_mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_result_params*)>("app_key",_mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_app_key));
_mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_static_inited=_mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_app_key_by_game_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string app_key=out();
static void _mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_app_key(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_app_key_by_game_id_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "app_key";
}
self->_m_app_key.set_ptr(item->value,item->value_size-1);
}
void mcp_get_pt_app_key_by_game_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_pt_app_key_by_game_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_result_params*)=0;
if(_mcpack2_load_mcp_get_pt_app_key_by_game_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_pt_app_key_by_game_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_pt_app_key_by_game_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string app_key=out();
{
int res=mc_pack_put_str(pack,"app_key",_m_app_key.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_pt_app_key_by_game_id_response
static void _mcpack2_load_mcp_get_pt_app_key_by_game_id_response_result_params(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_pt_app_key_by_game_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_pt_app_key_by_game_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_response*)>("result_params",_mcpack2_load_mcp_get_pt_app_key_by_game_id_response_result_params));
_mcpack2_load_mcp_get_pt_app_key_by_game_id_response_readmap.create(16*1);
_mcpack2_load_mcp_get_pt_app_key_by_game_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_pt_app_key_by_game_id_response_static_inited=_mcpack2_load_mcp_get_pt_app_key_by_game_id_response_static_init();
// @@mcp_get_pt_app_key_by_game_id_result_params result_params;
static void _mcpack2_load_mcp_get_pt_app_key_by_game_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_app_key_by_game_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_pt_app_key_by_game_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_pt_app_key_by_game_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_response*)=0;
do{
if(_mcpack2_load_mcp_get_pt_app_key_by_game_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_pt_app_key_by_game_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_pt_app_key_by_game_id_response*)=0;
if(_mcpack2_load_mcp_get_pt_app_key_by_game_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_pt_app_key_by_game_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_pt_app_key_by_game_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_pt_app_key_by_game_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_pt_game_id_by_app_key_params
static void _mcpack2_load_mcp_get_pt_game_id_by_app_key_params_app_key(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_pt_game_id_by_app_key_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_pt_game_id_by_app_key_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_params*)>("app_key",_mcpack2_load_mcp_get_pt_game_id_by_app_key_params_app_key));
_mcpack2_load_mcp_get_pt_game_id_by_app_key_params_readmap.create(16*1);
_mcpack2_load_mcp_get_pt_game_id_by_app_key_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_pt_game_id_by_app_key_params_static_inited=_mcpack2_load_mcp_get_pt_game_id_by_app_key_params_static_init();
// @@string app_key=in();
static void _mcpack2_load_mcp_get_pt_game_id_by_app_key_params_app_key(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_game_id_by_app_key_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "app_key";
}
self->_m_app_key.set_ptr(item->value,item->value_size-1);
}
void mcp_get_pt_game_id_by_app_key_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_params*)=0;
do{
if(_mcpack2_load_mcp_get_pt_game_id_by_app_key_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_pt_game_id_by_app_key_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_params*)=0;
if(_mcpack2_load_mcp_get_pt_game_id_by_app_key_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_pt_game_id_by_app_key_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_pt_game_id_by_app_key_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string app_key=in();
{
int res=mc_pack_put_str(pack,"app_key",_m_app_key.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_pt_game_id_by_app_key_result_params
static void _mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_count(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_result_params*);
static void _mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_game_id(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_result_params*)>("count",_mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_result_params*)>("game_id",_mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_game_id));
_mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_static_inited=_mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_game_id_by_app_key_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@string game_id=out();
static void _mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_game_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_game_id_by_app_key_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_pt_game_id_by_app_key_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_pt_game_id_by_app_key_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_result_params*)=0;
if(_mcpack2_load_mcp_get_pt_game_id_by_app_key_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_pt_game_id_by_app_key_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_pt_game_id_by_app_key_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_id=out();
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_pt_game_id_by_app_key_response
static void _mcpack2_load_mcp_get_pt_game_id_by_app_key_response_result_params(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_pt_game_id_by_app_key_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_pt_game_id_by_app_key_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_response*)>("result_params",_mcpack2_load_mcp_get_pt_game_id_by_app_key_response_result_params));
_mcpack2_load_mcp_get_pt_game_id_by_app_key_response_readmap.create(16*1);
_mcpack2_load_mcp_get_pt_game_id_by_app_key_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_pt_game_id_by_app_key_response_static_inited=_mcpack2_load_mcp_get_pt_game_id_by_app_key_response_static_init();
// @@mcp_get_pt_game_id_by_app_key_result_params result_params;
static void _mcpack2_load_mcp_get_pt_game_id_by_app_key_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_pt_game_id_by_app_key_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_pt_game_id_by_app_key_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_pt_game_id_by_app_key_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_response*)=0;
do{
if(_mcpack2_load_mcp_get_pt_game_id_by_app_key_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_pt_game_id_by_app_key_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_pt_game_id_by_app_key_response*)=0;
if(_mcpack2_load_mcp_get_pt_game_id_by_app_key_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_pt_game_id_by_app_key_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_pt_game_id_by_app_key_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_pt_game_id_by_app_key_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_exist_pt_game_by_game_id_params
static void _mcpack2_load_mcp_exist_pt_game_by_game_id_params_game_id(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_exist_pt_game_by_game_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_exist_pt_game_by_game_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_params*)>("game_id",_mcpack2_load_mcp_exist_pt_game_by_game_id_params_game_id));
_mcpack2_load_mcp_exist_pt_game_by_game_id_params_readmap.create(16*1);
_mcpack2_load_mcp_exist_pt_game_by_game_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_exist_pt_game_by_game_id_params_static_inited=_mcpack2_load_mcp_exist_pt_game_by_game_id_params_static_init();
// @@string game_id=in();
static void _mcpack2_load_mcp_exist_pt_game_by_game_id_params_game_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_exist_pt_game_by_game_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
void mcp_exist_pt_game_by_game_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_params*)=0;
do{
if(_mcpack2_load_mcp_exist_pt_game_by_game_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_exist_pt_game_by_game_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_params*)=0;
if(_mcpack2_load_mcp_exist_pt_game_by_game_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_exist_pt_game_by_game_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_exist_pt_game_by_game_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string game_id=in();
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_exist_pt_game_by_game_id_result_params
static void _mcpack2_load_mcp_exist_pt_game_by_game_id_result_params_flag(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_exist_pt_game_by_game_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_exist_pt_game_by_game_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_result_params*)>("flag",_mcpack2_load_mcp_exist_pt_game_by_game_id_result_params_flag));
_mcpack2_load_mcp_exist_pt_game_by_game_id_result_params_readmap.create(16*1);
_mcpack2_load_mcp_exist_pt_game_by_game_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_exist_pt_game_by_game_id_result_params_static_inited=_mcpack2_load_mcp_exist_pt_game_by_game_id_result_params_static_init();
// @@int32_t flag=out();
static void _mcpack2_load_mcp_exist_pt_game_by_game_id_result_params_flag(__attribute__((unused)) const mc_pack_item_t* item,mcp_exist_pt_game_by_game_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_flag));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "flag";
}
}
void mcp_exist_pt_game_by_game_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_exist_pt_game_by_game_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_exist_pt_game_by_game_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_result_params*)=0;
if(_mcpack2_load_mcp_exist_pt_game_by_game_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_exist_pt_game_by_game_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_exist_pt_game_by_game_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t flag=out();
{
int res=mc_pack_put_int32(pack,"flag",_m_flag);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_exist_pt_game_by_game_id_response
static void _mcpack2_load_mcp_exist_pt_game_by_game_id_response_result_params(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_exist_pt_game_by_game_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_exist_pt_game_by_game_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_response*)>("result_params",_mcpack2_load_mcp_exist_pt_game_by_game_id_response_result_params));
_mcpack2_load_mcp_exist_pt_game_by_game_id_response_readmap.create(16*1);
_mcpack2_load_mcp_exist_pt_game_by_game_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_exist_pt_game_by_game_id_response_static_inited=_mcpack2_load_mcp_exist_pt_game_by_game_id_response_static_init();
// @@mcp_exist_pt_game_by_game_id_result_params result_params;
static void _mcpack2_load_mcp_exist_pt_game_by_game_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_exist_pt_game_by_game_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_exist_pt_game_by_game_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_exist_pt_game_by_game_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_response*)=0;
do{
if(_mcpack2_load_mcp_exist_pt_game_by_game_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_exist_pt_game_by_game_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_exist_pt_game_by_game_id_response*)=0;
if(_mcpack2_load_mcp_exist_pt_game_by_game_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_exist_pt_game_by_game_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_exist_pt_game_by_game_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_exist_pt_game_by_game_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_is_same_pt_game_params
static void _mcpack2_load_mcp_is_same_pt_game_params_game_id(const mc_pack_item_t*,mcp_is_same_pt_game_params*);
static void _mcpack2_load_mcp_is_same_pt_game_params_app_key(const mc_pack_item_t*,mcp_is_same_pt_game_params*);
static void _mcpack2_load_mcp_is_same_pt_game_params_app_secret(const mc_pack_item_t*,mcp_is_same_pt_game_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_is_same_pt_game_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_is_same_pt_game_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_is_same_pt_game_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_is_same_pt_game_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_is_same_pt_game_params*)>("game_id",_mcpack2_load_mcp_is_same_pt_game_params_game_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_is_same_pt_game_params*)>("app_key",_mcpack2_load_mcp_is_same_pt_game_params_app_key));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_is_same_pt_game_params*)>("app_secret",_mcpack2_load_mcp_is_same_pt_game_params_app_secret));
_mcpack2_load_mcp_is_same_pt_game_params_readmap.create(16*3);
_mcpack2_load_mcp_is_same_pt_game_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_is_same_pt_game_params_static_inited=_mcpack2_load_mcp_is_same_pt_game_params_static_init();
// @@string game_id=in();
static void _mcpack2_load_mcp_is_same_pt_game_params_game_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_is_same_pt_game_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
// @@string app_key=in();
static void _mcpack2_load_mcp_is_same_pt_game_params_app_key(__attribute__((unused)) const mc_pack_item_t* item,mcp_is_same_pt_game_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "app_key";
}
self->_m_app_key.set_ptr(item->value,item->value_size-1);
}
// @@string app_secret=in();
static void _mcpack2_load_mcp_is_same_pt_game_params_app_secret(__attribute__((unused)) const mc_pack_item_t* item,mcp_is_same_pt_game_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "app_secret";
}
self->_m_app_secret.set_ptr(item->value,item->value_size-1);
}
void mcp_is_same_pt_game_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_is_same_pt_game_params*)=0;
do{
if(_mcpack2_load_mcp_is_same_pt_game_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_is_same_pt_game_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_is_same_pt_game_params*)=0;
if(_mcpack2_load_mcp_is_same_pt_game_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_is_same_pt_game_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_is_same_pt_game_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string game_id=in();
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string app_key=in();
{
int res=mc_pack_put_str(pack,"app_key",_m_app_key.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string app_secret=in();
{
int res=mc_pack_put_str(pack,"app_secret",_m_app_secret.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_is_same_pt_game_result_params
static void _mcpack2_load_mcp_is_same_pt_game_result_params_flag(const mc_pack_item_t*,mcp_is_same_pt_game_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_is_same_pt_game_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_is_same_pt_game_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_is_same_pt_game_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_is_same_pt_game_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_is_same_pt_game_result_params*)>("flag",_mcpack2_load_mcp_is_same_pt_game_result_params_flag));
_mcpack2_load_mcp_is_same_pt_game_result_params_readmap.create(16*1);
_mcpack2_load_mcp_is_same_pt_game_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_is_same_pt_game_result_params_static_inited=_mcpack2_load_mcp_is_same_pt_game_result_params_static_init();
// @@int32_t flag=out();
static void _mcpack2_load_mcp_is_same_pt_game_result_params_flag(__attribute__((unused)) const mc_pack_item_t* item,mcp_is_same_pt_game_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_flag));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "flag";
}
}
void mcp_is_same_pt_game_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_is_same_pt_game_result_params*)=0;
do{
if(_mcpack2_load_mcp_is_same_pt_game_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_is_same_pt_game_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_is_same_pt_game_result_params*)=0;
if(_mcpack2_load_mcp_is_same_pt_game_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_is_same_pt_game_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_is_same_pt_game_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t flag=out();
{
int res=mc_pack_put_int32(pack,"flag",_m_flag);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_is_same_pt_game_response
static void _mcpack2_load_mcp_is_same_pt_game_response_result_params(const mc_pack_item_t*,mcp_is_same_pt_game_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_is_same_pt_game_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_is_same_pt_game_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_is_same_pt_game_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_is_same_pt_game_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_is_same_pt_game_response*)>("result_params",_mcpack2_load_mcp_is_same_pt_game_response_result_params));
_mcpack2_load_mcp_is_same_pt_game_response_readmap.create(16*1);
_mcpack2_load_mcp_is_same_pt_game_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_is_same_pt_game_response_static_inited=_mcpack2_load_mcp_is_same_pt_game_response_static_init();
// @@mcp_is_same_pt_game_result_params result_params;
static void _mcpack2_load_mcp_is_same_pt_game_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_is_same_pt_game_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_is_same_pt_game_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_is_same_pt_game_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_is_same_pt_game_response*)=0;
do{
if(_mcpack2_load_mcp_is_same_pt_game_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_is_same_pt_game_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_is_same_pt_game_response*)=0;
if(_mcpack2_load_mcp_is_same_pt_game_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_is_same_pt_game_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_is_same_pt_game_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_is_same_pt_game_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_remove_pt_game_basic_list_by_app_key_params
static void _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_params_app_key(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_params*)>("app_key",_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_params_app_key));
_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_params_readmap.create(16*1);
_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_params_static_inited=_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_params_static_init();
// @@string app_key=in();
static void _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_params_app_key(__attribute__((unused)) const mc_pack_item_t* item,mcp_remove_pt_game_basic_list_by_app_key_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "app_key";
}
self->_m_app_key.set_ptr(item->value,item->value_size-1);
}
void mcp_remove_pt_game_basic_list_by_app_key_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_params*)=0;
do{
if(_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_remove_pt_game_basic_list_by_app_key_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_params*)=0;
if(_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_remove_pt_game_basic_list_by_app_key_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_remove_pt_game_basic_list_by_app_key_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string app_key=in();
{
int res=mc_pack_put_str(pack,"app_key",_m_app_key.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_remove_pt_game_basic_list_by_app_key_result_params
static void _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_result_params_flag(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_result_params*)>("flag",_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_result_params_flag));
_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_result_params_readmap.create(16*1);
_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_result_params_static_inited=_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_result_params_static_init();
// @@int32_t flag=out();
static void _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_result_params_flag(__attribute__((unused)) const mc_pack_item_t* item,mcp_remove_pt_game_basic_list_by_app_key_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_flag));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "flag";
}
}
void mcp_remove_pt_game_basic_list_by_app_key_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_result_params*)=0;
do{
if(_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_remove_pt_game_basic_list_by_app_key_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_result_params*)=0;
if(_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_remove_pt_game_basic_list_by_app_key_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_remove_pt_game_basic_list_by_app_key_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t flag=out();
{
int res=mc_pack_put_int32(pack,"flag",_m_flag);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_remove_pt_game_basic_list_by_app_key_response
static void _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_response_result_params(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_response*)>("result_params",_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_response_result_params));
_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_response_readmap.create(16*1);
_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_response_static_inited=_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_response_static_init();
// @@mcp_remove_pt_game_basic_list_by_app_key_result_params result_params;
static void _mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_remove_pt_game_basic_list_by_app_key_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_remove_pt_game_basic_list_by_app_key_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_remove_pt_game_basic_list_by_app_key_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_response*)=0;
do{
if(_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_remove_pt_game_basic_list_by_app_key_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_remove_pt_game_basic_list_by_app_key_response*)=0;
if(_mcpack2_load_mcp_remove_pt_game_basic_list_by_app_key_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_remove_pt_game_basic_list_by_app_key_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_remove_pt_game_basic_list_by_app_key_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_remove_pt_game_basic_list_by_app_key_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_new_user_consume_record_params
static void _mcpack2_load_mcp_add_new_user_consume_record_params_imei_id(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*);
static void _mcpack2_load_mcp_add_new_user_consume_record_params_order_id(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*);
static void _mcpack2_load_mcp_add_new_user_consume_record_params_goods_id(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*);
static void _mcpack2_load_mcp_add_new_user_consume_record_params_consume_date(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*);
static void _mcpack2_load_mcp_add_new_user_consume_record_params_udid(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_new_user_consume_record_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_new_user_consume_record_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*)>("imei_id",_mcpack2_load_mcp_add_new_user_consume_record_params_imei_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*)>("order_id",_mcpack2_load_mcp_add_new_user_consume_record_params_order_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*)>("goods_id",_mcpack2_load_mcp_add_new_user_consume_record_params_goods_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*)>("consume_date",_mcpack2_load_mcp_add_new_user_consume_record_params_consume_date));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*)>("udid",_mcpack2_load_mcp_add_new_user_consume_record_params_udid));
_mcpack2_load_mcp_add_new_user_consume_record_params_readmap.create(16*5);
_mcpack2_load_mcp_add_new_user_consume_record_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_new_user_consume_record_params_static_inited=_mcpack2_load_mcp_add_new_user_consume_record_params_static_init();
// @@string imei_id=in();
static void _mcpack2_load_mcp_add_new_user_consume_record_params_imei_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_user_consume_record_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "imei_id";
}
self->_m_imei_id.set_ptr(item->value,item->value_size-1);
}
// @@string order_id=in();
static void _mcpack2_load_mcp_add_new_user_consume_record_params_order_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_user_consume_record_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "order_id";
}
self->_m_order_id.set_ptr(item->value,item->value_size-1);
}
// @@string goods_id=in();
static void _mcpack2_load_mcp_add_new_user_consume_record_params_goods_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_user_consume_record_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "goods_id";
}
self->_m_goods_id.set_ptr(item->value,item->value_size-1);
}
// @@string consume_date=in();
static void _mcpack2_load_mcp_add_new_user_consume_record_params_consume_date(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_user_consume_record_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "consume_date";
}
self->_m_consume_date.set_ptr(item->value,item->value_size-1);
}
// @@string udid=in();
static void _mcpack2_load_mcp_add_new_user_consume_record_params_udid(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_user_consume_record_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "udid";
}
self->_m_udid.set_ptr(item->value,item->value_size-1);
}
void mcp_add_new_user_consume_record_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*)=0;
do{
if(_mcpack2_load_mcp_add_new_user_consume_record_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_new_user_consume_record_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_new_user_consume_record_params*)=0;
if(_mcpack2_load_mcp_add_new_user_consume_record_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_new_user_consume_record_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_new_user_consume_record_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string imei_id=in();
{
int res=mc_pack_put_str(pack,"imei_id",_m_imei_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string order_id=in();
{
int res=mc_pack_put_str(pack,"order_id",_m_order_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string goods_id=in();
{
int res=mc_pack_put_str(pack,"goods_id",_m_goods_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string consume_date=in();
{
int res=mc_pack_put_str(pack,"consume_date",_m_consume_date.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string udid=in();
{
int res=mc_pack_put_str(pack,"udid",_m_udid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_new_user_consume_record_result_params
static void _mcpack2_load_mcp_add_new_user_consume_record_result_params_ret_code(const mc_pack_item_t*,mcp_add_new_user_consume_record_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_user_consume_record_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_new_user_consume_record_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_new_user_consume_record_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_new_user_consume_record_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_user_consume_record_result_params*)>("ret_code",_mcpack2_load_mcp_add_new_user_consume_record_result_params_ret_code));
_mcpack2_load_mcp_add_new_user_consume_record_result_params_readmap.create(16*1);
_mcpack2_load_mcp_add_new_user_consume_record_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_new_user_consume_record_result_params_static_inited=_mcpack2_load_mcp_add_new_user_consume_record_result_params_static_init();
// @@int32_t ret_code=out();
static void _mcpack2_load_mcp_add_new_user_consume_record_result_params_ret_code(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_user_consume_record_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_ret_code));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ret_code";
}
}
void mcp_add_new_user_consume_record_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_new_user_consume_record_result_params*)=0;
do{
if(_mcpack2_load_mcp_add_new_user_consume_record_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_new_user_consume_record_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_new_user_consume_record_result_params*)=0;
if(_mcpack2_load_mcp_add_new_user_consume_record_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_new_user_consume_record_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_new_user_consume_record_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t ret_code=out();
{
int res=mc_pack_put_int32(pack,"ret_code",_m_ret_code);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_new_user_consume_record_response
static void _mcpack2_load_mcp_add_new_user_consume_record_response_result_params(const mc_pack_item_t*,mcp_add_new_user_consume_record_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_user_consume_record_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_new_user_consume_record_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_new_user_consume_record_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_new_user_consume_record_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_new_user_consume_record_response*)>("result_params",_mcpack2_load_mcp_add_new_user_consume_record_response_result_params));
_mcpack2_load_mcp_add_new_user_consume_record_response_readmap.create(16*1);
_mcpack2_load_mcp_add_new_user_consume_record_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_new_user_consume_record_response_static_inited=_mcpack2_load_mcp_add_new_user_consume_record_response_static_init();
// @@mcp_add_new_user_consume_record_result_params result_params;
static void _mcpack2_load_mcp_add_new_user_consume_record_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_new_user_consume_record_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_add_new_user_consume_record_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_add_new_user_consume_record_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_new_user_consume_record_response*)=0;
do{
if(_mcpack2_load_mcp_add_new_user_consume_record_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_new_user_consume_record_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_new_user_consume_record_response*)=0;
if(_mcpack2_load_mcp_add_new_user_consume_record_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_new_user_consume_record_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_new_user_consume_record_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_add_new_user_consume_record_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_news_info_list_params
static void _mcpack2_load_mcp_get_game_news_info_list_params_game_id(const mc_pack_item_t*,mcp_get_game_news_info_list_params*);
static void _mcpack2_load_mcp_get_game_news_info_list_params_ov_id(const mc_pack_item_t*,mcp_get_game_news_info_list_params*);
static void _mcpack2_load_mcp_get_game_news_info_list_params_news_type(const mc_pack_item_t*,mcp_get_game_news_info_list_params*);
static void _mcpack2_load_mcp_get_game_news_info_list_params_date_limit(const mc_pack_item_t*,mcp_get_game_news_info_list_params*);
static void _mcpack2_load_mcp_get_game_news_info_list_params_game_imgtypes(const mc_pack_item_t*,mcp_get_game_news_info_list_params*);
static void _mcpack2_load_mcp_get_game_news_info_list_params_page(const mc_pack_item_t*,mcp_get_game_news_info_list_params*);
static void _mcpack2_load_mcp_get_game_news_info_list_params_page_size(const mc_pack_item_t*,mcp_get_game_news_info_list_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_news_info_list_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_news_info_list_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_params*)>("game_id",_mcpack2_load_mcp_get_game_news_info_list_params_game_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_params*)>("ov_id",_mcpack2_load_mcp_get_game_news_info_list_params_ov_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_params*)>("news_type",_mcpack2_load_mcp_get_game_news_info_list_params_news_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_params*)>("date_limit",_mcpack2_load_mcp_get_game_news_info_list_params_date_limit));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_params*)>("game_imgtypes",_mcpack2_load_mcp_get_game_news_info_list_params_game_imgtypes));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_params*)>("page",_mcpack2_load_mcp_get_game_news_info_list_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_params*)>("page_size",_mcpack2_load_mcp_get_game_news_info_list_params_page_size));
_mcpack2_load_mcp_get_game_news_info_list_params_readmap.create(16*7);
_mcpack2_load_mcp_get_game_news_info_list_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_news_info_list_params_static_inited=_mcpack2_load_mcp_get_game_news_info_list_params_static_init();
// @@string game_id=in();
static void _mcpack2_load_mcp_get_game_news_info_list_params_game_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_info_list_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
// @@string ov_id=in();
static void _mcpack2_load_mcp_get_game_news_info_list_params_ov_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_info_list_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ov_id";
}
self->_m_ov_id.set_ptr(item->value,item->value_size-1);
}
// @@string news_type=in();
static void _mcpack2_load_mcp_get_game_news_info_list_params_news_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_info_list_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "news_type";
}
self->_m_news_type.set_ptr(item->value,item->value_size-1);
}
// @@string date_limit=in();
static void _mcpack2_load_mcp_get_game_news_info_list_params_date_limit(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_info_list_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "date_limit";
}
self->_m_date_limit.set_ptr(item->value,item->value_size-1);
}
// @@string game_imgtypes=in();
static void _mcpack2_load_mcp_get_game_news_info_list_params_game_imgtypes(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_info_list_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_imgtypes";
}
self->_m_game_imgtypes.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_game_news_info_list_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_info_list_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_game_news_info_list_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_info_list_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_game_news_info_list_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_info_list_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_news_info_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_news_info_list_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_info_list_params*)=0;
if(_mcpack2_load_mcp_get_game_news_info_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_news_info_list_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_news_info_list_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string game_id=in();
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ov_id=in();
{
int res=mc_pack_put_str(pack,"ov_id",_m_ov_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string news_type=in();
{
int res=mc_pack_put_str(pack,"news_type",_m_news_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string date_limit=in();
{
int res=mc_pack_put_str(pack,"date_limit",_m_date_limit.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_imgtypes=in();
{
int res=mc_pack_put_str(pack,"game_imgtypes",_m_game_imgtypes.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_news_info_list_result_params
static void _mcpack2_load_mcp_get_game_news_info_list_result_params_count(const mc_pack_item_t*,mcp_get_game_news_info_list_result_params*);
static void _mcpack2_load_mcp_get_game_news_info_list_result_params_game_news_info_list(const mc_pack_item_t*,mcp_get_game_news_info_list_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_news_info_list_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_news_info_list_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_result_params*)>("count",_mcpack2_load_mcp_get_game_news_info_list_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_result_params*)>("game_news_info_list",_mcpack2_load_mcp_get_game_news_info_list_result_params_game_news_info_list));
_mcpack2_load_mcp_get_game_news_info_list_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_game_news_info_list_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_news_info_list_result_params_static_inited=_mcpack2_load_mcp_get_game_news_info_list_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_game_news_info_list_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_info_list_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_news_info_t game_news_info_list=out(),array(0);
static void _mcpack2_load_mcp_get_game_news_info_list_result_params_game_news_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_info_list_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_news_info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_game_news_info_list)) lp0=&(self->_m_game_news_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_news_info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_news_info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_news_info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_game_news_info_list_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_info_list_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_news_info_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_news_info_list_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_info_list_result_params*)=0;
if(_mcpack2_load_mcp_get_game_news_info_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_news_info_list_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_news_info_list_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_news_info_t game_news_info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"game_news_info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_game_news_info_list)& lr0=(_m_game_news_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_news_info_list_response
static void _mcpack2_load_mcp_get_game_news_info_list_response_result_params(const mc_pack_item_t*,mcp_get_game_news_info_list_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_news_info_list_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_news_info_list_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_info_list_response*)>("result_params",_mcpack2_load_mcp_get_game_news_info_list_response_result_params));
_mcpack2_load_mcp_get_game_news_info_list_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_news_info_list_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_news_info_list_response_static_inited=_mcpack2_load_mcp_get_game_news_info_list_response_static_init();
// @@mcp_get_game_news_info_list_result_params result_params;
static void _mcpack2_load_mcp_get_game_news_info_list_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_info_list_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_news_info_list_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_news_info_list_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_info_list_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_news_info_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_news_info_list_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_info_list_response*)=0;
if(_mcpack2_load_mcp_get_game_news_info_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_news_info_list_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_news_info_list_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_news_info_list_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_news_entire_info_params
static void _mcpack2_load_mcp_get_game_news_entire_info_params_news_id(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*);
static void _mcpack2_load_mcp_get_game_news_entire_info_params_game_id(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*);
static void _mcpack2_load_mcp_get_game_news_entire_info_params_news_type(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*);
static void _mcpack2_load_mcp_get_game_news_entire_info_params_date_limit(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*);
static void _mcpack2_load_mcp_get_game_news_entire_info_params_order_type(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*);
static void _mcpack2_load_mcp_get_game_news_entire_info_params_game_imgtypes(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*);
static void _mcpack2_load_mcp_get_game_news_entire_info_params_channel_info(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*);
static void _mcpack2_load_mcp_get_game_news_entire_info_params_channel_id(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*);
static void _mcpack2_load_mcp_get_game_news_entire_info_params_page(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*);
static void _mcpack2_load_mcp_get_game_news_entire_info_params_page_size(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_news_entire_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_news_entire_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*)>("news_id",_mcpack2_load_mcp_get_game_news_entire_info_params_news_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*)>("game_id",_mcpack2_load_mcp_get_game_news_entire_info_params_game_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*)>("news_type",_mcpack2_load_mcp_get_game_news_entire_info_params_news_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*)>("date_limit",_mcpack2_load_mcp_get_game_news_entire_info_params_date_limit));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*)>("order_type",_mcpack2_load_mcp_get_game_news_entire_info_params_order_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*)>("game_imgtypes",_mcpack2_load_mcp_get_game_news_entire_info_params_game_imgtypes));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*)>("channel_info",_mcpack2_load_mcp_get_game_news_entire_info_params_channel_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*)>("channel_id",_mcpack2_load_mcp_get_game_news_entire_info_params_channel_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*)>("page",_mcpack2_load_mcp_get_game_news_entire_info_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*)>("page_size",_mcpack2_load_mcp_get_game_news_entire_info_params_page_size));
_mcpack2_load_mcp_get_game_news_entire_info_params_readmap.create(16*10);
_mcpack2_load_mcp_get_game_news_entire_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_news_entire_info_params_static_inited=_mcpack2_load_mcp_get_game_news_entire_info_params_static_init();
// @@string news_id=in();
static void _mcpack2_load_mcp_get_game_news_entire_info_params_news_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_entire_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "news_id";
}
self->_m_news_id.set_ptr(item->value,item->value_size-1);
}
// @@string game_id=in();
static void _mcpack2_load_mcp_get_game_news_entire_info_params_game_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_entire_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
// @@string news_type=in();
static void _mcpack2_load_mcp_get_game_news_entire_info_params_news_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_entire_info_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "news_type";
}
self->_m_news_type.set_ptr(item->value,item->value_size-1);
}
// @@string date_limit=in();
static void _mcpack2_load_mcp_get_game_news_entire_info_params_date_limit(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_entire_info_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "date_limit";
}
self->_m_date_limit.set_ptr(item->value,item->value_size-1);
}
// @@string order_type=in();
static void _mcpack2_load_mcp_get_game_news_entire_info_params_order_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_entire_info_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "order_type";
}
self->_m_order_type.set_ptr(item->value,item->value_size-1);
}
// @@string game_imgtypes=in();
static void _mcpack2_load_mcp_get_game_news_entire_info_params_game_imgtypes(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_entire_info_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_imgtypes";
}
self->_m_game_imgtypes.set_ptr(item->value,item->value_size-1);
}
// @@string channel_info=in();
static void _mcpack2_load_mcp_get_game_news_entire_info_params_channel_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_entire_info_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "channel_info";
}
self->_m_channel_info.set_ptr(item->value,item->value_size-1);
}
// @@string channel_id=in();
static void _mcpack2_load_mcp_get_game_news_entire_info_params_channel_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_entire_info_params* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "channel_id";
}
self->_m_channel_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_game_news_entire_info_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_entire_info_params* self){
self->_flag[8 >> 3] |= (1 << (8 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_game_news_entire_info_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_entire_info_params* self){
self->_flag[9 >> 3] |= (1 << (9 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_game_news_entire_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_news_entire_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_news_entire_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_entire_info_params*)=0;
if(_mcpack2_load_mcp_get_game_news_entire_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_news_entire_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_news_entire_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string news_id=in();
{
int res=mc_pack_put_str(pack,"news_id",_m_news_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_id=in();
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string news_type=in();
{
int res=mc_pack_put_str(pack,"news_type",_m_news_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string date_limit=in();
{
int res=mc_pack_put_str(pack,"date_limit",_m_date_limit.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string order_type=in();
{
int res=mc_pack_put_str(pack,"order_type",_m_order_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_imgtypes=in();
{
int res=mc_pack_put_str(pack,"game_imgtypes",_m_game_imgtypes.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string channel_info=in();
{
int res=mc_pack_put_str(pack,"channel_info",_m_channel_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string channel_id=in();
{
int res=mc_pack_put_str(pack,"channel_id",_m_channel_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_news_entire_info_result_params
static void _mcpack2_load_mcp_get_game_news_entire_info_result_params_count(const mc_pack_item_t*,mcp_get_game_news_entire_info_result_params*);
static void _mcpack2_load_mcp_get_game_news_entire_info_result_params_game_news_list(const mc_pack_item_t*,mcp_get_game_news_entire_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_news_entire_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_news_entire_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_result_params*)>("count",_mcpack2_load_mcp_get_game_news_entire_info_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_result_params*)>("game_news_list",_mcpack2_load_mcp_get_game_news_entire_info_result_params_game_news_list));
_mcpack2_load_mcp_get_game_news_entire_info_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_game_news_entire_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_news_entire_info_result_params_static_inited=_mcpack2_load_mcp_get_game_news_entire_info_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_game_news_entire_info_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_entire_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_news_entire_info_t game_news_list=out(),array(0);
static void _mcpack2_load_mcp_get_game_news_entire_info_result_params_game_news_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_entire_info_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_news_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_game_news_list)) lp0=&(self->_m_game_news_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_news_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_news_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_news_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_game_news_entire_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_entire_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_news_entire_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_news_entire_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_entire_info_result_params*)=0;
if(_mcpack2_load_mcp_get_game_news_entire_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_news_entire_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_news_entire_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_news_entire_info_t game_news_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"game_news_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_game_news_list)& lr0=(_m_game_news_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_news_entire_info_response
static void _mcpack2_load_mcp_get_game_news_entire_info_response_result_params(const mc_pack_item_t*,mcp_get_game_news_entire_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_news_entire_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_news_entire_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_entire_info_response*)>("result_params",_mcpack2_load_mcp_get_game_news_entire_info_response_result_params));
_mcpack2_load_mcp_get_game_news_entire_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_news_entire_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_news_entire_info_response_static_inited=_mcpack2_load_mcp_get_game_news_entire_info_response_static_init();
// @@mcp_get_game_news_entire_info_result_params result_params;
static void _mcpack2_load_mcp_get_game_news_entire_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_entire_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_news_entire_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_news_entire_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_entire_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_news_entire_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_news_entire_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_entire_info_response*)=0;
if(_mcpack2_load_mcp_get_game_news_entire_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_news_entire_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_news_entire_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_news_entire_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_netgame_activity_info_params
static void _mcpack2_load_mcp_get_netgame_activity_info_params_game_id(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*);
static void _mcpack2_load_mcp_get_netgame_activity_info_params_act_id(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*);
static void _mcpack2_load_mcp_get_netgame_activity_info_params_date_limit(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*);
static void _mcpack2_load_mcp_get_netgame_activity_info_params_channel(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*);
static void _mcpack2_load_mcp_get_netgame_activity_info_params_game_img_type(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*);
static void _mcpack2_load_mcp_get_netgame_activity_info_params_act_img_type(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*);
static void _mcpack2_load_mcp_get_netgame_activity_info_params_page(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*);
static void _mcpack2_load_mcp_get_netgame_activity_info_params_page_size(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_netgame_activity_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_netgame_activity_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*)>("game_id",_mcpack2_load_mcp_get_netgame_activity_info_params_game_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*)>("act_id",_mcpack2_load_mcp_get_netgame_activity_info_params_act_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*)>("date_limit",_mcpack2_load_mcp_get_netgame_activity_info_params_date_limit));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*)>("channel",_mcpack2_load_mcp_get_netgame_activity_info_params_channel));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*)>("game_img_type",_mcpack2_load_mcp_get_netgame_activity_info_params_game_img_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*)>("act_img_type",_mcpack2_load_mcp_get_netgame_activity_info_params_act_img_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*)>("page",_mcpack2_load_mcp_get_netgame_activity_info_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*)>("page_size",_mcpack2_load_mcp_get_netgame_activity_info_params_page_size));
_mcpack2_load_mcp_get_netgame_activity_info_params_readmap.create(16*8);
_mcpack2_load_mcp_get_netgame_activity_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_netgame_activity_info_params_static_inited=_mcpack2_load_mcp_get_netgame_activity_info_params_static_init();
// @@string game_id=in();
static void _mcpack2_load_mcp_get_netgame_activity_info_params_game_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_netgame_activity_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
// @@string act_id=in();
static void _mcpack2_load_mcp_get_netgame_activity_info_params_act_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_netgame_activity_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "act_id";
}
self->_m_act_id.set_ptr(item->value,item->value_size-1);
}
// @@string date_limit=in();
static void _mcpack2_load_mcp_get_netgame_activity_info_params_date_limit(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_netgame_activity_info_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "date_limit";
}
self->_m_date_limit.set_ptr(item->value,item->value_size-1);
}
// @@string channel=in();
static void _mcpack2_load_mcp_get_netgame_activity_info_params_channel(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_netgame_activity_info_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "channel";
}
self->_m_channel.set_ptr(item->value,item->value_size-1);
}
// @@string game_img_type=in();
static void _mcpack2_load_mcp_get_netgame_activity_info_params_game_img_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_netgame_activity_info_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_img_type";
}
self->_m_game_img_type.set_ptr(item->value,item->value_size-1);
}
// @@string act_img_type=in();
static void _mcpack2_load_mcp_get_netgame_activity_info_params_act_img_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_netgame_activity_info_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "act_img_type";
}
self->_m_act_img_type.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_netgame_activity_info_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_netgame_activity_info_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_netgame_activity_info_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_netgame_activity_info_params* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_netgame_activity_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_netgame_activity_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_netgame_activity_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_netgame_activity_info_params*)=0;
if(_mcpack2_load_mcp_get_netgame_activity_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_netgame_activity_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_netgame_activity_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string game_id=in();
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string act_id=in();
{
int res=mc_pack_put_str(pack,"act_id",_m_act_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string date_limit=in();
{
int res=mc_pack_put_str(pack,"date_limit",_m_date_limit.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string channel=in();
{
int res=mc_pack_put_str(pack,"channel",_m_channel.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_img_type=in();
{
int res=mc_pack_put_str(pack,"game_img_type",_m_game_img_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string act_img_type=in();
{
int res=mc_pack_put_str(pack,"act_img_type",_m_act_img_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_netgame_activity_info_result_params
static void _mcpack2_load_mcp_get_netgame_activity_info_result_params_count(const mc_pack_item_t*,mcp_get_netgame_activity_info_result_params*);
static void _mcpack2_load_mcp_get_netgame_activity_info_result_params_result_list(const mc_pack_item_t*,mcp_get_netgame_activity_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_netgame_activity_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_netgame_activity_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_result_params*)>("count",_mcpack2_load_mcp_get_netgame_activity_info_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_result_params*)>("result_list",_mcpack2_load_mcp_get_netgame_activity_info_result_params_result_list));
_mcpack2_load_mcp_get_netgame_activity_info_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_netgame_activity_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_netgame_activity_info_result_params_static_inited=_mcpack2_load_mcp_get_netgame_activity_info_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_netgame_activity_info_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_netgame_activity_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@netgame_activity_info_t result_list=out(),array(0);
static void _mcpack2_load_mcp_get_netgame_activity_info_result_params_result_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_netgame_activity_info_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_result_list)) lp0=&(self->_m_result_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_netgame_activity_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_netgame_activity_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_netgame_activity_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_netgame_activity_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_netgame_activity_info_result_params*)=0;
if(_mcpack2_load_mcp_get_netgame_activity_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_netgame_activity_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_netgame_activity_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@netgame_activity_info_t result_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"result_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_result_list)& lr0=(_m_result_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_netgame_activity_info_response
static void _mcpack2_load_mcp_get_netgame_activity_info_response_result_params(const mc_pack_item_t*,mcp_get_netgame_activity_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_netgame_activity_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_netgame_activity_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_netgame_activity_info_response*)>("result_params",_mcpack2_load_mcp_get_netgame_activity_info_response_result_params));
_mcpack2_load_mcp_get_netgame_activity_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_netgame_activity_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_netgame_activity_info_response_static_inited=_mcpack2_load_mcp_get_netgame_activity_info_response_static_init();
// @@mcp_get_netgame_activity_info_result_params result_params;
static void _mcpack2_load_mcp_get_netgame_activity_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_netgame_activity_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_netgame_activity_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_netgame_activity_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_netgame_activity_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_netgame_activity_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_netgame_activity_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_netgame_activity_info_response*)=0;
if(_mcpack2_load_mcp_get_netgame_activity_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_netgame_activity_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_netgame_activity_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_netgame_activity_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_download_app_info_params
static void _mcpack2_load_mcp_get_game_download_app_info_params_c_id(const mc_pack_item_t*,mcp_get_game_download_app_info_params*);
static void _mcpack2_load_mcp_get_game_download_app_info_params_package_name(const mc_pack_item_t*,mcp_get_game_download_app_info_params*);
static void _mcpack2_load_mcp_get_game_download_app_info_params_dev_version_code(const mc_pack_item_t*,mcp_get_game_download_app_info_params*);
static void _mcpack2_load_mcp_get_game_download_app_info_params_dev_version(const mc_pack_item_t*,mcp_get_game_download_app_info_params*);
static void _mcpack2_load_mcp_get_game_download_app_info_params_apk_md5(const mc_pack_item_t*,mcp_get_game_download_app_info_params*);
static void _mcpack2_load_mcp_get_game_download_app_info_params_file_md5(const mc_pack_item_t*,mcp_get_game_download_app_info_params*);
static void _mcpack2_load_mcp_get_game_download_app_info_params_game_img(const mc_pack_item_t*,mcp_get_game_download_app_info_params*);
static void _mcpack2_load_mcp_get_game_download_app_info_params_filter(const mc_pack_item_t*,mcp_get_game_download_app_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_download_app_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_download_app_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_params*)>("c_id",_mcpack2_load_mcp_get_game_download_app_info_params_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_params*)>("package_name",_mcpack2_load_mcp_get_game_download_app_info_params_package_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_params*)>("dev_version_code",_mcpack2_load_mcp_get_game_download_app_info_params_dev_version_code));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_params*)>("dev_version",_mcpack2_load_mcp_get_game_download_app_info_params_dev_version));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_params*)>("apk_md5",_mcpack2_load_mcp_get_game_download_app_info_params_apk_md5));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_params*)>("file_md5",_mcpack2_load_mcp_get_game_download_app_info_params_file_md5));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_params*)>("game_img",_mcpack2_load_mcp_get_game_download_app_info_params_game_img));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_params*)>("filter",_mcpack2_load_mcp_get_game_download_app_info_params_filter));
_mcpack2_load_mcp_get_game_download_app_info_params_readmap.create(16*8);
_mcpack2_load_mcp_get_game_download_app_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_download_app_info_params_static_inited=_mcpack2_load_mcp_get_game_download_app_info_params_static_init();
// @@string c_id=in();
static void _mcpack2_load_mcp_get_game_download_app_info_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_app_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string package_name=in();
static void _mcpack2_load_mcp_get_game_download_app_info_params_package_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_app_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "package_name";
}
self->_m_package_name.set_ptr(item->value,item->value_size-1);
}
// @@string dev_version_code=in();
static void _mcpack2_load_mcp_get_game_download_app_info_params_dev_version_code(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_app_info_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "dev_version_code";
}
self->_m_dev_version_code.set_ptr(item->value,item->value_size-1);
}
// @@string dev_version=in();
static void _mcpack2_load_mcp_get_game_download_app_info_params_dev_version(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_app_info_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "dev_version";
}
self->_m_dev_version.set_ptr(item->value,item->value_size-1);
}
// @@string apk_md5=in();
static void _mcpack2_load_mcp_get_game_download_app_info_params_apk_md5(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_app_info_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "apk_md5";
}
self->_m_apk_md5.set_ptr(item->value,item->value_size-1);
}
// @@string file_md5=in();
static void _mcpack2_load_mcp_get_game_download_app_info_params_file_md5(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_app_info_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "file_md5";
}
self->_m_file_md5.set_ptr(item->value,item->value_size-1);
}
// @@string game_img=in();
static void _mcpack2_load_mcp_get_game_download_app_info_params_game_img(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_app_info_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_img";
}
self->_m_game_img.set_ptr(item->value,item->value_size-1);
}
// @@string filter=in();
static void _mcpack2_load_mcp_get_game_download_app_info_params_filter(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_app_info_params* self){
self->_flag[7 >> 3] |= (1 << (7 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "filter";
}
self->_m_filter.set_ptr(item->value,item->value_size-1);
}
void mcp_get_game_download_app_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_download_app_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_download_app_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_download_app_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_download_app_info_params*)=0;
if(_mcpack2_load_mcp_get_game_download_app_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_download_app_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_download_app_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string package_name=in();
{
int res=mc_pack_put_str(pack,"package_name",_m_package_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string dev_version_code=in();
{
int res=mc_pack_put_str(pack,"dev_version_code",_m_dev_version_code.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string dev_version=in();
{
int res=mc_pack_put_str(pack,"dev_version",_m_dev_version.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string apk_md5=in();
{
int res=mc_pack_put_str(pack,"apk_md5",_m_apk_md5.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string file_md5=in();
{
int res=mc_pack_put_str(pack,"file_md5",_m_file_md5.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_img=in();
{
int res=mc_pack_put_str(pack,"game_img",_m_game_img.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string filter=in();
{
int res=mc_pack_put_str(pack,"filter",_m_filter.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_download_app_info_result_params
static void _mcpack2_load_mcp_get_game_download_app_info_result_params_count(const mc_pack_item_t*,mcp_get_game_download_app_info_result_params*);
static void _mcpack2_load_mcp_get_game_download_app_info_result_params_result_list(const mc_pack_item_t*,mcp_get_game_download_app_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_download_app_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_download_app_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_result_params*)>("count",_mcpack2_load_mcp_get_game_download_app_info_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_result_params*)>("result_list",_mcpack2_load_mcp_get_game_download_app_info_result_params_result_list));
_mcpack2_load_mcp_get_game_download_app_info_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_game_download_app_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_download_app_info_result_params_static_inited=_mcpack2_load_mcp_get_game_download_app_info_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_game_download_app_info_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_app_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_update_download_info result_list=out(),array(0);
static void _mcpack2_load_mcp_get_game_download_app_info_result_params_result_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_app_info_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_result_list)) lp0=&(self->_m_result_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_game_download_app_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_download_app_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_download_app_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_download_app_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_download_app_info_result_params*)=0;
if(_mcpack2_load_mcp_get_game_download_app_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_download_app_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_download_app_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_update_download_info result_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"result_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_result_list)& lr0=(_m_result_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_download_app_info_response
static void _mcpack2_load_mcp_get_game_download_app_info_response_result_params(const mc_pack_item_t*,mcp_get_game_download_app_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_download_app_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_download_app_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_app_info_response*)>("result_params",_mcpack2_load_mcp_get_game_download_app_info_response_result_params));
_mcpack2_load_mcp_get_game_download_app_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_download_app_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_download_app_info_response_static_inited=_mcpack2_load_mcp_get_game_download_app_info_response_static_init();
// @@mcp_get_game_download_app_info_result_params result_params;
static void _mcpack2_load_mcp_get_game_download_app_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_app_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_download_app_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_download_app_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_download_app_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_download_app_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_download_app_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_download_app_info_response*)=0;
if(_mcpack2_load_mcp_get_game_download_app_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_download_app_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_download_app_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_download_app_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_dbapp_detail_info_params
static void _mcpack2_load_mcp_get_game_dbapp_detail_info_params_package_name(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_params*);
static void _mcpack2_load_mcp_get_game_dbapp_detail_info_params_game_img(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_params*);
static void _mcpack2_load_mcp_get_game_dbapp_detail_info_params_filter(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_dbapp_detail_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_dbapp_detail_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_params*)>("package_name",_mcpack2_load_mcp_get_game_dbapp_detail_info_params_package_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_params*)>("game_img",_mcpack2_load_mcp_get_game_dbapp_detail_info_params_game_img));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_params*)>("filter",_mcpack2_load_mcp_get_game_dbapp_detail_info_params_filter));
_mcpack2_load_mcp_get_game_dbapp_detail_info_params_readmap.create(16*3);
_mcpack2_load_mcp_get_game_dbapp_detail_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_dbapp_detail_info_params_static_inited=_mcpack2_load_mcp_get_game_dbapp_detail_info_params_static_init();
// @@string package_name=in();
static void _mcpack2_load_mcp_get_game_dbapp_detail_info_params_package_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_dbapp_detail_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "package_name";
}
self->_m_package_name.set_ptr(item->value,item->value_size-1);
}
// @@string game_img=in();
static void _mcpack2_load_mcp_get_game_dbapp_detail_info_params_game_img(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_dbapp_detail_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_img";
}
self->_m_game_img.set_ptr(item->value,item->value_size-1);
}
// @@string filter=in();
static void _mcpack2_load_mcp_get_game_dbapp_detail_info_params_filter(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_dbapp_detail_info_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "filter";
}
self->_m_filter.set_ptr(item->value,item->value_size-1);
}
void mcp_get_game_dbapp_detail_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_dbapp_detail_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_dbapp_detail_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_params*)=0;
if(_mcpack2_load_mcp_get_game_dbapp_detail_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_dbapp_detail_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_dbapp_detail_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string package_name=in();
{
int res=mc_pack_put_str(pack,"package_name",_m_package_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_img=in();
{
int res=mc_pack_put_str(pack,"game_img",_m_game_img.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string filter=in();
{
int res=mc_pack_put_str(pack,"filter",_m_filter.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_dbapp_detail_info_result_params
static void _mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_count(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_result_params*);
static void _mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_result_list(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_result_params*)>("count",_mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_result_params*)>("result_list",_mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_result_list));
_mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_static_inited=_mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_dbapp_detail_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_update_download_info result_list=out(),array(0);
static void _mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_result_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_dbapp_detail_info_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_result_list)) lp0=&(self->_m_result_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_game_dbapp_detail_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_dbapp_detail_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_result_params*)=0;
if(_mcpack2_load_mcp_get_game_dbapp_detail_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_dbapp_detail_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_dbapp_detail_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_update_download_info result_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"result_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_result_list)& lr0=(_m_result_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_dbapp_detail_info_response
static void _mcpack2_load_mcp_get_game_dbapp_detail_info_response_result_params(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_dbapp_detail_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_dbapp_detail_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_response*)>("result_params",_mcpack2_load_mcp_get_game_dbapp_detail_info_response_result_params));
_mcpack2_load_mcp_get_game_dbapp_detail_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_dbapp_detail_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_dbapp_detail_info_response_static_inited=_mcpack2_load_mcp_get_game_dbapp_detail_info_response_static_init();
// @@mcp_get_game_dbapp_detail_info_result_params result_params;
static void _mcpack2_load_mcp_get_game_dbapp_detail_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_dbapp_detail_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_dbapp_detail_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_dbapp_detail_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_dbapp_detail_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_dbapp_detail_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_dbapp_detail_info_response*)=0;
if(_mcpack2_load_mcp_get_game_dbapp_detail_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_dbapp_detail_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_dbapp_detail_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_dbapp_detail_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_device_download_games_info_by_udid_params
static void _mcpack2_load_mcp_get_device_download_games_info_by_udid_params_udid(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_params*);
static void _mcpack2_load_mcp_get_device_download_games_info_by_udid_params_img_types(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_params*);
static void _mcpack2_load_mcp_get_device_download_games_info_by_udid_params_filter(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_device_download_games_info_by_udid_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_device_download_games_info_by_udid_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_params*)>("udid",_mcpack2_load_mcp_get_device_download_games_info_by_udid_params_udid));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_params*)>("img_types",_mcpack2_load_mcp_get_device_download_games_info_by_udid_params_img_types));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_params*)>("filter",_mcpack2_load_mcp_get_device_download_games_info_by_udid_params_filter));
_mcpack2_load_mcp_get_device_download_games_info_by_udid_params_readmap.create(16*3);
_mcpack2_load_mcp_get_device_download_games_info_by_udid_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_device_download_games_info_by_udid_params_static_inited=_mcpack2_load_mcp_get_device_download_games_info_by_udid_params_static_init();
// @@string udid=in();
static void _mcpack2_load_mcp_get_device_download_games_info_by_udid_params_udid(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_device_download_games_info_by_udid_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "udid";
}
self->_m_udid.set_ptr(item->value,item->value_size-1);
}
// @@string img_types=in();
static void _mcpack2_load_mcp_get_device_download_games_info_by_udid_params_img_types(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_device_download_games_info_by_udid_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "img_types";
}
self->_m_img_types.set_ptr(item->value,item->value_size-1);
}
// @@string filter=in();
static void _mcpack2_load_mcp_get_device_download_games_info_by_udid_params_filter(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_device_download_games_info_by_udid_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "filter";
}
self->_m_filter.set_ptr(item->value,item->value_size-1);
}
void mcp_get_device_download_games_info_by_udid_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_params*)=0;
do{
if(_mcpack2_load_mcp_get_device_download_games_info_by_udid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_device_download_games_info_by_udid_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_params*)=0;
if(_mcpack2_load_mcp_get_device_download_games_info_by_udid_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_device_download_games_info_by_udid_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_device_download_games_info_by_udid_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string udid=in();
{
int res=mc_pack_put_str(pack,"udid",_m_udid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string img_types=in();
{
int res=mc_pack_put_str(pack,"img_types",_m_img_types.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string filter=in();
{
int res=mc_pack_put_str(pack,"filter",_m_filter.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_device_download_games_info_by_udid_result_params
static void _mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_count(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_result_params*);
static void _mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_result_list(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_result_params*)>("count",_mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_result_params*)>("result_list",_mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_result_list));
_mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_static_inited=_mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_device_download_games_info_by_udid_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_content_download_info_t result_list=out(),array(0);
static void _mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_result_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_device_download_games_info_by_udid_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_result_list)) lp0=&(self->_m_result_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_device_download_games_info_by_udid_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_device_download_games_info_by_udid_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_result_params*)=0;
if(_mcpack2_load_mcp_get_device_download_games_info_by_udid_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_device_download_games_info_by_udid_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_device_download_games_info_by_udid_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_content_download_info_t result_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"result_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_result_list)& lr0=(_m_result_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_device_download_games_info_by_udid_response
static void _mcpack2_load_mcp_get_device_download_games_info_by_udid_response_result_params(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_device_download_games_info_by_udid_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_device_download_games_info_by_udid_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_response*)>("result_params",_mcpack2_load_mcp_get_device_download_games_info_by_udid_response_result_params));
_mcpack2_load_mcp_get_device_download_games_info_by_udid_response_readmap.create(16*1);
_mcpack2_load_mcp_get_device_download_games_info_by_udid_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_device_download_games_info_by_udid_response_static_inited=_mcpack2_load_mcp_get_device_download_games_info_by_udid_response_static_init();
// @@mcp_get_device_download_games_info_by_udid_result_params result_params;
static void _mcpack2_load_mcp_get_device_download_games_info_by_udid_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_device_download_games_info_by_udid_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_device_download_games_info_by_udid_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_device_download_games_info_by_udid_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_response*)=0;
do{
if(_mcpack2_load_mcp_get_device_download_games_info_by_udid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_device_download_games_info_by_udid_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_device_download_games_info_by_udid_response*)=0;
if(_mcpack2_load_mcp_get_device_download_games_info_by_udid_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_device_download_games_info_by_udid_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_device_download_games_info_by_udid_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_device_download_games_info_by_udid_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_device_download_game_params
static void _mcpack2_load_mcp_add_device_download_game_params_udid(const mc_pack_item_t*,mcp_add_device_download_game_params*);
static void _mcpack2_load_mcp_add_device_download_game_params_game_id(const mc_pack_item_t*,mcp_add_device_download_game_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_device_download_game_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_device_download_game_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_device_download_game_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_device_download_game_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_device_download_game_params*)>("udid",_mcpack2_load_mcp_add_device_download_game_params_udid));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_device_download_game_params*)>("game_id",_mcpack2_load_mcp_add_device_download_game_params_game_id));
_mcpack2_load_mcp_add_device_download_game_params_readmap.create(16*2);
_mcpack2_load_mcp_add_device_download_game_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_device_download_game_params_static_inited=_mcpack2_load_mcp_add_device_download_game_params_static_init();
// @@string udid=in();
static void _mcpack2_load_mcp_add_device_download_game_params_udid(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_device_download_game_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "udid";
}
self->_m_udid.set_ptr(item->value,item->value_size-1);
}
// @@string game_id=in();
static void _mcpack2_load_mcp_add_device_download_game_params_game_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_device_download_game_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
void mcp_add_device_download_game_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_device_download_game_params*)=0;
do{
if(_mcpack2_load_mcp_add_device_download_game_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_device_download_game_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_device_download_game_params*)=0;
if(_mcpack2_load_mcp_add_device_download_game_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_device_download_game_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_device_download_game_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string udid=in();
{
int res=mc_pack_put_str(pack,"udid",_m_udid.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_id=in();
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_device_download_game_result_params
static void _mcpack2_load_mcp_add_device_download_game_result_params_ret_code(const mc_pack_item_t*,mcp_add_device_download_game_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_device_download_game_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_device_download_game_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_device_download_game_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_device_download_game_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_device_download_game_result_params*)>("ret_code",_mcpack2_load_mcp_add_device_download_game_result_params_ret_code));
_mcpack2_load_mcp_add_device_download_game_result_params_readmap.create(16*1);
_mcpack2_load_mcp_add_device_download_game_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_device_download_game_result_params_static_inited=_mcpack2_load_mcp_add_device_download_game_result_params_static_init();
// @@int32_t ret_code=out();
static void _mcpack2_load_mcp_add_device_download_game_result_params_ret_code(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_device_download_game_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_ret_code));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ret_code";
}
}
void mcp_add_device_download_game_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_device_download_game_result_params*)=0;
do{
if(_mcpack2_load_mcp_add_device_download_game_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_device_download_game_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_device_download_game_result_params*)=0;
if(_mcpack2_load_mcp_add_device_download_game_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_device_download_game_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_device_download_game_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t ret_code=out();
{
int res=mc_pack_put_int32(pack,"ret_code",_m_ret_code);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_add_device_download_game_response
static void _mcpack2_load_mcp_add_device_download_game_response_result_params(const mc_pack_item_t*,mcp_add_device_download_game_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_add_device_download_game_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_add_device_download_game_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_add_device_download_game_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_add_device_download_game_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_add_device_download_game_response*)>("result_params",_mcpack2_load_mcp_add_device_download_game_response_result_params));
_mcpack2_load_mcp_add_device_download_game_response_readmap.create(16*1);
_mcpack2_load_mcp_add_device_download_game_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_add_device_download_game_response_static_inited=_mcpack2_load_mcp_add_device_download_game_response_static_init();
// @@mcp_add_device_download_game_result_params result_params;
static void _mcpack2_load_mcp_add_device_download_game_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_add_device_download_game_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_add_device_download_game_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_add_device_download_game_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_add_device_download_game_response*)=0;
do{
if(_mcpack2_load_mcp_add_device_download_game_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_add_device_download_game_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_add_device_download_game_response*)=0;
if(_mcpack2_load_mcp_add_device_download_game_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_add_device_download_game_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_add_device_download_game_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_add_device_download_game_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_content_info_list_ext_params
static void _mcpack2_load_mcp_get_game_content_info_list_ext_params_input(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_params*);
static void _mcpack2_load_mcp_get_game_content_info_list_ext_params_page(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_params*);
static void _mcpack2_load_mcp_get_game_content_info_list_ext_params_page_size(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_content_info_list_ext_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_content_info_list_ext_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_params*)>("input",_mcpack2_load_mcp_get_game_content_info_list_ext_params_input));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_params*)>("page",_mcpack2_load_mcp_get_game_content_info_list_ext_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_params*)>("page_size",_mcpack2_load_mcp_get_game_content_info_list_ext_params_page_size));
_mcpack2_load_mcp_get_game_content_info_list_ext_params_readmap.create(16*3);
_mcpack2_load_mcp_get_game_content_info_list_ext_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_content_info_list_ext_params_static_inited=_mcpack2_load_mcp_get_game_content_info_list_ext_params_static_init();
// @@string input=in();
static void _mcpack2_load_mcp_get_game_content_info_list_ext_params_input(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_content_info_list_ext_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "input";
}
self->_m_input.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_game_content_info_list_ext_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_content_info_list_ext_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_game_content_info_list_ext_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_content_info_list_ext_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_game_content_info_list_ext_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_content_info_list_ext_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_content_info_list_ext_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_params*)=0;
if(_mcpack2_load_mcp_get_game_content_info_list_ext_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_content_info_list_ext_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_content_info_list_ext_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string input=in();
{
int res=mc_pack_put_str(pack,"input",_m_input.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_content_info_list_ext_result_params
static void _mcpack2_load_mcp_get_game_content_info_list_ext_result_params_count(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_result_params*);
static void _mcpack2_load_mcp_get_game_content_info_list_ext_result_params_result_list(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_content_info_list_ext_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_content_info_list_ext_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_result_params*)>("count",_mcpack2_load_mcp_get_game_content_info_list_ext_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_result_params*)>("result_list",_mcpack2_load_mcp_get_game_content_info_list_ext_result_params_result_list));
_mcpack2_load_mcp_get_game_content_info_list_ext_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_game_content_info_list_ext_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_content_info_list_ext_result_params_static_inited=_mcpack2_load_mcp_get_game_content_info_list_ext_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_game_content_info_list_ext_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_content_info_list_ext_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_content_download_info_t result_list=out(),array(0);
static void _mcpack2_load_mcp_get_game_content_info_list_ext_result_params_result_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_content_info_list_ext_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_result_list)) lp0=&(self->_m_result_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "result_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_game_content_info_list_ext_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_content_info_list_ext_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_content_info_list_ext_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_result_params*)=0;
if(_mcpack2_load_mcp_get_game_content_info_list_ext_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_content_info_list_ext_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_content_info_list_ext_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_content_download_info_t result_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"result_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_result_list)& lr0=(_m_result_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_content_info_list_ext_response
static void _mcpack2_load_mcp_get_game_content_info_list_ext_response_result_params(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_content_info_list_ext_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_content_info_list_ext_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_response*)>("result_params",_mcpack2_load_mcp_get_game_content_info_list_ext_response_result_params));
_mcpack2_load_mcp_get_game_content_info_list_ext_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_content_info_list_ext_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_content_info_list_ext_response_static_inited=_mcpack2_load_mcp_get_game_content_info_list_ext_response_static_init();
// @@mcp_get_game_content_info_list_ext_result_params result_params;
static void _mcpack2_load_mcp_get_game_content_info_list_ext_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_content_info_list_ext_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_content_info_list_ext_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_content_info_list_ext_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_content_info_list_ext_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_content_info_list_ext_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_content_info_list_ext_response*)=0;
if(_mcpack2_load_mcp_get_game_content_info_list_ext_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_content_info_list_ext_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_content_info_list_ext_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_content_info_list_ext_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_currency_rate_params
static void _mcpack2_load_mcp_get_game_currency_rate_params_input(const mc_pack_item_t*,mcp_get_game_currency_rate_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_currency_rate_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_currency_rate_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_currency_rate_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_currency_rate_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_currency_rate_params*)>("input",_mcpack2_load_mcp_get_game_currency_rate_params_input));
_mcpack2_load_mcp_get_game_currency_rate_params_readmap.create(16*1);
_mcpack2_load_mcp_get_game_currency_rate_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_currency_rate_params_static_inited=_mcpack2_load_mcp_get_game_currency_rate_params_static_init();
// @@string input=in();
static void _mcpack2_load_mcp_get_game_currency_rate_params_input(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_currency_rate_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "input";
}
self->_m_input.set_ptr(item->value,item->value_size-1);
}
void mcp_get_game_currency_rate_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_currency_rate_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_currency_rate_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_currency_rate_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_currency_rate_params*)=0;
if(_mcpack2_load_mcp_get_game_currency_rate_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_currency_rate_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_currency_rate_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string input=in();
{
int res=mc_pack_put_str(pack,"input",_m_input.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_currency_rate_result_params
static void _mcpack2_load_mcp_get_game_currency_rate_result_params_currency_info(const mc_pack_item_t*,mcp_get_game_currency_rate_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_currency_rate_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_currency_rate_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_currency_rate_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_currency_rate_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_currency_rate_result_params*)>("currency_info",_mcpack2_load_mcp_get_game_currency_rate_result_params_currency_info));
_mcpack2_load_mcp_get_game_currency_rate_result_params_readmap.create(16*1);
_mcpack2_load_mcp_get_game_currency_rate_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_currency_rate_result_params_static_inited=_mcpack2_load_mcp_get_game_currency_rate_result_params_static_init();
// @@game_dev_vir_currency_info currency_info=out();
static void _mcpack2_load_mcp_get_game_currency_rate_result_params_currency_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_currency_rate_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_currency_info){
self->_m_currency_info=::idl::game_dev_vir_currency_info::create(self->_pool);
}
self->_m_currency_info->LoadWithoutCheck(pack);
}
void mcp_get_game_currency_rate_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_currency_rate_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_currency_rate_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_currency_rate_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_currency_rate_result_params*)=0;
if(_mcpack2_load_mcp_get_game_currency_rate_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_currency_rate_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_currency_rate_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@game_dev_vir_currency_info currency_info=out();
{
mc_pack_t* subpack=mc_pack_put_object(pack,"currency_info");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_currency_info->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_currency_rate_response
static void _mcpack2_load_mcp_get_game_currency_rate_response_result_params(const mc_pack_item_t*,mcp_get_game_currency_rate_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_currency_rate_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_currency_rate_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_currency_rate_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_currency_rate_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_currency_rate_response*)>("result_params",_mcpack2_load_mcp_get_game_currency_rate_response_result_params));
_mcpack2_load_mcp_get_game_currency_rate_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_currency_rate_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_currency_rate_response_static_inited=_mcpack2_load_mcp_get_game_currency_rate_response_static_init();
// @@mcp_get_game_currency_rate_result_params result_params;
static void _mcpack2_load_mcp_get_game_currency_rate_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_currency_rate_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_currency_rate_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_currency_rate_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_currency_rate_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_currency_rate_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_currency_rate_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_currency_rate_response*)=0;
if(_mcpack2_load_mcp_get_game_currency_rate_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_currency_rate_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_currency_rate_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_currency_rate_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_download_info_params
static void _mcpack2_load_mcp_get_game_download_info_params_c_id(const mc_pack_item_t*,mcp_get_game_download_info_params*);
static void _mcpack2_load_mcp_get_game_download_info_params_channel_info(const mc_pack_item_t*,mcp_get_game_download_info_params*);
static void _mcpack2_load_mcp_get_game_download_info_params_channel_id(const mc_pack_item_t*,mcp_get_game_download_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_download_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_download_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_download_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_info_params*)>("c_id",_mcpack2_load_mcp_get_game_download_info_params_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_info_params*)>("channel_info",_mcpack2_load_mcp_get_game_download_info_params_channel_info));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_info_params*)>("channel_id",_mcpack2_load_mcp_get_game_download_info_params_channel_id));
_mcpack2_load_mcp_get_game_download_info_params_readmap.create(16*3);
_mcpack2_load_mcp_get_game_download_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_download_info_params_static_inited=_mcpack2_load_mcp_get_game_download_info_params_static_init();
// @@string c_id=in();
static void _mcpack2_load_mcp_get_game_download_info_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string channel_info=in();
static void _mcpack2_load_mcp_get_game_download_info_params_channel_info(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "channel_info";
}
self->_m_channel_info.set_ptr(item->value,item->value_size-1);
}
// @@string channel_id=in();
static void _mcpack2_load_mcp_get_game_download_info_params_channel_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_info_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "channel_id";
}
self->_m_channel_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_game_download_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_download_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_download_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_download_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_download_info_params*)=0;
if(_mcpack2_load_mcp_get_game_download_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_download_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_download_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string channel_info=in();
{
int res=mc_pack_put_str(pack,"channel_info",_m_channel_info.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string channel_id=in();
{
int res=mc_pack_put_str(pack,"channel_id",_m_channel_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_download_info_result_params
static void _mcpack2_load_mcp_get_game_download_info_result_params_count(const mc_pack_item_t*,mcp_get_game_download_info_result_params*);
static void _mcpack2_load_mcp_get_game_download_info_result_params_download_list(const mc_pack_item_t*,mcp_get_game_download_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_download_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_download_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_download_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_info_result_params*)>("count",_mcpack2_load_mcp_get_game_download_info_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_info_result_params*)>("download_list",_mcpack2_load_mcp_get_game_download_info_result_params_download_list));
_mcpack2_load_mcp_get_game_download_info_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_game_download_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_download_info_result_params_static_inited=_mcpack2_load_mcp_get_game_download_info_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_game_download_info_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@download_detail_t download_list=out(),array(0);
static void _mcpack2_load_mcp_get_game_download_info_result_params_download_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_info_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_download_list)) lp0=&(self->_m_download_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "download_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_game_download_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_download_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_download_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_download_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_download_info_result_params*)=0;
if(_mcpack2_load_mcp_get_game_download_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_download_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_download_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@download_detail_t download_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"download_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_download_list)& lr0=(_m_download_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_download_info_response
static void _mcpack2_load_mcp_get_game_download_info_response_result_params(const mc_pack_item_t*,mcp_get_game_download_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_download_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_download_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_download_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_download_info_response*)>("result_params",_mcpack2_load_mcp_get_game_download_info_response_result_params));
_mcpack2_load_mcp_get_game_download_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_download_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_download_info_response_static_inited=_mcpack2_load_mcp_get_game_download_info_response_static_init();
// @@mcp_get_game_download_info_result_params result_params;
static void _mcpack2_load_mcp_get_game_download_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_download_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_download_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_download_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_download_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_download_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_download_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_download_info_response*)=0;
if(_mcpack2_load_mcp_get_game_download_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_download_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_download_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_download_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_news_without_pbus_params
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_info_id(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*);
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_c_id(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*);
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_info_type(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*);
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_game_type(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*);
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_date_limit(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*);
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_page(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*);
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_page_size(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_news_without_pbus_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_news_without_pbus_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*)>("info_id",_mcpack2_load_mcp_get_game_news_without_pbus_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*)>("c_id",_mcpack2_load_mcp_get_game_news_without_pbus_params_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*)>("info_type",_mcpack2_load_mcp_get_game_news_without_pbus_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*)>("game_type",_mcpack2_load_mcp_get_game_news_without_pbus_params_game_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*)>("date_limit",_mcpack2_load_mcp_get_game_news_without_pbus_params_date_limit));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*)>("page",_mcpack2_load_mcp_get_game_news_without_pbus_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*)>("page_size",_mcpack2_load_mcp_get_game_news_without_pbus_params_page_size));
_mcpack2_load_mcp_get_game_news_without_pbus_params_readmap.create(16*7);
_mcpack2_load_mcp_get_game_news_without_pbus_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_news_without_pbus_params_static_inited=_mcpack2_load_mcp_get_game_news_without_pbus_params_static_init();
// @@string info_id=in();
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_without_pbus_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id=in();
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_without_pbus_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string info_type=in();
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_without_pbus_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
self->_m_info_type.set_ptr(item->value,item->value_size-1);
}
// @@string game_type=in();
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_game_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_without_pbus_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_type";
}
self->_m_game_type.set_ptr(item->value,item->value_size-1);
}
// @@string date_limit=in();
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_date_limit(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_without_pbus_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "date_limit";
}
self->_m_date_limit.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_without_pbus_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_game_news_without_pbus_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_without_pbus_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_game_news_without_pbus_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_news_without_pbus_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_news_without_pbus_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_params*)=0;
if(_mcpack2_load_mcp_get_game_news_without_pbus_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_news_without_pbus_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_news_without_pbus_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_type=in();
{
int res=mc_pack_put_str(pack,"info_type",_m_info_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_type=in();
{
int res=mc_pack_put_str(pack,"game_type",_m_game_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string date_limit=in();
{
int res=mc_pack_put_str(pack,"date_limit",_m_date_limit.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_news_without_pbus_result_params
static void _mcpack2_load_mcp_get_game_news_without_pbus_result_params_count(const mc_pack_item_t*,mcp_get_game_news_without_pbus_result_params*);
static void _mcpack2_load_mcp_get_game_news_without_pbus_result_params_game_info_list(const mc_pack_item_t*,mcp_get_game_news_without_pbus_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_news_without_pbus_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_news_without_pbus_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_result_params*)>("count",_mcpack2_load_mcp_get_game_news_without_pbus_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_result_params*)>("game_info_list",_mcpack2_load_mcp_get_game_news_without_pbus_result_params_game_info_list));
_mcpack2_load_mcp_get_game_news_without_pbus_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_game_news_without_pbus_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_news_without_pbus_result_params_static_inited=_mcpack2_load_mcp_get_game_news_without_pbus_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_game_news_without_pbus_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_without_pbus_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_info_t game_info_list=out(),array(0);
static void _mcpack2_load_mcp_get_game_news_without_pbus_result_params_game_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_without_pbus_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_game_info_list)) lp0=&(self->_m_game_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_game_news_without_pbus_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_news_without_pbus_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_news_without_pbus_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_result_params*)=0;
if(_mcpack2_load_mcp_get_game_news_without_pbus_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_news_without_pbus_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_news_without_pbus_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_info_t game_info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"game_info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_game_info_list)& lr0=(_m_game_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_news_without_pbus_response
static void _mcpack2_load_mcp_get_game_news_without_pbus_response_result_params(const mc_pack_item_t*,mcp_get_game_news_without_pbus_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_news_without_pbus_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_news_without_pbus_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_response*)>("result_params",_mcpack2_load_mcp_get_game_news_without_pbus_response_result_params));
_mcpack2_load_mcp_get_game_news_without_pbus_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_news_without_pbus_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_news_without_pbus_response_static_inited=_mcpack2_load_mcp_get_game_news_without_pbus_response_static_init();
// @@mcp_get_game_news_without_pbus_result_params result_params;
static void _mcpack2_load_mcp_get_game_news_without_pbus_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_without_pbus_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_news_without_pbus_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_news_without_pbus_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_news_without_pbus_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_news_without_pbus_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_without_pbus_response*)=0;
if(_mcpack2_load_mcp_get_game_news_without_pbus_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_news_without_pbus_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_news_without_pbus_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_news_without_pbus_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_mobile_music_info_params
static void _mcpack2_load_mcp_get_mobile_music_info_params_name(const mc_pack_item_t*,mcp_get_mobile_music_info_params*);
static void _mcpack2_load_mcp_get_mobile_music_info_params_singer(const mc_pack_item_t*,mcp_get_mobile_music_info_params*);
static void _mcpack2_load_mcp_get_mobile_music_info_params_ring_id(const mc_pack_item_t*,mcp_get_mobile_music_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_mobile_music_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_mobile_music_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_mobile_music_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_info_params*)>("name",_mcpack2_load_mcp_get_mobile_music_info_params_name));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_info_params*)>("singer",_mcpack2_load_mcp_get_mobile_music_info_params_singer));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_info_params*)>("ring_id",_mcpack2_load_mcp_get_mobile_music_info_params_ring_id));
_mcpack2_load_mcp_get_mobile_music_info_params_readmap.create(16*3);
_mcpack2_load_mcp_get_mobile_music_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_mobile_music_info_params_static_inited=_mcpack2_load_mcp_get_mobile_music_info_params_static_init();
// @@string name=in();
static void _mcpack2_load_mcp_get_mobile_music_info_params_name(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_mobile_music_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "name";
}
self->_m_name.set_ptr(item->value,item->value_size-1);
}
// @@string singer=in();
static void _mcpack2_load_mcp_get_mobile_music_info_params_singer(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_mobile_music_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "singer";
}
self->_m_singer.set_ptr(item->value,item->value_size-1);
}
// @@string ring_id=in();
static void _mcpack2_load_mcp_get_mobile_music_info_params_ring_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_mobile_music_info_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ring_id";
}
self->_m_ring_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_mobile_music_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_mobile_music_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_mobile_music_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_mobile_music_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_mobile_music_info_params*)=0;
if(_mcpack2_load_mcp_get_mobile_music_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_mobile_music_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_mobile_music_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string name=in();
{
int res=mc_pack_put_str(pack,"name",_m_name.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string singer=in();
{
int res=mc_pack_put_str(pack,"singer",_m_singer.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ring_id=in();
{
int res=mc_pack_put_str(pack,"ring_id",_m_ring_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_mobile_music_info_result_params
static void _mcpack2_load_mcp_get_mobile_music_info_result_params_count(const mc_pack_item_t*,mcp_get_mobile_music_info_result_params*);
static void _mcpack2_load_mcp_get_mobile_music_info_result_params_music_list(const mc_pack_item_t*,mcp_get_mobile_music_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_mobile_music_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_mobile_music_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_mobile_music_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_info_result_params*)>("count",_mcpack2_load_mcp_get_mobile_music_info_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_info_result_params*)>("music_list",_mcpack2_load_mcp_get_mobile_music_info_result_params_music_list));
_mcpack2_load_mcp_get_mobile_music_info_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_mobile_music_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_mobile_music_info_result_params_static_inited=_mcpack2_load_mcp_get_mobile_music_info_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_mobile_music_info_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_mobile_music_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@mobile_music_info_t music_list=out(),array(0);
static void _mcpack2_load_mcp_get_mobile_music_info_result_params_music_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_mobile_music_info_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "music_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_music_list)) lp0=&(self->_m_music_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "music_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "music_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "music_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_mobile_music_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_mobile_music_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_mobile_music_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_mobile_music_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_mobile_music_info_result_params*)=0;
if(_mcpack2_load_mcp_get_mobile_music_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_mobile_music_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_mobile_music_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@mobile_music_info_t music_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"music_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_music_list)& lr0=(_m_music_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_mobile_music_info_response
static void _mcpack2_load_mcp_get_mobile_music_info_response_result_params(const mc_pack_item_t*,mcp_get_mobile_music_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_mobile_music_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_mobile_music_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_mobile_music_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_info_response*)>("result_params",_mcpack2_load_mcp_get_mobile_music_info_response_result_params));
_mcpack2_load_mcp_get_mobile_music_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_mobile_music_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_mobile_music_info_response_static_inited=_mcpack2_load_mcp_get_mobile_music_info_response_static_init();
// @@mcp_get_mobile_music_info_result_params result_params;
static void _mcpack2_load_mcp_get_mobile_music_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_mobile_music_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_mobile_music_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_mobile_music_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_mobile_music_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_mobile_music_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_mobile_music_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_mobile_music_info_response*)=0;
if(_mcpack2_load_mcp_get_mobile_music_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_mobile_music_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_mobile_music_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_mobile_music_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_set_mobile_music_ptag_by_ring_id_params
static void _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_ring_id(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_params*);
static void _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_ptag(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_params*)>("ring_id",_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_ring_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_params*)>("ptag",_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_ptag));
_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_readmap.create(16*2);
_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_static_inited=_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_static_init();
// @@string ring_id=in();
static void _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_ring_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_set_mobile_music_ptag_by_ring_id_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ring_id";
}
self->_m_ring_id.set_ptr(item->value,item->value_size-1);
}
// @@string ptag=in();
static void _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_ptag(__attribute__((unused)) const mc_pack_item_t* item,mcp_set_mobile_music_ptag_by_ring_id_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ptag";
}
self->_m_ptag.set_ptr(item->value,item->value_size-1);
}
void mcp_set_mobile_music_ptag_by_ring_id_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_params*)=0;
do{
if(_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_set_mobile_music_ptag_by_ring_id_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_params*)=0;
if(_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_set_mobile_music_ptag_by_ring_id_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_set_mobile_music_ptag_by_ring_id_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string ring_id=in();
{
int res=mc_pack_put_str(pack,"ring_id",_m_ring_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string ptag=in();
{
int res=mc_pack_put_str(pack,"ptag",_m_ptag.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_set_mobile_music_ptag_by_ring_id_result_params
static void _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_result_params_result(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_result_params*)>("result",_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_result_params_result));
_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_result_params_readmap.create(16*1);
_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_result_params_static_inited=_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_result_params_static_init();
// @@uint32_t result=out();
static void _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_set_mobile_music_ptag_by_ring_id_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
void mcp_set_mobile_music_ptag_by_ring_id_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_result_params*)=0;
do{
if(_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_set_mobile_music_ptag_by_ring_id_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_result_params*)=0;
if(_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_set_mobile_music_ptag_by_ring_id_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_set_mobile_music_ptag_by_ring_id_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t result=out();
{
int res=mc_pack_put_uint32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_set_mobile_music_ptag_by_ring_id_response
static void _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_response_result_params(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_response*)>("result_params",_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_response_result_params));
_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_response_readmap.create(16*1);
_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_response_static_inited=_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_response_static_init();
// @@mcp_set_mobile_music_ptag_by_ring_id_result_params result_params;
static void _mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_set_mobile_music_ptag_by_ring_id_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_set_mobile_music_ptag_by_ring_id_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_set_mobile_music_ptag_by_ring_id_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_response*)=0;
do{
if(_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_set_mobile_music_ptag_by_ring_id_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_set_mobile_music_ptag_by_ring_id_response*)=0;
if(_mcpack2_load_mcp_set_mobile_music_ptag_by_ring_id_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_set_mobile_music_ptag_by_ring_id_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_set_mobile_music_ptag_by_ring_id_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_set_mobile_music_ptag_by_ring_id_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_mobile_music_ring_id_by_ptag_params
static void _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_params_ptag(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_params*)>("ptag",_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_params_ptag));
_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_params_readmap.create(16*1);
_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_params_static_inited=_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_params_static_init();
// @@string ptag=in();
static void _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_params_ptag(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_mobile_music_ring_id_by_ptag_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ptag";
}
self->_m_ptag.set_ptr(item->value,item->value_size-1);
}
void mcp_get_mobile_music_ring_id_by_ptag_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_params*)=0;
do{
if(_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_mobile_music_ring_id_by_ptag_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_params*)=0;
if(_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_mobile_music_ring_id_by_ptag_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_mobile_music_ring_id_by_ptag_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string ptag=in();
{
int res=mc_pack_put_str(pack,"ptag",_m_ptag.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_mobile_music_ring_id_by_ptag_result_params
static void _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_ring_id(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_result_params*);
static void _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_result(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_result_params*)>("ring_id",_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_ring_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_result_params*)>("result",_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_result));
_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_static_inited=_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_static_init();
// @@string ring_id=out();
static void _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_ring_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_mobile_music_ring_id_by_ptag_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ring_id";
}
self->_m_ring_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t result=out();
static void _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_mobile_music_ring_id_by_ptag_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
void mcp_get_mobile_music_ring_id_by_ptag_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_mobile_music_ring_id_by_ptag_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_result_params*)=0;
if(_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_mobile_music_ring_id_by_ptag_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_mobile_music_ring_id_by_ptag_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string ring_id=out();
{
int res=mc_pack_put_str(pack,"ring_id",_m_ring_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t result=out();
{
int res=mc_pack_put_uint32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_mobile_music_ring_id_by_ptag_response
static void _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_response_result_params(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_response*)>("result_params",_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_response_result_params));
_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_response_readmap.create(16*1);
_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_response_static_inited=_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_response_static_init();
// @@mcp_get_mobile_music_ring_id_by_ptag_result_params result_params;
static void _mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_mobile_music_ring_id_by_ptag_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_mobile_music_ring_id_by_ptag_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_mobile_music_ring_id_by_ptag_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_response*)=0;
do{
if(_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_mobile_music_ring_id_by_ptag_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_mobile_music_ring_id_by_ptag_response*)=0;
if(_mcpack2_load_mcp_get_mobile_music_ring_id_by_ptag_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_mobile_music_ring_id_by_ptag_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_mobile_music_ring_id_by_ptag_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_mobile_music_ring_id_by_ptag_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_championship_info_params
static void _mcpack2_load_mcp_get_championship_info_params_page(const mc_pack_item_t*,mcp_get_championship_info_params*);
static void _mcpack2_load_mcp_get_championship_info_params_page_size(const mc_pack_item_t*,mcp_get_championship_info_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_championship_info_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_championship_info_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_championship_info_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_championship_info_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_championship_info_params*)>("page",_mcpack2_load_mcp_get_championship_info_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_championship_info_params*)>("page_size",_mcpack2_load_mcp_get_championship_info_params_page_size));
_mcpack2_load_mcp_get_championship_info_params_readmap.create(16*2);
_mcpack2_load_mcp_get_championship_info_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_championship_info_params_static_inited=_mcpack2_load_mcp_get_championship_info_params_static_init();
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_championship_info_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_championship_info_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_championship_info_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_championship_info_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_championship_info_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_championship_info_params*)=0;
do{
if(_mcpack2_load_mcp_get_championship_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_championship_info_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_championship_info_params*)=0;
if(_mcpack2_load_mcp_get_championship_info_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_championship_info_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_championship_info_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_championship_info_result_params
static void _mcpack2_load_mcp_get_championship_info_result_params_count(const mc_pack_item_t*,mcp_get_championship_info_result_params*);
static void _mcpack2_load_mcp_get_championship_info_result_params_championship_list(const mc_pack_item_t*,mcp_get_championship_info_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_championship_info_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_championship_info_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_championship_info_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_championship_info_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_championship_info_result_params*)>("count",_mcpack2_load_mcp_get_championship_info_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_championship_info_result_params*)>("championship_list",_mcpack2_load_mcp_get_championship_info_result_params_championship_list));
_mcpack2_load_mcp_get_championship_info_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_championship_info_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_championship_info_result_params_static_inited=_mcpack2_load_mcp_get_championship_info_result_params_static_init();
// @@uint32_t count=out();
static void _mcpack2_load_mcp_get_championship_info_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_championship_info_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@championship_info_t championship_list=out(),array(0);
static void _mcpack2_load_mcp_get_championship_info_result_params_championship_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_championship_info_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "championship_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_championship_list)) lp0=&(self->_m_championship_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "championship_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "championship_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "championship_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_championship_info_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_championship_info_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_championship_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_championship_info_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_championship_info_result_params*)=0;
if(_mcpack2_load_mcp_get_championship_info_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_championship_info_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_championship_info_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t count=out();
{
int res=mc_pack_put_uint32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@championship_info_t championship_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"championship_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_championship_list)& lr0=(_m_championship_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_championship_info_response
static void _mcpack2_load_mcp_get_championship_info_response_result_params(const mc_pack_item_t*,mcp_get_championship_info_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_championship_info_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_championship_info_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_championship_info_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_championship_info_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_championship_info_response*)>("result_params",_mcpack2_load_mcp_get_championship_info_response_result_params));
_mcpack2_load_mcp_get_championship_info_response_readmap.create(16*1);
_mcpack2_load_mcp_get_championship_info_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_championship_info_response_static_inited=_mcpack2_load_mcp_get_championship_info_response_static_init();
// @@mcp_get_championship_info_result_params result_params;
static void _mcpack2_load_mcp_get_championship_info_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_championship_info_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_championship_info_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_championship_info_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_championship_info_response*)=0;
do{
if(_mcpack2_load_mcp_get_championship_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_championship_info_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_championship_info_response*)=0;
if(_mcpack2_load_mcp_get_championship_info_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_championship_info_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_championship_info_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_championship_info_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_user_add_coins_params
static void _mcpack2_load_mcp_user_add_coins_params_user_id(const mc_pack_item_t*,mcp_user_add_coins_params*);
static void _mcpack2_load_mcp_user_add_coins_params_game_id(const mc_pack_item_t*,mcp_user_add_coins_params*);
static void _mcpack2_load_mcp_user_add_coins_params_opt(const mc_pack_item_t*,mcp_user_add_coins_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_user_add_coins_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_user_add_coins_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_user_add_coins_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_user_add_coins_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_add_coins_params*)>("user_id",_mcpack2_load_mcp_user_add_coins_params_user_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_add_coins_params*)>("game_id",_mcpack2_load_mcp_user_add_coins_params_game_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_add_coins_params*)>("opt",_mcpack2_load_mcp_user_add_coins_params_opt));
_mcpack2_load_mcp_user_add_coins_params_readmap.create(16*3);
_mcpack2_load_mcp_user_add_coins_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_user_add_coins_params_static_inited=_mcpack2_load_mcp_user_add_coins_params_static_init();
// @@string user_id=in();
static void _mcpack2_load_mcp_user_add_coins_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_add_coins_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
// @@string game_id=in();
static void _mcpack2_load_mcp_user_add_coins_params_game_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_add_coins_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_id";
}
self->_m_game_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t opt=in();
static void _mcpack2_load_mcp_user_add_coins_params_opt(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_add_coins_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_opt));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "opt";
}
}
void mcp_user_add_coins_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_user_add_coins_params*)=0;
do{
if(_mcpack2_load_mcp_user_add_coins_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_user_add_coins_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_user_add_coins_params*)=0;
if(_mcpack2_load_mcp_user_add_coins_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_user_add_coins_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_user_add_coins_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string user_id=in();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_id=in();
{
int res=mc_pack_put_str(pack,"game_id",_m_game_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t opt=in();
{
int res=mc_pack_put_uint32(pack,"opt",_m_opt);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_user_add_coins_result_params
static void _mcpack2_load_mcp_user_add_coins_result_params_result(const mc_pack_item_t*,mcp_user_add_coins_result_params*);
static void _mcpack2_load_mcp_user_add_coins_result_params_errorcode(const mc_pack_item_t*,mcp_user_add_coins_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_user_add_coins_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_user_add_coins_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_user_add_coins_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_user_add_coins_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_add_coins_result_params*)>("result",_mcpack2_load_mcp_user_add_coins_result_params_result));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_add_coins_result_params*)>("errorcode",_mcpack2_load_mcp_user_add_coins_result_params_errorcode));
_mcpack2_load_mcp_user_add_coins_result_params_readmap.create(16*2);
_mcpack2_load_mcp_user_add_coins_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_user_add_coins_result_params_static_inited=_mcpack2_load_mcp_user_add_coins_result_params_static_init();
// @@uint32_t result=out();
static void _mcpack2_load_mcp_user_add_coins_result_params_result(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_add_coins_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_result));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "result";
}
}
// @@uint32_t errorcode=out();
static void _mcpack2_load_mcp_user_add_coins_result_params_errorcode(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_add_coins_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_errorcode));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "errorcode";
}
}
void mcp_user_add_coins_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_user_add_coins_result_params*)=0;
do{
if(_mcpack2_load_mcp_user_add_coins_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_user_add_coins_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_user_add_coins_result_params*)=0;
if(_mcpack2_load_mcp_user_add_coins_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_user_add_coins_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_user_add_coins_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t result=out();
{
int res=mc_pack_put_uint32(pack,"result",_m_result);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t errorcode=out();
{
int res=mc_pack_put_uint32(pack,"errorcode",_m_errorcode);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_user_add_coins_response
static void _mcpack2_load_mcp_user_add_coins_response_result_params(const mc_pack_item_t*,mcp_user_add_coins_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_user_add_coins_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_user_add_coins_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_user_add_coins_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_user_add_coins_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_user_add_coins_response*)>("result_params",_mcpack2_load_mcp_user_add_coins_response_result_params));
_mcpack2_load_mcp_user_add_coins_response_readmap.create(16*1);
_mcpack2_load_mcp_user_add_coins_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_user_add_coins_response_static_inited=_mcpack2_load_mcp_user_add_coins_response_static_init();
// @@mcp_user_add_coins_result_params result_params;
static void _mcpack2_load_mcp_user_add_coins_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_user_add_coins_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_user_add_coins_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_user_add_coins_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_user_add_coins_response*)=0;
do{
if(_mcpack2_load_mcp_user_add_coins_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_user_add_coins_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_user_add_coins_response*)=0;
if(_mcpack2_load_mcp_user_add_coins_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_user_add_coins_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_user_add_coins_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_user_add_coins_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_news_params
static void _mcpack2_load_mcp_get_game_news_params_info_id(const mc_pack_item_t*,mcp_get_game_news_params*);
static void _mcpack2_load_mcp_get_game_news_params_c_id(const mc_pack_item_t*,mcp_get_game_news_params*);
static void _mcpack2_load_mcp_get_game_news_params_info_type(const mc_pack_item_t*,mcp_get_game_news_params*);
static void _mcpack2_load_mcp_get_game_news_params_game_type(const mc_pack_item_t*,mcp_get_game_news_params*);
static void _mcpack2_load_mcp_get_game_news_params_date_limit(const mc_pack_item_t*,mcp_get_game_news_params*);
static void _mcpack2_load_mcp_get_game_news_params_page(const mc_pack_item_t*,mcp_get_game_news_params*);
static void _mcpack2_load_mcp_get_game_news_params_page_size(const mc_pack_item_t*,mcp_get_game_news_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_news_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_news_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_news_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_params*)>("info_id",_mcpack2_load_mcp_get_game_news_params_info_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_params*)>("c_id",_mcpack2_load_mcp_get_game_news_params_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_params*)>("info_type",_mcpack2_load_mcp_get_game_news_params_info_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_params*)>("game_type",_mcpack2_load_mcp_get_game_news_params_game_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_params*)>("date_limit",_mcpack2_load_mcp_get_game_news_params_date_limit));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_params*)>("page",_mcpack2_load_mcp_get_game_news_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_params*)>("page_size",_mcpack2_load_mcp_get_game_news_params_page_size));
_mcpack2_load_mcp_get_game_news_params_readmap.create(16*7);
_mcpack2_load_mcp_get_game_news_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_news_params_static_inited=_mcpack2_load_mcp_get_game_news_params_static_init();
// @@string info_id=in();
static void _mcpack2_load_mcp_get_game_news_params_info_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_id";
}
self->_m_info_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id=in();
static void _mcpack2_load_mcp_get_game_news_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string info_type=in();
static void _mcpack2_load_mcp_get_game_news_params_info_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "info_type";
}
self->_m_info_type.set_ptr(item->value,item->value_size-1);
}
// @@string game_type=in();
static void _mcpack2_load_mcp_get_game_news_params_game_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "game_type";
}
self->_m_game_type.set_ptr(item->value,item->value_size-1);
}
// @@string date_limit=in();
static void _mcpack2_load_mcp_get_game_news_params_date_limit(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "date_limit";
}
self->_m_date_limit.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_game_news_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_params* self){
self->_flag[5 >> 3] |= (1 << (5 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_game_news_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_params* self){
self->_flag[6 >> 3] |= (1 << (6 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_game_news_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_news_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_news_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_params*)=0;
if(_mcpack2_load_mcp_get_game_news_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_news_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_news_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string info_id=in();
{
int res=mc_pack_put_str(pack,"info_id",_m_info_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string info_type=in();
{
int res=mc_pack_put_str(pack,"info_type",_m_info_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string game_type=in();
{
int res=mc_pack_put_str(pack,"game_type",_m_game_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string date_limit=in();
{
int res=mc_pack_put_str(pack,"date_limit",_m_date_limit.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_news_result_params
static void _mcpack2_load_mcp_get_game_news_result_params_count(const mc_pack_item_t*,mcp_get_game_news_result_params*);
static void _mcpack2_load_mcp_get_game_news_result_params_game_info_list(const mc_pack_item_t*,mcp_get_game_news_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_news_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_news_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_news_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_result_params*)>("count",_mcpack2_load_mcp_get_game_news_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_result_params*)>("game_info_list",_mcpack2_load_mcp_get_game_news_result_params_game_info_list));
_mcpack2_load_mcp_get_game_news_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_game_news_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_news_result_params_static_inited=_mcpack2_load_mcp_get_game_news_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_game_news_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@game_info_t_hall game_info_list=out(),array(0);
static void _mcpack2_load_mcp_get_game_news_result_params_game_info_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_game_info_list)) lp0=&(self->_m_game_info_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "game_info_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_game_news_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_game_news_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_news_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_result_params*)=0;
if(_mcpack2_load_mcp_get_game_news_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_news_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_news_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@game_info_t_hall game_info_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"game_info_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_game_info_list)& lr0=(_m_game_info_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_game_news_response
static void _mcpack2_load_mcp_get_game_news_response_result_params(const mc_pack_item_t*,mcp_get_game_news_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_game_news_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_game_news_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_game_news_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_game_news_response*)>("result_params",_mcpack2_load_mcp_get_game_news_response_result_params));
_mcpack2_load_mcp_get_game_news_response_readmap.create(16*1);
_mcpack2_load_mcp_get_game_news_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_game_news_response_static_inited=_mcpack2_load_mcp_get_game_news_response_static_init();
// @@mcp_get_game_news_result_params result_params;
static void _mcpack2_load_mcp_get_game_news_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_game_news_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_game_news_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_game_news_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_response*)=0;
do{
if(_mcpack2_load_mcp_get_game_news_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_game_news_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_game_news_response*)=0;
if(_mcpack2_load_mcp_get_game_news_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_game_news_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_game_news_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_game_news_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ip_province_params
static void _mcpack2_load_mcp_get_ip_province_params_ip(const mc_pack_item_t*,mcp_get_ip_province_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ip_province_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ip_province_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ip_province_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ip_province_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ip_province_params*)>("ip",_mcpack2_load_mcp_get_ip_province_params_ip));
_mcpack2_load_mcp_get_ip_province_params_readmap.create(16*1);
_mcpack2_load_mcp_get_ip_province_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ip_province_params_static_inited=_mcpack2_load_mcp_get_ip_province_params_static_init();
// @@string ip=in();
static void _mcpack2_load_mcp_get_ip_province_params_ip(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ip_province_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ip";
}
self->_m_ip.set_ptr(item->value,item->value_size-1);
}
void mcp_get_ip_province_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ip_province_params*)=0;
do{
if(_mcpack2_load_mcp_get_ip_province_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ip_province_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ip_province_params*)=0;
if(_mcpack2_load_mcp_get_ip_province_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ip_province_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ip_province_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string ip=in();
{
int res=mc_pack_put_str(pack,"ip",_m_ip.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ip_province_result_params
static void _mcpack2_load_mcp_get_ip_province_result_params_ip_scope(const mc_pack_item_t*,mcp_get_ip_province_result_params*);
static void _mcpack2_load_mcp_get_ip_province_result_params_province(const mc_pack_item_t*,mcp_get_ip_province_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ip_province_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ip_province_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ip_province_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ip_province_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ip_province_result_params*)>("ip_scope",_mcpack2_load_mcp_get_ip_province_result_params_ip_scope));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ip_province_result_params*)>("province",_mcpack2_load_mcp_get_ip_province_result_params_province));
_mcpack2_load_mcp_get_ip_province_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_ip_province_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ip_province_result_params_static_inited=_mcpack2_load_mcp_get_ip_province_result_params_static_init();
// @@string ip_scope=out();
static void _mcpack2_load_mcp_get_ip_province_result_params_ip_scope(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ip_province_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "ip_scope";
}
self->_m_ip_scope.set_ptr(item->value,item->value_size-1);
}
// @@int32_t province=out();
static void _mcpack2_load_mcp_get_ip_province_result_params_province(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ip_province_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_province));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "province";
}
}
void mcp_get_ip_province_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ip_province_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_ip_province_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ip_province_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ip_province_result_params*)=0;
if(_mcpack2_load_mcp_get_ip_province_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ip_province_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ip_province_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string ip_scope=out();
{
int res=mc_pack_put_str(pack,"ip_scope",_m_ip_scope.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int32_t province=out();
{
int res=mc_pack_put_int32(pack,"province",_m_province);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_ip_province_response
static void _mcpack2_load_mcp_get_ip_province_response_result_params(const mc_pack_item_t*,mcp_get_ip_province_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_ip_province_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_ip_province_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_ip_province_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_ip_province_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_ip_province_response*)>("result_params",_mcpack2_load_mcp_get_ip_province_response_result_params));
_mcpack2_load_mcp_get_ip_province_response_readmap.create(16*1);
_mcpack2_load_mcp_get_ip_province_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_ip_province_response_static_inited=_mcpack2_load_mcp_get_ip_province_response_static_init();
// @@mcp_get_ip_province_result_params result_params;
static void _mcpack2_load_mcp_get_ip_province_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_ip_province_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_ip_province_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_ip_province_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_ip_province_response*)=0;
do{
if(_mcpack2_load_mcp_get_ip_province_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_ip_province_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_ip_province_response*)=0;
if(_mcpack2_load_mcp_get_ip_province_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_ip_province_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_ip_province_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_ip_province_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_question_type_name_params
static void _mcpack2_load_mcp_get_question_type_name_params_page(const mc_pack_item_t*,mcp_get_question_type_name_params*);
static void _mcpack2_load_mcp_get_question_type_name_params_page_size(const mc_pack_item_t*,mcp_get_question_type_name_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_question_type_name_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_question_type_name_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_question_type_name_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_question_type_name_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_question_type_name_params*)>("page",_mcpack2_load_mcp_get_question_type_name_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_question_type_name_params*)>("page_size",_mcpack2_load_mcp_get_question_type_name_params_page_size));
_mcpack2_load_mcp_get_question_type_name_params_readmap.create(16*2);
_mcpack2_load_mcp_get_question_type_name_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_question_type_name_params_static_inited=_mcpack2_load_mcp_get_question_type_name_params_static_init();
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_question_type_name_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_question_type_name_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_question_type_name_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_question_type_name_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_question_type_name_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_question_type_name_params*)=0;
do{
if(_mcpack2_load_mcp_get_question_type_name_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_question_type_name_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_question_type_name_params*)=0;
if(_mcpack2_load_mcp_get_question_type_name_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_question_type_name_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_question_type_name_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_question_type_name_result_params
static void _mcpack2_load_mcp_get_question_type_name_result_params_count(const mc_pack_item_t*,mcp_get_question_type_name_result_params*);
static void _mcpack2_load_mcp_get_question_type_name_result_params_question_type_name_list(const mc_pack_item_t*,mcp_get_question_type_name_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_question_type_name_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_question_type_name_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_question_type_name_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_question_type_name_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_question_type_name_result_params*)>("count",_mcpack2_load_mcp_get_question_type_name_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_question_type_name_result_params*)>("question_type_name_list",_mcpack2_load_mcp_get_question_type_name_result_params_question_type_name_list));
_mcpack2_load_mcp_get_question_type_name_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_question_type_name_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_question_type_name_result_params_static_inited=_mcpack2_load_mcp_get_question_type_name_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_question_type_name_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_question_type_name_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@question_type_name_t question_type_name_list=out(),array(0);
static void _mcpack2_load_mcp_get_question_type_name_result_params_question_type_name_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_question_type_name_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "question_type_name_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_question_type_name_list)) lp0=&(self->_m_question_type_name_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "question_type_name_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "question_type_name_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "question_type_name_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_question_type_name_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_question_type_name_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_question_type_name_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_question_type_name_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_question_type_name_result_params*)=0;
if(_mcpack2_load_mcp_get_question_type_name_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_question_type_name_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_question_type_name_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@question_type_name_t question_type_name_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"question_type_name_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_question_type_name_list)& lr0=(_m_question_type_name_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_question_type_name_response
static void _mcpack2_load_mcp_get_question_type_name_response_result_params(const mc_pack_item_t*,mcp_get_question_type_name_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_question_type_name_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_question_type_name_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_question_type_name_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_question_type_name_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_question_type_name_response*)>("result_params",_mcpack2_load_mcp_get_question_type_name_response_result_params));
_mcpack2_load_mcp_get_question_type_name_response_readmap.create(16*1);
_mcpack2_load_mcp_get_question_type_name_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_question_type_name_response_static_inited=_mcpack2_load_mcp_get_question_type_name_response_static_init();
// @@mcp_get_question_type_name_result_params result_params;
static void _mcpack2_load_mcp_get_question_type_name_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_question_type_name_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_question_type_name_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_question_type_name_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_question_type_name_response*)=0;
do{
if(_mcpack2_load_mcp_get_question_type_name_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_question_type_name_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_question_type_name_response*)=0;
if(_mcpack2_load_mcp_get_question_type_name_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_question_type_name_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_question_type_name_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_question_type_name_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_submit_question_params
static void _mcpack2_load_mcp_submit_question_params_user_id(const mc_pack_item_t*,mcp_submit_question_params*);
static void _mcpack2_load_mcp_submit_question_params_c_id(const mc_pack_item_t*,mcp_submit_question_params*);
static void _mcpack2_load_mcp_submit_question_params_question_type(const mc_pack_item_t*,mcp_submit_question_params*);
static void _mcpack2_load_mcp_submit_question_params_question(const mc_pack_item_t*,mcp_submit_question_params*);
static void _mcpack2_load_mcp_submit_question_params_phone(const mc_pack_item_t*,mcp_submit_question_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_submit_question_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_submit_question_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_submit_question_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_submit_question_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_submit_question_params*)>("user_id",_mcpack2_load_mcp_submit_question_params_user_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_submit_question_params*)>("c_id",_mcpack2_load_mcp_submit_question_params_c_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_submit_question_params*)>("question_type",_mcpack2_load_mcp_submit_question_params_question_type));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_submit_question_params*)>("question",_mcpack2_load_mcp_submit_question_params_question));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_submit_question_params*)>("phone",_mcpack2_load_mcp_submit_question_params_phone));
_mcpack2_load_mcp_submit_question_params_readmap.create(16*5);
_mcpack2_load_mcp_submit_question_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_submit_question_params_static_inited=_mcpack2_load_mcp_submit_question_params_static_init();
// @@string user_id=in();
static void _mcpack2_load_mcp_submit_question_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_submit_question_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
// @@string c_id=in();
static void _mcpack2_load_mcp_submit_question_params_c_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_submit_question_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_id";
}
self->_m_c_id.set_ptr(item->value,item->value_size-1);
}
// @@string question_type=in();
static void _mcpack2_load_mcp_submit_question_params_question_type(__attribute__((unused)) const mc_pack_item_t* item,mcp_submit_question_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "question_type";
}
self->_m_question_type.set_ptr(item->value,item->value_size-1);
}
// @@string question=in();
static void _mcpack2_load_mcp_submit_question_params_question(__attribute__((unused)) const mc_pack_item_t* item,mcp_submit_question_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "question";
}
self->_m_question.set_ptr(item->value,item->value_size-1);
}
// @@string phone=in();
static void _mcpack2_load_mcp_submit_question_params_phone(__attribute__((unused)) const mc_pack_item_t* item,mcp_submit_question_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "phone";
}
self->_m_phone.set_ptr(item->value,item->value_size-1);
}
void mcp_submit_question_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_submit_question_params*)=0;
do{
if(_mcpack2_load_mcp_submit_question_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_submit_question_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_submit_question_params*)=0;
if(_mcpack2_load_mcp_submit_question_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_submit_question_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_submit_question_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string user_id=in();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string c_id=in();
{
int res=mc_pack_put_str(pack,"c_id",_m_c_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string question_type=in();
{
int res=mc_pack_put_str(pack,"question_type",_m_question_type.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string question=in();
{
int res=mc_pack_put_str(pack,"question",_m_question.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string phone=in();
{
int res=mc_pack_put_str(pack,"phone",_m_phone.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_submit_question_result_params
static void _mcpack2_load_mcp_submit_question_result_params_res(const mc_pack_item_t*,mcp_submit_question_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_submit_question_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_submit_question_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_submit_question_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_submit_question_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_submit_question_result_params*)>("res",_mcpack2_load_mcp_submit_question_result_params_res));
_mcpack2_load_mcp_submit_question_result_params_readmap.create(16*1);
_mcpack2_load_mcp_submit_question_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_submit_question_result_params_static_inited=_mcpack2_load_mcp_submit_question_result_params_static_init();
// @@int32_t res=out();
static void _mcpack2_load_mcp_submit_question_result_params_res(__attribute__((unused)) const mc_pack_item_t* item,mcp_submit_question_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_res));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "res";
}
}
void mcp_submit_question_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_submit_question_result_params*)=0;
do{
if(_mcpack2_load_mcp_submit_question_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_submit_question_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_submit_question_result_params*)=0;
if(_mcpack2_load_mcp_submit_question_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_submit_question_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_submit_question_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t res=out();
{
int res=mc_pack_put_int32(pack,"res",_m_res);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_submit_question_response
static void _mcpack2_load_mcp_submit_question_response_result_params(const mc_pack_item_t*,mcp_submit_question_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_submit_question_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_submit_question_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_submit_question_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_submit_question_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_submit_question_response*)>("result_params",_mcpack2_load_mcp_submit_question_response_result_params));
_mcpack2_load_mcp_submit_question_response_readmap.create(16*1);
_mcpack2_load_mcp_submit_question_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_submit_question_response_static_inited=_mcpack2_load_mcp_submit_question_response_static_init();
// @@mcp_submit_question_result_params result_params;
static void _mcpack2_load_mcp_submit_question_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_submit_question_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_submit_question_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_submit_question_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_submit_question_response*)=0;
do{
if(_mcpack2_load_mcp_submit_question_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_submit_question_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_submit_question_response*)=0;
if(_mcpack2_load_mcp_submit_question_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_submit_question_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_submit_question_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_submit_question_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_user_question_params
static void _mcpack2_load_mcp_get_user_question_params_user_id(const mc_pack_item_t*,mcp_get_user_question_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_question_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_user_question_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_user_question_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_user_question_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_question_params*)>("user_id",_mcpack2_load_mcp_get_user_question_params_user_id));
_mcpack2_load_mcp_get_user_question_params_readmap.create(16*1);
_mcpack2_load_mcp_get_user_question_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_user_question_params_static_inited=_mcpack2_load_mcp_get_user_question_params_static_init();
// @@string user_id=in();
static void _mcpack2_load_mcp_get_user_question_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_question_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_user_question_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_user_question_params*)=0;
do{
if(_mcpack2_load_mcp_get_user_question_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_user_question_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_user_question_params*)=0;
if(_mcpack2_load_mcp_get_user_question_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_user_question_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_user_question_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string user_id=in();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_user_question_result_params
static void _mcpack2_load_mcp_get_user_question_result_params_count(const mc_pack_item_t*,mcp_get_user_question_result_params*);
static void _mcpack2_load_mcp_get_user_question_result_params_user_question_answer_list(const mc_pack_item_t*,mcp_get_user_question_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_question_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_user_question_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_user_question_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_user_question_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_question_result_params*)>("count",_mcpack2_load_mcp_get_user_question_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_question_result_params*)>("user_question_answer_list",_mcpack2_load_mcp_get_user_question_result_params_user_question_answer_list));
_mcpack2_load_mcp_get_user_question_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_user_question_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_user_question_result_params_static_inited=_mcpack2_load_mcp_get_user_question_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_user_question_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_question_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@user_question_answer_t user_question_answer_list=out(),array(0);
static void _mcpack2_load_mcp_get_user_question_result_params_user_question_answer_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_question_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "user_question_answer_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_user_question_answer_list)) lp0=&(self->_m_user_question_answer_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "user_question_answer_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "user_question_answer_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "user_question_answer_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_user_question_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_user_question_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_user_question_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_user_question_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_user_question_result_params*)=0;
if(_mcpack2_load_mcp_get_user_question_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_user_question_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_user_question_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@user_question_answer_t user_question_answer_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"user_question_answer_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_user_question_answer_list)& lr0=(_m_user_question_answer_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_user_question_response
static void _mcpack2_load_mcp_get_user_question_response_result_params(const mc_pack_item_t*,mcp_get_user_question_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_question_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_user_question_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_user_question_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_user_question_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_user_question_response*)>("result_params",_mcpack2_load_mcp_get_user_question_response_result_params));
_mcpack2_load_mcp_get_user_question_response_readmap.create(16*1);
_mcpack2_load_mcp_get_user_question_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_user_question_response_static_inited=_mcpack2_load_mcp_get_user_question_response_static_init();
// @@mcp_get_user_question_result_params result_params;
static void _mcpack2_load_mcp_get_user_question_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_user_question_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_user_question_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_user_question_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_user_question_response*)=0;
do{
if(_mcpack2_load_mcp_get_user_question_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_user_question_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_user_question_response*)=0;
if(_mcpack2_load_mcp_get_user_question_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_user_question_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_user_question_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_user_question_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_qp_activity_params
static void _mcpack2_load_mcp_get_qp_activity_params_id(const mc_pack_item_t*,mcp_get_qp_activity_params*);
static void _mcpack2_load_mcp_get_qp_activity_params_page(const mc_pack_item_t*,mcp_get_qp_activity_params*);
static void _mcpack2_load_mcp_get_qp_activity_params_page_size(const mc_pack_item_t*,mcp_get_qp_activity_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_qp_activity_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_qp_activity_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_qp_activity_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_params*)>("id",_mcpack2_load_mcp_get_qp_activity_params_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_params*)>("page",_mcpack2_load_mcp_get_qp_activity_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_params*)>("page_size",_mcpack2_load_mcp_get_qp_activity_params_page_size));
_mcpack2_load_mcp_get_qp_activity_params_readmap.create(16*3);
_mcpack2_load_mcp_get_qp_activity_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_qp_activity_params_static_inited=_mcpack2_load_mcp_get_qp_activity_params_static_init();
// @@string id=in();
static void _mcpack2_load_mcp_get_qp_activity_params_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_qp_activity_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "id";
}
self->_m_id.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_qp_activity_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_qp_activity_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_qp_activity_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_qp_activity_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_qp_activity_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_qp_activity_params*)=0;
do{
if(_mcpack2_load_mcp_get_qp_activity_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_qp_activity_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_qp_activity_params*)=0;
if(_mcpack2_load_mcp_get_qp_activity_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_qp_activity_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_qp_activity_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string id=in();
{
int res=mc_pack_put_str(pack,"id",_m_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_qp_activity_result_params
static void _mcpack2_load_mcp_get_qp_activity_result_params_count(const mc_pack_item_t*,mcp_get_qp_activity_result_params*);
static void _mcpack2_load_mcp_get_qp_activity_result_params_qp_activity_list(const mc_pack_item_t*,mcp_get_qp_activity_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_qp_activity_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_qp_activity_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_qp_activity_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_result_params*)>("count",_mcpack2_load_mcp_get_qp_activity_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_result_params*)>("qp_activity_list",_mcpack2_load_mcp_get_qp_activity_result_params_qp_activity_list));
_mcpack2_load_mcp_get_qp_activity_result_params_readmap.create(16*2);
_mcpack2_load_mcp_get_qp_activity_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_qp_activity_result_params_static_inited=_mcpack2_load_mcp_get_qp_activity_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_qp_activity_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_qp_activity_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@qp_activity_t qp_activity_list=out(),array(0);
static void _mcpack2_load_mcp_get_qp_activity_result_params_qp_activity_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_qp_activity_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "qp_activity_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_qp_activity_list)) lp0=&(self->_m_qp_activity_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "qp_activity_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "qp_activity_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "qp_activity_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_qp_activity_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_qp_activity_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_qp_activity_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_qp_activity_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_qp_activity_result_params*)=0;
if(_mcpack2_load_mcp_get_qp_activity_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_qp_activity_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_qp_activity_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@qp_activity_t qp_activity_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"qp_activity_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_qp_activity_list)& lr0=(_m_qp_activity_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_qp_activity_response
static void _mcpack2_load_mcp_get_qp_activity_response_result_params(const mc_pack_item_t*,mcp_get_qp_activity_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_qp_activity_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_qp_activity_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_qp_activity_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_response*)>("result_params",_mcpack2_load_mcp_get_qp_activity_response_result_params));
_mcpack2_load_mcp_get_qp_activity_response_readmap.create(16*1);
_mcpack2_load_mcp_get_qp_activity_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_qp_activity_response_static_inited=_mcpack2_load_mcp_get_qp_activity_response_static_init();
// @@mcp_get_qp_activity_result_params result_params;
static void _mcpack2_load_mcp_get_qp_activity_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_qp_activity_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_qp_activity_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_qp_activity_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_qp_activity_response*)=0;
do{
if(_mcpack2_load_mcp_get_qp_activity_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_qp_activity_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_qp_activity_response*)=0;
if(_mcpack2_load_mcp_get_qp_activity_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_qp_activity_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_qp_activity_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_qp_activity_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_qp_activity_person_params
static void _mcpack2_load_mcp_get_qp_activity_person_params_c_ids(const mc_pack_item_t*,mcp_get_qp_activity_person_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_person_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_qp_activity_person_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_qp_activity_person_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_qp_activity_person_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_person_params*)>("c_ids",_mcpack2_load_mcp_get_qp_activity_person_params_c_ids));
_mcpack2_load_mcp_get_qp_activity_person_params_readmap.create(16*1);
_mcpack2_load_mcp_get_qp_activity_person_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_qp_activity_person_params_static_inited=_mcpack2_load_mcp_get_qp_activity_person_params_static_init();
// @@string c_ids=in();
static void _mcpack2_load_mcp_get_qp_activity_person_params_c_ids(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_qp_activity_person_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "c_ids";
}
self->_m_c_ids.set_ptr(item->value,item->value_size-1);
}
void mcp_get_qp_activity_person_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_qp_activity_person_params*)=0;
do{
if(_mcpack2_load_mcp_get_qp_activity_person_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_qp_activity_person_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_qp_activity_person_params*)=0;
if(_mcpack2_load_mcp_get_qp_activity_person_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_qp_activity_person_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_qp_activity_person_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string c_ids=in();
{
int res=mc_pack_put_str(pack,"c_ids",_m_c_ids.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_qp_activity_person_result_params
static void _mcpack2_load_mcp_get_qp_activity_person_result_params_res(const mc_pack_item_t*,mcp_get_qp_activity_person_result_params*);
static void _mcpack2_load_mcp_get_qp_activity_person_result_params_total_person_num(const mc_pack_item_t*,mcp_get_qp_activity_person_result_params*);
static void _mcpack2_load_mcp_get_qp_activity_person_result_params_qp_activity_person_list(const mc_pack_item_t*,mcp_get_qp_activity_person_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_person_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_qp_activity_person_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_qp_activity_person_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_qp_activity_person_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_person_result_params*)>("res",_mcpack2_load_mcp_get_qp_activity_person_result_params_res));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_person_result_params*)>("total_person_num",_mcpack2_load_mcp_get_qp_activity_person_result_params_total_person_num));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_person_result_params*)>("qp_activity_person_list",_mcpack2_load_mcp_get_qp_activity_person_result_params_qp_activity_person_list));
_mcpack2_load_mcp_get_qp_activity_person_result_params_readmap.create(16*3);
_mcpack2_load_mcp_get_qp_activity_person_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_qp_activity_person_result_params_static_inited=_mcpack2_load_mcp_get_qp_activity_person_result_params_static_init();
// @@int32_t res=out();
static void _mcpack2_load_mcp_get_qp_activity_person_result_params_res(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_qp_activity_person_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_res));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "res";
}
}
// @@int32_t total_person_num=out();
static void _mcpack2_load_mcp_get_qp_activity_person_result_params_total_person_num(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_qp_activity_person_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_total_person_num));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "total_person_num";
}
}
// @@qp_activity_person_t qp_activity_person_list=out(),array(0);
static void _mcpack2_load_mcp_get_qp_activity_person_result_params_qp_activity_person_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_qp_activity_person_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "qp_activity_person_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_qp_activity_person_list)) lp0=&(self->_m_qp_activity_person_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "qp_activity_person_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "qp_activity_person_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "qp_activity_person_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_qp_activity_person_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_qp_activity_person_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_qp_activity_person_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_qp_activity_person_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_qp_activity_person_result_params*)=0;
if(_mcpack2_load_mcp_get_qp_activity_person_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_qp_activity_person_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_qp_activity_person_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t res=out();
{
int res=mc_pack_put_int32(pack,"res",_m_res);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int32_t total_person_num=out();
{
int res=mc_pack_put_int32(pack,"total_person_num",_m_total_person_num);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@qp_activity_person_t qp_activity_person_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"qp_activity_person_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_qp_activity_person_list)& lr0=(_m_qp_activity_person_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_qp_activity_person_response
static void _mcpack2_load_mcp_get_qp_activity_person_response_result_params(const mc_pack_item_t*,mcp_get_qp_activity_person_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_person_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_qp_activity_person_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_qp_activity_person_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_qp_activity_person_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_qp_activity_person_response*)>("result_params",_mcpack2_load_mcp_get_qp_activity_person_response_result_params));
_mcpack2_load_mcp_get_qp_activity_person_response_readmap.create(16*1);
_mcpack2_load_mcp_get_qp_activity_person_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_qp_activity_person_response_static_inited=_mcpack2_load_mcp_get_qp_activity_person_response_static_init();
// @@mcp_get_qp_activity_person_result_params result_params;
static void _mcpack2_load_mcp_get_qp_activity_person_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_qp_activity_person_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_qp_activity_person_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_qp_activity_person_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_qp_activity_person_response*)=0;
do{
if(_mcpack2_load_mcp_get_qp_activity_person_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_qp_activity_person_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_qp_activity_person_response*)=0;
if(_mcpack2_load_mcp_get_qp_activity_person_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_qp_activity_person_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_qp_activity_person_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_qp_activity_person_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_person_award_list_params
static void _mcpack2_load_mcp_get_person_award_list_params_page(const mc_pack_item_t*,mcp_get_person_award_list_params*);
static void _mcpack2_load_mcp_get_person_award_list_params_page_size(const mc_pack_item_t*,mcp_get_person_award_list_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_list_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_person_award_list_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_person_award_list_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_person_award_list_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_list_params*)>("page",_mcpack2_load_mcp_get_person_award_list_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_list_params*)>("page_size",_mcpack2_load_mcp_get_person_award_list_params_page_size));
_mcpack2_load_mcp_get_person_award_list_params_readmap.create(16*2);
_mcpack2_load_mcp_get_person_award_list_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_person_award_list_params_static_inited=_mcpack2_load_mcp_get_person_award_list_params_static_init();
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_person_award_list_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_award_list_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_person_award_list_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_award_list_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_person_award_list_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_person_award_list_params*)=0;
do{
if(_mcpack2_load_mcp_get_person_award_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_person_award_list_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_person_award_list_params*)=0;
if(_mcpack2_load_mcp_get_person_award_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_person_award_list_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_person_award_list_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_person_award_list_result_params
static void _mcpack2_load_mcp_get_person_award_list_result_params_res(const mc_pack_item_t*,mcp_get_person_award_list_result_params*);
static void _mcpack2_load_mcp_get_person_award_list_result_params_count(const mc_pack_item_t*,mcp_get_person_award_list_result_params*);
static void _mcpack2_load_mcp_get_person_award_list_result_params_person_award_list(const mc_pack_item_t*,mcp_get_person_award_list_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_list_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_person_award_list_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_person_award_list_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_person_award_list_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_list_result_params*)>("res",_mcpack2_load_mcp_get_person_award_list_result_params_res));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_list_result_params*)>("count",_mcpack2_load_mcp_get_person_award_list_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_list_result_params*)>("person_award_list",_mcpack2_load_mcp_get_person_award_list_result_params_person_award_list));
_mcpack2_load_mcp_get_person_award_list_result_params_readmap.create(16*3);
_mcpack2_load_mcp_get_person_award_list_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_person_award_list_result_params_static_inited=_mcpack2_load_mcp_get_person_award_list_result_params_static_init();
// @@int32_t res=out();
static void _mcpack2_load_mcp_get_person_award_list_result_params_res(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_award_list_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_res));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "res";
}
}
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_person_award_list_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_award_list_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@person_award_info_t person_award_list=out(),array(0);
static void _mcpack2_load_mcp_get_person_award_list_result_params_person_award_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_award_list_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "person_award_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_person_award_list)) lp0=&(self->_m_person_award_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "person_award_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "person_award_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "person_award_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_person_award_list_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_person_award_list_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_person_award_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_person_award_list_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_person_award_list_result_params*)=0;
if(_mcpack2_load_mcp_get_person_award_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_person_award_list_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_person_award_list_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t res=out();
{
int res=mc_pack_put_int32(pack,"res",_m_res);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@person_award_info_t person_award_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"person_award_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_person_award_list)& lr0=(_m_person_award_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_person_award_list_response
static void _mcpack2_load_mcp_get_person_award_list_response_result_params(const mc_pack_item_t*,mcp_get_person_award_list_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_list_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_person_award_list_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_person_award_list_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_person_award_list_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_list_response*)>("result_params",_mcpack2_load_mcp_get_person_award_list_response_result_params));
_mcpack2_load_mcp_get_person_award_list_response_readmap.create(16*1);
_mcpack2_load_mcp_get_person_award_list_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_person_award_list_response_static_inited=_mcpack2_load_mcp_get_person_award_list_response_static_init();
// @@mcp_get_person_award_list_result_params result_params;
static void _mcpack2_load_mcp_get_person_award_list_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_award_list_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_person_award_list_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_person_award_list_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_person_award_list_response*)=0;
do{
if(_mcpack2_load_mcp_get_person_award_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_person_award_list_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_person_award_list_response*)=0;
if(_mcpack2_load_mcp_get_person_award_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_person_award_list_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_person_award_list_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_person_award_list_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_person_all_awards_params
static void _mcpack2_load_mcp_get_person_all_awards_params_page(const mc_pack_item_t*,mcp_get_person_all_awards_params*);
static void _mcpack2_load_mcp_get_person_all_awards_params_page_size(const mc_pack_item_t*,mcp_get_person_all_awards_params*);
static void _mcpack2_load_mcp_get_person_all_awards_params_user_id(const mc_pack_item_t*,mcp_get_person_all_awards_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_all_awards_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_person_all_awards_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_person_all_awards_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_person_all_awards_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_all_awards_params*)>("page",_mcpack2_load_mcp_get_person_all_awards_params_page));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_all_awards_params*)>("page_size",_mcpack2_load_mcp_get_person_all_awards_params_page_size));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_all_awards_params*)>("user_id",_mcpack2_load_mcp_get_person_all_awards_params_user_id));
_mcpack2_load_mcp_get_person_all_awards_params_readmap.create(16*3);
_mcpack2_load_mcp_get_person_all_awards_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_person_all_awards_params_static_inited=_mcpack2_load_mcp_get_person_all_awards_params_static_init();
// @@uint32_t page=in();
static void _mcpack2_load_mcp_get_person_all_awards_params_page(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_all_awards_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page";
}
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_person_all_awards_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_all_awards_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
// @@string user_id=in();
static void _mcpack2_load_mcp_get_person_all_awards_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_all_awards_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_person_all_awards_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_person_all_awards_params*)=0;
do{
if(_mcpack2_load_mcp_get_person_all_awards_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_person_all_awards_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_person_all_awards_params*)=0;
if(_mcpack2_load_mcp_get_person_all_awards_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_person_all_awards_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_person_all_awards_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@uint32_t page=in();
{
int res=mc_pack_put_uint32(pack,"page",_m_page);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string user_id=in();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_person_all_awards_result_params
static void _mcpack2_load_mcp_get_person_all_awards_result_params_count(const mc_pack_item_t*,mcp_get_person_all_awards_result_params*);
static void _mcpack2_load_mcp_get_person_all_awards_result_params_res(const mc_pack_item_t*,mcp_get_person_all_awards_result_params*);
static void _mcpack2_load_mcp_get_person_all_awards_result_params_person_all_award_list(const mc_pack_item_t*,mcp_get_person_all_awards_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_all_awards_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_person_all_awards_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_person_all_awards_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_person_all_awards_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_all_awards_result_params*)>("count",_mcpack2_load_mcp_get_person_all_awards_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_all_awards_result_params*)>("res",_mcpack2_load_mcp_get_person_all_awards_result_params_res));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_all_awards_result_params*)>("person_all_award_list",_mcpack2_load_mcp_get_person_all_awards_result_params_person_all_award_list));
_mcpack2_load_mcp_get_person_all_awards_result_params_readmap.create(16*3);
_mcpack2_load_mcp_get_person_all_awards_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_person_all_awards_result_params_static_inited=_mcpack2_load_mcp_get_person_all_awards_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_person_all_awards_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_all_awards_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@int32_t res=out();
static void _mcpack2_load_mcp_get_person_all_awards_result_params_res(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_all_awards_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_res));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "res";
}
}
// @@person_all_award_info_t person_all_award_list=out(),array(0);
static void _mcpack2_load_mcp_get_person_all_awards_result_params_person_all_award_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_all_awards_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "person_all_award_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_person_all_award_list)) lp0=&(self->_m_person_all_award_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "person_all_award_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "person_all_award_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "person_all_award_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_person_all_awards_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_person_all_awards_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_person_all_awards_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_person_all_awards_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_person_all_awards_result_params*)=0;
if(_mcpack2_load_mcp_get_person_all_awards_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_person_all_awards_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_person_all_awards_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int32_t res=out();
{
int res=mc_pack_put_int32(pack,"res",_m_res);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@person_all_award_info_t person_all_award_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"person_all_award_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_person_all_award_list)& lr0=(_m_person_all_award_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_person_all_awards_response
static void _mcpack2_load_mcp_get_person_all_awards_response_result_params(const mc_pack_item_t*,mcp_get_person_all_awards_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_all_awards_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_person_all_awards_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_person_all_awards_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_person_all_awards_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_all_awards_response*)>("result_params",_mcpack2_load_mcp_get_person_all_awards_response_result_params));
_mcpack2_load_mcp_get_person_all_awards_response_readmap.create(16*1);
_mcpack2_load_mcp_get_person_all_awards_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_person_all_awards_response_static_inited=_mcpack2_load_mcp_get_person_all_awards_response_static_init();
// @@mcp_get_person_all_awards_result_params result_params;
static void _mcpack2_load_mcp_get_person_all_awards_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_all_awards_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_person_all_awards_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_person_all_awards_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_person_all_awards_response*)=0;
do{
if(_mcpack2_load_mcp_get_person_all_awards_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_person_all_awards_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_person_all_awards_response*)=0;
if(_mcpack2_load_mcp_get_person_all_awards_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_person_all_awards_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_person_all_awards_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_person_all_awards_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_person_award_params
static void _mcpack2_load_mcp_get_person_award_params_user_id(const mc_pack_item_t*,mcp_get_person_award_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_person_award_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_person_award_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_person_award_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_params*)>("user_id",_mcpack2_load_mcp_get_person_award_params_user_id));
_mcpack2_load_mcp_get_person_award_params_readmap.create(16*1);
_mcpack2_load_mcp_get_person_award_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_person_award_params_static_inited=_mcpack2_load_mcp_get_person_award_params_static_init();
// @@string user_id=in();
static void _mcpack2_load_mcp_get_person_award_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_award_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
void mcp_get_person_award_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_person_award_params*)=0;
do{
if(_mcpack2_load_mcp_get_person_award_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_person_award_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_person_award_params*)=0;
if(_mcpack2_load_mcp_get_person_award_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_person_award_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_person_award_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string user_id=in();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_person_award_result_params
static void _mcpack2_load_mcp_get_person_award_result_params_rank(const mc_pack_item_t*,mcp_get_person_award_result_params*);
static void _mcpack2_load_mcp_get_person_award_result_params_count(const mc_pack_item_t*,mcp_get_person_award_result_params*);
static void _mcpack2_load_mcp_get_person_award_result_params_res(const mc_pack_item_t*,mcp_get_person_award_result_params*);
static void _mcpack2_load_mcp_get_person_award_result_params_person_award_list(const mc_pack_item_t*,mcp_get_person_award_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_person_award_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_person_award_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_person_award_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_result_params*)>("rank",_mcpack2_load_mcp_get_person_award_result_params_rank));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_result_params*)>("count",_mcpack2_load_mcp_get_person_award_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_result_params*)>("res",_mcpack2_load_mcp_get_person_award_result_params_res));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_result_params*)>("person_award_list",_mcpack2_load_mcp_get_person_award_result_params_person_award_list));
_mcpack2_load_mcp_get_person_award_result_params_readmap.create(16*4);
_mcpack2_load_mcp_get_person_award_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_person_award_result_params_static_inited=_mcpack2_load_mcp_get_person_award_result_params_static_init();
// @@int32_t rank=out();
static void _mcpack2_load_mcp_get_person_award_result_params_rank(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_award_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_rank));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "rank";
}
}
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_person_award_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_award_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@int32_t res=out();
static void _mcpack2_load_mcp_get_person_award_result_params_res(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_award_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_res));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "res";
}
}
// @@person_award_info_t person_award_list=out(),array(0);
static void _mcpack2_load_mcp_get_person_award_result_params_person_award_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_award_result_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "person_award_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_person_award_list)) lp0=&(self->_m_person_award_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "person_award_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "person_award_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "person_award_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_person_award_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_person_award_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_person_award_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_person_award_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_person_award_result_params*)=0;
if(_mcpack2_load_mcp_get_person_award_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_person_award_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_person_award_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t rank=out();
{
int res=mc_pack_put_int32(pack,"rank",_m_rank);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int32_t res=out();
{
int res=mc_pack_put_int32(pack,"res",_m_res);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@person_award_info_t person_award_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"person_award_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_person_award_list)& lr0=(_m_person_award_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_person_award_response
static void _mcpack2_load_mcp_get_person_award_response_result_params(const mc_pack_item_t*,mcp_get_person_award_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_person_award_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_person_award_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_person_award_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_person_award_response*)>("result_params",_mcpack2_load_mcp_get_person_award_response_result_params));
_mcpack2_load_mcp_get_person_award_response_readmap.create(16*1);
_mcpack2_load_mcp_get_person_award_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_person_award_response_static_inited=_mcpack2_load_mcp_get_person_award_response_static_init();
// @@mcp_get_person_award_result_params result_params;
static void _mcpack2_load_mcp_get_person_award_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_person_award_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_person_award_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_person_award_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_person_award_response*)=0;
do{
if(_mcpack2_load_mcp_get_person_award_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_person_award_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_person_award_response*)=0;
if(_mcpack2_load_mcp_get_person_award_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_person_award_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_person_award_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_person_award_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_award_list_params
static void _mcpack2_load_mcp_get_award_list_params_award_channel(const mc_pack_item_t*,mcp_get_award_list_params*);
static void _mcpack2_load_mcp_get_award_list_params_page_size(const mc_pack_item_t*,mcp_get_award_list_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_award_list_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_award_list_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_award_list_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_award_list_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_award_list_params*)>("award_channel",_mcpack2_load_mcp_get_award_list_params_award_channel));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_award_list_params*)>("page_size",_mcpack2_load_mcp_get_award_list_params_page_size));
_mcpack2_load_mcp_get_award_list_params_readmap.create(16*2);
_mcpack2_load_mcp_get_award_list_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_award_list_params_static_inited=_mcpack2_load_mcp_get_award_list_params_static_init();
// @@string award_channel=in();
static void _mcpack2_load_mcp_get_award_list_params_award_channel(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_award_list_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "award_channel";
}
self->_m_award_channel.set_ptr(item->value,item->value_size-1);
}
// @@uint32_t page_size=in();
static void _mcpack2_load_mcp_get_award_list_params_page_size(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_award_list_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_uint32_from_item(item,&(self->_m_page_size));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "page_size";
}
}
void mcp_get_award_list_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_award_list_params*)=0;
do{
if(_mcpack2_load_mcp_get_award_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_award_list_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_award_list_params*)=0;
if(_mcpack2_load_mcp_get_award_list_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_award_list_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_award_list_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string award_channel=in();
{
int res=mc_pack_put_str(pack,"award_channel",_m_award_channel.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@uint32_t page_size=in();
{
int res=mc_pack_put_uint32(pack,"page_size",_m_page_size);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_award_list_result_params
static void _mcpack2_load_mcp_get_award_list_result_params_count(const mc_pack_item_t*,mcp_get_award_list_result_params*);
static void _mcpack2_load_mcp_get_award_list_result_params_res(const mc_pack_item_t*,mcp_get_award_list_result_params*);
static void _mcpack2_load_mcp_get_award_list_result_params_award_list(const mc_pack_item_t*,mcp_get_award_list_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_award_list_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_award_list_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_award_list_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_award_list_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_award_list_result_params*)>("count",_mcpack2_load_mcp_get_award_list_result_params_count));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_award_list_result_params*)>("res",_mcpack2_load_mcp_get_award_list_result_params_res));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_award_list_result_params*)>("award_list",_mcpack2_load_mcp_get_award_list_result_params_award_list));
_mcpack2_load_mcp_get_award_list_result_params_readmap.create(16*3);
_mcpack2_load_mcp_get_award_list_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_award_list_result_params_static_inited=_mcpack2_load_mcp_get_award_list_result_params_static_init();
// @@int32_t count=out();
static void _mcpack2_load_mcp_get_award_list_result_params_count(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_award_list_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_count));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "count";
}
}
// @@int32_t res=out();
static void _mcpack2_load_mcp_get_award_list_result_params_res(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_award_list_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_res));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "res";
}
}
// @@award_info_t award_list=out(),array(0);
static void _mcpack2_load_mcp_get_award_list_result_params_award_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_award_list_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "award_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_award_list)) lp0=&(self->_m_award_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "award_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "award_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "award_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_get_award_list_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_award_list_result_params*)=0;
do{
if(_mcpack2_load_mcp_get_award_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_award_list_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_award_list_result_params*)=0;
if(_mcpack2_load_mcp_get_award_list_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_award_list_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_award_list_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t count=out();
{
int res=mc_pack_put_int32(pack,"count",_m_count);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int32_t res=out();
{
int res=mc_pack_put_int32(pack,"res",_m_res);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@award_info_t award_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"award_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_award_list)& lr0=(_m_award_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_get_award_list_response
static void _mcpack2_load_mcp_get_award_list_response_result_params(const mc_pack_item_t*,mcp_get_award_list_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_get_award_list_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_get_award_list_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_get_award_list_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_get_award_list_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_get_award_list_response*)>("result_params",_mcpack2_load_mcp_get_award_list_response_result_params));
_mcpack2_load_mcp_get_award_list_response_readmap.create(16*1);
_mcpack2_load_mcp_get_award_list_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_get_award_list_response_static_inited=_mcpack2_load_mcp_get_award_list_response_static_init();
// @@mcp_get_award_list_result_params result_params;
static void _mcpack2_load_mcp_get_award_list_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_get_award_list_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_get_award_list_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_get_award_list_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_get_award_list_response*)=0;
do{
if(_mcpack2_load_mcp_get_award_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_get_award_list_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_get_award_list_response*)=0;
if(_mcpack2_load_mcp_get_award_list_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_get_award_list_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_get_award_list_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_get_award_list_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_grab_award_params
static void _mcpack2_load_mcp_grab_award_params_user_id(const mc_pack_item_t*,mcp_grab_award_params*);
static void _mcpack2_load_mcp_grab_award_params_award_channel(const mc_pack_item_t*,mcp_grab_award_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_grab_award_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_grab_award_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_grab_award_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_grab_award_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_grab_award_params*)>("user_id",_mcpack2_load_mcp_grab_award_params_user_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_grab_award_params*)>("award_channel",_mcpack2_load_mcp_grab_award_params_award_channel));
_mcpack2_load_mcp_grab_award_params_readmap.create(16*2);
_mcpack2_load_mcp_grab_award_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_grab_award_params_static_inited=_mcpack2_load_mcp_grab_award_params_static_init();
// @@string user_id=in();
static void _mcpack2_load_mcp_grab_award_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_grab_award_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
// @@string award_channel=in();
static void _mcpack2_load_mcp_grab_award_params_award_channel(__attribute__((unused)) const mc_pack_item_t* item,mcp_grab_award_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "award_channel";
}
self->_m_award_channel.set_ptr(item->value,item->value_size-1);
}
void mcp_grab_award_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_grab_award_params*)=0;
do{
if(_mcpack2_load_mcp_grab_award_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_grab_award_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_grab_award_params*)=0;
if(_mcpack2_load_mcp_grab_award_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_grab_award_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_grab_award_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string user_id=in();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string award_channel=in();
{
int res=mc_pack_put_str(pack,"award_channel",_m_award_channel.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_grab_award_result_params
static void _mcpack2_load_mcp_grab_award_result_params_res(const mc_pack_item_t*,mcp_grab_award_result_params*);
static void _mcpack2_load_mcp_grab_award_result_params_user_id(const mc_pack_item_t*,mcp_grab_award_result_params*);
static void _mcpack2_load_mcp_grab_award_result_params_award_list(const mc_pack_item_t*,mcp_grab_award_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_grab_award_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_grab_award_result_params_readmap;
// static initialization.
static bool _mcpack2_load_mcp_grab_award_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_grab_award_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_grab_award_result_params*)>("res",_mcpack2_load_mcp_grab_award_result_params_res));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_grab_award_result_params*)>("user_id",_mcpack2_load_mcp_grab_award_result_params_user_id));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_grab_award_result_params*)>("award_list",_mcpack2_load_mcp_grab_award_result_params_award_list));
_mcpack2_load_mcp_grab_award_result_params_readmap.create(16*3);
_mcpack2_load_mcp_grab_award_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_grab_award_result_params_static_inited=_mcpack2_load_mcp_grab_award_result_params_static_init();
// @@int32_t res=out();
static void _mcpack2_load_mcp_grab_award_result_params_res(__attribute__((unused)) const mc_pack_item_t* item,mcp_grab_award_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_res));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "res";
}
}
// @@string user_id=out();
static void _mcpack2_load_mcp_grab_award_result_params_user_id(__attribute__((unused)) const mc_pack_item_t* item,mcp_grab_award_result_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "user_id";
}
self->_m_user_id.set_ptr(item->value,item->value_size-1);
}
// @@award_info_t award_list=out(),array(0);
static void _mcpack2_load_mcp_grab_award_result_params_award_list(__attribute__((unused)) const mc_pack_item_t* item,mcp_grab_award_result_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "award_list";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_award_list)) lp0=&(self->_m_award_list);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "award_list";
}
for(int i0=0;i0<size0;i0++){
const mc_pack_t* pack=0;
res0=mc_pack_get_pack_from_item(&item0,&pack);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "award_list";
}
lp0->MutableGetWithoutCheck(i0)->LoadWithoutCheck(pack);
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "award_list";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
void mcp_grab_award_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_grab_award_result_params*)=0;
do{
if(_mcpack2_load_mcp_grab_award_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_grab_award_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_grab_award_result_params*)=0;
if(_mcpack2_load_mcp_grab_award_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_grab_award_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_grab_award_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t res=out();
{
int res=mc_pack_put_int32(pack,"res",_m_res);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string user_id=out();
{
int res=mc_pack_put_str(pack,"user_id",_m_user_id.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@award_info_t award_list=out(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"award_list");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_award_list)& lr0=(_m_award_list);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
mc_pack_t *subpack=mc_pack_put_object(pack0,0);
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
lr0.GetWithoutCheck(i0).save(subpack);
mc_pack_finish(subpack);
}
// level 0 end.

mc_pack_finish(pack0);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class mcp_grab_award_response
static void _mcpack2_load_mcp_grab_award_response_result_params(const mc_pack_item_t*,mcp_grab_award_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,mcp_grab_award_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_mcp_grab_award_response_readmap;
// static initialization.
static bool _mcpack2_load_mcp_grab_award_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,mcp_grab_award_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,mcp_grab_award_response*)>("result_params",_mcpack2_load_mcp_grab_award_response_result_params));
_mcpack2_load_mcp_grab_award_response_readmap.create(16*1);
_mcpack2_load_mcp_grab_award_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_mcp_grab_award_response_static_inited=_mcpack2_load_mcp_grab_award_response_static_init();
// @@mcp_grab_award_result_params result_params;
static void _mcpack2_load_mcp_grab_award_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,mcp_grab_award_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::mcp_grab_award_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void mcp_grab_award_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,mcp_grab_award_response*)=0;
do{
if(_mcpack2_load_mcp_grab_award_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int mcp_grab_award_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,mcp_grab_award_response*)=0;
if(_mcpack2_load_mcp_grab_award_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void mcp_grab_award_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t mcp_grab_award_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@mcp_grab_award_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class Notify_addSystemNotify_params
static void _mcpack2_load_Notify_addSystemNotify_params_sourceId(const mc_pack_item_t*,Notify_addSystemNotify_params*);
static void _mcpack2_load_Notify_addSystemNotify_params_titleId(const mc_pack_item_t*,Notify_addSystemNotify_params*);
static void _mcpack2_load_Notify_addSystemNotify_params_targetUid(const mc_pack_item_t*,Notify_addSystemNotify_params*);
static void _mcpack2_load_Notify_addSystemNotify_params_messageContent(const mc_pack_item_t*,Notify_addSystemNotify_params*);
static void _mcpack2_load_Notify_addSystemNotify_params_bussiness(const mc_pack_item_t*,Notify_addSystemNotify_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,Notify_addSystemNotify_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_Notify_addSystemNotify_params_readmap;
// static initialization.
static bool _mcpack2_load_Notify_addSystemNotify_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,Notify_addSystemNotify_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,Notify_addSystemNotify_params*)>("sourceId",_mcpack2_load_Notify_addSystemNotify_params_sourceId));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,Notify_addSystemNotify_params*)>("titleId",_mcpack2_load_Notify_addSystemNotify_params_titleId));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,Notify_addSystemNotify_params*)>("targetUid",_mcpack2_load_Notify_addSystemNotify_params_targetUid));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,Notify_addSystemNotify_params*)>("messageContent",_mcpack2_load_Notify_addSystemNotify_params_messageContent));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,Notify_addSystemNotify_params*)>("bussiness",_mcpack2_load_Notify_addSystemNotify_params_bussiness));
_mcpack2_load_Notify_addSystemNotify_params_readmap.create(16*5);
_mcpack2_load_Notify_addSystemNotify_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_Notify_addSystemNotify_params_static_inited=_mcpack2_load_Notify_addSystemNotify_params_static_init();
// @@string sourceId=in();
static void _mcpack2_load_Notify_addSystemNotify_params_sourceId(__attribute__((unused)) const mc_pack_item_t* item,Notify_addSystemNotify_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "sourceId";
}
self->_m_sourceId.set_ptr(item->value,item->value_size-1);
}
// @@string titleId=in();
static void _mcpack2_load_Notify_addSystemNotify_params_titleId(__attribute__((unused)) const mc_pack_item_t* item,Notify_addSystemNotify_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "titleId";
}
self->_m_titleId.set_ptr(item->value,item->value_size-1);
}
// @@int32_t targetUid=in(),array(0);
static void _mcpack2_load_Notify_addSystemNotify_params_targetUid(__attribute__((unused)) const mc_pack_item_t* item,Notify_addSystemNotify_params* self){
self->_flag[2 >> 3] |= (1 << (2 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack0=0;
res=mc_pack_get_array_from_item(item,&pack0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG << "targetUid";
}
// level 0 begin.
int size0=mc_pack_get_item_count(pack0);

typeof(&(self->_m_targetUid)) lp0=&(self->_m_targetUid);
lp0->resize(size0);
if(size0>0){
mc_pack_item_t item0;
int res0=mc_pack_first_item(pack0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "targetUid";
}
for(int i0=0;i0<size0;i0++){
res0=mc_pack_get_int32_from_item(&item0,lp0->MutableGetWithoutCheck(i0));
if(res0){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "targetUid";
}
if(i0<(size0-1)){
res0=mc_pack_next_item(&item0,&item0);
if(res0<0){
throw ::idl::McpackException(res) << BSL_EARG << "targetUid";
}
}
} // for(int i0=0;i0<size;i0++)
} // if(size0>0)
// level 0 end.

}
// @@string messageContent=in();
static void _mcpack2_load_Notify_addSystemNotify_params_messageContent(__attribute__((unused)) const mc_pack_item_t* item,Notify_addSystemNotify_params* self){
self->_flag[3 >> 3] |= (1 << (3 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
if(item->type!=MC_IT_TXT){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "messageContent";
}
self->_m_messageContent.set_ptr(item->value,item->value_size-1);
}
// @@int32_t bussiness=in();
static void _mcpack2_load_Notify_addSystemNotify_params_bussiness(__attribute__((unused)) const mc_pack_item_t* item,Notify_addSystemNotify_params* self){
self->_flag[4 >> 3] |= (1 << (4 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_bussiness));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "bussiness";
}
}
void Notify_addSystemNotify_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,Notify_addSystemNotify_params*)=0;
do{
if(_mcpack2_load_Notify_addSystemNotify_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int Notify_addSystemNotify_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,Notify_addSystemNotify_params*)=0;
if(_mcpack2_load_Notify_addSystemNotify_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void Notify_addSystemNotify_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t Notify_addSystemNotify_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@string sourceId=in();
{
int res=mc_pack_put_str(pack,"sourceId",_m_sourceId.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@string titleId=in();
{
int res=mc_pack_put_str(pack,"titleId",_m_titleId.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int32_t targetUid=in(),array(0);
{
mc_pack_t *pack0=mc_pack_put_array(pack,"targetUid");
if(MC_PACK_PTR_ERR(pack0)){
throw ::idl::McpackException(pack0) << BSL_EARG;
}
// level 0 begin.
typeof(_m_targetUid)& lr0=(_m_targetUid);
size_t size0=lr0.size();
for(size_t i0=0;i0<size0;i0++){
int res0=mc_pack_put_int32(pack0,0,lr0.GetWithoutCheck(i0));
if(res0){
throw ::idl::McpackException(res0) << BSL_EARG;
}
}
// level 0 end.

mc_pack_finish(pack0);
}
// @@string messageContent=in();
{
int res=mc_pack_put_str(pack,"messageContent",_m_messageContent.c_str());
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int32_t bussiness=in();
{
int res=mc_pack_put_int32(pack,"bussiness",_m_bussiness);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class Notify_addSystemNotify_result_params
static void _mcpack2_load_Notify_addSystemNotify_result_params_resault(const mc_pack_item_t*,Notify_addSystemNotify_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,Notify_addSystemNotify_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_Notify_addSystemNotify_result_params_readmap;
// static initialization.
static bool _mcpack2_load_Notify_addSystemNotify_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,Notify_addSystemNotify_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,Notify_addSystemNotify_result_params*)>("resault",_mcpack2_load_Notify_addSystemNotify_result_params_resault));
_mcpack2_load_Notify_addSystemNotify_result_params_readmap.create(16*1);
_mcpack2_load_Notify_addSystemNotify_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_Notify_addSystemNotify_result_params_static_inited=_mcpack2_load_Notify_addSystemNotify_result_params_static_init();
// @@bool resault=out();
static void _mcpack2_load_Notify_addSystemNotify_result_params_resault(__attribute__((unused)) const mc_pack_item_t* item,Notify_addSystemNotify_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_bool_from_item(item,&(self->_m_resault));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "resault";
}
}
void Notify_addSystemNotify_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,Notify_addSystemNotify_result_params*)=0;
do{
if(_mcpack2_load_Notify_addSystemNotify_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int Notify_addSystemNotify_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,Notify_addSystemNotify_result_params*)=0;
if(_mcpack2_load_Notify_addSystemNotify_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void Notify_addSystemNotify_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t Notify_addSystemNotify_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@bool resault=out();
{
int res=mc_pack_put_bool(pack,"resault",_m_resault);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class Notify_addSystemNotify_response
static void _mcpack2_load_Notify_addSystemNotify_response_result_params(const mc_pack_item_t*,Notify_addSystemNotify_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,Notify_addSystemNotify_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_Notify_addSystemNotify_response_readmap;
// static initialization.
static bool _mcpack2_load_Notify_addSystemNotify_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,Notify_addSystemNotify_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,Notify_addSystemNotify_response*)>("result_params",_mcpack2_load_Notify_addSystemNotify_response_result_params));
_mcpack2_load_Notify_addSystemNotify_response_readmap.create(16*1);
_mcpack2_load_Notify_addSystemNotify_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_Notify_addSystemNotify_response_static_inited=_mcpack2_load_Notify_addSystemNotify_response_static_init();
// @@Notify_addSystemNotify_result_params result_params;
static void _mcpack2_load_Notify_addSystemNotify_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,Notify_addSystemNotify_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::Notify_addSystemNotify_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void Notify_addSystemNotify_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,Notify_addSystemNotify_response*)=0;
do{
if(_mcpack2_load_Notify_addSystemNotify_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int Notify_addSystemNotify_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,Notify_addSystemNotify_response*)=0;
if(_mcpack2_load_Notify_addSystemNotify_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void Notify_addSystemNotify_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t Notify_addSystemNotify_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@Notify_addSystemNotify_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class GameHallPoint_addGameHallScore_params
static void _mcpack2_load_GameHallPoint_addGameHallScore_params_userId(const mc_pack_item_t*,GameHallPoint_addGameHallScore_params*);
static void _mcpack2_load_GameHallPoint_addGameHallScore_params_opId(const mc_pack_item_t*,GameHallPoint_addGameHallScore_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_GameHallPoint_addGameHallScore_params_readmap;
// static initialization.
static bool _mcpack2_load_GameHallPoint_addGameHallScore_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_params*)>("userId",_mcpack2_load_GameHallPoint_addGameHallScore_params_userId));
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_params*)>("opId",_mcpack2_load_GameHallPoint_addGameHallScore_params_opId));
_mcpack2_load_GameHallPoint_addGameHallScore_params_readmap.create(16*2);
_mcpack2_load_GameHallPoint_addGameHallScore_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_GameHallPoint_addGameHallScore_params_static_inited=_mcpack2_load_GameHallPoint_addGameHallScore_params_static_init();
// @@int32_t userId=in();
static void _mcpack2_load_GameHallPoint_addGameHallScore_params_userId(__attribute__((unused)) const mc_pack_item_t* item,GameHallPoint_addGameHallScore_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_userId));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "userId";
}
}
// @@int32_t opId=in();
static void _mcpack2_load_GameHallPoint_addGameHallScore_params_opId(__attribute__((unused)) const mc_pack_item_t* item,GameHallPoint_addGameHallScore_params* self){
self->_flag[1 >> 3] |= (1 << (1 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_opId));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "opId";
}
}
void GameHallPoint_addGameHallScore_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_params*)=0;
do{
if(_mcpack2_load_GameHallPoint_addGameHallScore_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int GameHallPoint_addGameHallScore_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_params*)=0;
if(_mcpack2_load_GameHallPoint_addGameHallScore_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void GameHallPoint_addGameHallScore_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t GameHallPoint_addGameHallScore_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t userId=in();
{
int res=mc_pack_put_int32(pack,"userId",_m_userId);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// @@int32_t opId=in();
{
int res=mc_pack_put_int32(pack,"opId",_m_opId);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class GameHallPoint_addGameHallScore_result_params
static void _mcpack2_load_GameHallPoint_addGameHallScore_result_params_score(const mc_pack_item_t*,GameHallPoint_addGameHallScore_result_params*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_result_params*),::idl::string_hash,::idl::string_equal> _mcpack2_load_GameHallPoint_addGameHallScore_result_params_readmap;
// static initialization.
static bool _mcpack2_load_GameHallPoint_addGameHallScore_result_params_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_result_params*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_result_params*)>("score",_mcpack2_load_GameHallPoint_addGameHallScore_result_params_score));
_mcpack2_load_GameHallPoint_addGameHallScore_result_params_readmap.create(16*1);
_mcpack2_load_GameHallPoint_addGameHallScore_result_params_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_GameHallPoint_addGameHallScore_result_params_static_inited=_mcpack2_load_GameHallPoint_addGameHallScore_result_params_static_init();
// @@int32_t score=out();
static void _mcpack2_load_GameHallPoint_addGameHallScore_result_params_score(__attribute__((unused)) const mc_pack_item_t* item,GameHallPoint_addGameHallScore_result_params* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
res=mc_pack_get_int32_from_item(item,&(self->_m_score));
if(res){
throw ::idl::McpackWrongTypeException() << BSL_EARG << "score";
}
}
void GameHallPoint_addGameHallScore_result_params::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_result_params*)=0;
do{
if(_mcpack2_load_GameHallPoint_addGameHallScore_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int GameHallPoint_addGameHallScore_result_params::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_result_params*)=0;
if(_mcpack2_load_GameHallPoint_addGameHallScore_result_params_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void GameHallPoint_addGameHallScore_result_params::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t GameHallPoint_addGameHallScore_result_params::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@int32_t score=out();
{
int res=mc_pack_put_int32(pack,"score",_m_score);
if(res){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
// @@class GameHallPoint_addGameHallScore_response
static void _mcpack2_load_GameHallPoint_addGameHallScore_response_result_params(const mc_pack_item_t*,GameHallPoint_addGameHallScore_response*);
static bsl::readmap<const char*,void (*)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_response*),::idl::string_hash,::idl::string_equal> _mcpack2_load_GameHallPoint_addGameHallScore_response_readmap;
// static initialization.
static bool _mcpack2_load_GameHallPoint_addGameHallScore_response_static_init(){
std::vector< std::pair<const char*, void (*)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_response*)> >_vec;
_vec.push_back(std::pair<const char*,void (*)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_response*)>("result_params",_mcpack2_load_GameHallPoint_addGameHallScore_response_result_params));
_mcpack2_load_GameHallPoint_addGameHallScore_response_readmap.create(16*1);
_mcpack2_load_GameHallPoint_addGameHallScore_response_readmap.assign(_vec.begin(),_vec.end());
return true;
}
__attribute__((unused)) static bool _mcpack2_load_GameHallPoint_addGameHallScore_response_static_inited=_mcpack2_load_GameHallPoint_addGameHallScore_response_static_init();
// @@GameHallPoint_addGameHallScore_result_params result_params;
static void _mcpack2_load_GameHallPoint_addGameHallScore_response_result_params(__attribute__((unused)) const mc_pack_item_t* item,GameHallPoint_addGameHallScore_response* self){
self->_flag[0 >> 3] |= (1 << (0 & 0x7));
 
__attribute__((unused)) int res=0;
__attribute__((unused)) size_t size=0;
const mc_pack_t *pack=0;
res=mc_pack_get_pack_from_item(item,&pack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(!self->_m_result_params){
self->_m_result_params=::idl::GameHallPoint_addGameHallScore_result_params::create(self->_pool);
}
self->_m_result_params->LoadWithoutCheck(pack);
}
void GameHallPoint_addGameHallScore_response::LoadWithoutCheck(const mc_pack_t* pack){
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
clear();
mc_pack_item_t item;
int res=mc_pack_first_item(pack,&item);
if(res && res!=MC_PE_NOT_FOUND){
throw ::idl::McpackException(res) << BSL_EARG;
}
if(res!=MC_PE_NOT_FOUND){
void (*func)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_response*)=0;
do{
if(_mcpack2_load_GameHallPoint_addGameHallScore_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
}else{
bool push=true;
for(size_t i=0;i<_ext.size();i++){
if(_ext[i]->load(item)>=0){
push=false;
}
}
if(push){
unknown().push_back<mc_pack_item_t>(item);
}
}
}while(!mc_pack_next_item(&item,&item));
}
}
//for compatiblity.return 0 when it accepts item,else return -1
int GameHallPoint_addGameHallScore_response::load(const mc_pack_item_t& item){
void (*func)(const mc_pack_item_t*,GameHallPoint_addGameHallScore_response*)=0;
if(_mcpack2_load_GameHallPoint_addGameHallScore_response_readmap.get(mc_pack_get_subkey(item.key),&func)==bsl::HASH_EXIST){
func(&item,this);
return 0;
}
return -1;
}
void GameHallPoint_addGameHallScore_response::load(const mc_pack_t* pack){
LoadWithoutCheck(pack);
check();
}
size_t GameHallPoint_addGameHallScore_response::save(mc_pack_t* pack) const{
if(MC_PACK_PTR_ERR(pack)){
throw ::idl::McpackException(pack) << BSL_EARG;
}
size_t orig_size=mc_pack_get_size(pack);
// @@GameHallPoint_addGameHallScore_result_params result_params;
{
mc_pack_t* subpack=mc_pack_put_object(pack,"result_params");
if(MC_PACK_PTR_ERR(subpack)){
throw ::idl::McpackException(subpack) << BSL_EARG;
}
_m_result_params->save(subpack);
mc_pack_finish(subpack);
}
// save '_unknown' field.
for(size_t i=0;i<_unknown.size();i++){
const mc_pack_item_t& item=_unknown.GetWithoutCheck< mc_pack_item_t >(i);
if(item.type==MC_PT_OBJ){
mc_pack_t* tmp=mc_pack_put_object(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_pack_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else if(item.type==MC_PT_ARR){
mc_pack_t* tmp=mc_pack_put_array(pack,mc_pack_get_subkey(item.key));
if(MC_PACK_PTR_ERR(tmp)){
throw ::idl::McpackException(tmp) << BSL_EARG;
}
const mc_pack_t* tmppack=0;
int res=mc_pack_get_array_from_item(&item,&tmppack);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
res=mc_pack_copy_item(tmppack,tmp,0);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
mc_pack_finish(tmp);
}else{
int res=mc_pack_put_item(pack,&item);
if(res<0){
throw ::idl::McpackException(res) << BSL_EARG;
}
}
}
// save '_ext' field.
for(size_t i=0;i<_ext.size();i++){
_ext[i]->save(pack);
}
return mc_pack_get_size(pack)-orig_size;
}
} // namespace idl
